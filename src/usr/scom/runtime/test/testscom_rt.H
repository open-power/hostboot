/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/scom/runtime/test/testscom_rt.H $                     */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2013,2024                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
#ifndef __SCOMTEST_H
#define __SCOMTEST_H

/**
 *  @file scomtest.H
 *
 *  @brief Test case for SCOM code
*/

#include <cxxtest/TestSuite.H>
#include <errl/errlmanager.H>
#include <errl/errlentry.H>
#include <devicefw/userif.H>
#include <fsi/fsiif.H>
#include <targeting/common/util.H>
#include <targeting/common/utilFilter.H>
#include <hw_access_def.H>
#include <devicefw/driverif.H>
#include <trace/interface.H>
#include <chipids.H>

extern trace_desc_t* g_trac_scom;


class ScomTestRt: public CxxTest::TestSuite
{
public:

  /**
   * @brief Test the Runtime OCMB Odyssey Device Register Interfaces
   *
   *        Main mission of the test_SCOMreadWrite_ocmb_ody Runtime
   *        test is to assure that the proper DEVICE_REGISTER_ROUTE
   *        interfaces are built to properly map the DEVICE request
   *        to the proper Device Driver (DD) subsystems/interfaces.
   *
   *        For example, ibscom.C implements the routeIbScom procedure
   *        to calculate the proper routing of the OCMB IBSCOM
   *        ADDRESS to either the EXPLORER or ODYSSEY deviceOp,
   *        either DEVICE_IBSCOM_EXP_ADDRESS or DEVICE_IBSCOM_ODY_ADDRESS.
   *
   *        During the Runtime tests, rtloader.H emulates PHYP, therefore
   *        some scom/mmio address manipulations are required directly
   *        in the rtloader.H logic (efforts are made to minimize any
   *        duplication, however the purpose of these tests are NOT
   *        the specific deviceOp, but the main purpose here are the
   *        application layer interfaces in order to achieve the desired
   *        call/return logic.
   */
  void _DISABLE_test_SCOMreadWrite_ocmb_ody(void)
  {
      TRACFCOMP( g_trac_scom, "ScomTest::test_SCOMreadWrite_ocmb_ody> Start" );
      errlHndl_t l_err = nullptr;
      uint64_t fails = 0;
      uint64_t total = 0;
      size_t op_size = sizeof(uint64_t);

      // ODYSSEY Specific
      // See doIbscomMulticastWorkaround for more information on masks for parsing addresses
      constexpr uint64_t CHIPLET1        = 0x010f001e;  // T.TPCHIP.NET.PCBRSPPERV.RESPONDER_CONFIG_REG Responder config register
      constexpr uint64_t CHIPLET2        = 0x080f001e; //  T.TPCHIP.NET.PCBRSPMC.RESPONDER_CONFIG_REG   Responder config register
      constexpr uint64_t DATA1           = 0xFEEDB0B000001234;
      constexpr uint64_t DATA2           = 0xFEDCBA9876543210;
      constexpr uint64_t MC_OR_ADDR      = 0x470f001e;  // IS_MULTICAST | GROUP_ALL
      constexpr uint64_t MC_BITWISE_ADDR = 0x570f001e;  // IS_MULTICAST | MULTICAST_OP_BITWISE | GROUP_ALL

      uint64_t l_expected = 0x0ULL;

      // scratch data to use
      struct {
          uint64_t addr;
          uint64_t data;
      } test_data[] = {
          { CHIPLET1, DATA1},
          { CHIPLET2, DATA2},
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS] = {0};

      do {
          TARGETING::TargetHandle_t   ocmb_target = nullptr;
          TARGETING::TargetHandleList ocmb_target_list;
          getAllChips(ocmb_target_list, TARGETING::TYPE_OCMB_CHIP);
          if (ocmb_target_list.size() == 0)
          {
              TS_INFO("test_SCOMreadWrite_ocmb_ody> No OCMB targets found.  Exiting.");
              break;
          }
          ocmb_target = ocmb_target_list[0]; // pick the first target to test with
          if ((ocmb_target->getAttr<TARGETING::ATTR_HWAS_STATE>().functional == true) && (ocmb_target->getAttr<TARGETING::ATTR_CHIP_ID>() == POWER_CHIPID::ODYSSEY_16))
          {
              for ( uint64_t x = 0; x < NUM_ADDRS; x++ ) // First write the OCMB two chiplets with some test data
              {
                  total++;
                  // Buffer passed to deviceWrite will be manipulated (like byte and word swapping) so use a volatile buffer
                  // so as to not alter the expected test data to later compare results
                  uint64_t volatile_data = 0x0ULL;
                  volatile_data = test_data[x].data;
                  l_err = deviceWrite(ocmb_target,
                                      &volatile_data,
                                      op_size,
                                      DEVICE_SCOM_ADDRESS(test_data[x].addr) );
                  if( l_err )
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d WRITE: Error SCOM addr=0x%llX, RC=%llX", x, test_data[x].addr, l_err->reasonCode() );
                      fails++;
                      errlCommit(l_err,SCOM_COMP_ID);
                  }
              } // end FOR ALL NUM_ADDRS
              for ( uint64_t x = 0; x < NUM_ADDRS; x++ ) // Read back what we wrote and compare results on the OCMB two chiplets, id=0x01 and id=0x08
              {
                  total++;
                  l_err = deviceRead( ocmb_target,
                                      &(read_data[x]),
                                      op_size,
                                      DEVICE_SCOM_ADDRESS(test_data[x].addr) );
                  if( l_err )
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d Read: Error SCOM addr=0x%X, RC=%X", x, test_data[x].addr, l_err->reasonCode() );
                      fails++;
                      errlCommit(l_err,SCOM_COMP_ID);
                  }
                  else if (read_data[x] != test_data[x].data)
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d FAILURE !! NO MATCH !! READ -> 0x%llX TEST DATA -> 0x%llX", x, read_data[x], test_data[x].data);
                      fails++;
                  }
              } // end FOR ALL NUM_ADDRS
              for ( uint64_t x = 0; x < NUM_ADDRS; x++ ) // Multicast OR Tests
              {
                  total++;
                  l_err = deviceRead( ocmb_target,
                                      &(read_data[x]),
                                      op_size,
                                      DEVICE_SCOM_ADDRESS(MC_OR_ADDR) );
                  // See details on multicast workaround for Odyssey OCMB address space limitations
                  // i.e. see doIbscomMulticastWorkaround and masks for parsing the address
                  if( l_err )
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d MC_OR_ADDR Read: Error SCOM addr=0x%X, RC=%X", x, test_data[x].addr, l_err->reasonCode() );
                      fails++;
                      errlCommit(l_err,SCOM_COMP_ID);
                  }
                  else if (read_data[x] != (DATA1 | DATA2))
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d MC_OR_ADDR FAILURE !! NO MATCH !! READ -> 0x%llX DATA1|DATA2 -> 0x%llX", x, read_data[x], (DATA1|DATA2));
                      fails++;
                  }
              } // end FOR ALL NUM_ADDRS
              for ( uint64_t x = 0; x < NUM_ADDRS; x++ ) // Multicast BITWISE Tests
              {
                  total++;
                  read_data[x] = 0x0ULL;
                  l_err = deviceRead( ocmb_target,
                                      &(read_data[x]),
                                      op_size,
                                      DEVICE_SCOM_ADDRESS(MC_BITWISE_ADDR) );
                  // For each OCMB chiplet (id=0x01 and id=0x08) if the data read from the register
                  // in that chiplet position is set (=1) then set expectations on the BITWISE READ
                  // to have the bit(s) set (=1).
                  // See details on multicast workaround for Odyssey OCMB address space limitations
                  // i.e. see doIbscomMulticastWorkaround and masks for parsing the address
                  if (DATA1 & 0x8000000000000000)
                  {
                      l_expected |= (0x8000000000000000 >> 0x01);
                  }
                  if (DATA2 & 0x8000000000000000)
                  {
                      l_expected |= (0x8000000000000000 >> 0x08);
                  }
                  if( l_err )
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d BITWISE Read: Error SCOM addr=0x%X, RC=%X", x, test_data[x].addr, l_err->reasonCode() );
                      fails++;
                      errlCommit(l_err,SCOM_COMP_ID);
                  }
                  else if (read_data[x] != l_expected)
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d BITWISE FAILURE !! NO MATCH !! READ llX -> 0x%llX l_expected -> 0x%llX", x, read_data[x], l_expected);
                      fails++;
                  }
              } // end FOR ALL NUM_ADDRS

              // Set up the SCOM SWITCHES for CHANNEL FAILURE tests
              mutex_t* l_mutex = nullptr;
              l_mutex = ocmb_target->getHbMutexAttr<TARGETING::ATTR_SCOM_ACCESS_MUTEX>();
              recursive_mutex_lock(l_mutex);
              TARGETING::ScomSwitches l_switches = ocmb_target->getAttr<TARGETING::ATTR_SCOM_SWITCHES>();
              l_switches.useI2cScom = 0;
              l_switches.useSbeScom = 1;
              l_switches.useInbandScom = 0;
              ocmb_target->setAttr<TARGETING::ATTR_SCOM_SWITCHES>(l_switches);
              ocmb_target->setAttr<TARGETING::ATTR_USE_PIPE_FIFO>(0);
              recursive_mutex_unlock(l_mutex);

              for ( uint64_t x = 0; x < NUM_ADDRS; x++ )
              {
                  // Re-write the test data into the regs. Channel failure will
                  // use a different (I2CR) path to write the data, so we will
                  // exercise a different code path with this write.
                  total++;
                  uint64_t volatile_data = 0x0ULL;
                  volatile_data = test_data[x].data;
                  l_err = deviceWrite( ocmb_target,
                                      &volatile_data,
                                      op_size,
                                      DEVICE_SCOM_ADDRESS(test_data[x].addr) );
                  if( l_err )
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> x=%d WRITE: Error SCOM addr=0x%llX, RC=%llX", x, test_data[x].addr, l_err->reasonCode() );
                      fails++;
                      errlCommit(l_err,SCOM_COMP_ID);
                  }

                  total++;
                  l_err = deviceRead( ocmb_target,
                                      &(read_data[x]),
                                      op_size,
                                      DEVICE_SCOM_ADDRESS(test_data[x].addr) );
                  if( l_err )
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> Read: CHANNEL FAIL Error UNSUPPORTED needs PFHB-400 SCOM addr=0x%llX, RC=%X", test_data[x].addr, l_err->reasonCode() );
                      fails++;
                      errlCommit(l_err,SCOM_COMP_ID);
                  }
                  else if (read_data[x] != test_data[x].data)
                  {
                      TS_FAIL("ScomTest::test_SCOMreadWrite_ocmb_ody> CHANNEL FAIL FAILURE !! NO MATCH !! READ llx -> 0x%llX TEST DATA -> 0x%llX", read_data[x], test_data[x].data);
                      fails++;
                  }

              } // end FOR ALL NUM_ADDRS

              // Restore the SCOM_SWITCHES
              l_mutex = ocmb_target->getHbMutexAttr<TARGETING::ATTR_SCOM_ACCESS_MUTEX>();
              recursive_mutex_lock(l_mutex);
              l_switches = ocmb_target->getAttr<TARGETING::ATTR_SCOM_SWITCHES>();
              l_switches.useI2cScom = 0;
              l_switches.useSbeScom = 0;
              l_switches.useInbandScom = 1;
              ocmb_target->setAttr<TARGETING::ATTR_SCOM_SWITCHES>(l_switches);
              ocmb_target->setAttr<TARGETING::ATTR_USE_PIPE_FIFO>(1);
              recursive_mutex_unlock(l_mutex);

          } // end FUNCTIONAL
          else
          {
              if (ocmb_target->getAttr<TARGETING::ATTR_CHIP_ID>() == POWER_CHIPID::ODYSSEY_16)
              {
                  // We expect a functional ODYSSEY OCMB HUID
                  TS_FAIL("test_SCOMreadWrite_ocmb_ody> ODYSSEY OCMB HUID=0x%X NON-FUNCTIONAL", get_huid(ocmb_target));
                  fails++;
              }
              else
              {
                  TS_INFO("test_SCOMreadWrite_ocmb_ody> SKIPPING EXPLORER OCMB HUID=0x%X", get_huid(ocmb_target));
              }
          }
      } while (0);

      TRACFCOMP( g_trac_scom, "ScomTest::test_SCOMreadWrite_ocmb_ody> %d/%d fails", fails, total );
  }

  void test_SCOMreadWrite_proc(void)
  {

      TRACFCOMP( g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> Start" );

      uint64_t fails = 0;
      uint64_t total = 0;
      errlHndl_t l_err = NULL;

      // Setup some targets to use
      enum {
          PROC0,
          PROC1,
          NUM_TARGETS
      };
      TARGETING::Target* scom_targets[NUM_TARGETS];
      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          scom_targets[x] = NULL;
      }

      // Target Proc 0
      TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
      epath.addLast(TARGETING::TYPE_SYS,0);
      epath.addLast(TARGETING::TYPE_NODE,0);
      epath.addLast(TARGETING::TYPE_PROC,0);
      scom_targets[PROC0] = TARGETING::targetService().toTarget(epath);

      // Target Proc 1
      epath.removeLast();
      epath.addLast(TARGETING::TYPE_PROC,1);
      scom_targets[PROC1] = TARGETING::targetService().toTarget(epath);

      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          //only run if the target exists
          if(scom_targets[x] == NULL)
          {
              continue;
          }
          else if (scom_targets[x]->
                getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACDCOMP( g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> Target %d is not functional", x );
              scom_targets[x] = NULL; //remove from our list
          }
      }

      // scratch data to use
      struct {
          TARGETING::Target* target;
          uint64_t addr;
          uint64_t data;
      } test_data[] = {
          { scom_targets[PROC0], 0x040110C4 ,0xFEEDB0B000001234},
          { scom_targets[PROC0], 0x02040008, 0xFEDCBA9876543210},
          { scom_targets[PROC1], 0x040110C4, 0x1234567887654321},
          { scom_targets[PROC1], 0x02040008, 0x1122334455667788},
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS];
      size_t op_size = sizeof(uint32_t);

      // write all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceWrite( test_data[x].target,
                               &(test_data[x].data),
                               op_size,
                               DEVICE_SCOM_ADDRESS(test_data[x].addr) );
          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> [%d] Write: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_SCOMreadWrite_proc> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
      }

      // read all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceRead( test_data[x].target,
                              &(read_data[x]),
                              op_size,
                              DEVICE_SCOM_ADDRESS(test_data[x].addr) );
          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> [%d] Read: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_SCOMreadWrite_proc> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
          else if(read_data[x] != test_data[x].data)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> [%d] Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);
              TS_FAIL( "ScomTest::test_SCOMreadWrite_proc> ERROR : Data mismatch between read and expected data" );
              fails++;
          }
      }

      TRACFCOMP( g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> %d/%d fails", fails, total );

  }

// Currently this test can only be verified manually by looking at the traces
// There is no way to tell if the requested deviceRead/deviceWrite followed the
// opMode. For example you cannot know if the core skipped the wakeup when the
// DO_NOT_DO_WAKEUP opMode is set unless you look at the traces to see if there
// is traces from the wakeup code path. In the future when the wakeup is
// implemented we may have the ability to know if a core has tried to wake or not.
// @TODO RTC: 132413

 void test_opModes(void)
  {

      TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> Start" );

      uint64_t fails = 0;
      uint64_t total = 0;
      errlHndl_t l_err = NULL;


      // Setup some targets to use
      enum {
          myProc0,
          myEX1,
          myEX5,
          NUM_TARGETS
      };

      TARGETING::Target* scom_targets[NUM_TARGETS];
      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          scom_targets[x] = NULL;
      }

      TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> num_targets: %d", NUM_TARGETS);

      // Target Proc 0 - to make sure we have XSCOM and FSISCOM attributes
      TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
      epath.addLast(TARGETING::TYPE_SYS,0);
      epath.addLast(TARGETING::TYPE_NODE,0);
      epath.addLast(TARGETING::TYPE_PROC,0);
      epath.addLast(TARGETING::TYPE_EQ,0);

      scom_targets[myProc0] = TARGETING::targetService().toTarget(epath);


      if (scom_targets[myProc0] != NULL)
      {
          // Add the Ex1 to the path and  create new target
          epath.addLast(TARGETING::TYPE_EX,1);
          scom_targets[myEX1] = TARGETING::targetService().toTarget(epath);

          // remove EX1 target (off of sys-0/node-0/proc-0/eq-0/EX1)
          epath.removeLast();
          // remove eq0 target (off of sys-0/node-0/proc-0/eq-0)
          epath.removeLast();

          // add eq2 target.
          epath.addLast(TARGETING::TYPE_EQ,2);
          // add EX5 target.
          epath.addLast(TARGETING::TYPE_EX,5);
          scom_targets[myEX5] = TARGETING::targetService().toTarget(epath);
      }
      // scratch data to use

      struct {
          TARGETING::Target* target;
          uint64_t addr;
          uint64_t data;
          fapi2::OpModes mode;
          bool     expectErr;
      } test_data[] = {
          { scom_targets[myEX1], 0x21000000 ,0x7676767676767676,  fapi2::NORMAL, false},  // pervasive addr does not req wakeup
          { scom_targets[myEX5], 0x20010A02, 0x9191919191919191,  fapi2::NORMAL, false},
          { scom_targets[myEX5], 0x13040002, 0xabcdabcdabcdabcd,  fapi2::NORMAL, true},   // invalid unit 0 address
          { scom_targets[myEX1], 0x000F0166, 0xabcdabcdabcdabcd,  fapi2::NORMAL, true},   // invalid address range for target
          { scom_targets[myEX1], 0x21000000 ,0x7676767676767676,  fapi2::IGNORE_HW_ERROR, false},  // pervasive addr does not req wakeup
          { scom_targets[myEX5], 0x20010A02, 0x9191919191919191,  fapi2::IGNORE_HW_ERROR, false},
          { scom_targets[myEX5], 0x2E010010, 0xabcdabcdabcdabcd,  fapi2::IGNORE_HW_ERROR, true},   // invalid unit 0 address
          { scom_targets[myEX1], 0x2E010009, 0xabcdabcdabcdabcd,  fapi2::IGNORE_HW_ERROR, true},   // invalid address range for target
          { scom_targets[myEX1], 0x21000000 ,0x7676767676767676,  fapi2::DO_NOT_DO_WAKEUP, false}, // pervasive addr does not req wakeup
          { scom_targets[myEX5], 0x20010A02, 0x9191919191919191,  fapi2::DO_NOT_DO_WAKEUP, false},
          { scom_targets[myEX5], 0x13040002, 0xabcdabcdabcdabcd,  fapi2::DO_NOT_DO_WAKEUP, true},   // invalid unit 0 address
          { scom_targets[myEX1], 0x000F0166, 0xabcdabcdabcdabcd,  fapi2::DO_NOT_DO_WAKEUP, true},   // invalid address range for target
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      size_t op_size = sizeof(uint32_t);

      // write all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> test target is null, continuing" );
              continue;
          }
          // check to see if the target is functional.. if not.. skip this target
          else if (test_data[x].target->
              getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> Target %d is not functional", x );
              continue;
          }
          if(test_data[x].expectErr)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> Writing 0x%X to the addr: 0x%X with opMode: 0x%X and an error is expected on target: %d",
                      test_data[x].data,test_data[x].addr,test_data[x].mode, x);
          }
          else
          {
            TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> Writing 0x%X to the addr: 0x%X with opMode: 0x%X and an error is NOT expected on target: %d",
                      test_data[x].data,test_data[x].addr,test_data[x].mode, x);
          }
          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceWrite( test_data[x].target,
                               &(test_data[x].data),
                               op_size,
                               DEVICE_SCOM_ADDRESS(test_data[x].addr, test_data[x].mode)
                               );

          if (!test_data[x].expectErr)
          {
              if( l_err )
              {
                  TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> [%d] Write: Error from device : addr=0x%X, RC=%X on target: %d", x,  test_data[x].addr, l_err->reasonCode(), x );
                  TS_FAIL( "ScomTest::test_opModes> ERROR : Unexpected error log from deviceWrite" );
                  fails++;
                  errlCommit(l_err,SCOM_COMP_ID);
              }
          }
          else
          {
              if( l_err )
              {
                  TRACFCOMP( g_trac_scom, "ScomTest::test_opModes.. Expected Error log returned> " );
              }
              else
              {
                  TRACFCOMP( g_trac_scom, "ScomTest::test_opModes.. Expected an error log and did not get one for addr 0x%X on target: %d " ,test_data[x].addr, x );
                  TS_FAIL( "ScomTest::test_opModes> ERROR : Expected an Error log and did not get one" );
                  fails++;
              }
          }
          delete l_err;
      }

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS];

      memset(read_data, 0, sizeof (read_data));


      // read all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
            TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> test target is null, continuing" );
              continue;
          }

          if (test_data[x].target->
              getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> Target %d is not functional", x );
              continue;
          }

          op_size = sizeof(uint64_t);

          if(test_data[x].expectErr)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> Reading from the addr: 0x%X with opMode: 0x%X and an error is expected",
                        test_data[x].addr,test_data[x].mode);
          }
          else
          {
            TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> Reading from the addr: 0x%X with opMode: 0x%X and an error is not expected",
                      test_data[x].addr,test_data[x].mode);
          }

          total++;
          l_err = deviceRead( test_data[x].target,
                              &(read_data[x]),
                              op_size,
                              DEVICE_SCOM_ADDRESS(test_data[x].addr, test_data[x].mode));
          if (!test_data[x].expectErr)
          {
              if( l_err )
              {
                  TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> [%d] Read: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
                  TS_FAIL( "ScomTest::test_opModes> ERROR : Unexpected error log from deviceRead" );
                  fails++;
                  errlCommit(l_err,SCOM_COMP_ID);
              }
              else if((read_data[x]) != (test_data[x].data))
              {
                  TRACFCOMP(g_trac_scom, "ScomTest::test_opModes> [%d] Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);
                  TS_FAIL( "ScomTest::test_opModes> ERROR : Data mismatch between read and expected data" );
                  fails++;
              }
          }
          else
          {
              if( l_err )
              {
                  TRACFCOMP( g_trac_scom, "ScomTest::test_opModes.. Expected Error log returned> " );
              }
              else
              {
                  TRACFCOMP( g_trac_scom, "ScomTest::test_opModes.. Expected Error log and did not get one for addr 0x%X " ,test_data[x].addr );
                  TS_FAIL( "ScomTest::test_opModes> ERROR : Expected Error log and did not get one" );
                  fails++;
              }
          }
          delete l_err;
      }

      TRACFCOMP( g_trac_scom, "ScomTest::test_opModes> %d/%d fails", fails, total );

 }


 void test_TranslateScom_MCS(void)
  {

      TRACFCOMP( g_trac_scom, "ScomTest::test_TranslateScom_MCS Start" );
      errlHndl_t l_err = NULL;

      uint64_t fails = 0;
      uint64_t total = 0;



      //@VBU workaround - Disable Indirect SCOM test case o
      //Test case read/writes to valid addresses and is
      //potentially destructive on VBU
      if (TARGETING::is_vpo())
      {
           return;
      }

      // Setup some targets to use
      enum {
          myProc0,
          myMCS0,
          myMCS3,
          NUM_TARGETS
      };

      TARGETING::Target* scom_targets[NUM_TARGETS];
      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          scom_targets[x] = NULL;
      }

      // Target Proc 0 - to make sure we have XSCOM and FSISCOM attributes
      TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
      epath.addLast(TARGETING::TYPE_SYS,0);
      epath.addLast(TARGETING::TYPE_NODE,0);
      epath.addLast(TARGETING::TYPE_PROC,0);

      scom_targets[myProc0] = TARGETING::targetService().toTarget(epath);

      if (scom_targets[myProc0] != NULL)
      {
          // Add the MCS(0) to the path and  create new target
          epath.addLast(TARGETING::TYPE_MCS,0);
          scom_targets[myMCS0] = TARGETING::targetService().toTarget(epath);

          // remote MCS(0) (off of sys-0/node-0/proc-0/MCS0)
          epath.removeLast();

          // add MCS3 target.
          epath.addLast(TARGETING::TYPE_MCS,3);
          scom_targets[myMCS3] = TARGETING::targetService().toTarget(epath);
      }

      // scratch data to use
      struct {
          TARGETING::Target* target;
          uint64_t addr;
          uint64_t data;
      } test_data[] = {
          { scom_targets[myMCS0], 0x05010800 ,0x1111111122222222},
          { scom_targets[myMCS3], 0x05010800, 0x3333333344444444},
          { scom_targets[myMCS0], 0x0601184A, 0x0101010101010101}, // invalid
          { scom_targets[myMCS0], 0x0200184A, 0x2323232323232323}, // invalid
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      size_t op_size = sizeof(uint32_t);

      // write all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }
          // check to see if the target is functional.. if not skip this target
          else if (test_data[x].target->
              getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACDCOMP( g_trac_scom, "ScomTest::test_TranslateScom_MCS> Target %d is not functional", x );
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceWrite( test_data[x].target,
                               &(test_data[x].data),
                               op_size,
                               DEVICE_SCOM_ADDRESS(test_data[x].addr) );
          if( l_err )
          {
              if ((x == NUM_ADDRS-1) || (x==NUM_ADDRS-2))
              {
                  TRACDCOMP( g_trac_scom, "ScomTest::test_TranslateScom_MCS.. Expected Error log returned> x = %d", x );
              }
              else
              {
                  TRACFCOMP(g_trac_scom, "ScomTest::test_TranslateScom_MCS> [%d] Write: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
                  TS_FAIL( "ScomTest::test_TranslateScom_MCS> ERROR : Unexpected error log from write1" );
                  fails++;
                  errlCommit(l_err,SCOM_COMP_ID);
              }

              delete l_err;
          }
      }

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS];

      memset(read_data, 0, sizeof read_data);

      // read all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS-2; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceRead( test_data[x].target,
                              &(read_data[x]),
                              op_size,
                              DEVICE_SCOM_ADDRESS(test_data[x].addr) );

          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_TranslateScom_MCS> [%d] Read: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_TranslateScom_MCS> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
          else if((read_data[x]) != (test_data[x].data))
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_TranslateScom_MCS> [%d] Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);

              //temp workaround for MCSs that have been turned off
              // (RTC Issue 84907)
              if (read_data[x] != 0x0)
              {
                   TS_FAIL( "ScomTest::test_TranslateScom_MCS> ERROR : Data mismatch between read and expected data" );
                   fails++;
              }
          }

      }

      TRACFCOMP( g_trac_scom, "ScomTest::test_TranslateScom_MCS> %d/%d fails", fails, total );

 }



 void test_TranslateScom_MBA_MBS(void)
  {
      TRACFCOMP( g_trac_scom, "ScomTest::test_TranslateScom_MBA_MBS Start" );
#if 0
      uint64_t fails = 0;
      uint64_t total = 0;
      errlHndl_t l_err = NULL;

      //@VBU workaround - Disable Indirect SCOM test case o
      //Test case read/writes to valid addresses and is
      //potentially destructive on VBU
      if (TARGETING::is_vpo())
      {
           return;
      }

      // Setup some targets to use
      enum {
          myMembuf0,
          myMBA0,
          myMBA1,
          NUM_TARGETS
      };


      TARGETING::Target* scom_targets[NUM_TARGETS];
      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          scom_targets[x] = NULL;
      }

      // Target Proc 0 - to make sure we have XSCOM and FSISCOM attributes
      TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
      epath.addLast(TARGETING::TYPE_SYS,0);
      epath.addLast(TARGETING::TYPE_NODE,0);
      epath.addLast(TARGETING::TYPE_MEMBUF,0);

      scom_targets[myMembuf0] = TARGETING::targetService().toTarget(epath);

      if(scom_targets[myMembuf0] != NULL)
      {

          // add MBA0 target.
          epath.addLast(TARGETING::TYPE_MBA,0);
          scom_targets[myMBA0] = TARGETING::targetService().toTarget(epath);

          // remote MBA0 target (off of sys-0/node-0/membuf-0/MBA0)
          epath.removeLast();

          // Add MBA1 to the path and  create new target
          epath.addLast(TARGETING::TYPE_MBA,1);
          scom_targets[myMBA1] = TARGETING::targetService().toTarget(epath);
      }
      // scratch data to use
      struct {
          TARGETING::Target* target;
          uint64_t addr;
          uint64_t data;
      } test_data[] = {
          { scom_targets[myMBA0], 0x03010655 ,0x111111111111DDDD},
          { scom_targets[myMBA1], 0x03010655, 0x333333334444EEEE},
          { scom_targets[myMBA0], 0x8000C0140301143F,0x1111111111111212},
          { scom_targets[myMBA1], 0x8000C0140301143F, 0x333333334444abcd},
          { scom_targets[myMBA0], 0x8000C0140301183F,0x111111111111ccee}, // invalid non zero indirect address
          { scom_targets[myMBA0], 0x03010E55, 0x010101010101CCCC},  // invalid passing in a non-0 unit address
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      size_t op_size = sizeof(uint32_t);

      // write all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          // check to see if the target is functional.. if not.. skip this target
          else if (test_data[x].target->
              getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACDCOMP( g_trac_scom, "ScomTest::test_translate_scom_MBA_MBS> Target %d is not functional", x );
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceWrite( test_data[x].target,
                               &(test_data[x].data),
                               op_size,
                               DEVICE_SCOM_ADDRESS(test_data[x].addr) );
          if( l_err )
          {
            // checking the read of NUM_ADDRs - 1 because the last entry written above failed as expected.
            if ((x == NUM_ADDRS-1) || (x==NUM_ADDRS-2))
            {
                TRACDCOMP( g_trac_scom, "ScomTest::test_translate MBA_MBS.. Expected Errorlog Returned> x = %d", x );
            }
            else
            {
              TRACFCOMP(g_trac_scom, "ScomTest::test_translate_Scom_MBA_MBS> [%d] Write: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_Translate_SCOM_MBA_MBS> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
            }

              delete l_err;
          }
      }

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS];

      // read all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS-2; x++ )
      {
          memset(read_data, 0, sizeof read_data);
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }
          // check to see if the target is functional.. if not.. skip this target
          else if (test_data[x].target->
              getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACDCOMP( g_trac_scom, "ScomTest::test_translate_scom_MBA_MBS> Target %d is not functional", x );
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceRead( test_data[x].target,
                              &(read_data[x]),
                              op_size,
                              DEVICE_SCOM_ADDRESS(test_data[x].addr) );

          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_TranslateScom_MBA_MBS> [%d] Read: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_TranslateScom_MBA_MBS> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
          else if ((x == 2) || (x==3))
          {
              if((read_data[x] & 0x000000000000FFFF) != (test_data[x].data & 0x000000000000FFFF))

              {
                  TRACFCOMP(g_trac_scom, "ScomTest::test_TranslateScom_ABUS> [%d] Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);
                  TS_FAIL( "ScomTest::test_TranslateScom_ABUS> ERROR : Data mismatch between read and expected data" );
                  fails++;
              }
          }
          else if((read_data[x]) != (test_data[x].data))
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_TranslateScom_MBA_MBS> [%d] Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);
              TS_FAIL( "ScomTest::test_TranslateScom_MBA_MBS> ERROR : Data mismatch between read and expected data" );
              fails++;
          }

      }

      TRACFCOMP( g_trac_scom, "ScomTest::test_translateScom_MBA_MBS> %d/%d fails", fails, total );
#endif
 }


  /**
   * @brief multi chip SCOM test
   *
   */
  void test_Form1IBSCOMreadWrite_proc(void)
  {

      TRACFCOMP( g_trac_scom, "ScomTest::test_Form1IBSCOMreadWrite_proc> Start" );

/*
 * TODO RTC 158024 - Enable form 1  test case

      uint64_t fails = 0;
      uint64_t total = 0;
      errlHndl_t l_err = NULL;

      //@VBU workaround - Disable Indirect SCOM test case o
      //Test case read/writes to valid addresses and is
      //potentially destructive on VBU
      if (TARGETING::is_vpo())
      {
           return;
      }

      // Setup some targets to use
      enum {
          myPROC0,
          NUM_TARGETS
      };
      TARGETING::Target* scom_targets[NUM_TARGETS];
      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          scom_targets[x] = NULL;
      }

      // Target Proc 9 - the FSI wrap-back connection in simics
      TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
      epath.addLast(TARGETING::TYPE_SYS,0);
      epath.addLast(TARGETING::TYPE_NODE,0);
      epath.addLast(TARGETING::TYPE_PROC,0);

      scom_targets[myPROC0] = TARGETING::targetService().toTarget(epath);

      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          //only run if the target exists
          if(scom_targets[x] == NULL)
          {
              TRACDCOMP( g_trac_scom, "ScomTestForm1 - TARGET = NULL - 1 x = %d", x);
              continue;
          }
          else if ((scom_targets[x]->getAttr<TARGETING::ATTR_SCOM_SWITCHES>().useXscom == 0) &&
                   (scom_targets[x]->getAttr<TARGETING::ATTR_SCOM_SWITCHES>().useFsiScom == 0))
          {
              // If both FSI and XSCOM are not enabled.. then ignore..
              TRACDCOMP(g_trac_scom, "INDIRECT SCOMForm1>> SKIPPING ");
              scom_targets[x] = NULL; //remove from our list
          }
          else if (scom_targets[x]->getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACDCOMP( g_trac_scom, "ScomTest::test_FSISCOMreadWriteForm1 > Target %d is not functional", x );
              scom_targets[x] = NULL; //remove from our list
          }
      }

      // scratch data to use

      struct {
          TARGETING::Target* target;
          uint64_t addr;
          uint64_t data;
          bool     isFail;
      } test_data[] = {
          { scom_targets[myPROC0], 0x900003210D010BEE, 0x0004432112344321, false}, // Form 1
          { scom_targets[myPROC0], 0x9000012307011BEE, 0x000443211234ABAB, false }, // Form 1
          { scom_targets[myPROC0], 0x9000000007011BEE, 0x123443211234ABAB, true }, // Form 1
          { scom_targets[myPROC0], 0x9FEEDB0B0DEADBEE, 0x000443211234ABAB, true }, // Form 1
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      size_t op_size = sizeof(uint32_t);

      // write all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceWrite( test_data[x].target,
                               &(test_data[x].data),
                               op_size,
                               DEVICE_SCOM_ADDRESS(test_data[x].addr) );

          if(!test_data[x].isFail && l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_IndirectScomForm1_proc> [%d] Write: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_IndirectScomForm1_proc> ERROR : Unexpected error log from device write: addr=0x%X, RC=%X ",  test_data[x].addr, l_err->reasonCode() );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
              l_err = NULL;
          }
          else if(test_data[x].isFail && !l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_IndirectScomForm1_proc> [%d] Write: Expected an Error from device write: addr=0x%X", x,  test_data[x].addr );
              TS_FAIL( "ScomTest::test_IndirectScomForm1_proc> ERROR : Expected an error log from device write and did not get one : addr=0x%X",  test_data[x].addr );
              fails++;
          }
          else if(l_err)
          {
              //delete expected errors
              delete l_err;
          }
      }
          // Now lets make sure the data is correct
          // Form 1 doesn't support read. Simics action is set up to write to
          // a regigster whcih will we scom
          // allocate space for read data
      struct {
          TARGETING::Target* target;
          uint64_t addr;
      } read_addresses[] = {
          { scom_targets[myPROC0], 0x0D010123 }, // Form 1
          { scom_targets[myPROC0], 0x07011123 }, // Form 1
      };
      const uint64_t READ_ADDRS = sizeof(read_addresses)/sizeof(read_addresses[0]);
      uint64_t read_form1data[READ_ADDRS];

      memset(read_form1data, 0, sizeof read_form1data);

      // read all the read registers
      for( uint64_t x = 0; x < READ_ADDRS; x++ )
      {
          //only run if the target exists
          if(read_addresses[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceRead( read_addresses[x].target,
                              &(read_form1data[x]),
                              op_size,
                              DEVICE_SCOM_ADDRESS(read_addresses[x].addr) );

          if(l_err)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_IndirectScomreadWriteForm1_proc> [%d] read written data: Unxpected Error from device : addr=0x%X, RC=%X", x,  read_addresses[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_IndirectScomreadWriteForm1_proc> ERROR : Unxpected Error on reading written data : addr=0x%X, RC=%X", read_addresses[x].addr, l_err->reasonCode() );
              fails++;
          }
          if((read_form1data[x] & 0x000000000000FFFF) !=
                (test_data[x].data & 0x000000000000FFFF))
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_IndirectScomreadWriteForm1_proc> [%d] Read: Data miss-match : addr=0x%X, read_form1data=0x%llx, write_data=0x%llx", x, read_addresses[x].addr, read_form1data[x], test_data[x].data);
              TS_FAIL( "ScomTest::test_IndirectScomreadWriteForm1_proc> ERROR : Data miss-match between read and expected data" );
              fails++;
          }
      }

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS];

      memset(read_data, 0, sizeof read_data);

      // read all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;
          l_err = deviceRead( test_data[x].target,
                              &(read_data[x]),
                              op_size,
                              DEVICE_SCOM_ADDRESS(test_data[x].addr) );

          // Form1 doesn't support read so if we don't get an error back, that's bad
          if(!l_err)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_IndirectScomreadWriteForm1_proc> [%d] Read: Expected Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test_IndirectScomreadWriteForm1_proc> ERROR : Expected Error on READ : addr=0x%X, RC=%X", test_data[x].addr, l_err->reasonCode() );
              fails++;
          }
          // else, if we are form1 and DO get an error back on read, that's expected.
          else
          {
              //delete expected errors
              delete l_err;
          }
      }
*/
  }


  /**
   * @brief multi chip SCOM test
   *
   */
  void test_MultiChipSCOMreadWrite_proc(void)
  {

      TRACFCOMP( g_trac_scom, "ScomTest::test_MultiChipSCOMreadWrite_proc> Start" );

      uint64_t fails = 0;
      uint64_t total = 0;
      errlHndl_t l_err = NULL;

      // Setup some targets to use
      enum {
          PROC1,
          NUM_TARGETS
      };
      TARGETING::Target* scom_targets[NUM_TARGETS];
      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          scom_targets[x] = NULL;
      }

      TARGETING::EntityPath epath(TARGETING::EntityPath::PATH_PHYSICAL);
      epath.addLast(TARGETING::TYPE_SYS,0);
      epath.addLast(TARGETING::TYPE_NODE,0);
      epath.addLast(TARGETING::TYPE_PROC,1);
      scom_targets[PROC1] = TARGETING::targetService().toTarget(epath);

      for( uint64_t x = 0; x < NUM_TARGETS; x++ )
      {
          //only run if the target exists
          if(scom_targets[x] == NULL)
          {
              continue;
          }
          else if (scom_targets[x]->
              getAttr<TARGETING::ATTR_HWAS_STATE>().functional != true)
          {
              TRACDCOMP( g_trac_scom, "ScomTest::test_SCOMreadWrite_proc> Target %d is not functional", x );
              scom_targets[x] = NULL; //remove from our list
          }
      }
      // scratch data to use
      struct {
          TARGETING::Target* target;
          uint64_t addr;
          uint64_t data;
      } test_data[] = {
          { scom_targets[PROC1],    0x01010803, 0x1234567887654321},
          { scom_targets[PROC1],    0x02040004, 0x1122334455667788},
      };
      const uint64_t NUM_ADDRS = sizeof(test_data)/sizeof(test_data[0]);

      // allocate space for read data
      uint64_t read_data[NUM_ADDRS];
      size_t op_size = sizeof(uint32_t);

      // write all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;

          l_err = deviceOp(    DeviceFW::WRITE,
                               test_data[x].target,
                               &(test_data[x].data),
                               op_size,
                               DEVICE_XSCOM_ADDRESS(test_data[x].addr) );

          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test_MultiChipScomWrite_proc> [%d] Write: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test__MultiChipScomWrite_proc> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
      }

      // read all the test registers
      for( uint64_t x = 0; x < NUM_ADDRS; x++ )
      {
          //only run if the target exists
          if(test_data[x].target == NULL)
          {
              continue;
          }

          op_size = sizeof(uint64_t);

          total++;

          // read the data back using XSCOM
          l_err = deviceOp(    DeviceFW::READ,
                               test_data[x].target,
                               &(read_data[x]),
                               op_size,
                               DEVICE_XSCOM_ADDRESS(test_data[x].addr) );

          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test__MultiChipScomWrite_proc> [%d] XSCOM Read: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test__MultiChipScomWrite_proc> ERROR : Unexpected error log from write1" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
          else if(read_data[x] != test_data[x].data)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test__MultiChipScomWrite_proc> [%d] XSCOM Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);
              TS_FAIL( "ScomTest::test__MultiChipScomWrite_proc> ERROR : Data mismatch between read and expected data" );
              fails++;
          }

          // Read the data back using generic SCOM to make sure the data is the same.
          l_err = deviceOp(    DeviceFW::READ,
                               test_data[x].target,
                               &(read_data[x]),
                               op_size,
                               DEVICE_SCOM_ADDRESS(test_data[x].addr) );


          if( l_err )
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test__MultiChipScomWrite_proc> [%d] SCOM Read: Error from device : addr=0x%X, RC=%X", x,  test_data[x].addr, l_err->reasonCode() );
              TS_FAIL( "ScomTest::test__MultiChipScomWrite_proc> ERROR : Unexpected error log from write2" );
              fails++;
              errlCommit(l_err,SCOM_COMP_ID);
          }
          else if(read_data[x] != test_data[x].data)
          {
              TRACFCOMP(g_trac_scom, "ScomTest::test__MultiChipScomWrite_proc> [%d] SCOM Read: Data mismatch : addr=0x%X, read_data=0x%llx, write_data=0x%llx", x, test_data[x].addr, read_data[x], test_data[x].data);
              TS_FAIL( "ScomTest::test__MultiChipScomWrite_proc> ERROR : Data mismatch between read and expected data" );
              fails++;
          }

      }

      TRACFCOMP( g_trac_scom, "ScomTest::test__MultiChipScomWrite_proc> %d/%d fails", fails, total );

  }

};



#endif
