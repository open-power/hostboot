# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/isteps/plugins/ebmc/hbfwPlatHwpErrParser.py $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2022
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG
# hbfwPlatHwpErrParser.py
# This file is generated by perl script platCreateHwpErrParser.pl
# Last generated: Tue Jul  5 15:21:52 2022 GMT

import json
from udparsers.helpers.errludP_Helpers import intConcat
def hbfwErrLookupHwpRc(ver, data):
    d = dict()
    i = 0

    RCDesc={
            0x955ab8: [ "RC_FAPI2_BUFFER",
                        "fapi2 error from a buffer operation" ],
            0xb6ffb1: [ "RC_FAPI2_SAMPLE",
                        "sample error to be thrown for testing purposes" ],
            0xbcbcb1: [ "RC_MSS_BAD_MR_PARAMETER",
                        "A bad parameter was passed to MR processing This is probably due to a bad value received from the SPD (e.g. unsupported cas latency) Could be a code error" ],
            0xe416a2: [ "RC_MSS_DIVIDE_BY_ZERO",
                        "Attempt to divide by zero" ],
            0x7b312a: [ "RC_MSS_EMPTY_VECTOR",
                        "Empty vector conditional failed." ],
            0x5cd8ca: [ "RC_MSS_FAILED_TO_FIND_TRFC",
                        "Unable to find tRFC (ps) from map with SDRAM density key" ],
            0x059baf: [ "RC_MSS_FREQ_CL_EXCEEDS_TAA_MAX",
                        "Calculated Cas Latency exceeds JEDEC value for TAA Max desired (and DIMM supported) cas_latency * proposed tck from mss freq attributes > jedec taa_max Probably due to MRW/ VPD freqs being too high" ],
            0xf9f987: [ "RC_MSS_FREQ_FAILED_TO_FIND_SUPPORTED_CL",
                        "Desired CAS latency isn't supported in the common CAS latency bin retrieved from SPD." ],
            0xc37370: [ "RC_MSS_FREQ_DDR5_FAILED_TO_FIND_SUPPORTED_CL",
                        "Desired CAS latency isn't supported in the common CAS latency bin retrieved from SPD." ],
            0x1dbeb9: [ "RC_MSS_FREQ_DDR5_COMPUTED_ZERO_TCK_STD",
                        "Dutring CAS latency computation, tCKstd value of zero was computed, likely due to a problem with the SPD." ],
            0xf30338: [ "RC_MSS_OVERFLOW_WHEN_ROUNDING_TO_EVEN",
                        "Overflow when rounding a timing value to the next larger even value" ],
            0x559861: [ "RC_MSS_FREQ_INDEX_TOO_LARGE",
                        "Error calculating the index into max_freq array" ],
            0xabe12b: [ "RC_MSS_FREQ_INVALID_CALCULATED_TCK",
                        "Invalid value clock period (less than equal 0). Should be code bug and error comparing MRW and VPD SUPPRTED_FREQS Caused by bad MRW values for MSS_MRW_SUPPORTED_FREQ" ],
            0x90d439: [ "RC_MSS_INVALID_CW_ENCODING",
                        "Set if a controlword is invalid" ],
            0x0f7aa2: [ "RC_MSS_INVALID_RTT_WR_ENCODING",
                        "An invalid/unsupported RTT_WR encoding was received" ],
            0x62f4f6: [ "RC_MSS_FREQ_NO_COMMON_SUPPORTED_CL",
                        "Current Configuration has no common supported CL values. Caused by bad SPD on one of the plugged DIMMS or DIMM configuration is not supported" ],
            0xac6099: [ "RC_MSS_FREQ_SELECTED_FREQ_NOT_SUPPORTED",
                        "Selected freq based on calculations from the DIMM and VPD is not supported" ],
            0xca88ab: [ "RC_MSS_INVALID_CAST_WHEN_ROUNDING",
                        "Invalid cast or calculation for corrected_ps_per_jedec" ],
            0xf51d9b: [ "RC_MSS_INVALID_CAST_CALC_NCK",
                        "Invalid cast or calculation for calc_nck" ],
            0xb089df: [ "RC_MSS_INVALID_CLOCK_PERIOD",
                        "An invalid clock period was passed to clock period to frequency" ],
            0x95eebe: [ "RC_MSS_INVALID_DB_MDQ_DRIVE_STRENGTH",
                        "Bad SPD data for bytes 145 - 147. Reserved settings for data buffer MDQ drive strength received. This could be code problem (decoding) or bad SPD." ],
            0xfa26a9: [ "RC_MSS_INVALID_DIMM_SPEED",
                        "Invalid DIMM speed received. Possibly a programming error." ],
            0x7c57df: [ "RC_MSS_INVALID_DIMM_TYPE",
                        "Received a DIMM type unsupported by the SPD decoder factory" ],
            0x0a7852: [ "RC_MSS_INVALID_DRAM_GEN",
                        "Received a DRAM gen unsupported by the SPD decoder factory" ],
            0x3c1074: [ "RC_MSS_INVALID_FREQ_PASSED_IN",
                        "An invalid Freq value has been set" ],
            0xdda43d: [ "RC_MSS_INVALID_FREQUENCY",
                        "An invalid frequency was passed to frequency to clock period" ],
            0xba46d8: [ "RC_MSS_INVALID_FREQ_LIST_PASSED",
                        "Wrong size vector passed into frequency scoreboard function" ],
            0x995d5b: [ "RC_MSS_INVALID_FINE_REFRESH_MODE",
                        "Invalid fine refresh mode received from the mrw" ],
            0x7b2c98: [ "RC_MSS_INVALID_PORT_INDEX_PASSED",
                        "An invalid port index was passed into an MSS function" ],
            0x1d85da: [ "RC_MSS_INVALID_RANK",
                        "Invalid rank passed into function" ],
            0xcf4fb1: [ "RC_MSS_INVALID_REFRESH_RATE_REQUEST",
                        "Invalid refresh request rate received. Possibly due to bad MRW setting for ATTR_MSS_MRW_REFRESH_RATE_REQUEST." ],
            0x742c6a: [ "RC_MSS_INVALID_SPD_NONHYBRID_MDS",
                        "Conflict in SPD fields: HYBRID_MEDIA_TYPE (byte 3, bits 1:3) cannot be MDS if HYBRID (byte 3, bit 0) is not set." ],
            0xcc6696: [ "RC_MSS_INVALID_SPD_REVISION",
                        "Unable to fall back SPD decoder to the highest decoded revision. Most likely a programming error." ],
            0xbd1670: [ "RC_MSS_INVALID_SPD_REVISION_FOR_MODULE_SPECIFC",
                        "Unable to fall back SPD decoder to the highest decoded revision when generating the module specific processor. Most likely a programming error." ],
            0x7449c5: [ "RC_MSS_INVALID_SPD_RANK",
                        "Invalid rank passed into attribute engine. May be due to problem in SPD. Note: calls out the rank from the PHY perspective." ],
            0x596b37: [ "RC_MSS_INVALID_SPD_RESERVED_BITS",
                        "Invalid SPD reserved bits received. This could be code problem (decoding) or bad SPD." ],
            0xdbb13c: [ "RC_MSS_INVALID_TIMING_VALUE",
                        "Invalid value calculated for timing value based on MTB and FTB from SPD." ],
            0xc93d99: [ "RC_MSS_INVALID_VPD_FREQ_LIST_PASSED",
                        "Wrong size vector passed into limit_freq_by_vpd function" ],
            0x6ca9fb: [ "RC_MSS_INVALID_VPD_KEYWORD_MAX",
                        "VPD keyword is too big for space allocated for it." ],
            0xd029f2: [ "RC_MSS_LOOKUP_FAILED",
                        "Conditional that tests whether a certain key value is located in a map." ],
            0x66554d: [ "RC_MSS_MEMDIAGS_NO_MCBIST_SUBTESTS",
                        "Attempt to run an MCBIST program with no subtests" ],
            0xe53456: [ "RC_MSS_MCBIST_EXCEEDED_MAX_SUBTESTS",
                        "Attempt to run an MCBIST program exceeding the max number of subtests (32)" ],
            0x6951ef: [ "RC_MSS_MCBIST_INCORRECT_PATTERN_LENGTH",
                        "MCBIST pattern has an incorrect length" ],
            0x74e61c: [ "RC_MSS_VOLT_WRONG_NUMBER_OF_VOLTAGES",
                        "Incorrect number of voltages supplied to set_voltage_attributes function" ],
            0x3c6a8e: [ "RC_MSS_VOLT_DDR_TYPE_REQUIRED_VOLTAGE",
                        "One or more DIMMs do not support required voltage for DDR type." ],
            0x38aa7e: [ "RC_MSS_PORT_DOES_NOT_SUPPORT_MAJORITY_FREQ",
                        "When considering the frequencies in the MRW and the max supported frequencies based on DIMM config, the indicated port's DIMM do not support the frequency of the majority of other ports' DIMM in the frequency domain. DIMM on the offending port will be deconfigured so the IPL can continue. All DIMM in the offending port's frequency domain will be marked as Hardware Callout." ],
            0x087653: [ "RC_MSS_OUT_OF_BOUNDS_INDEXING",
                        "Desired index is larger than list (std::vector, array, etc.) size. Likely a programming error." ],
            0x03a5ae: [ "RC_MSS_CONVERSION_ERROR",
                        "Overflow or underflow occured converting one integral type to another. This is a programming error." ],
            0xb54613: [ "RC_MSS_FAILED_DATA_INTEGRITY_CHECK",
                        "Bad data received. Settings are incorrect for received data. This could be code problem (decoding) or bad data." ],
            0xd66114: [ "RC_MSS_ZERO_FREQ_OR_SIZE",
                        "An zero memory frequency was passed to calculate min cmd gap" ],
            0x91d395: [ "RC_MSS_MEMDIAGS_INVALID_PATTERN_INDEX",
                        "An invalid pattern index was passed to the pattern loader" ],
            0xf46a8a: [ "RC_MSS_MCBIST_PROGRAM_TOO_BIG",
                        "MCBIST program larger than currently supported size" ],
            0x9390c1: [ "RC_MSS_MCBIST_INVALID_ADDRESS_PAIR_INDEX",
                        "An invalid address pair index" ],
            0x93f1aa: [ "RC_MSS_POWER_INTERCEPT_NOT_SET",
                        "The attribute ATTR_MSS_TOTAL_POWER_INTERCEPT was not set and equals 0" ],
            0xe4bbc7: [ "RC_MSS_POWER_SLOPE_NOT_SET",
                        "The attribute ATTR_MSS_TOTAL_POWER_INTERCEPT was not set and equals 0" ],
            0x1e685d: [ "RC_MSS_NO_DATABUS_UTILIZATION",
                        "There are 2 DIMMS on the port but both have 0 databus utilization" ],
            0x0c98fd: [ "RC_MSS_CALC_POWER_CURVE_DIVIDE_BY_ZERO",
                        "Denominator equals 0" ],
            0xde8a7d: [ "RC_MSS_CALC_POWER_CURVE_NEGATIVE_OR_ZERO_SLOPE",
                        "Power curve slope equals 0 or is negative" ],
            0x5bec3b: [ "RC_MSS_NO_PORT_POWER_LIMIT",
                        "Got 0 when calculating port power limit. Either no dimms or attribute MEM_WATT_TARGET wasn't set" ],
            0x710086: [ "RC_MSS_NO_PORT_POWER",
                        "Got 0 when calculating port power limits using the DIMMs databus utilization" ],
            0x2b7ea7: [ "RC_MSS_M_DRAM_CLOCKS_EQUALS_ZERO",
                        "ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS was not set and equals zero" ],
            0x48c219: [ "RC_MSS_MAX_FREQ_ATTR_SIZE_CHANGED",
                        "Number of entries for MSS_MRW_MAX_FREQ attribute from VPD has changed without updating the code Asserted because direct accesses to array" ],
            0x98f715: [ "RC_MSS_CALC_PORT_POWER_EXCEEDS_MAX",
                        "The calculated port power from equalizing throttles exceeds the maximum allowed power" ],
            0x170eb2: [ "RC_MSS_SPD_TIMING_FAIL",
                        "Timing SPD parameter failed to meet JEDEC SPD timing bounds. FUNCTION_CODE ffdc field encodes which timing param." ],
            0x5f58ea: [ "RC_MSS_TOO_MANY_DIMMS_ON_PORT",
                        "There seem to be too many dimms on the port" ],
            0xf899bd: [ "RC_MSS_SLOT_UTIL_EXCEEDS_PORT",
                        "The memory throttle per slot (DIMM) exceeds the allowed throttle for the port" ],
            0x63a41f: [ "RC_MSS_OUTPUT_OVERFLOW_CALC_UTIL",
                        "Type of output variable is not large enough for the calculations" ],
            0x84f8da: [ "RC_MSS_TCCDL_OVERFLOW_CALC",
                        "TCCD_L calculation experienced an overflow" ],
            0x1e7d47: [ "RC_MSS_POWER_THERMAL_DECODE_ERROR",
                        "There was no match or value found in decoding the power thermal attributes" ],
            0x689bd0: [ "RC_MSS_MRW_SAFEMODE_UTIL_THROTTLE_NOT_SUPPORTED",
                        "The MRW safemode utilization that is less than the minimum utilization supported. Check ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL." ],
            0x2ce66b: [ "RC_MSS_NO_POWER_THERMAL_ATTR_FOUND",
                        "There was no match or value found in decoding the power thermal attributes" ],
            0x329a72: [ "RC_MSS_POWER_THERMAL_ENCODE_ERROR",
                        "There was no match or value found in encoding the power thermal attributes" ],
            0x352894: [ "RC_MSS_POWER_THERMAL_ATTR_VECTORS_INCORRECT",
                        "The attributes vectors size is incorrect for find_xxx functions" ],
            0xdd30c0: [ "RC_MSS_POWER_THERMAL_DIMM_INDEX_OUT_OF_BOUND",
                        "The dimm index is out of bound for the port" ],
            0xb7bbc5: [ "RC_MSS_UNSUPPORTED_MRW_POWER_CONTROL_REQUESTED",
                        "The value of ATTR_MSS_MRW_POWER_CONTROL_REQUESTED is unsupported" ],
            0xbe7260: [ "RC_MSS_TOO_MANY_PRIMARY_RANKS_ON_DIMM",
                        "Too many primary ranks were seen on the dimm according to the call to master_ranks_per_dimm" ],
            0x0939cc: [ "RC_MSS_TOO_MANY_PRIMARY_RANKS_ON_PORT",
                        "Too many primary ranks were seen on the port according to the call to master_ranks_per_dimm" ],
            0x411a07: [ "RC_MSS_RANK_OUT_OF_RANGE",
                        "The rank provided to the rank::info constructor exceeded the maximum rank for the MC" ],
            0x8d37db: [ "RC_MSS_INVALID_GALOIS_TO_SYMBOL",
                        "An invalid galois code was found" ],
            0x2c1c20: [ "RC_MSS_INVALID_SYMBOL_FOR_GALOIS",
                        "An invalid symbol was passed to symbol_to_galois" ],
            0x414146: [ "RC_MSS_INVALID_DQ_TO_SYMBOL",
                        "An invalid DQ bit index received to map to Galois symbol" ],
            0x415be7: [ "RC_MSS_INVALID_SYMBOL_TO_DQ",
                        "An invalid symbol received to map to DQ bit index" ],
            0xb13afe: [ "RC_MSS_INVALID_RANK_PASSED",
                        "An invalid rank was passed to ecc::read function" ],
            0x3dd6f6: [ "RC_MSS_INVALID_INDEX_PASSED",
                        "An invalid index was passed to the specified function" ],
            0x098ebb: [ "RC_MSS_INVALID_PAGE_SIZE",
                        "Invalid page size" ],
            0xef2f1a: [ "RC_MSS_MIN_UTILIZATION_ERROR",
                        "The input utilization is less than the minimum utilization allowed." ],
            0x2a5085: [ "RC_MSS_DDIMM_RESET_N_DEAD_LOAD",
                        "A DDIMM shares a reset_n signal with a deconfigured DDIMM." ],
            0xb2a3a2: [ "RC_MSS_RESTORE_REPAIRS_NIBBLE_OUT_OF_RANGE",
                        "The nibble index to perform repairs on / deploy a spare was out of range." ],
            0x3cf21f: [ "RC_MSS_PLUG_RULES_MIXED_MDS_PLUG_ERROR",
                        "An invalid mixing of MDS and non-MDS dimms detected." ],
            0xfb9285: [ "RC_INVALID_MDS_MEDIA_CNTL_TARGET_CONFIG",
                        "Did not find a valid media controller target on an MDS DDIMM" ],
            0xc038c5: [ "RC_MSS_PLUG_RULES_INVALID_DIMM_SIZE_MIX",
                        "Memory addressing setup requires DIMMs under an OMI channel pair to be of equal size. If this is not the case, the DIMM with the smaller size will be deconfigured. For characterization testing this plug rule can be skipped by overriding ATTR_MEM_IGNORE_PLUG_RULES_DIMM_SIZE_MIX" ],
            0x01a146: [ "RC_MSS_INVALID_FINE_REFRESH",
                        "Incorrect FINE Refresh Mode received" ],
            0xce2718: [ "RC_MSS_PLUG_RULES_INVALID_DIMM_HEIGHT_MIX",
                        "This is due to mechanical restrictions on the system boards. Currently only same height DDIMMs can be used on a P10 systems. For overriding use ATTR_MEM_IGNORE_PLUG_RULES_DIMM_HEIGHT_MIX" ],
            0xcd672e: [ "RC_MSS_CONCURRENT_CCS_EXCEEDS_INSTRUCTION_LIMIT",
                        "Requested CCS Program exceeds the 32 instruction limit for concurrent CCS." ],
            0x4d95cc: [ "RC_MSS_INVALID_PRIMARY_RANK_COUNT",
                        "Invalid number of primary ranks per port retrieved" ],
            0xb2f99a: [ "RC_OCMB_IS_NOT_EXPLORER",
                        "Procedure: exp_omi_init.C The Explorer O0DID was not read." ],
            0xc44e2c: [ "RC_PROC_DOES_NOT_SUPPORT_US_B",
                        "Procedure: exp_omi_init.C Upstream tempate B was requested, but the connected processor does not support it." ],
            0xb7d62b: [ "RC_PROC_DOES_NOT_SUPPORT_DS_A",
                        "Procedure: exp_omi_init.C Downstream tempate A was requested, but the connected processor does not support it." ],
            0xe2001b: [ "RC_METADATA_ENABLE_REQUIRES_TEMPLATE_5_OR_9",
                        "Procedure: exp_omi_init.C Upstream template 5 or 9 need to be enabled for metadata enable." ],
            0xec20e5: [ "RC_ACTAG_PASID_CONFIG_INVALID",
                        "MFIR_ACTAG_PASID_CFG_ERR has been lit due to unsupported configuration in number of acTAGs and PASIDs" ],
            0x7dd35e: [ "RC_EXP_UPDATE_INVALID_IMAGE_SIZE",
                        "Explorer firmware image must be less than 16MB" ],
            0xef84eb: [ "RC_EXP_UPDATE_CMD_FAILED",
                        "Explorer firmware update command returned an unknown error" ],
            0x7afa99: [ "RC_EXP_UPDATE_DEV_INF_ERR",
                        "Explorer firmware update command encountered a device info retrieve error. Likely, this is caused by a bad flash part, so the part is garded" ],
            0x779879: [ "RC_EXP_UPDATE_DEV_SECTOR_INF_ERR",
                        "Explorer firmware update command encountered a device sector info retrieve error Likely, this is caused by a bad flash part, so the part is garded" ],
            0x686643: [ "RC_EXP_UPDATE_DEV_ERASE_ERR",
                        "Explorer firmware update command encountered a device erase error Likely, this is caused by a bad flash part, so the part is garded" ],
            0xe45481: [ "RC_EXP_UPDATE_WRITE_FAIL",
                        "Explorer firmware update command encountered a device write error Likely, this is caused by a bad flash part, so the part is garded" ],
            0xfc2a14: [ "RC_EXP_UPDATE_INV_IMAGE_LEN",
                        "Explorer firmware update command indicated an invalid firmware image size" ],
            0xf63129: [ "RC_EXP_UPDATE_AUTH_FAIL",
                        "Explorer firmware update command indicated a firmware image authentication failure" ],
            0x28378c: [ "RC_EXP_SPI_FLASH_AUTH_FAIL_MFG",
                        "Explorer SPI flash authentication failed for one FW image during MFG test." ],
            0xf1313f: [ "RC_EXP_SPI_FLASH_AUTH_FAIL",
                        "Explorer SPI flash authentication failed for one FW image during MFG test. Without MFG_THRESHOLDS set this error will not deconfigure or gard any hardware." ],
            0x8a8d25: [ "RC_EXP_FLASH_COMMAND_ERR",
                        "Explorer flash command returned a failure" ],
            0x2ac353: [ "RC_EXP_MNFG_SPI_FLASH_CE",
                        "Explorer SPI Flash CE FIR bit, LOCAL_FIR[23], was set during MNFG SPI Flash screen test." ],
            0x0a5d1e: [ "RC_EXP_MNFG_SPI_FLASH_TIMEOUT_READING_IMAGE",
                        "Explorer SPI flash timeout reading FW image during MNFG SPI Flash screen test." ],
            0xe98eca: [ "RC_EXP_MNFG_SPI_FLASH_TIMEOUT_WRITING_TEMP_BANK",
                        "Explorer SPI flash timeout writing FW image to temp bank during MNFG SPI Flash screen test." ],
            0xebb32a: [ "RC_EXP_TWI_INVALID_STATUS_ID",
                        "The status_id field of the TWI status was invalid" ],
            0xfdadba: [ "RC_EXP_TWI_UNEXPECTED_STATUS",
                        "Received unexpected TWI status" ],
            0x3a5583: [ "RC_EXP_TWI_UNEXPECTED_WRITE_OFFSET",
                        "Received unexpected TWI write offset" ],
            0x65c956: [ "RC_EXP_TWI_INVALID_IMAGE_SIZE",
                        "Explorer TWI firmware image must be less than 256KB" ],
            0x5ea902: [ "RC_MSS_EXP_I2C_FW_DOWNLOAD_INVALID_STATE",
                        "Must be in BOOT_ROM or FW_UPGRADE boot stage to issue FW_DOWNLOAD command" ],
            0x2a566f: [ "RC_EXP_FW_UPDATE_WRITE_NO_DOORBELL",
                        "Explorer firmware update write command did not receive the doorbell" ],
            0x4f5451: [ "RC_EXP_FW_UPDATE_COMMIT_NO_DOORBELL",
                        "Explorer firmware update write command did not receive the doorbell" ],
            0x28ecdb: [ "RC_EXP_UNKNOWN_REVISION",
                        "The Explorer revision does not match a known DD level." ],
            0x8756b9: [ "RC_EXP_INBAND_RSP_CRC_ERR",
                        "Inband response CRC failed to validate." ],
            0x87d44b: [ "RC_EXP_INBAND_LE_DATA_RANGE",
                        "Data is not long enough for little endian conversion" ],
            0xd27cc2: [ "RC_EXP_INBAND_BE_DATA_RANGE",
                        "Data is not long enough for big endian conversion" ],
            0xc31539: [ "RC_EXP_INBAND_RSP_NO_DOORBELL",
                        "Doorbell is low when expecting a response" ],
            0x5879a5: [ "RC_EXP_MEMDIAGS_COMPARE_ERROR_IN_LAST_PATTERN",
                        "A miscompare error was caused by the last MCBIST pattern" ],
            0xf2634e: [ "RC_EXP_MEMDIAGS_ERROR_IN_LAST_PATTERN",
                        "An error was caused by the last MCBIST pattern" ],
            0xc757b9: [ "RC_EXP_MEMDIAGS_MCBIST_FAILED_TO_START",
                        "The MCBIST engine failed to start its program" ],
            0x3aeb6e: [ "RC_EXP_MEMDIAGS_PORT_NOT_FUNCTIONAL",
                        "The port used in an MCBIST program is not functional" ],
            0xd62168: [ "RC_EXP_MEMDIAGS_SUPERFAST_INIT_FAILED_TO_INIT",
                        "A superfast init operation failed initialization" ],
            0x6d1323: [ "RC_EXP_MEMDIAGS_SUPERFAST_READ_FAILED_TO_INIT",
                        "A superfast read operation failed initialization" ],
            0x38f892: [ "RC_EXP_MEMDIAGS_MCBIST_FAILED_TO_STOP",
                        "The MCBIST engine failed to stop its program" ],
            0xdb90b1: [ "RC_EXP_MEMDIAGS_CONTINUOUS_SCRUB_FAILED_TO_INIT",
                        "A continuous scrub operation failed initialization" ],
            0xecefeb: [ "RC_EXP_MEMDIAGS_TARGETED_SCRUB_FAILED_TO_INIT",
                        "A continuous scrub operation failed initialization" ],
            0x692bcd: [ "RC_EXP_MEMDIAGS_ALREADY_AT_BOUNDARY",
                        "A continue request asked to stop at a boundary, but we are there already" ],
            0xd116f0: [ "RC_EXP_MCBIST_TIMEOUT",
                        "MCBIST program failed to return in the time allowed Software timer, MCBIST has not finished in the time allowed" ],
            0x457927: [ "RC_EXP_MCBIST_DATA_FAIL",
                        "MCBIST program appeared to have failed, but set conflicting bits in the status register" ],
            0xec9182: [ "RC_EXP_MCBIST_UNKNOWN_FAILURE",
                        "MCBIST program reported a failure but no error status was found" ],
            0x5c947c: [ "RC_MSS_EXP_DRAMINIT_UNSUPPORTED_DIMM_TYPE",
                        "Unsupported DIMM type encountered in draminit_training procedure" ],
            0x15de5a: [ "RC_MSS_EXP_DRAMINIT_UNSUPPORTED_DRAM_WIDTH",
                        "Unsupported DRAM width encountered in draminit_training procedure" ],
            0xa0a8b0: [ "RC_MSS_EXP_DRAMINIT_UNSUPPORTED_3DS_HEIGHT",
                        "Unsupported 3DS height encountered in draminit_training procedure" ],
            0x93b56a: [ "RC_MSS_EXP_FW_STATUS_POLLING_TIMEOUT",
                        "An OCMB chip failed to reply over i2c during FW_STATUS loop." ],
            0x71d47a: [ "RC_MSS_EXP_HALF_DIMM_MODE_NOT_SUPPORTED",
                        "The enterprise settings do not support half dimm mode." ],
            0xb66d3c: [ "RC_MSS_EXP_ENTERPRISE_INVALID_CONFIGURATION",
                        "The enterprise supported bit from explorer fuse conflicts with the enterprise policy setting." ],
            0x241b0e: [ "RC_MSS_EXP_ENTERPRISE_SETUP_ERROR",
                        "The enterprise mode bit is in the incorrect state" ],
            0x0a607c: [ "RC_MSS_EXP_I2C_FW_STATUS_BUSY",
                        "Received FW_BUSY status after polling timeout for command ID EXP_FW_STATUS. See CMD_ID for the failing command id." ],
            0x463be1: [ "RC_MSS_EXP_POLL_ABORT_FW_STATUS_BUSY",
                        "Received FW_BUSY status after polling timeout for command ID EXP_FW_STATUS after sending the POLL_ABORT command." ],
            0x0a7704: [ "RC_MSS_EXP_I2C_CMD_FAIL",
                        "Received non-SUCCESS status for command ID EXP_FW_STATUS. See CMD_ID for the failing command id." ],
            0x625630: [ "RC_MSS_MDS_I2C_WRONG_RSP_SIZE",
                        "Received an incorrect response size for MDS I2C scoms." ],
            0x528041: [ "RC_MSS_MDS_I2C_CMD_FAIL",
                        "Received non-SUCCESS status for MDS I2C scoms." ],
            0x32bffe: [ "RC_MSS_EXP_I2C_WRONG_BOOT_STAGE",
                        "Received incorrect boot stage from command ID EXP_FW_STATUS This RC is set during check_for_ready. At this time, the only stages that can come out are RUNTIME_FW, BOOT_ROM, and FW_UPGRADE. Likely this RC is set for FW_UPGRADE, which means that explorer has missing or corrupted FW." ],
            0xbb21c7: [ "RC_MSS_EXP_I2C_POLLING_TIMEOUT_RESET",
                        "Polling the explorer I2C interface for an ACK timed out when explorer was coming out of reset." ],
            0xbf6ad7: [ "RC_MSS_EXP_I2C_POLLING_TIMEOUT_BOOT_ROM",
                        "Polling the explorer I2C interface for an ACK timed out during explorer boot ROM to runtime FW transition" ],
            0x572db0: [ "RC_MSS_EXP_I2C_FW_STATUS_INVALID_SIZE",
                        "Received incorrect EXP_FW_STATUS data size" ],
            0x40e643: [ "RC_MSS_EXP_RSP_ARG_FAILED",
                        "The response_argument field of the host_fw_response_struct returned a FAILURE" ],
            0x58acac: [ "RC_MSS_EXP_SENSOR_CACHE_ENABLE_FAILED",
                        "The response_argument field of the host_fw_response_struct returned a FAILURE for enabling sensor cache" ],
            0x9768b9: [ "RC_MSS_EXP_BOOT_CONFIG_INVALID_CMD",
                        "BOOT_CONFIG command was invalid." ],
            0x34c5ab: [ "RC_MSS_EXP_BOOT_CONFIG_LOOPBACK_FAIL",
                        "BOOT_CONFIG command encountered an OMI loopback test failure." ],
            0x228291: [ "RC_MSS_EXP_BOOT_CONFIG_SERDES_INIT_FAIL",
                        "BOOT_CONFIG command encountered an OMI SerDes initialization failure." ],
            0x5fda0d: [ "RC_MSS_EXP_BOOT_CONFIG_SERDES_DLL_LOCK_FAIL",
                        "BOOT_CONFIG command encountered an OMI SerDes DLL lock failure." ],
            0x4c904b: [ "RC_MSS_EXP_BOOT_CONFIG_DLX_CONFIG_FAIL",
                        "BOOT_CONFIG command encountered an OMI DL config or training failure." ],
            0x4479f1: [ "RC_MSS_EXP_BOOT_CONFIG_LANE_INV_FAIL",
                        "BOOT_CONFIG command encountered an OMI lane inversion failure." ],
            0x50f21f: [ "RC_MSS_EXP_BOOT_CONFIG_PARITY_UECC_ERROR",
                        "BOOT_CONFIG command encountered OMI parity or UECC errors." ],
            0x14ea6e: [ "RC_MSS_EXP_DDR_PHY_INIT_UNSUPPORTED_MODE",
                        "Phy Init command configured with an unsupported phy init mode." ],
            0x8f55c8: [ "RC_MSS_EXP_DDR_PHY_INIT_USER_INPUT_MSDG_SIZE_ERROR",
                        "Phy Init command sent user_input_msdg with an incorrect size." ],
            0x9e75fc: [ "RC_MSS_EXP_DDR_PHY_INIT_USER_INPUT_MSDG_MISSING_FLAG",
                        "Phy Init command sent user_input_msdg missing extended data flag." ],
            0xcf3be3: [ "RC_MSS_EXP_DDR_PHY_INIT_USER_INPUT_MSDG_ERROR",
                        "Phy Init command encountered user_input_msdg error. This could be caused by bad SPD or attribute overrides." ],
            0xc174d1: [ "RC_MSS_EXP_DDR_PHY_INIT_TRAINING_FAIL",
                        "Phy Init command encountered a training fail. Note: this should be logged as recovered and bad DRAM repaired" ],
            0xff1625: [ "RC_MSS_EXP_DRAMINIT_TRAINING_TIMEOUT_FAIL",
                        "Phy Init command encountered a training timeout fail. These can usually be solved by retrying training As we are not able to retrigger training, we deconfigure the part" ],
            0xd688bb: [ "RC_MSS_EXP_CATASTROPHIC_DRAMINIT_TRAINING_FAIL",
                        "Phy Init command encountered a catastrophic training fail. This error means that the bad bits coming out of training cannot be trusted As such, the part will be deconfigured" ],
            0x7d343a: [ "RC_MSS_EXP_DDR_PHY_INIT_UNKNOWN_ERROR",
                        "Phy Init command encountered an unknown fail. Check error code and extended codes in trace data." ],
            0x095783: [ "RC_MSS_EXP_CCS_READ_MISCOMPARE",
                        "CCS reports a read miscompare." ],
            0x5303e7: [ "RC_MSS_EXP_CCS_UE_SUE",
                        "CCS reports a UE or SUE in the CCS program array Chould be an indicator of corruption in the CCS program" ],
            0x33236f: [ "RC_MSS_EXP_CCS_HUNG",
                        "Software reported that the machine is not seeing the CCS finish in the alloted time" ],
            0x9f51e1: [ "RC_EXP_CCS_HUNG_TRYING_TO_STOP",
                        "CCS failed to return from in-progress status while trying to stop a previous program Software reported that CCS did not finish in alloted time after manually triggering stop" ],
            0xe47655: [ "RC_EXP_RESPONSE_WRONG_REQID",
                        "Request ID in Explorer response was not equal to the ID in the command. Indicates a mismatch between command and response." ],
            0x0dfc3e: [ "RC_MSS_EXP_UNKNOWN_PHY_INIT_MODE",
                        "The PHY init mode value was an unknown value." ],
            0x998c9c: [ "RC_MSS_EXP_INVALID_PHY_INIT_RSP_DATA_LENGTH",
                        "The data buffer vector retrieved from the EXP_FW_DDR_PHY_INIT response did not match the expected length" ],
            0x0cd3c1: [ "RC_MSS_EXP_INVALID_FW_ADAPTER_PROPERTIES_RSP_DATA_LENGTH",
                        "The data buffer vector retrieved from the EXP_FW_ADAPTER_PROPERTIES_GET response did not match the expected length" ],
            0x354e05: [ "RC_MSS_EXP_SUM_MASK_REG_SCOM_FAIL",
                        "A Scom fail occurred when attempting to access EXPLR_TP_MB_UNIT_TOP_SUM_MASK_REG at address 0x08040017. This is likely due to using an unsupported Explorer firmware version (prior to CL402648)" ],
            0x1cb173: [ "RC_MSS_EXP_UNKNOWN_THERMAL_SENSOR",
                        "The thermal sensor type for the given port was not a known value" ],
            0xb74459: [ "RC_EXP_MAINT_SYMBOL_NOT_FOUND",
                        "The requested symbol does not match a steer index." ],
            0x1b6023: [ "RC_EXP_MAINT_BAD_RANK_INPUT",
                        "The rank passed into a steer function was invalid." ],
            0xd25739: [ "RC_EXP_MAINT_BAD_SPARE_INDEX",
                        "A spare index returned from symbol translation was invalid." ],
            0xafe5cb: [ "RC_EXP_MAINT_BAD_STEER_MUX_TYPE",
                        "The steer mux type passed into a steer function was invalid." ],
            0xd1c892: [ "RC_EXP_MAINT_INVALID_SYMBOL",
                        "The symbol passed into a steer function was invalid." ],
            0x17a177: [ "RC_EXP_MAINT_DO_STEER_ALL_SPARES_DEPLOYED",
                        "All spares are already deployed when do_steer called." ],
            0x04d7bb: [ "RC_I2C_GET_SCOM_INVALID_READ_SIZE",
                        "First Byte data returned from the i2c register read contains the size of the remaining bytes returned. This should match the number of bytes we requested." ],
            0xfa6bda: [ "RC_I2C_SCOM_EXPECTED_IBM_INDICATOR",
                        "First Byte of the address passed to i2c_scom operation did not match what was required for IBM scom. I2c scoms associated with 64 bits of are assumed to be IBM scoms and must have 0x08 set in the first byte of the address." ],
            0x9d60c7: [ "RC_I2C_SCOM_UNEXPECTED_IBM_INDICATOR",
                        "First Byte of the address passed to i2c_scom operation had 0x08 set which indicates IBM scom. But the data associated with the address does not match IBM scom data size." ],
            0xb33ed3: [ "RC_COLLECT_EXPLORER_ERROR",
                        "Collects error log data from Explorer chip" ],
            0x2b999a: [ "RC_EXPLORER_ACTIVE_ERROR_LOG",
                        "Collect active explorer errors during exp_collect_explorer_active_log" ],
            0xaa5674: [ "RC_EXPLORER_SAVED_IMAGEA_ERROR_LOG",
                        "Collect saved explorer errors during exp_collect_explorer_saved_log" ],
            0x111afc: [ "RC_EXPLORER_SAVED_IMAGEB_ERROR_LOG",
                        "Collect saved explorer errors during exp_collect_explorer_saved_log" ],
            0x8115bb: [ "RC_EXP_OMI_TRAIN_ERR",
                        "exp_omi_train_check did not see expected trained status from OCMB DL0 status register" ],
            0xc00dae: [ "RC_MSS_FFE_CURSOR_OVERFLOW",
                        "Sum of FFE pre-cursor and post-cursor needs to be less than 64" ],
            0xb7e553: [ "RC_OMI_CDR_BW_UNKNOWN_FREQ",
                        "Got unsupported OMI frequency when fetching OMI CDR BW override" ],
            0xe53f0a: [ "RC_EXP_DRAM_INDEX_OUT_OF_BOUNDS",
                        "Index supplied to row repair function out of bounds." ],
            0x1ffe41: [ "RC_EXP_ROW_REPAIR_ENTRY_OUT_OF_BOUNDS",
                        "Input supplied to row repair function out of bounds." ],
            0x5fa471: [ "RC_EXP_ROW_REPAIR_WITH_MNFG_REPAIRS_DISABLED",
                        "Valid row repair was requested while repairs are disabled." ],
            0x70d664: [ "RC_EXP_ROW_REPAIR_MCBIST_STUCK_IN_PROGRESS",
                        "MCBIST is failed to exit scrub or is in use and not available for repair." ],
            0xccbdac: [ "RC_EXP_ROW_REPAIR_CCS_STUCK_IN_PROGRESS",
                        "CCS engine is in use and not available for repair." ],
            0xb78d57: [ "RC_I2C_PMIC_INVALID_READ_SIZE",
                        "The number of bytes returned from the read did not match the expected value." ],
            0x9bd618: [ "RC_PMIC_CHIP_NOT_RECOGNIZED",
                        "The PMIC identifier register contents did not match any known chip." ],
            0x939cd0: [ "RC_PMIC_VOLTAGE_OUT_OF_RANGE",
                        "The voltage from the SPD and offset combination or bias operation was out of range for the PMIC." ],
            0x87ce3f: [ "RC_PMIC_RANGE_CONVERSION_OVERFLOW",
                        "Converting voltage between PMIC switch node range 1 to 0 caused an overflow" ],
            0x952cca: [ "RC_PMIC_ORDER_OUT_OF_RANGE",
                        "The sequence order specified by the SPD was out of range for the PMIC (max 4)" ],
            0x5d64d8: [ "RC_PMIC_DELAY_OUT_OF_RANGE",
                        "The sequence delay specified by the SPD was out of range for the PMIC (max bitmap: 0b111)" ],
            0x1b8472: [ "RC_GPIO_INPUT_PORT_TIMEOUT",
                        "Polling timeout for the GPIO input port while attempting initial communication with PMIC." ],
            0x32add3: [ "RC_PMIC_NOT_ENABLED",
                        "After running pmic_enable, the PMIC VR Enable bit did not remain set. Therefore, the PMIC did not enable successfully." ],
            0xe7801f: [ "RC_PMIC_STATUS_ERRORS",
                        "After running pmic_enable, one or more error status bits were set on the PMICs of this OCMB." ],
            0x34e5c3: [ "RC_PMIC_MISMATCHING_VENDOR_IDS",
                        "The PMIC vendor ID defined in the SPD did not match the ID of the PMIC. Exiting due to possibly incorrect voltage settings." ],
            0x48e8a4: [ "RC_PMIC_MISMATCHING_REVISIONS",
                        "The PMIC revision register value did not match the SPD value. Exiting due to possibly incorrect voltage settings." ],
            0x41773b: [ "RC_VIN_BULK_BELOW_TOLERANCE",
                        "The VIN_BULK read by the PMIC ADC was below the minimum tolerance." ],
            0xf69758: [ "RC_PMIC_EFUSE_BLOWN",
                        "PMIC EFUSE data shows VIN to be out of valid range, indicating the EFUSE must be blown. Before the EFUSE is enabled VIN should be below the EFUSE_OFF_HIGH threshold, and after it should be between EFUSE_ON_LOW and EFUSE_ON_HIGH." ],
            0x1898e2: [ "RC_INVALID_PMIC_TARGET_CONFIG",
                        "Expected to see 2 PMICs on the provided OCMB_TARGET in order to properly perform pmic_enable." ],
            0x6c805d: [ "RC_INVALID_PMIC_GI2C_TARGET_CONFIG",
                        "Expected 4 GENERICI2CSLAVE targets and at least 2 PMICs in order to properly perform 4U pmic_enable." ],
            0x1db32b: [ "RC_PMIC_ENABLE_FAIL",
                        "A PMIC had errors during pmic_enable. See previous recoverable errors to further diagnose. Note: this return code is used for OCMB without PMIC redundancy" ],
            0x1897d0: [ "RC_PMIC_NON_REDUNDANT_FAIL",
                        "A PMIC had errors during pmic_enable and does not have a redundant backup. See previous recoverable errors to further diagnose. Note: this return code is used for OCMB without PMIC redundancy" ],
            0x5cc840: [ "RC_PMIC_REDUNDANCY_FAIL",
                        "Both PMICs in a redundant pair had errors which caused each to drop into N-Mode. Neither PMIC will be able to be VR_ENABLE'd" ],
            0x7e89f8: [ "RC_PMIC_DROPPED_INTO_N_MODE",
                        "The provided PMIC_ID on OCMB_TARGET had errors which has caused a drop into N-Mode. Should be logged as recoverable, only a bad status resulting from multiple PMICs would cause a procedure failure via a different error." ],
            0x8068d3: [ "RC_DIMM_RUNNING_IN_N_MODE",
                        "One of the 4 PMICs had errors which caused the DIMM to drop into N-Mode. Should be logged as recoverable unless the thresholds policy setting overrides this." ],
            0x85dc36: [ "RC_CORECACHE_CLK_CTRL_SL_FAILED",
                        "core/cache clock start/stop failed in SL thold." ],
            0xb590bb: [ "RC_CORECACHE_CLK_CTRL_NSL_FAILED",
                        "core/cache clock start/stop failed in NSL thold." ],
            0x4750a3: [ "RC_CORECACHE_CLK_CTRL_ARY_FAILED",
                        "core/cache clock start/stop failed in ARY thold." ],
            0x3cb12c: [ "RC_CORECACHE_CLK_CTRL_TIMEOUT_EQ",
                        "core/cache clock start/stop timed out." ],
            0x38c80e: [ "RC_CORECACHE_CLK_CTRL_TIMEOUT_CORE",
                        "core/cache clock start/stop timed out." ],
            0x641d7b: [ "RC_EXTRACT_SBE_RC_POWERCHECK_FAIL",
                        "VDN_PGOOD C4 pin is not set high. Action:Retrigger IPL or HRESET [RESTART_SBE]" ],
            0xd966ff: [ "RC_EXTRACT_SBE_RC_RUNNING",
                        "SBE engine is in running state, but an error was raised by external FW code. Action:Retrigger IPL or HRESET [RESTART_SBE]" ],
            0xfe1093: [ "RC_EXTRACT_SBE_RC_NEVER_STARTED",
                        "SBE engine was probably never started or SBE got halted by programming XCR to halt Action:Retrigger IPL or HRESET [RESTART_SBE]" ],
            0x72ca6f: [ "RC_EXTRACT_SBE_RC_PROGRAM_INTERRUPT",
                        "Program interrupt promoted Action:Switch both boot and measurement SEEPROMs [REIPL_BKP_BMSEEPROM]" ],
            0xf43665: [ "RC_EXTRACT_SBE_RC_INST_STORE_INTR",
                        "Instruction storage interrupt Action:Switch boot and measurement SEEPROMs [REIPL_BKP_BMSEEPROM]" ],
            0x13f35a: [ "RC_EXTRACT_SBE_RC_ALIGN_INTR",
                        "Alignment interrupt Action:Retrigger IPL or HRESET [RESTART_SBE]" ],
            0x66847b: [ "RC_EXTRACT_SBE_RC_DATA_STORE_INTR",
                        "Data storage interrupt Action:Retrigger IPL or HRESET [RESTART_SBE]" ],
            0x4292c9: [ "RC_EXTRACT_SBE_RC_ADDR_NOT_RECOGNIZED",
                        "Address scope out of range Action:Switch both boot and masurement SEEPROMs [REIPL_BKP_BMSEEPROM]" ],
            0x2a7844: [ "RC_EXTRACT_SBE_RC_OTP_ECC_ERR_NONSECURE_MODE",
                        "Uncorrectable error detected in OTPROM memory read Action:No recovery action possible to correct this error [NO_RECOVERY_ACTION]" ],
            0xfae593: [ "RC_EXTRACT_SBE_RC_MAGIC_NUMBER_MISMATCH",
                        "SEEPROM magic number didn't match Action:Update of SEEPROM required or switch seeprom [REIPL_UPD_SEEPROM]" ],
            0x85286d: [ "RC_EXTRACT_SBE_RC_SBE_L1_LOADER_FAIL",
                        "Program Interrupt occured during base loader Action:Switch seeprom [REIPL_BKP_MSEEPROM]" ],
            0x0c35ae: [ "RC_EXTRACT_SBE_RC_SBE_L2_LOADER_FAIL",
                        "Program Interrupt occured during L2 loader or pk boot Action:Switch seeprom [REIPL_BKP_SEEPROM]" ],
            0xa5b4ba: [ "RC_EXTRACT_SBE_RC_UNEXPECTED_OTPROM_HALT",
                        "Halted in OTPROM, but not at an expected halt location Action:No recovery action possible to correct this error [NO_RECOVERY_ACTION]" ],
            0xa8a695: [ "RC_EXTRACT_SBE_RC_PIBMEM_ECC_ERR",
                        "Uncorrectable error occurred while PIB memory access, Check if REPAIR solution is applied Action:Retrigger IPL or HRESET [RESTART_SBE]" ],
            0xcc20e3: [ "RC_EXTRACT_SBE_RC_OTP_ECC_ERR",
                        "Uncorrectable error detected in OTPROM memory read Action:No recovery action possible to correct this error [NO_RECOVERY_ACTION]" ],
            0xe37834: [ "RC_EXTRACT_SBE_RC_OTP_TIMEOUT",
                        "PIB Timeout error detected Action:Warm ipl where we don't switch off VSB just toggle start_cbs from FSP [RESTART_CBS]" ],
            0x9fb509: [ "RC_EXTRACT_SBE_RC_OTP_PIB_ERR",
                        "Scom error detected Action:Warm ipl where we don't switch off VSB just toggle start_cbs from FSP [RESTART_CBS]" ],
            0x6c7628: [ "RC_EXTRACT_SBE_RC_PIBMEM_PIB_ERR",
                        "Error detected during pibmem access Action:Warm ipl where we don't switch off VSB just toggle start_cbs from FSP [RESTART_CBS]" ],
            0xf27f9c: [ "RC_EXTRACT_SBE_RC_SPI_CLK_ERR",
                        "SPI is configured with invalid clock divider (less than 0x4) error detected Action:SP code needs to be updated to configure a valid clock divider [REIPL_UPD_SPI_CLK_DIV]" ],
            0xb6dac4: [ "RC_EXTRACT_SBE_RC_SPI_ECC_ERR",
                        "There are 2 bit flips in read data which cannot be corrected Action:Update of SEEPROM required or switch seeprom [REIPL_UPD_*SEEPROM]" ],
            0x9ce47c: [ "RC_EXTRACT_SBE_RC_SPI_SPRM_CFG_ERR",
                        "SPI SEEPROM config error detected Action:Warm ipl where we don't switch off VSB just toggle start_cbs from FSP [RESTART_CBS]" ],
            0x569abe: [ "RC_EXTRACT_SBE_RC_SPI_RSC_ERR",
                        "SPI resources being accessed is not available. Port multiplexer or lock error detected Action:Warm ipl where we don't switch off VSB just toggle start_cbs from FSP [RESTART_CBS]" ],
            0xb4a5c5: [ "RC_EXTRACT_SBE_RC_UNKNOWN_ERROR",
                        "Unknown error has occured, try bkup seeproms or debug has to be done to understand the error Action: Switch sides or debug[REIPL_BKP_BMSEEPROM]" ],
            0x7e8585: [ "RC_SBE_SCAN0_DONE_POLL_THRESHOLD_ERR",
                        "Timeout waiting for scan0 to complete , loop count expired that polls for OPCG_DONE" ],
            0x442bdf: [ "RC_SBE_ARRAYINIT_POLL_THRESHOLD_ERR",
                        "Polling for OPCG_DONE for arrayInit reached threshold , count expired." ],
            0xdf6b25: [ "RC_SRAM_ABIST_DONE_BIT_ERR",
                        "SRAM abist done bit is not set" ],
            0xede569: [ "RC_CPLT_OPCG_DONE_NOT_SET_ERR",
                        "Chiplet OPCG_DONE not set after clock start/stop command" ],
            0x7f8fa1: [ "RC_THOLD_ERR",
                        "thold status not matching the expected value 	in clock start stop sequence" ],
            0xd5a7aa: [ "RC_MC_GROUP_SETUP_ERR",
                        "Chiplet is being added into more 4 groups" ],
            0x93af94: [ "RC_CPLT_NOT_ALIGNED_ERR",
                        "Chiplet not aligned" ],
            0x983ab6: [ "RC_SBE_SCOM_FAILURE",
                        "SBE encountered a SCOM failure" ],
            0xacefa9: [ "RC_SBE_PIB_XSCOM_ERROR",
                        "SBE SCOM failure - PIB XSCOM failure" ],
            0x477ae0: [ "RC_SBE_PIB_OFFLINE_ERROR",
                        "SBE SCOM failure - Chiplet offline" ],
            0x81831e: [ "RC_SBE_PIB_PARTIAL_ERROR",
                        "SBE SCOM failure - Partial SCOM failure" ],
            0xddb281: [ "RC_SBE_PIB_ADDRESS_ERROR",
                        "SBE SCOM failure - SCOM address failure" ],
            0x9e41b0: [ "RC_SBE_PIB_CLOCK_ERROR",
                        "SBE SCOM failure - Clock error" ],
            0xb51845: [ "RC_SBE_PIB_PARITY_ERROR",
                        "SBE SCOM failure - Parity error" ],
            0x38c80d: [ "RC_SBE_PIB_TIMEOUT_ERROR",
                        "SBE SCOM failure - Timeout error" ],
            0xdf5fe2: [ "RC_P10_L3ERR_EXTRACT_UNKNOWN_SYNDROME_ECC",
                        "Procedure: p10_l3err_extract Syndrome ECC is unknown" ],
            0x9f6208: [ "RC_P10_L3ERR_LINE_DELETE_REG_BUSY",
                        "Procedure: p10_l3err_linedelete Time out waiting for PRD L3 Purge engine busy bit." ],
            0x1cad78: [ "RC_P10_L3ERR_EXTRACT_TA_WRONG_SIZE_ERR",
                        "Procedure: p10_l3err_extract Specified trace array length does not match expected length" ],
            0x4d60fe: [ "RC_P10_L3ERR_EXTRACT_SYNDROME_NOT_FOUND",
                        "Procedure: p10_l3err_extract Could not find syndrome" ],
            0xd9a086: [ "RC_P10_L3ERR_RD_CMD_NOT_FOUND",
                        "Procedure: p10_l3err_extract Could not find rd_cmd" ],
            0x05b83b: [ "RC_PM_OCC_GPE_BAD_MODE",
                        "Unknown mode passed to p10_pm_occ_gpe_init." ],
            0x90d227: [ "RC_PM_OCC_GPE0_HALT_TIMEOUT",
                        "Failed to halt OCC GPE0 during HALT operation." ],
            0x7c5657: [ "RC_PM_OCC_GPE1_HALT_TIMEOUT",
                        "Failed to halt OCC GPE1 during HALT operation." ],
            0x2704be: [ "RC_QME_BAD_MODE",
                        "Unknown mode passed to p10_pm_qme_init." ],
            0x4677ff: [ "RC_QME_VREF_CALIBRATION_FAILED",
                        "VDMs/IVRM enabled but necessary VREF calibration failed." ],
            0xbb3b8f: [ "RC_QME_START_TIMEOUT",
                        "QME start timed out while waiting for QME Active in OCCFLG register." ],
            0xa766d3: [ "RC_QME_START_HALTED",
                        "QME start hit a QME engine halt." ],
            0x9c241b: [ "RC_QME_HALT_TIMEOUT",
                        "QME init timedout while waiting for HALT status in XSR register." ],
            0x510858: [ "RC_QME_INVALID_CORE_EX_CONFIG",
                        "Invalid configuration of good core and bad EX detected" ],
            0xe94898: [ "RC_QME_INVALID_CORE_EQ_CONFIG",
                        "Invalid configuration of good core and bad EQ detected" ],
            0xef3f5a: [ "RC_QME_INVALID_EX_CORE_CONFIG",
                        "Invalid configuration of good EX and no functional cores detected" ],
            0x084873: [ "RC_QME_BCE_BUSY_ERR",
                        "QME's block copy engine was found busy and transfer of QME's hcode could not be initiated." ],
            0xf021b1: [ "RC_QME_BCE_HW_ERR",
                        "QME's block copy engine was found in errorneous state and transfer of QME's hcode could not be initiated." ],
            0x87547d: [ "RC_QME_HCODE_TRANSFER_FAILED",
                        "HWP initiated transfer of QME hcode but could not complete within a specified amount of time." ],
            0x31107c: [ "RC_OPIT_INTERRUPT_NOT_CLEAR",
                        "OPIT Type A Interrupts could not be cleared by writing to PIG registers" ],
            0x085a11: [ "RC_QME_FAILED_TO_ENTER_QUIESCE_MODE",
                        "QME(s) failed to confirm entry to quiesce mode" ],
            0xe81447: [ "RC_PPEBAR_TOPOLOGY_INIT_ERROR",
                        "PPE BAR register is initialized with an address which do not fall into list of regions marked valid in topology scom registers." ],
            0x676836: [ "RC_BCEBAR0_TOPOLOGY_INIT_ERROR",
                        "BCEBAR0 register is initialized with an address which do not fall into list of regions marked valid in topology scom registers." ],
            0xb8d63a: [ "RC_BCEBAR1_TOPOLOGY_INIT_ERROR",
                        "BCEBAR1 register is initialized with an address which do not fall into list of regions marked valid in topology scom registers." ],
            0xe8fb62: [ "RC_P10_MSS_BAD_FREQ_CALCULATED",
                        "No frequency found for MC Either bad mrw attribute or no DIMMS installed? Should be a code bug if we get here" ],
            0xd43e36: [ "RC_P10_MSS_FAILED_SYNC_MODE",
                        "DIMM speeds are different and sync mode is required" ],
            0xfb44eb: [ "RC_P10_MSS_MRW_FREQ_MAX_FREQ_EMPTY_SET",
                        "When considering the frequencies in the MRW, the OMI frequency, and the max supported frequencies based on DIMM config (MAX_ALLOWED_DIMM_FREQ), there are no applicable frequencies remaining" ],
            0x38f9cc: [ "RC_P10_MSS_NO_SUPPORTED_FREQ",
                        "When considering the frequencies in the MRW and the max supported frequencies based on DIMM config, there are no applicable frequencies remaining. User data PORTX_FREQ_SUPPORT is a bitmap of DDR frequencies supported by each memory port due to MRW and SPD constraints, with bit0=2666 bit1=2933 bit2=3200 MT/s" ],
            0x85b666: [ "RC_P10_MSS_UNSUPPORTED_OMI_FREQ",
                        "Unsupported OMI frequency encountered in mss_freq_system" ],
            0x257113: [ "RC_P10_MSS_ZERO_HOST_TO_DDR_FREQ_RATIO",
                        "Zero OMI to DDR frequency ratio encountered in mss_freq_system" ],
            0x56849b: [ "RC_P10_RAM_THREAD_INVALID_ERR",
                        "Invalid ram thread specified" ],
            0x751136: [ "RC_P10_SPR_NAME_MAP_INIT_ERR",
                        "SPR name map is not empty while try to initialize." ],
            0x6b08b3: [ "RC_P10_SPR_NAME_MAP_ACCESS_ERR",
                        "Illegal SPR name or read/write mode access" ],
            0x3b95f6: [ "RC_P10_RAM_NOT_SETUP_CLEANUP_ERR",
                        "RAM is not setup as active before cleanup" ],
            0xd6111e: [ "RC_P10_RAM_NOT_SETUP_IO_ERR",
                        "RAM is not setup as active before doing put_reg or get_reg operation" ],
            0x360f36: [ "RC_P10_RAM_NOT_SETUP_OPCODE_ERR",
                        "RAM is not setup as active before doing opcode operation" ],
            0xbd8950: [ "RC_P10_PUT_REG_RAM_INACTIVE_THREAD_HW542214",
                        "RAM to inactive thread (put_reg) and HW542214 is present" ],
            0x4b7ded: [ "RC_P10_OPCODE_RAM_INACTIVE_THREAD_HW542214",
                        "RAM to inactive thread (ram_opcode) and HW542214 is present" ],
            0x1e42db: [ "RC_P10_RAM_THREAD_NOT_STOP_ERR",
                        "The thread to perform ramming is not stopped" ],
            0xf3da63: [ "RC_P10_RAM_THREAD_INACTIVE_ERR",
                        "The thread to perform ramming is not active" ],
            0x1c7637: [ "RC_P10_RAM_STATUS_IN_RECOVERY_ERR",
                        "Attempt to perform ramming during recovery" ],
            0x77d4fb: [ "RC_P10_RAM_STATUS_EXCEPTION_ERR",
                        "Exception or interrupt happened during ramming" ],
            0xde6ec0: [ "RC_P10_RAM_STATUS_POLL_THRESHOLD_ERR",
                        "Polling for ram done reached threshold" ],
            0xde4ce0: [ "RC_P10_RAM_THREAD_ACTION_POLL_THRESHOLD_ERR",
                        "Polling for ram thread action reached threshold" ],
            0x79fb4f: [ "RC_P10_RAM_INVALID_REG_TYPE_ACCESS_ERR",
                        "Illegal reg type access, if REG_NUM = 0xff then ignore the REG_NUM ffdc" ],
            0x3f43c1: [ "RC_P10_RAM_TEST_ECMD_ERROR",
                        "ECMD error during RAM test" ],
            0xf61117: [ "RC_P10_RAM_TEST_GENERAL_ERROR",
                        "General error during RAM test" ],
            0xc84f99: [ "RC_P10_RAM_RANDOM_SPR_NAME_ERROR",
                        "An error occurred while attempting to generate a random SPR name" ],
            0x16e8ae: [ "RC_P10_RAM_HW533775_FUSED_CORE_SEARCH_ERROR",
                        "Unable to find fused core partner for target of RAM operation" ],
            0x64d2e9: [ "RC_P10_RAM_HW533775_RECOVERY_ERROR",
                        "Timeout waiting for core FIR to clear after injecting recovery" ],
            0xda1e11: [ "RC_P10_RNG_INIT_CONDITIONER_STARTUP_TEST_FAILED_ERR",
                        "Procedure: p10_rng_init_phase1 NX RNG Read Conditioner startup test failed after POR, NX RNG is unusable" ],
            0x2805e8: [ "RC_P10_RNG_INIT_SELF_TEST_FAILED_ERR",
                        "Procedure: p10_rng_init_phase2 NX RNG Self Test Hard Fail status is non-zero after programmed initialization, NX RNG is unusable" ],
            0x12c25f: [ "RC_HTM_SETUP_PROC_BAR_SIZE",
                        "ATTR_PROC_HTM_BAR_SIZE contains an invalid size value. Firmware error." ],
            0x34395b: [ "RC_P10_NHTM_CTRL_BAD_STATE",
                        "NHTM is not at the expected state for current operation." ],
            0xadcaaa: [ "RC_P10_CHTM_CTRL_BAD_STATE",
                        "CHTM is not at the expected state for current operation." ],
            0x24c2ab: [ "RC_P10_NHTM_CTRL_TIMEOUT",
                        "NHTM state machine change did not complete in allotted time." ],
            0xf28d00: [ "RC_P10_CHTM_CTRL_TIMEOUT",
                        "CHTM state machine change did not complete in allotted time." ],
            0xf0feef: [ "RC_NHTM_TRACE_TYPE_NOT_SUPPORTED",
                        "The selected Nest HTM trace type is not yet supported." ],
            0xb794cf: [ "RC_CHTM_TRACE_TYPE_NOT_SUPPORTED",
                        "The selected Core HTM trace type is not yet supported." ],
            0x95f128: [ "RC_L3_PURGE_DONE_TIMEOUT",
                        "L3 Purge Done Timeout." ],
            0x55fa9a: [ "RC_P10_SMP_LINK_FIRS_IOHS_NOT_SMP",
                        "The requested IOHS target is not configured as an SMP link. This is a pre-requisite to setup the related FIR registers." ],
            0x280838: [ "RC_P10_SMP_LINK_FIRS_UNSUPPORTED_ACTION",
                        "Procedure: p10_smp_link_firs Unsupported action requested for smp link fir register setup" ],
            0x6865a3: [ "RC_P10_FBC_EFF_CONFIG_LINKS_DIFF_GROUP_ID_ERR",
                        "Procedure: p10_fbc_eff_config_links Error when smpx connected with chip_is_group, or smpa connected -- Two chips in different fabric groups have the same fabric group ID." ],
            0xd69b5b: [ "RC_P10_FBC_EFF_CONFIG_LINKS_SAME_GROUP_ID_ERR",
                        "Procedure: p10_fbc_eff_config_links Error when smpx connected with chip_is_node -- Two chips in the same fabric group do not have the same fabric group ID." ],
            0xb989ed: [ "RC_P10_FBC_EFF_CONFIG_LINKS_IOLINK_POS_ERR",
                        "Procedure: p10_fbc_eff_config_links IOHS sublink children have unexpected unit position numbers" ],
            0xdcb6df: [ "RC_P10_FBC_EFF_CONFIG_LINKS_REMOTE_LINK_ID_ERR",
                        "Procedure: p10_fbc_eff_config_links Unable to determine remote FBC link ID" ],
            0x24436d: [ "RC_P10_FBC_EFF_CONFIG_LINKS_IOLINK_ENDP_ERR",
                        "Procedure: p10_fbc_eff_config_links IOHS sublink remote endpoints don't match MRW link split specification" ],
            0x25b4b4: [ "RC_P10_FBC_EFF_CONFIG_LINKS_IOLINK_NUM_ERR",
                        "Procedure: p10_fbc_eff_config_links More than two IOHS sublink children found" ],
            0x8cb287: [ "RC_P10_FBC_EFF_CONFIG_LINKS_UNSUPPORTED_SPLIT",
                        "Procedure: p10_fbc_eff_config_links IOHS sublink split only supported on odd numbered IOHS targets" ],
            0xcfda24: [ "RC_P10_FBC_EFF_CONFIG_LINKS_MULTIPLE_SPECIFICATION",
                        "Procedure: p10_fbc_eff_config_links Multiple IOHS endpoint links specify connectivity for the same logical fabric link" ],
            0x187e28: [ "RC_XGPE_BAD_MODE",
                        "Unknown mode passed to p10_pm_xgpe_init." ],
            0xd22aea: [ "RC_XGPE_INIT_TIMEOUT",
                        "XGPE init timed out while waiting for XGPE Active in OCC SCRATCH2." ],
            0x63423d: [ "RC_XGPE_INIT_DEBUG_HALT",
                        "XGPE init detected a Debug Halt condition. This should only assert in a development debug environment." ],
            0x63da64: [ "RC_XGPE_RESET_TIMEOUT",
                        "XGPE init timed out while waiting for HALT status in XSR register." ],
            0x8c08f2: [ "RC_XGPE_PBA_INIT_FAILED",
                        "p10_pm_pba_init failed in PM_INIT mode." ],
            0xc39468: [ "RC_PM_SUSPEND_XGPE_FAILS",
                        "XGPE failed to suspend power management" ],
            0xdc93dc: [ "RC_PM_PGPE_SAFE_MODE_FAILS",
                        "PGPE fails to put the system to safe freq/volt" ],
            0x41e816: [ "RC_CORECACHE_PFET_SEQ_STATE_ERROR",
                        "pfet sequencer state isnt 0 before operation." ],
            0xb79de5: [ "RC_CORECACHE_POW_CTRL_TIMEOUT",
                        "core/cache pfet operation timed out." ],
            0x6aa6b0: [ "RC_P10_IO_POWER_ON_OFF_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete io power on or off" ],
            0xb9e96b: [ "RC_P10_THREAD_CONTROL_START_NOMAINT",
                        "Start command precondition not met: RAS STAT Maintenance bit is not set." ],
            0xa81991: [ "RC_P10_THREAD_CONTROL_STOP_FAIL",
                        "Stop command issued to core PC, but RAS STAT maintenance bit is not set." ],
            0x83bcfd: [ "RC_P10_THREAD_CONTROL_STEP_NOTSTOPPING",
                        "Step command precondition not met: Not all threads are stopped." ],
            0x5de972: [ "RC_P10_THREAD_CONTROL_STEP_FAIL",
                        "Step command issued to core PC, but RAS STAT run bit is still set." ],
            0xe8ac86: [ "RC_P10_THREAD_CONTROL_INVALID_COMMAND",
                        "p10_thread_control is called with an invalid command" ],
            0x3d7eb6: [ "RC_P10_ADU_UTILS_INVALID_FLAG",
                        "There was an invalid argument passed in when building flag. It could be either Transaction size or Operation type. Check error trace. Procedure: p10_adu_utils" ],
            0x5bcb95: [ "RC_P10_ADU_UTILS_MISALIGNED_ADDR",
                        "There is an invalid argument (misaligned address) passed to the adu access or adu setup procedure Procedure: p10_adu_utils" ],
            0x472528: [ "RC_P10_ADU_UTILS_INVALID_ADDR",
                        "There is an invalid argument (address out of the fabric address range) passed to the adu access or adu setup procedure Procedure: p10_adu_utils" ],
            0x23ed34: [ "RC_P10_ADU_FBC_NOT_INITIALIZED",
                        "The fabric was not initialized or not running Procedure: p10_adu_utils" ],
            0x128690: [ "RC_P10_ADU_STATUS_REG_UNEXPECTED_ERR",
                        "The ALTD_STATUS_REGISTER contains unexpected status with no indication of a combined response address error Procedure: p10_adu_utils" ],
            0xb14326: [ "RC_P10_ADU_STATUS_REG_ADDRESS_ERR",
                        "The ALTD_STATUS_REGISTER contains unexpected status with an indication of a combined response address error Procedure: p10_adu_utils" ],
            0xa9f691: [ "RC_P10_ADU_UTILS_LOCK_ERR",
                        "Number of lock attempts exceeded when attempting to acquire the ADU lock or error occured when attempting to pick the ADU lock Procedure: p10_adu_utils" ],
            0x86ffa3: [ "RC_P10_ADU_UTILS_EXTRA_INPUT_DATA",
                        "Error code used to collect HWP input arguments Procedure:p10_adu_utils" ],
            0x6f95d5: [ "RC_BAD_HOMER_PTR",
                        "Pointer to HOMER base is bad" ],
            0xc5748b: [ "RC_NO_MALF_PM_RESET",
                        "PM Complex has been reset for a reason other than malfunction" ],
            0x8cc282: [ "RC_PM_MALF_DEAD_CORES_FOUND",
                        "PM malfunction caused loss of functional cores" ],
            0x12270a: [ "RC_PM_MALF_NO_DEAD_CORES",
                        "PM malfunction detected but it did not cause loss of functional cores." ],
            0x6c040b: [ "RC_P10_IOHS_INIT_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete io init" ],
            0xcfe7b9: [ "RC_P10_IOHS_RESET_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete io reset" ],
            0xee83cd: [ "RC_P10_IOHS_RESET_IOLINK_SEARCH_ERR",
                        "No IOLINK target found to match requested link half" ],
            0xfc57bb: [ "RC_CORE_CHANGE_DONE_RESCLK_ENTRY_TIMEOUT",
                        "core change done on resclk entry timed out." ],
            0x354cef: [ "RC_ECL2_CLK_SYNC_DROP_TIMEOUT",
                        "core+L2 clock sync done timed out." ],
            0x130632: [ "RC_P10_IO_IOHS_POLL_RECAL_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete io recal" ],
            0x92714e: [ "RC_P10_L3_FLUSH_INVALID_ARGS_ERR",
                        "Procedure: p10_l3_flush Invalid parameters passed in for a L3 flush operation." ],
            0xbc4729: [ "RC_P10_L3_FLUSH_PREVIOUS_PURGE_ACTIVE_ERR",
                        "Procedure: p10_l3_flush A previous L3 purge request has not finished." ],
            0xe461a9: [ "RC_P10_L3_FLUSH_PURGE_REQ_TIMEOUT_ERR",
                        "Procedure: p10_l3_flush The L3 flush did not finish and has timed out" ],
            0x19e639: [ "RC_BAD_POUNDW_VPD_READ",
                        "Attempted to read #W data and got less data than we expected" ],
            0xe1a2c3: [ "RC_INVALID_POUNDW_VERSION",
                        "Read unknown version type from #W keyword in a CRP0 record" ],
            0x5ecc85: [ "RC_INCORRECT_POUNDW_BUCKET_ID",
                        "Bucket Id in #W data was not the expected Bucket Id." ],
            0x616991: [ "RC_P10_IO_INIT_DONE_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete io init" ],
            0x710114: [ "RC_SPCWKUP_CORE_TIMEOUT",
                        "Special wakeup to core chiplet timed out." ],
            0x511770: [ "RC_SPCWKUP_CORE_TIMEOUT_MC",
                        "Special wakeup to multi-cast core chiplet timed out." ],
            0x24b00f: [ "RC_SYSTEM_IN_CHECKSTOP_STATE",
                        "System is in Checkstop state. Attempt to special wakeup a core will not succeed. Hence, HWP will not even attempt for core special wakeup. CORE_TARGET/EQ_TARGET ffdc tags could be both multicast targets, if not the CORE_SELECT/EQ_MC_GROUP ffdc tags will be set to 0 and MCGROUP_COUNT respectively." ],
            0xc0c7ae: [ "RC_INTERNAL_SPCWKUP_IN_PROGRESS",
                        "Special wakeup is already in progress. Ignoring current request. NOTE: The intention of defining this RC is to generate the constant value fapi2::RC_INTERNAL_SPCWKUP_IN_PROGRESS. No ffdc nor callouts are required" ],
            0xabafd7: [ "RC_CORE_SPECIAL_WAKEUP_NOT_FEASIBLE",
                        "Special Wakeup can not be serviced for given core. QME servcing the cores of the quad is not booted yet." ],
            0x86a5f5: [ "RC_INTERNAL_NO_TIMEOUT_DUETO_STOP0_BUG",
                        "An internal RC suggesting that spl wakeup timeout did not occur due to HW529794 NOTE: The intention of defining this RC is to generate the constant value fapi2::RC_INTERNAL_SPCWKUP_IN_PROGRESS. No ffdc nor callouts are required" ],
            0x3ef579: [ "RC_SPCWKUP_CORE_HW529794_TIMEOUT",
                        "Special wakeup request to core chiplet timed out due to HW529794" ],
            0x0b4ee9: [ "RC_SPCWKUP_CORE_HW529794_TIMEOUT_MC",
                        "Special wakeup request to multicast core chiplet timed out due to HW529794" ],
            0x36dd57: [ "RC_ECO_CORE_SPWU_SKIPPED",
                        "special wakeup is skipped for ECO core when QME is quiesced" ],
            0xd84723: [ "RC_MVPD_RING_FUNC_ENDLESS_BUFFER",
                        "Corrupted MVPD data buffer" ],
            0xdd2a89: [ "RC_MVPD_RING_FUNC_INVALID_RS4_MAGIC",
                        "The RS4 magic word is invalid" ],
            0xd701a9: [ "RC_MVPD_RING_FUNC_INVALID_RS4_HEADER",
                        "One or more fields in the RS4 header or ring block buffer is wrong" ],
            0xd2ebb1: [ "RC_MVPD_RING_FUNC_NULL_POINTER",
                        "NULL pointer passed to mvpdRingFunc(SET) is not allowed" ],
            0xca4972: [ "RC_MVPD_RING_FUNC_INVALID_RECORD_KEYWORD_PAIR",
                        "The Mvpd record and keyword don't pair up properly" ],
            0xfc87ff: [ "RC_MVPD_RING_NOT_FOUND",
                        "Specified MVPD ring was not found (Not a bug. Info to caller.)" ],
            0x4aa918: [ "RC_MVPD_RING_BUFFER_TOO_SMALL",
                        "Data does not fit into supplied buffer (Not a bug. Info to caller.)" ],
            0x1a6337: [ "RC_MVPD_INSUFFICIENT_RECORD_SPACE",
                        "Ring content does not fit into Mvpd record buffer" ],
            0xac7ed4: [ "RC_MVPD_INSUFFICIENT_RING_BUFFER_SPACE",
                        "Data does not fit into output ring buffer" ],
            0xfd971d: [ "RC_MVPD_CODE_BUG",
                        "Code bug: Fix code!" ],
            0xc92365: [ "RC_I2C_STATUS_ERROR",
                        "I2C status error - one of the error bits set" ],
            0x568774: [ "RC_I2C_STATUS_INTR_ERROR",
                        "I2C status error - one of the i2c interrupt hit" ],
            0x14afed: [ "RC_I2C_FIFO_TIMEOUT_ERROR",
                        "I2C fifo condition error - timedout waiting for a condition" ],
            0x43b630: [ "RC_SBE_I2C_WAIT_FOR_CMD_COMP_TIMEOUT_ERROR",
                        "I2C wait for command completion error - Timeout error" ],
            0xcdaf48: [ "RC_SBE_SPI_INVALID_PORT_MULTIPLEX_SET",
                        "Procedure: Error calling p10_sbe_spi_cmd HWP Error due to settings error bit 50 for port multiplexer setting on SPI cmd status register." ],
            0xe164fb: [ "RC_SBE_SPI_CMD_STATUS_REG_UNSUPPORTED_STATE",
                        "The SPI status register state bits check validation failed." ],
            0x1eda3a: [ "RC_SBE_SPI_HANG_TIMEOUT",
                        "Procedure: Error calling p10_sbe_spi_cmd HWP Error due to detected hang while waiting for SPI cmd completion." ],
            0x658fa7: [ "RC_MSS_BAD_CL_CAST",
                        "Calculated Cas Latency exceeds the 8-bit limit. Error calculating" ],
            0xe7af7e: [ "RC_MSS_BAD_FREQ_CALCULATED",
                        "No frequency found for MC Either bad mrw attribute or no DIMMS installed? Should be a code bug if we get here" ],
            0x2aad48: [ "RC_MSS_FREQ_NOT_EQUAL_MAX_DOMAIN_FREQ",
                        "Case when mss_freq speeds are different and sync mode is required, and mss_freq is not equal to max freq in domain." ],
            0xad3c68: [ "RC_MSS_FAILED_SYNC_MODE",
                        "DIMM speeds are different and sync mode is required" ],
            0x1038e2: [ "RC_MSS_EMPTY_FREQ_TARGET_VECTOR_PASSED",
                        "Empty freq target vector found when constructing dimm speed mapping" ],
            0x521857: [ "RC_MSS_ERROR_FINDING_DIMM_SPEED_MAP",
                        "Empty MCBIST target vector found when constructing dimm speed mapping" ],
            0xea348f: [ "RC_MSS_ALL_TARGETS_HAVE_0_FREQ",
                        "All targets in the freq domain (MCBIST or port) have 0 MSS_FREQ, but there are dimms still configured?" ],
            0x89cffe: [ "RC_MSS_MRW_FREQ_MAX_FREQ_EMPTY_SET",
                        "When considering the frequencies in the MRW and the max supported frequencies based on DIMM config (MAX_ALLOWED_DIMM_FREQ), there are no applicable frequencies remaining If sync mode required, frequencies have to match a nest frequency Note: at this time this is a cronus only error" ],
            0x61af08: [ "RC_P10_IOP_XRAM_OFFSET_ERROR",
                        "XRAM offset must be less than 32K and 8-byte aligned." ],
            0xb4cf3a: [ "RC_P10_IOP_TOP_PHY_ERROR",
                        "Invalid iop_top and/or Phy num to access XRAM." ],
            0xcae1b5: [ "RC_P10_IOP_XRAM_ACCESS_SIZE_ERROR",
                        "Invalid IOP XRAM access size. Must access full 32K bytes." ],
            0x21e4c8: [ "RC_P10_IOP_XRAM_INIT_TIMEOUT_ERROR",
                        "SRAM init done bit is not asserted after PHY reset." ],
            0xb4fc32: [ "RC_PLL_LOCK_ERR",
                        "PLL Lock Not set" ],
            0x0f5e43: [ "RC_P10_HW540133_CCALCOMP_TIMEOUT",
                        "Polling timeout reached waiting for CCALCOMP to resolve on PLL" ],
            0x7eac7b: [ "RC_P10_HW540133_SB_WA_ERR",
                        "Error applying static bandsel workaround -- bad return code in scan/scom sequence application or failure to observe subseqent PLL lock" ],
            0x1022fb: [ "RC_P10_HW540133_CBM1_WA_ERR",
                        "Error applying calibrated_bandsel_m1 workaround -- bad return code in scan/scom sequence application or failure to observe subseqent PLL lock" ],
            0x447d86: [ "RC_P10_HW540133_LLB_WA_ERR",
                        "Error applying last_locking_bandsel workaround -- bad return code in scan/scom sequence application or failure to observe subseqent PLL lock" ],
            0x211617: [ "RC_P10_HW540133_FLB_WA_ERR",
                        "Error applying first_locking_bandsel workaround -- bad return code in scan/scom sequence application or failure to observe subseqent PLL lock" ],
            0xc2aa20: [ "RC_P10_HW540133_COMBO_WA_ERR",
                        "Error applying combo_bandsel workaround -- bad return code in scan/scom sequence application or failure to observe subseqent PLL lock" ],
            0x35a983: [ "RC_P10_HW540133_WORKAROUND_ERR",
                        "Unsupported workaround selection" ],
            0x92458c: [ "RC_P10_FBC_TDM_INJECT_PRE_CONDITION_ERR",
                        "TDM injection on selected link is not possible; partner half link is not currently running" ],
            0x7d7424: [ "RC_P10_FBC_TDM_INJECT_POST_CONDITION_ERR",
                        "After TDM request injected, DL logic reports half-link is still running" ],
            0x230961: [ "RC_SET_ATOMIC_LOCK_BUSY",
                        "Couldn't grab the lock due to resource busy" ],
            0xbb9129: [ "RC_SET_ATOMIC_LOCK_FAIL",
                        "Couldn't grab the lock from he hardware" ],
            0x83f1c7: [ "RC_ATOMIC_LOCK_OWNER_ID_INVALID",
                        "Lock Id doesn't match, looks like somebody has override the lock" ],
            0xd7bc0c: [ "RC_STATIC_POWER_GATING_PFET_CNFG_ERR",
                        "Procedure: p10_sbe_tp_chiplet_reset Check that the PFETs we configure earlier actually switched as expected" ],
            0x2a21bc: [ "RC_P10_PHB_PERST_ACTION_INVALID_ARGS_ERR",
                        "Invalid PERST action input." ],
            0x6620b5: [ "RC_P10_PHB_PERST_PBCQ_CQ_NOT_IDLE",
                        "PBCQ CQ did not go to idle after getting reset." ],
            0x0f887c: [ "RC_P10_PHB_PERST_NFIR_NOT_CLEARED",
                        "Attempt to clear PCI Nest FIR Register is unsuccessful." ],
            0xf909b6: [ "RC_P10_DL_PGRESET_STUCK",
                        "DL_PGRESET did not complete reset." ],
            0x5deb35: [ "RC_P10_IOP_XRAM_FW_VER_ERROR",
                        "IOP FW version values read from HW reference image and physical hardware are not equivalent" ],
            0x1dfa57: [ "RC_P10_FBC_TDM_UTILS_LOC_ENDP_TARGET_ERR",
                        "Local endpoint target has no iolink children targets" ],
            0x536942: [ "RC_P10_FBC_TDM_UTILS_REM_IOLINK_TARGET_ERR",
                        "No remote iolink target found for given local link iolink target" ],
            0x3fff5c: [ "RC_P10_FBC_TDM_UTILS_CONFIG_MODE_ERR",
                        "Requested link is not carrying SMP traffic." ],
            0x2386b7: [ "RC_P10_FBC_TDM_UTILS_CCM_NOT_SUPPORTED_ERR",
                        "Concurrent maintenance for this requested link is not possible, as it was configured in half-width mode at IPL time." ],
            0xca6366: [ "RC_P10_FBC_TDM_UTILS_IOLINK_SEARCH_ERR",
                        "No IOLINK target found to match requested operation" ],
            0xf3a013: [ "RC_INVALID_SPI_ENGINE",
                        "An invalid SPI engine was requested to swap over to FSI mode" ],
            0xd6c6d2: [ "RC_PSTATE_MVPD_CHIPLET_VOLTAGE_NOT_EQUAL",
                        "#V data is not same across EQ chiplets" ],
            0xbf8714: [ "RC_PSTATE_PB_BIASED_POUNDV_SLOPE_ERROR",
                        "During #V Biased data validity checking, the data did not have at or increasing slopes (eg Power Save LE Nominal LE Turbo LE UltraTurbo). Pstates are being disabled." ],
            0x328df4: [ "RC_PSTATE_PB_POUNDV_SLOPE_ERROR",
                        "During #V validity checking, the data did not have at or increasing slopes (eg Power Save LE Nominal LE Turbo LE UltraTurbo). Pstates are being disabled." ],
            0xec6072: [ "RC_PSTATE_PB_POUNDV_ZERO_ERROR",
                        "During #V validity checking, one or more required fields were found to contain zero contents. Pstates are being disabled." ],
            0x832f23: [ "RC_PSTATE_PB_BIASED_POUNDV_ZERO_ERROR",
                        "During #V Biased data validity checking, one or more required fields were found to contain zero contents. Pstates are being disabled." ],
            0x8db9a2: [ "RC_PSTATE_PB_POUNDV_WOF_UT_ERROR",
                        "WOF was intending to be enabled but could not due to #V validity checking issue of the UltraTurbo content. The machine continues as functional but with WOF disabled." ],
            0x2b2181: [ "RC_PSTATE_PB_BIASED_POUNDV_WOF_UT_ERROR",
                        "WOF was intending to be enabled but could not due to #V validity checking issue of the biased UltraTurbo content. The machine continues as functional but with WOF disabled." ],
            0x96d61c: [ "RC_PSTATE_PB_WOF_HEADER_DATA_INVALID",
                        "WOF Header data is invalid. The machine continues as functional but with WOF disabled." ],
            0x25d19e: [ "RC_PSTATE_PB_WOF_OVERRIDE_INVALID",
                        "WOF Header Override data is invalid. The machine continues as functional but with WOF disabled." ],
            0x9b867e: [ "RC_PSTATE_PB_VRT_HEADER_DATA_INVALID",
                        "VRT Header data is invalid. The machine continues as functional but with WOF disabled." ],
            0x1ce078: [ "RC_PSTATE_PB_ZERO_DCCR",
                        "The #W VPD field for the DDS Count Control Register (DCCR) is zero. This will lead to the following function disablement: - Over Current Sensor (OCS) - Undervolting - Overvolting" ],
            0x85bd78: [ "RC_PSTATE_PB_IQ_VPD_ERROR",
                        "#IQ data payload header is invalid" ],
            0xa6fc0f: [ "RC_PSTATE_PB_IQ_ACCESS_ERROR",
                        "pstate parameter accesses within proc_get_mvpd_iddq failed" ],
            0x6fc79f: [ "RC_PSTATE_PB_PG_ACCESS_ERROR",
                        "pstate parameter accesses within proc_get_mvpd_PG failed" ],
            0xfda102: [ "RC_PSTATE_PB_DDS_ADJ_DELAY_UNDERFLOW",
                        "The delay value created by adjustment with ATTR_DDS_DELAY_ADJUST has underflowed to negative." ],
            0x10666a: [ "RC_PSTATE_PB_DDS_ADJ_DELAY_OVERFLOW",
                        "The delay value created by adjustment with ATTR_DDS_DELAY_ADJUST has overflowed beyond the supported upper limit." ],
            0xe1ff7b: [ "RC_PSTATE_PB_DDS_ADJ_LARGE_DROOP_UNDERFLOW",
                        "The delay value created by adjustment with ATTR_DDS_LARGE_DROOP_ADJUST has underflowed to negative." ],
            0xbb486a: [ "RC_PSTATE_PB_DDS_ADJ_LARGE_DROOP_OVERFLOW",
                        "The delay value created by adjustment with ATTR_DDS_LARGE_DROOP_ADJUST has overflowed beyond the supported upper limit." ],
            0x9fef13: [ "RC_PSTATE_PB_DDS_ADJ_TRIP_OFFSET_UNDERFLOW",
                        "The delay value created by adjustment with ATTR_DDS_TRIP_OFFSET_ADJUST has underflowed to negative." ],
            0x18ecbe: [ "RC_PSTATE_PB_DDS_ADJ_TRIP_OFFSET_OVERFLOW",
                        "The delay value created by adjustment with ATTR_DDS_TRIP_OFFSET_ADJUST has overflowed beyond the supported upper limit." ],
            0x0f1f86: [ "RC_PSTATE_PB_POUND_W_TDP_IAC_INVALID",
                        "#W one or more Idd TDP AC values are zero" ],
            0x5341a0: [ "RC_PSTATE_PB_POUND_W_TDP_IDC_INVALID",
                        "#W one or more Idd TDP DC values are zero" ],
            0x4b0a30: [ "RC_PSTATE_PB_POUND_W_INVALID_VID_VALUE",
                        "#W vid compare ivid value is zero" ],
            0x3fbf1c: [ "RC_PSTATE_PB_POUND_W_INVALID_VID_ORDER",
                        "#W vid compare ivid value is not in increasing order" ],
            0x117405: [ "RC_PSTATE_PB_POUND_W_INVALID_THRESHOLD_VALUE",
                        "#W threshold values are invalid" ],
            0xcd9bb1: [ "RC_PSTATE_PB_POUND_W_INVALID_FREQ_DROP_VALUE",
                        "#W freq drop values are invalid" ],
            0x8b89c3: [ "RC_PSTATE_PB_POUND_W_VERY_INVALID_VDM_DATA",
                        "For VDM enablement, the Turbo Large Turbo threshold in #W is found to less than -32mV which is an indicator of bad (or old) VPD. VDMs are being disabled but otherwise pressing on." ],
            0xf0d7bc: [ "RC_PSTATE_PB_POUND_W_ACCESS_FAIL",
                        "pstate parameter accesses within proc_get_mvpd_poundw failed" ],
            0xf8e2a4: [ "RC_PSTATE_PB_RESCLK_INDEX_ERROR",
                        "The resonant clock index vector size is not expected." ],
            0x2d5d3d: [ "RC_PSTATE_PB_RESCLK_TABLE_ERROR",
                        "The resonant clock table vector size is not expected." ],
            0x0cd578: [ "RC_PSTATE_PB_RESCLK_L3_TABLE_ERROR",
                        "The resonant clock L3 table vector size is not expected." ],
            0x556444: [ "RC_PSTATE_PB_CORE_FLOOR_FREQ_GT_CF6_FREQ",
                        "The core floor frequency is greater than CF6 freq of the part." ],
            0x9082c1: [ "RC_PSTATE_PB_FREQ2PS_LT_PSTATE_MIN_ERROR",
                        "The calculated Pstate is less than the allowed minimum.." ],
            0xe7ca34: [ "RC_PSTATE_PB_SAFE_FREQ_GT_PS0_FREQ",
                        "The calculated Save Mode frequency, after uplifting to account for DDS droop events, is above the maximum frequency of the part." ],
            0x78082b: [ "RC_PSTATE_PB_ATTRIBUTE_ACCESS_ERROR",
                        "Pstate attribute access failure." ],
            0xaa34ff: [ "RC_PSTATE_PAU_FREQ_EQ_ZERO",
                        "The system attribute ATTR_FREQ_PAU_MHZ has a zero value. This is fatal to Pstate functionality." ],
            0xb745b5: [ "RC_PSTATE_PB_UT_FREQ_MISMATCH",
                        "The UltraTurbo frequency for this part does not match the others in the system. This indicates the parts from different sorts may be plugged into the machine." ],
            0x03b31e: [ "RC_MULTINODE_FREQ_MISMATCH",
                        "There is a mismatch in the UltraTurbo frequency values between different nodes" ],
            0xba8ce1: [ "RC_PM_STATIC_POUNDV_EC_MISMATCH",
                        "A mismatch in chips in the system has been detected whereby static #V is required but an attribute override to ATTR_CHIP_EC_FEATURE_STATIC_POUND_V is preventing it." ],
            0x15f753: [ "RC_PSTATE_PB_FREQ_GT_PSTATE0_FREQ",
                        "A frequency desiring to be converted to a Pstate is greater than the Pstate 0 reference frequency. This is typically due to a mismatch between #V VPD and WOF Tables." ],
            0x67ef94: [ "RC_PSTATE_PB_PSTATE_STEP_EQ_0",
                        "In converting a frequency to a Pstate, the Pstate step size is 0." ],
            0x7115a1: [ "RC_PSTATE_PB_PSTATE0_FREQ_NOT_SET",
                        "The Pstate0 reference frequency is 0. Pstates cannot work unless this is set." ],
            0x51803c: [ "RC_PSTATE_PB_XLATE_UNDERFLOW",
                        "An underflow occured translating to a Pstate." ],
            0x026fea: [ "RC_PSTATE_PB_XLATE_OVERFLOW",
                        "An overflow occured translating to a Pstate." ],
            0x81f21f: [ "RC_PSTATE_PB_PDV_TDP_CURRENT_ERROR",
                        "The #V TDP Current Mark is not set for an enabled DD level. WOF is disabled." ],
            0xca6ae8: [ "RC_PM_DPLL_FREQ_UPDATE_FAIL",
                        "Safe mode freq update failed during host_set_voltage" ],
            0x595645: [ "RC_P10_SBE_SCOMINIT_XSCOM_BAR_ATTR_ERR",
                        "Procedure: p10_sbe_scominit Invalid XSCOM BAR attribute configuration, BAR is not aligned to HW implementation" ],
            0x65f20a: [ "RC_P10_SBE_SCOMINIT_LPC_BAR_ATTR_ERR",
                        "Procedure: p10_sbe_scominit Invalid LPC BAR attribute configuration, BAR is not aligned to HW implementation" ],
            0x90a43e: [ "RC_P10_SBE_SCOMINIT_FABRIC_BROADCAST_ATTR_ERR",
                        "Procedure: p10_sbe_scominit Invalid attribute value for fabric broadcast mode" ],
            0xf047ae: [ "RC_P10_SBE_SCOMINIT_FUSED_CORE_MISMATCH_ERR",
                        "Requested fused core state does not match hardware reported status from export regulation control register" ],
            0xf9cc64: [ "RC_P10_LOAD_IOP_XRAM_HW_IMG_ERROR",
                        "Invalid NULL pointer to HW reference image passed to p10_load_iop_xram HWP" ],
            0xe510d5: [ "RC_P10_LOAD_IOP_XRAM_IMG_ERROR",
                        "Null pointer or zero size section encountered when searching nested XRAM XIP image extracted from HW reference image pointer" ],
            0xde61d9: [ "RC_POWERBUS_PURGE_DONE_TIMEOUT",
                        "PowerBus Purge Done Timeout." ],
            0x33552f: [ "RC_L3_CLK_SYNC_DROP_TIMEOUT",
                        "L3 clock sync done timed out." ],
            0x2ba21f: [ "RC_P10_FAB_IOVALID_DL_FFDC_ERR",
                        "FFDC collected for DL layer training failure." ],
            0x737c2f: [ "RC_P10_FAB_IOVALID_TL_FFDC_ERR",
                        "FFDC collected for TL layer training failure." ],
            0x91aa4d: [ "RC_P10_FAB_IOVALID_REM_ENDP_TARGET_ERR",
                        "No matching remote endpoint target found for link which should be enabled." ],
            0x9edd19: [ "RC_P10_FAB_IOVALID_DL_FULL_NOT_TRAINED_RETRAIN_NONE_ERR",
                        "Full-width link DL training did not complete successfully, no retry possible." ],
            0x4fcd04: [ "RC_P10_FAB_IOVALID_DL_HALF_NOT_TRAINED_RETRAIN_NONE_ERR",
                        "Half-width link DL training did not complete successfully, no retry possible." ],
            0x619d19: [ "RC_P10_FAB_IOVALID_DL_FULL_NOT_TRAINED_RETRAIN_HALF_ERR",
                        "Full-width link DL training did not complete successfully, attempt retraining on half link basis." ],
            0xa7c6c8: [ "RC_P10_FAB_IOVALID_TL_FULL_NOT_TRAINED_RETRAIN_NONE_ERR",
                        "Full-width link TL training did not complete successfully, no retry possible." ],
            0x4a7730: [ "RC_P10_FAB_IOVALID_TL_FULL_NOT_TRAINED_RETRAIN_HALF_ERR",
                        "Full-width link TL training did not complete successfully, attempt retraining on half link basis." ],
            0xf8fa8f: [ "RC_P10_FAB_IOVALID_TL_HALF_NOT_TRAINED_RETRAIN_NONE_ERR",
                        "Half-width link TL training did not complete successfully, no retry possible." ],
            0x9f357d: [ "RC_P10_OTL_NOT_IN_RESET",
                        "Procedure: p10_sbe_check_quiesce The OTLs are not all in the reset state for the NPU" ],
            0x820bd8: [ "RC_P10_NX_PBI_WRITE_IDLE_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce The PBI Write Idle never happened" ],
            0xf66c28: [ "RC_P10_NX_CRB_KILL_DONE_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce CRB kills were not complete" ],
            0x9d4fd0: [ "RC_P10_NX_STOP_UMAC_FETCHING_NEW_CRBS_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce UMAC was not stopped from fetching new CRBs" ],
            0xe5fe12: [ "RC_P10_NX_UMAC_DISPATCH_SLOTS_TO_DRAIN_CRBS_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce UMAC was not done dispatching slots to drain of CRBs" ],
            0x17737b: [ "RC_P10_WAIT_FOR_DMA_CHANNELS_TO_DRAIN_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce DMA channels were not drained" ],
            0xead415: [ "RC_P10_WAIT_FOR_ERAT_IDLE",
                        "Procedure: p10_sbe_check_quiesce ERAT was not idle" ],
            0x7c4c64: [ "RC_P10_PBI_MASTER_MACHINES_IDLE_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce PBI Master machines are not idle" ],
            0xd5a6f8: [ "RC_P10_UMAC_QUIESCE_FAILED",
                        "Procedure: p10_sbe_check_quiesce UMAC status control quiesce failed" ],
            0x0d7ebe: [ "RC_P10_PSIHBCR_INBOUND_QUEUE_NOT_EMPTY",
                        "Procedure: p10_sbe_check_quiesce PSIHBCR inbound queue not empty" ],
            0x718520: [ "RC_P10_VAS_QUIESCE_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce The VAS quiesce was not achieved" ],
            0x3fd2b1: [ "RC_P10_INTP_QUIESCE_TIMEOUT",
                        "Procedure: p10_sbe_check_quiesce INTP master or slave is not idle" ],
            0x0fc5d8: [ "RC_P10_INT_SCRUB_NOT_FINISHED_ERR",
                        "Procedure: p10_sbe_check_quiesce Cache scrub operation did not finish within programmed wait period" ],
            0x898265: [ "RC_PROCPM_AVSBUS_POLL_TIMEOUT",
                        "A timeout occured while polling OCB status register O2SST for o2s_ongoing=0" ],
            0xc9b7f3: [ "RC_PM_AVSBUS_ZERO_RESP_ERROR",
                        "AVS command failed. All 0 response data received possibly due to AVSBus IO RI/DIs disabled." ],
            0xf7f170: [ "RC_PM_AVSBUS_NO_RESP_ERROR",
                        "AVS command failed. No response from VRM device, Check AVSBus interface connectivity to VRM in system." ],
            0x0e1382: [ "RC_PM_AVSBUS_MASTER_BAD_CRC_ERROR",
                        "AVS command failed. Bad CRC detected by P10 on AVSBus Slave Segement." ],
            0xbf1f21: [ "RC_PM_AVSBUS_SLAVE_BAD_CRC_ERROR",
                        "AVS command failed failed. Bad CRC indicated by Slave VRM on AVSBus Master Segement." ],
            0x0423fb: [ "RC_PM_AVSBUS_UNAVAILABLE_RESOURCE_ERROR",
                        "AVS command failed. Valid data sent but no action is taken due to unavailable resource." ],
            0x38aedf: [ "RC_PM_AVSBUS_INVALID_DATA_ERROR",
                        "AVS command failed. Unknown resource, invalid data, incorrect data or incorrect action." ],
            0x95be2c: [ "RC_PM_AVSBUS_EXCESSIVE_VOLTAGE_ERROR",
                        "A voltage higher than the VRM maximum was to be attempted." ],
            0x75f4b6: [ "RC_PM_AVSBUS_WRITE_VOLTAGE_ERROR",
                        "An AVSBus Voltage Write command returned bad status." ],
            0x4772e0: [ "RC_PM_AVSBUS_STATUS_READ_ERROR",
                        "An AVSBus Voltage Write command returned bad status." ],
            0xefade8: [ "RC_SBE_SELECT_EX_FUSED_NOT_EVEN_ERROR",
                        "The first core found in fused mode was not an even core." ],
            0xedcef2: [ "RC_SBE_SELECT_EX_FUSED_ODD_ERROR",
                        "The first core found in fused mode was even but the companion odd core was not functional." ],
            0x8ece72: [ "RC_SBE_SELECT_EX_INSUFFICIENT_ACTIVE_CORES_ERROR",
                        "The requested active cores were not able to be configured." ],
            0xa34fd5: [ "RC_SBE_SELECT_EX_INSUFFICIENT_BACKING_CACHES_ERROR",
                        "The requested backing caches were not able to be configured." ],
            0xd98e95: [ "RC_SBE_SELECT_EX_NEEDED_CONFIG_ERROR",
                        "Core configuration needed cannot be satisfied." ],
            0xeed42c: [ "RC_SBE_SELECT_EX_ECO_CACHE_CONTAINED_CONFIG_ERROR",
                        "No ECO cores are expected to be configured in cache contained mode" ],
            0x86414f: [ "RC_SBE_SELECT_EX_ECO_CHIP_CONTAINED_CONFIG_ERROR",
                        "ECO core configured which is not a backing cache in chip contained mode" ],
            0xdf4b7e: [ "RC_SBE_SELECT_EX_ACTIVE_ECO_ERROR",
                        "Core configuration needed cannot be satisfied." ],
            0xafe4b5: [ "RC_STOP_TRANSITION_PENDING",
                        "Indicates the targeted core is still pending in make a transition" ],
            0xa25c77: [ "RC_ILLEGAL_EXPECTED_STOP_LEVEL",
                        "Indicates the expected stop level was invalid." ],
            0x6d499a: [ "RC_EXPECTED_STOP_LEVEL_NOT_REACHED",
                        "Indicates the targeted core is not at an actual STOP level that meets the expectation." ],
            0x08c7c0: [ "RC_MSS_EFF_CONFIG_MIRROR_DISABLED",
                        "Mirroring is disabled but Mirror placement policy is flipped. Firmware error. - ATTR_MRW_HW_MIRRORING_ENABLE is not false - ATTR_MEM_MIRROR_PLACEMENT_POLICY is FLIPPED" ],
            0x87ff9b: [ "RC_MSS_EFF_GROUPING_NO_GROUP_ALLOWED",
                        "ATTR_MSS_INTERLEAVE_ENABLE doesn't have any grouping type allowed. Firmware error." ],
            0xd6c1b4: [ "RC_MSS_EFF_GROUPING_UNABLE_TO_GROUP",
                        "p10_mss_eff_grouping is unable to group at least one MCC on this chip based on the specified memory interleaving (ATTR_MSS_INTERLEAVE_ENABLE) and mirroring rules (ATTR_MRW_HW_MIRRORING_ENABLE). The most likely cause of this error: - Limitation of group/region size (ATTR_MAX_INTERLEAVE_GROUP_SIZE) - ATTR_MSS_INTERLEAVE_ENABLE doesn't allow a group of 1 MCC. - ATTR_MRW_HW_MIRRORING_ENABLE is 'required' and the ungrouped MCC's subchannels are not both enabled. This is a memory plugging error. Refer to memory plugging rules." ],
            0x9c965d: [ "RC_MSS_EFF_GROUPING_UNABLE_TO_GROUP_DIMM",
                        "p10_mss_eff_grouping is unable to group this DIMM" ],
            0xfb5c3e: [ "RC_MSS_EFF_GROUPING_NOT_ENOUGH_MEMORY",
                        "There is not enough memory available to fulfill the amount of memory requested for the current bar. The amount of memory bars requested are specified in these attributes: ATTR_PROC_NHTM_BAR_SIZE ATTR_PROC_CHTM_BAR_SIZES ATTR_PROC_SMF_BAR_SIZE etc..." ],
            0x012dfe: [ "RC_MSS_EFF_GROUPING_MEMORY_BAR_NOT_POSSIBLE",
                        "There is not enough memory available to fulfill the amount of memory requested for the current bar type due to memory hole." ],
            0xaad34a: [ "RC_MSS_EFF_GROUPING_ADDRESS_NOT_ALIGNED",
                        "Current BAR's base address calculated is not aligned with its requested size." ],
            0xa71951: [ "RC_MSS_EFF_GROUPING_SMF_NOT_ENABLED",
                        "Requirements to enable a secure memory space not met: ATTR_PROC_SMF_BAR_SIZE size is set (> 0) but ATTR_SMF_CONFIG is not set to 'ENABLED'." ],
            0x585ef0: [ "RC_MSS_EFF_GROUPING_INVALID_BAR_TYPE",
                        "The specified BAR type value is invalid. Bar type must be: CHTM0-CHTM31, NHTM, SMF, or OCC." ],
            0x7f23a0: [ "RC_MSS_EFF_GROUPING_SMF_256MB_MINIMUM_ERROR",
                        "Secure memory must be a minimum size of 256MB by design. If ATTR_SMF_CONFIG is set to 'ENABLED' then the minimum bar size ATTR_PROC_SMF_BAR_SIZE is required to be set at least 256MB." ],
            0x611c01: [ "RC_MSS_EFF_GROUPING_SMF_256MB_OFFSET_ERROR",
                        "Secure memory base address must be allocated in offsets of 256MB by design." ],
            0xb5cdc6: [ "RC_MSS_EFF_GROUPING_NM_REGION_MAP_ERROR",
                        "Memory grouping is not able to find a region to map current non-mirrored group. This could be because the non-mirror region has exceeded the max non-mirror regions allowed, or the non-mirror region size left does not fit the size of the group." ],
            0x6e44f7: [ "RC_MSS_EFF_GROUPING_M_REGION_MAP_ERROR",
                        "Memory grouping is not able to find a region to map current mirrored group. This could be because the mirror region has exceeded the max mirror regions allowed, or the mirror region size left does not fit the size of the group." ],
            0xae13e3: [ "RC_MSS_EFF_GROUPING_INVALID_GROUP_SIZE",
                        "Unable to determine the encoded GROUP_SIZE value (bits 25:39 of MCFGP/MCFGPM) for given group size." ],
            0x65e3b4: [ "RC_MSS_EFF_GROUPING_INVALID_MCC_CONFIG",
                        "Invalid number of MCCs assigned to a group. The valid number of MCCs allow in a group are 8,6,4,,3,2, or 1." ],
            0xf83d13: [ "RC_MAGIC_NUMBER_NOT_VALID",
                        "Magic number not matching from Seeprom read with Fused number in OTPROM" ],
            0xab6571: [ "RC_FILT_PLL_LOCK_ERR",
                        "Filter pll not locked" ],
            0xcde18a: [ "RC_DPLL_LOCK_ERR",
                        "NEST/PAU DPLL not locked" ],
            0x816a30: [ "RC_SHADOW_DIS_FDCR_UPDATE_IN_PROG_TIMEOUT",
                        "FDCR Update Timeout." ],
            0xa332b5: [ "RC_SHADOW_DIS_CORE_SHADOW_STATE_TIMEOUT",
                        "Shadow Disable FTC/PP/DPT Shadow State Timeout." ],
            0xc3909b: [ "RC_TIMEFAC_FROM_PC_XFER_RECEIVE_DONE_TIMEOUT",
                        "Shadow Disable Xfer Receive Done Timeout." ],
            0x9d3fdd: [ "RC_TIMEFAC_FROM_PC_TFCSR_ERROR_CHECK_FAILED",
                        "Shadow Disable TFCSR Error Check Failed." ],
            0xe99e34: [ "RC_P10_DETERMINE_ECO_MODE_TARGET_STATE_ERR",
                        "Procedure: p10_determine_eco_mode Non-functional core target or related EQ/PERV target" ],
            0xed9082: [ "RC_P10_DETERMINE_ECO_MODE_PG_ERR",
                        "Procedure: p10_determine_eco_mode PG keyword attribute data does not indicate core is functional" ],
            0x60aab3: [ "RC_P10_SBE_EXIT_CACHE_CONTAINED_ECO_MODE_ERR",
                        "Unexpected ECO mode cache found in set of active cores or backing caches" ],
            0xf05edf: [ "RC_P10_SBE_PURGE_HB_ECO_MODE_ERR",
                        "Unexpected ECO mode cache found in set of active cores or backing caches" ],
            0x47bd26: [ "RC_P10_SBE_STOP_HB_ECO_MODE_ERR",
                        "Unexpected ECO mode cache found in set of active cores or backing caches" ],
            0x039214: [ "RC_P10_SBE_EXIT_CACHE_CONTAINED_ACTIVE_BACKING_OVERLAP_ERR",
                        "Same core appears in set of both active cores and backing caches" ],
            0x719e62: [ "RC_P10_SBE_EXIT_CACHE_CONTAINED_MULTIPLE_MASTER_ERR",
                        "Master core found more than once in set of active cores" ],
            0x2deaaf: [ "RC_P10_SBE_EXIT_CACHE_CONTAINED_NO_MASTER_ERR",
                        "Master core was not found in set of active cores" ],
            0x5643b1: [ "RC_P10_SBE_EXIT_CACHE_CONTAINED_NO_MASTER_PAIR_ERR",
                        "Master core pair in fused mode was not found in set of active cores" ],
            0x222607: [ "RC_P10_SBE_EXIT_CACHE_CONTAINED_THREAD_STOP_ERR",
                        "Thread on active core did not reach expected state after being requested to stop" ],
            0x0e675d: [ "RC_SETUP_REF_CLOCK_NE_TERM_UNAVAILABLE",
                        "System planar requires internal near-end refclock termination, but processor does not support this." ],
            0x43f1a1: [ "RC_PM_PSS_ADC_ERROR",
                        "SPIADC error bit asserted waiting for operation to complete." ],
            0xa506ac: [ "RC_PM_PSS_ADC_WRITE_WHILE_BUSY",
                        "SPI ADC was written while the bridge was busy. Cleared with coming reset." ],
            0x127db5: [ "RC_PM_PSS_ADC_TIMEOUT",
                        "SPIADC timed waiting to be quiesced. The SPIADC will be reset anyway so as to attempt to recover the interface." ],
            0xb93e5c: [ "RC_PM_PSS_P2S_ERROR",
                        "SPIP2S error bit asserted waiting for operation to complete." ],
            0x768215: [ "RC_P10_SMP_WRAP_MFG_FLAGS_ERR",
                        "Manufacturing flags must be set for smp wrap mode." ],
            0xd5697b: [ "RC_P10_SMP_WRAP_UNSUPPORTED_BROADCAST_MODE",
                        "Unsupported broadcast mode with smp wrap; only 2HOP_CHIP_IS_NODE is supported in an smp wrap configuration." ],
            0x317db1: [ "RC_QME_SRAM_ACCESS_ERROR",
                        "Incorrect Address passed to QME SRAM Display routine" ],
            0x51cc47: [ "RC_QME_SRAM_ACCESS_DENIED",
                        "Qme sram access denied because ownership is not yet released" ],
            0x9ce885: [ "RC_P10_FBC_EFF_CONFIG_EPSILON_UNSUPPORTED_TABLE_TYPE_ERR",
                        "Unsupported epsilon table type or content detected." ],
            0x500035: [ "RC_P10_FBC_EFF_CONFIG_EPSILON_UNSUPPORTED_PAU_FREQ_ERR",
                        "Unsupported PAU frequency specified for epsilon table lookup." ],
            0x78e57c: [ "RC_P10_FBC_EFF_CONFIG_EPSILON_UNSUPPORTED_BROADCAST_MODE_ERR",
                        "Unsupported combination of epsilon table type and broadcast mode detected." ],
            0x30c425: [ "RC_P10_FBC_EFF_CONFIG_EPSILON_UNSUPPORTED_DLR_PSAVE_MODE_ERR",
                        "Unsupported combination of epsilon table type and dlr psave mode detected." ],
            0x108939: [ "RC_P10_FBC_EFF_CONFIG_EPSILON_INVALID_VALUES_ERR",
                        "Invalid epsilon values detected; values must increase for each tier." ],
            0x527198: [ "RC_P10_FBC_EFF_CONFIG_CORE_FREQ_RANGE_ERR",
                        "Invalid relationship between ceiling/floor core frequency attributes." ],
            0x3587dc: [ "RC_P10_FBC_EFF_CONFIG_CORE_FREQ_RATIO_ERR",
                        "Unsupported core floor to ceiling frequency ratio." ],
            0xbeb5b5: [ "RC_P10_FBC_EFF_CONFIG_LCO_MODE_SETUP_ADAPTIVE_ATTR_ERR",
                        "Invalid absolute or relative value for ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_N or ATTR_PROC_LCO_MODE_SETUP_ADAPTIVE_D attributes" ],
            0x5b534f: [ "RC_P10_FBC_EFF_CONFIG_LCO_MODE_SETUP_ATTR_ERR",
                        "Unsupported enum for ATTR_PROC_LCO_MODE_SETUP attribute" ],
            0x84841e: [ "RC_PM_SET_HOMER_BAR_NOT_4MB_ALIGNED",
                        "HOMER BAR is not aligned to 4MB." ],
            0xbc06ed: [ "RC_PM_SET_HOMER_BAR_SIZE_INVALID",
                        "HOMER Size is 0 but BAR is non-zero." ],
            0xee5ab4: [ "RC_PM_PBA_ADDR_OUT_OF_RANGE",
                        "PBA Address beyond permissible range" ],
            0xc66fa7: [ "RC_PM_PBA_ADDR_ALIGNMENT_ERROR",
                        "pba BAR must be on a 1MB boundary" ],
            0xd57ba5: [ "RC_PM_PBA_BAR_SIZE_INVALID",
                        "Non-zero PBA BAR defined with region size of 0. Size must be 1MB or greater" ],
            0x3f7f63: [ "RC_INVALID_SBE_FFDC_PACKET",
                        "Invalid data detected in the SBE FFDC buffer" ],
            0xd45696: [ "RC_RCS_CLOCK_TEST_OUT_ERR",
                        "One or more processor reference clocks not toggling The clock is either more likely the root cause or it is indeterminate which of the two parts is at fault. Guarding the processor has the potential (based on resources) to prevent the system from IPLing, which would be undesirable when there could be a perfectly good redundant clock available. Therefore, we will not guard or deconfigure the processor on any of these errors." ],
            0x03a458: [ "RC_PM_OCBINIT_BAD_MODE",
                        "Unknown mode passed to p9_pm_ocb_init." ],
            0x11c8b6: [ "RC_PM_OCBINIT_BAD_Q_LENGTH_PARM",
                        "Bad push/pull Queue Length provided while setting up of the OCB channel." ],
            0x5d02e3: [ "RC_P10_SETUP_MMIO_BARS_FSP_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars FSP BAR attributes are not aligned to HW implementation" ],
            0xa4af0c: [ "RC_P10_SETUP_MMIO_BARS_PSI_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars PSI BAR attributes are not aligned to HW implementation" ],
            0x8f5f30: [ "RC_P10_SETUP_MMIO_BARS_PAU_MMIO_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars PAU MMIO BAR attributes are not aligned to HW implementation" ],
            0xfb5e82: [ "RC_P10_SETUP_MMIO_BARS_INT_NVPG_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars INT NVPG BAR attributes are not aligned to HW implementation" ],
            0xa0bc4f: [ "RC_P10_SETUP_MMIO_BARS_INT_NVC_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars INT NVC BAR attributes are not aligned to HW implementation" ],
            0xad5cf3: [ "RC_P10_SETUP_MMIO_BARS_INT_TM_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars INT TM BAR attributes are not aligned to HW implementation" ],
            0xa89f57: [ "RC_P10_SETUP_MMIO_BARS_INT_IC_BAR_ATTR_ERR",
                        "Procedure: p10_setup_mmio_bars INT IC BAR attributes are not aligned to HW implementation" ],
            0xebda60: [ "RC_P10_SETUP_MMIO_BARS_RANGE_OVERLAP_ERR",
                        "Procedure: p10_setup_mmio_bars Overlapping memory/MMIO address ranges detected" ],
            0x5c7fde: [ "RC_CORECACHE_REALIGN_TIMEOUT",
                        "core/cache realign timed out." ],
            0xe6a2af: [ "RC_P10_OCMB_ENABLE_SWIZZLE_BIT_OUT_OF_RANGE_ERROR",
                        "Procedure: p10_ocmb_enable Swizzle bit in Root CTRL7 is out of range" ],
            0xf3b9fe: [ "RC_P10_GETSRAM_TARGET_NOT_FUNCTIONAL_ERROR",
                        "Requested pervasive chiplet ID not functional on target chip" ],
            0xb3eaee: [ "RC_P10_PUTSRAM_TARGET_NOT_FUNCTIONAL_ERROR",
                        "Requested pervasive chiplet ID not functional on target chip" ],
            0x4c006a: [ "RC_P10_INVALID_OCC_ACCESS_MODE_ERROR",
                        "Invalid OCC SRAM access mode. Mode expected: 1 = Normal; 2 = Debug; 3 = Circular." ],
            0x3e06a3: [ "RC_INVALID_RING_SECTION",
                        "Invalid offset to ring section in image header" ],
            0xc2a034: [ "RC_INVALID_RING_CHIPLET_SECTION",
                        "Invalid offset to chiplet level TOR in ring section" ],
            0xeb740a: [ "RC_INVALID_TOR_VERSION",
                        "Invalid value of TOR version in TOR header" ],
            0x29ac15: [ "RC_INVALID_RING_ID",
                        "Ring id passed is incorrect or unknown" ],
            0x5d4f73: [ "RC_P10_PUTRING_CHECKWORD_DATA_MISMATCH",
                        "putring failed due to checkword mismatch" ],
            0xe49b6e: [ "RC_P10_PUTRING_OPCG_DONE_TIMEOUT",
                        "putring failed due to opcg done timeout" ],
            0x474275: [ "RC_P10_PARALLEL_SCAN_COMPARE_ERR",
                        "Putring failed to complete parallel scanning" ],
            0xf115c5: [ "RC_PUTRING_INVALID_PARAMETER",
                        "Invalid parameter passed for scanning" ],
            0x2c95b3: [ "RC_TOR_TRAVERSAL_ERROR",
                        "TOR Traversal led to incorrect ring" ],
            0xa6a85e: [ "RC_ROTATE_OP_FAILED",
                        "Rotate operation timed out during scanning" ],
            0x6e8e6e: [ "RC_QME_PUTRING_PARALLEL_SCAN_ERR",
                        "Parallel scanning failed for QME" ],
            0x10bde2: [ "RC_QME_PUTRING_HEADER_ERR",
                        "Erroneous content found in RS4 ring header" ],
            0x27ba35: [ "RC_QME_PUTRING_BAD_STRING",
                        "RS4 ring payload found invalid. Nibble index do not agree with length specified in the ring header" ],
            0x515c8c: [ "RC_QME_PUTRING_HEADER_MISMATCH",
                        "Checkword read back did not match what was written at the beginning of scanning. It indicates either bad ring, bad scan routine or bad hardware." ],
            0x3c79a6: [ "RC_QME_PUTRING_BAD_NIBBLE_INDEX",
                        "Current nibble index within RS4 string exceeds ring length as specified in RS4 ring header." ],
            0x487452: [ "RC_QME_PUTRING_UNKNOWN_ERR",
                        "An unknown error was encountered by QME hcode during scanning" ],
            0x0805ca: [ "RC_P10_SBE_MCS_SETUP_NO_MC_FOUND_ERR",
                        "There is no functional MCS/MI unit target configured on the master chip" ],
            0x1db306: [ "RC_PM_OCB_PUT_NO_DATA_ERROR",
                        "Valid data not provided to be written via the OCB channel." ],
            0xc569d7: [ "RC_PM_OCB0_PUT_DATA_POLL_NOT_FULL_ERROR",
                        "Indicates that a timeout occured waiting for a push queue to be non-full before writing data. Is likely due to OCC firmware not pulling entries off of the queue in a timely manner." ],
            0x6bfe6f: [ "RC_PM_OCB1_PUT_DATA_POLL_NOT_FULL_ERROR",
                        "Indicates that a timeout occured waiting for a push queue to be non-full before writing data. Is likely due to OCC firmware not pulling entries off of the queue in a timely manner." ],
            0xf09891: [ "RC_PM_OCB2_PUT_DATA_POLL_NOT_FULL_ERROR",
                        "Indicates that a timeout occured waiting for a push queue to be non-full before writing data. Is likely due to OCC firmware not pulling entries off of the queue in a timely manner." ],
            0xebb8f0: [ "RC_PM_OCB3_PUT_DATA_POLL_NOT_FULL_ERROR",
                        "Indicates that a timeout occured waiting for a push queue to be non-full before writing data. Is likely due to OCC firmware not pulling entries off of the queue in a timely manner." ],
            0x8d85a3: [ "RC_PM_OCB0_GET_DATA_ERROR",
                        "Indicates that a fail occured reading the OCB data register as part of a channel GET operation. Such a fail can occur due to channel setup or use issues (i.e.underflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0x766858: [ "RC_PM_OCB1_GET_DATA_ERROR",
                        "Indicates that a fail occured reading the OCB data register as part of a channel GET operation. Such a fail can occur due to channel setup or use issues (i.e.underflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0x1979a3: [ "RC_PM_OCB2_GET_DATA_ERROR",
                        "Indicates that a fail occured reading the OCB data register as part of a channel GET operation. Such a fail can occur due to channel setup or use issues (i.e.underflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0x523107: [ "RC_PM_OCB3_GET_DATA_ERROR",
                        "Indicates that a fail occured reading the OCB data register as part of a channel GET operation. Such a fail can occur due to channel setup or use issues (i.e.underflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0x78d4fe: [ "RC_PM_OCB0_PUT_DATA_ERROR",
                        "Indicates that a fail occured writing the OCB data register as part of a channel PUT operation. Such a fail can occur due to channel setup or use issues (i.e.overflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0x74a0cd: [ "RC_PM_OCB1_PUT_DATA_ERROR",
                        "Indicates that a fail occured writing the OCB data register as part of a channel PUT operation. Such a fail can occur due to channel setup or use issues (i.e.overflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0xd0576e: [ "RC_PM_OCB2_PUT_DATA_ERROR",
                        "Indicates that a fail occured writing the OCB data register as part of a channel PUT operation. Such a fail can occur due to channel setup or use issues (i.e.overflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0x800f95: [ "RC_PM_OCB3_PUT_DATA_ERROR",
                        "Indicates that a fail occured writing the OCB data register as part of a channel PUT operation. Such a fail can occur due to channel setup or use issues (i.e.overflow) or secondary failures to a SCOM access (eg address issue going to the OCC SRAM)." ],
            0xa981de: [ "RC_PM_OCC_FIRINIT_BAD_MODE",
                        "Unknown mode passed to p10_pm_occ_firinit." ],
            0x0e9dd5: [ "RC_P10_BUILD_SMP_MASTER_DESIGNATION_ERR",
                        "Node or system master chip designation error." ],
            0x1f0f88: [ "RC_P10_BUILD_SMP_MASTER_CONFIGURATION_ERR",
                        "Designated master chip is not properly configured as the current/next master in hardware." ],
            0x01cf64: [ "RC_P10_BUILD_SMP_GROUP_ADD_INTERNAL_ERR",
                        "Internal program error; SMP data structure map insert failed." ],
            0x8f5f24: [ "RC_P10_BUILD_SMP_DUPLICATE_FABRIC_ID_ERR",
                        "Multiple chips found with identical fabric node/chip ID attribute values." ],
            0xf2f1f9: [ "RC_P10_BUILD_SMP_MULTIPLE_MASTER_DESIGNATION_ERR",
                        "Input parameter designating post-reconfiguration master chip matches more than one chip in HWP input targets to process." ],
            0x1bf53a: [ "RC_P10_BUILD_SMP_NO_MASTER_DESIGNATION_ERR",
                        "Input parameter designating post-reconfiguration master chip does not match any chips in HWP input targets to process." ],
            0x45d042: [ "RC_P10_BUILD_SMP_MAX_SIZE_ERR",
                        "Number of chips in HWP input arguments exceeds supported SMP size." ],
            0x912f48: [ "RC_P10_BUILD_SMP_LINK_VALIDATE_IOHS_TARGET_ERR",
                        "Error in matching properties of A/X link to IOHS target" ],
            0xaf1e83: [ "RC_P10_BUILD_SMP_LINK_VALIDATE_NO_IOHS_MATCH_ERR",
                        "Error finding IOHS target to match A/X link" ],
            0x675014: [ "RC_P10_BUILD_SMP_INVALID_LINK_STATE",
                        "Link is marked active, but DL/TL/iovalid state do not support functional operation." ],
            0xecbd47: [ "RC_P10_BUILD_SMP_INVALID_TOPOLOGY",
                        "Invalid fabric topology specified by input parameters." ],
            0x9e56ad: [ "RC_P10_BUILD_SMP_HOTPLUG_CONSISTENCY_ERR",
                        "Fabric hotplug racetrack register contents are not consistent." ],
            0x1699c5: [ "RC_P10_BUILD_SMP_NON_HOTPLUG_CONSISTENCY_ERR",
                        "Fabric hotplug racetrack register contents are not consistent." ],
            0x23401d: [ "RC_P10_BUILD_SMP_BAD_OPERATION_ERR",
                        "Invalid SMP operation specified." ],
            0x9f8a91: [ "RC_P10_BUILD_SMP_BAD_ADU_ACTION_ERR",
                        "Invalid ADU action specified." ],
            0xf672d5: [ "RC_P10_BUILD_SMP_ADU_STATUS_MISMATCH_ERR",
                        "Status mismatch detected on ADU operation execution for SMP configuration." ],
            0xb81f88: [ "RC_P10_BUILD_SMP_DLR_REM_ENDP_TARGET_ERR",
                        "No remote endpoint target found for given local link endpoint." ],
            0x840f7c: [ "RC_P10_BUILD_SMP_DLR_INVALID_MODE",
                        "Invalid DLR psave mode specified." ],
            0x0fed5f: [ "RC_P10_BUILD_SMP_INVALID_ECO_TARGET",
                        "Found ECO target in set of active cores, backing caches whne performing phase1 topology table update" ],
            0x5820e8: [ "RC_P10_TOD_SETUP_NULL_NODE",
                        "Procedure: p10_tod_setup A null node has been passed into the procedure" ],
            0x0dfb3c: [ "RC_P10_TOD_SETUP_INVALID_NODE_DELAY",
                        "Procedure: p10_tod_setup Delay is out of range. Node delay must be between 0 and 255 inclusive." ],
            0x738d5c: [ "RC_P10_TOD_SETUP_IOLINK_TARGET_MATCH_ERR",
                        "Procedure: p10_tod_setup No matching IOLINK targets found for IOHS target" ],
            0x987aec: [ "RC_P10_TOD_SETUP_INVALID_LATENCY",
                        "Procedure: p10_tod_setup FBC Latency measurement register has invalid results." ],
            0x1ebda9: [ "RC_P10_TOD_SETUP_INVALID_TOPOLOGY",
                        "Procedure: p10_tod_setup Invalid TOD oscillator configuration" ],
            0xe35467: [ "RC_P10_TOD_SETUP_INVALID_TOPOLOGY_RX",
                        "Procedure: p10_tod_setup RX configuration specifies a deconfigured fabric link" ],
            0xf7092d: [ "RC_P10_TOD_SETUP_INVALID_TOPOLOGY_TX",
                        "Procedure: p10_tod_setup TX configuration specifies a deconfigured fabric link" ],
            0x1d734a: [ "RC_P10_TOD_SETUP_INVALID_CLOCK_ATTRIBUTES",
                        "Procedure: p10_tod_setup Invalid clock attributes." ],
            0x0a150f: [ "RC_P10_TOD_INIT_NOT_RUNNING",
                        "Procedure: p10_tod_init TOD FSM did not reach running state prior to timeout" ],
            0xb406b7: [ "RC_P10_TOD_INIT_M_PATH_0_STEP_CHECK_ERROR",
                        "Procedure: p10_tod_init TOD error register indicates master path 0 step check error" ],
            0xb6a869: [ "RC_P10_TOD_INIT_M_PATH_1_STEP_CHECK_ERROR",
                        "Procedure: p10_tod_init TOD error register indicates master path 1 step check error" ],
            0xbc478a: [ "RC_P10_TOD_INIT_ERROR",
                        "Procedure: p10_tod_init Unexpected error bit(s) set in TOD error register" ],
            0xdadc4e: [ "RC_P10_TOD_INIT_SECONDARY_TOPOLOGY_ERROR",
                        "Procedure: p10_tod_init Unexpected error bit(s) set in TOD error register related to the secondary topology" ],
            0xf4dbdb: [ "RC_P10_TOD_MOVE_TOD_TO_TB_INIT_TIMEOUT",
                        "Procedure: p10_tod_move_tod_to_tb Timeout reaching expected TFMR state" ],
            0x64d348: [ "RC_P10_TOD_MOVE_TOD_TO_TB_INIT_ERROR",
                        "Procedure: p10_tod_move_tod_to_tb Step error detected or issue with the external TOD oscillator" ],
            0x370296: [ "RC_P10_TOD_MF_CLK_FAILURE",
                        "Procedure: p10_tod_init TOD FSM did not reach running state due to interrupt from TOD Oscillator switch" ],
            0xd18e2d: [ "RC_P10_TOD_TIMER_START_SIGNAL_ERROR",
                        "Procedure: p10_tod_init The tod timer start signal did not go high as expected" ],
            0xdddefd: [ "RC_P10_TOD_MOVE_TOD_TO_TB_SCOM_XLATE_ERR",
                        "Error translating chip unit relative SCOM address" ],
            0x2db1b5: [ "RC_P10_TOD_STATUS_ERR",
                        "Error checking TOD Status" ],
            0x0a96ea: [ "RC_P10_TOD_TIMER_STEP_COUNT_ERROR",
                        "Procedure: p10_tod_init The TOD timer did not count as expected" ],
            0x9aec78: [ "RC_P10_TOD_POLLING_DELAY_CALC_OVERFLOW",
                        "Procedure: p10_tod_init Polling delay calculation exceeds numeric limits." ],
            0x3ac037: [ "RC_P10_TOD_INVALID_SPS",
                        "Procedure: p10_tod_init An invalid TOD SPS value has been passed into the procedure" ],
            0x510b6f: [ "RC_P10_DYNINIT_BITVEC_SAVE_ERROR",
                        "Requested bit vector type can't be saved to platform attribute" ],
            0x8050b2: [ "RC_P10_DYNINIT_BITVEC_RANGE_ERROR",
                        "Requested bit position is out of range for bitvec" ],
            0xd2987a: [ "RC_P10_BOOT_MODE_BITVEC_MERGE_ERROR",
                        "Inconsistent input type or source values in bitvecs supplied to merge function" ],
            0x1474ff: [ "RC_P10_BOOT_MODE_BITVEC_PLAT_ERROR",
                        "Platform requested bit position is out of range for HW image capabilities" ],
            0xfd2042: [ "RC_P10_BOOT_MODE_FEATURE_LOOKUP_ERROR",
                        "Inconsistent input type in bitvecs supplied to HW image feature lookup function" ],
            0xf40b6b: [ "RC_P10_BOOT_MODE_UNEQUAL_MC_FREQS",
                        "Chip has unequal MC chiplet frequencies" ],
            0xeadc5e: [ "RC_KVREF_CAL_NOT_DONE_ERR",
                        "Precision reference voltage calibration not done" ],
            0x664d3c: [ "RC_P10_PCI_REFCLOCK_ERR",
                        "First SCOM attempted into PCI chiplet failed" ],
            0xa8913a: [ "RC_XIPC_BAD_PG_XLATE",
                        "Code bug: Invalid translation from PERV target chip unit position to image PG index" ],
            0x501c77: [ "RC_XIPC_INVALID_INPUT_BUFFER_PTR_PARM",
                        "Caller bug: Caller supplied one or more invalid input buffer pointers" ],
            0x648aaa: [ "RC_XIPC_INVALID_INPUT_BUFFER_SIZE_PARM",
                        "Caller bug: Caller supplied one or more invalid input buffer sizes" ],
            0xdbbd5f: [ "RC_XIPC_INVALID_SYSPHASE_PARM",
                        "Caller bug: Caller supplied unsupported sysPhase" ],
            0x877be2: [ "RC_XIPC_ATTR_MAX_SBE_SEEPROM_SIZE_TOO_SMALL",
                        "SBE Seeprom size reported in attribute is smaller than MAX_SBE_SEEPROM_SIZE" ],
            0xe5adfe: [ "RC_XIPC_INVALID_MVPD_RINGCLASS",
                        "Code bug: Unsupported value of ringClass" ],
            0x9ba1d1: [ "RC_XIPC_MVPD_CHIPLET_ID_MESS",
                        "VPD ring's chipletId doesn't match requested chipletId" ],
            0x2737ee: [ "RC_XIPC_MVPD_RING_SIZE_TOO_BIG",
                        "VPD ring's size exceed allowed ring buffer space" ],
            0x2e016b: [ "RC_XIPC_RING_IS_REDUNDANT",
                        "Ring has redundant data (Not a bug. Info to caller.)" ],
            0x3c6b32: [ "RC_XIPC_RS4_REDUNDANT_ERROR",
                        "rs4_redundant() failed" ],
            0x67daf2: [ "RC_XIPC_RINGID_RINGPROPS_ERROR",
                        "ringid_get_ringProps() failed" ],
            0x8f83d1: [ "RC_XIPC_RINGID_CHIPLETPROPS_ERROR",
                        "ringid_get_chipletProps() failed" ],
            0x17c6c8: [ "RC_XIPC_TOR_APPEND_RING_FAILED",
                        "tor_append_ring() failed" ],
            0xa2dc1e: [ "RC_XIPC_SECTION_REMOVAL_ERROR",
                        "p9_xip_delete_section() failed to remove an XIP section" ],
            0xf9f6d7: [ "RC_XIPC_XIP_GET_SECTION_ERROR",
                        "p9_xip_get_section() failed getting an image section or a sub-section within an image section" ],
            0xf2d78c: [ "RC_XIPC_XIP_APPEND_ERROR",
                        "p9_xip_append() failed appending an an IPL (XIP) section to the image" ],
            0xfb8d9d: [ "RC_XIPC_XIP_API_MISC_ERROR",
                        "An XIP API call failed with a non-categorized error" ],
            0xed5fc2: [ "RC_XIPC_EMPTY_IMAGE_SECTION",
                        "The section size is zero." ],
            0x82e266: [ "RC_XIPC_IMAGE_WOULD_OVERFLOW",
                        "Would run out of ring section buffer space trying to append more rings" ],
            0x4085a0: [ "RC_XIPC_IMAGE_WOULD_OVERFLOW_ADDL_INFO",
                        "Additional FFDC info for RC_XIPC_IMAGE_WOULD_OVERFLOW error" ],
            0xefaefd: [ "RC_XIPC_IMAGE_WOULD_OVERFLOW_BEFORE_REACHING_MIN_ECS",
                        "Image buffer would overflow before reaching minimum number of boot cores Note if ACTUAL_EC_COUNT == 0xFFFFFFFF then the actual EC count is unknown." ],
            0x8d488c: [ "RC_XIPC_RING_SECTION_SIZING",
                        "Code bug: Ring section size would exceed max ring section size" ],
            0xd7a58e: [ "RC_XIPC_IMAGE_SIZING",
                        "Code bug: Image size would exceed max image size" ],
            0x0a6694: [ "RC_XIPC_IMAGE_TOO_LARGE",
                        "Image size exceeds max allowed image size" ],
            0xd27503: [ "RC_XIPC_TOR_GET_SINGLE_RING_ERROR",
                        "tor_get_single_ring() failed to fetch a ring" ],
            0x448aa5: [ "RC_XIPC_RS4_OVERLAY_ERROR",
                        "rs4_overlay() failed" ],
            0x7d20ba: [ "RC_XIPC_RS4_DECOMPRESS_ERROR",
                        "_rs4_decompress() failed" ],
            0x9387d5: [ "RC_XIPC_MVPD_OVLY_RING_HEADER_MISMATCH",
                        "Mvpd and Ovly ring header mismatch" ],
            0x7ddbc2: [ "RC_XIPC_INPUT_SBE_IMAGE_NONZERO_RINGS_SIZE",
                        "The DD specific input SBE image .rings size is not zero" ],
            0x40a3b9: [ "RC_XIPC_DD_LEVEL_MISMATCH_ERROR",
                        "The DD level from HB and MVPD is not same" ],
            0x4d1479: [ "RC_XIPC_CHIPNAME_MISMATCH_ERROR",
                        "The Chip Name from HB and MVPD is not same" ],
            0x18b4ce: [ "RC_XIPC_MVPD_DD_KEYWORD_VERSION_ERROR",
                        "The DD Keyword version from MVPD, found to be invalid" ],
            0x7a93d8: [ "RC_XIPC_SKELETON_GEN_FAILED",
                        "Failure in tor_skeleton_generation" ],
            0x64e1fb: [ "RC_XIPC_OVERLAYS_RING_IS_EMPTY",
                        "Specified Overlays ring is empty. Note this is just used as a CONST and is not expected to be FAPI_ASSERT'ed on so we do not need ffdc or callouts" ],
            0xbc1d31: [ "RC_XIPC_DYNAMIC_INIT_FAILED",
                        "Failure in process_target_and_dynamic_rings" ],
            0x3e3e75: [ "RC_XIPC_DYNAMIC_NO_RINGS_FOUND",
                        "No Dynamic and no Base rings found. Note this is just used as a CONST and is not expected to be FAPI_ASSERT'ed on so we do not need ffdc or callouts." ],
            0x2ecee5: [ "RC_XIPC_DYN_GET_RING_ERROR",
                        "Failure in dyn_get_ring" ],
            0x577a6e: [ "RC_XIPC_TYPE_FIELD_MISMATCH",
                        "Two RS4 rings' iv_type field do not match in the non-ORIG bits" ],
            0x4ad1e3: [ "RC_XIPC_CODE_BUG",
                        "Code bug: Fix code!" ],
            0x14b598: [ "RC_XIPC_MVPD_RINGTABLE_VERSION_MISMATCH",
                        "Mismatch between ring table version of MVPD and Code header" ],
            0x541fa0: [ "RC_XIPC_FEATURE_LIST_SIZE_OVERFLOW",
                        "The ringId-feature list size has exceeded the max allowed size" ],
            0xcf6a63: [ "RC_EXPAND_RING_UTIL_INVALID_PARAMETERS",
                        "Error calling p10_expand_ring_util when checking input parameters" ],
            0x948af1: [ "RC_XIPC_MVPD_MK_KEYWORD_VERSION_ERROR",
                        "The MK Keyword version from MVPD, found to be invalid" ],
            0x0891ee: [ "RC_XIPC_MVPD_PG_KEYWORD_VERSION_ERROR",
                        "The PG Keyword version from MVPD, found to be invalid" ],
            0x201b20: [ "RC_DDIMM_GET_EFD_VPD_BUFFER_INADEQUATE_TO_GET_DDR_TYPE",
                        "The VPD buffer needs to be large enough to retrieve the DDR type." ],
            0x055062: [ "RC_DDIMM_GET_EFD_VPD_BUFFER_INADEQUATE_FOR_DDR",
                        "The VPD buffer size is less than the DDR size or the DDR type is incorrect." ],
            0xc82cf8: [ "RC_DDIMM_GET_EFD_EFD_MEMORY_SPACE_OFFSET_ERROR",
                        "The EFD memory space offset resides within the DDR4 memory space." ],
            0xbe0606: [ "RC_DDIMM_GET_EFD_EFD_MEMORY_SIZE_MAPPING_ERROR",
                        "Unable to map the EFD memory space size." ],
            0xe2fcc6: [ "RC_DDIMM_GET_EFD_EFD_MEMORY_SPACE_SIZE_ERROR",
                        "The VPD buffer size is inadequate for the EFD memory space size with the given EFD memory space offest." ],
            0xe25919: [ "RC_DDIMM_GET_EFD_NUMBER_OF_EFD_IS_ZERO",
                        "No EFDs to work with. The number of EFDs is zero. Need at least 1 EFD to work with." ],
            0xe687ef: [ "RC_DDIMM_GET_EFD_INADEQUATE_EFD_BUFFER_SIZE",
                        "The size of the return EFD buffer size is insufficient to accommodate an EFD block size." ],
            0xc06efa: [ "RC_DDIMM_GET_EFD_UNSUPPORTED_DMB_MFG_ID",
                        "DMB manufacturer ID is not the expected ID and therefore not supported." ],
            0xc6f14a: [ "RC_DDIMM_GET_EFD_UNSUPPORTED_DMB_REVISION",
                        "DMB revision is not the expected revision and therefore not supported." ],
            0x4e4f77: [ "RC_DDIMM_UNSUPPORTED_FREQUENCY",
                        "Chosen frequency not supported by this DDIMM" ],
            0x21579b: [ "RC_DDIMM_GET_EFD_UNSUPPORTED_FREQUENCY",
                        "Invalid Frequency. Valid values are 12800, 14930, 17060, 19200, 21330, 23460 and 25600." ],
            0x8161c9: [ "RC_DDIMM_GET_EFD_UNSUPPORTED_RANK",
                        "Invalid Rank. Valid values are 0,1,2 and 3." ],
            0x6bb015: [ "RC_DDIMM_GET_EFD_EFD_BLOCK_SIZE_IS_OUT_OF_BOUNDS",
                        "The EFD block size resides outside the bounds of the EFD memory space." ],
            0x06c5d6: [ "RC_DDIMM_GET_EFD_EFD_NOT_FOUND",
                        "No EFD found to match frequency and MR criteria." ],
            0xb479c8: [ "RC_P10_PURGE_CMD_REG_ERR",
                        "Procedure: p10_l2_flush CORE_PRD_PURGE_CMD_REG_ERR bit is set in Purge Engine Command Register." ],
            0xf83458: [ "RC_P10_PURGE_COMPLETE_TIMEOUT",
                        "Procedure: p10_l2_flush Timed out waiting for purge busy indication to clear in L2 Purge Engine Command Register." ],
            0x0a97f5: [ "RC_CBS_NOT_IN_IDLE_STATE",
                        "CBS did not complete (did not arrive in IDLE state) within timeout" ],
            0x57cc3a: [ "RC_VDN_PGOOD_NOT_SET",
                        "Nest power (VDN) Power Good indication not set" ],
            0xa2ab2c: [ "RC_PM_PBA_INIT_INCORRECT_MODE",
                        "Incorrect mode passed to pba init procedure." ],
            0x6dcc0f: [ "RC_PM_PBA_SLAVE_RESET_TIMEOUT",
                        "pba_init timed out waiting for the PBA slave to reset." ],
            0x2a8931: [ "RC_PM_PBA_SLAVE_BUSY_AFTER_RESET",
                        "pba_init detected a busy PBA slave after the slave was reset." ],
            0x7aab27: [ "RC_PM_PBA_BCDE_STOP_TIMEOUT",
                        "pba_init timed out waiting to stop the Block Copy Download Engine." ],
            0x0f5438: [ "RC_PM_PBA_BCUE_STOP_TIMEOUT",
                        "pba_init timed out waiting to stop the Block Copy Upload Engine." ],
            0x8a71e0: [ "RC_P10_INVALID_LINK_CONFIG_ERR",
                        "Procedure: p10_fabric_dl_setup_linktrain Error when 50G speed is selected along with the odd half of the bus. Only the even half can be used with 50G" ],
            0x9dc57f: [ "RC_P10_OMI_SETUP_BARS_INVALID_BAR_1",
                        "ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET had an invalid value" ],
            0x186c6b: [ "RC_P10_OMI_SETUP_BARS_INVALID_BAR_2",
                        "ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET had an invalid value" ],
            0xb8cd45: [ "RC_P10_OMI_SETUP_BARS_INVALID_BAR_3",
                        "ATTR_OMI_INBAND_BAR_BASE_ADDR_OFFSET had an invalid value" ],
            0xcc18fa: [ "RC_QMEC_FUNC_CALL_ARGUMENT_ERROR",
                        "Some function call arguments are invalid." ],
            0x11b65e: [ "RC_QMEC_TOR_HEADER_MISMATCH",
                        "Some data in TOR header does not match." ],
            0xb58738: [ "RC_QMEC_RINGS_OUTPUT_BUFFER_TOO_SMALL",
                        "Customized QME ring section buffer is too small." ],
            0x5b733c: [ "RC_QMEC_TOR_SKELETON_GEN_ERROR",
                        "Error with calling tor_skeleton_generation()." ],
            0x6fe91a: [ "RC_QMEC_RINGID_API_ERROR",
                        "Error with calling ringid_xyz()." ],
            0x484fc2: [ "RC_QMEC_TOR_GET_SINGLE_RING_ERROR",
                        "Code bug: Error with calling tor_get_single_ring()." ],
            0xf8343b: [ "RC_QMEC_TOR_APPEND_RING_ERROR",
                        "Code bug: Error with calling tor_append_ring()." ],
            0xc8ac96: [ "RC_QMEC_CODE_BUG",
                        "Code bug: Fix code!" ],
            0x48fddf: [ "RC_P10_NCU_ENABLE_DARN_RNG_DISABLED",
                        "RNG on target chip is not enabled" ],
            0x249227: [ "RC_NCU_PURGE_DONE_TIMEOUT",
                        "NCU Purge Done Timeout." ],
            0xd099a8: [ "RC_P10_PPE_STATE_HALT_TIMEOUT_ERR",
                        "A HALT operation to a PPE timed out." ],
            0x325b56: [ "RC_RCS_CLOCK_ERR",
                        "RCS clock error" ],
            0x374965: [ "RC_RCS_PLL_LOCK_ERR",
                        "RCS pll not locked" ],
            0xda4f81: [ "RC_RCS_FPLL_DESKEW_ERR",
                        "Error in caliberating the deskew for RCS FPLL" ],
            0x7ad6f5: [ "RC_RCS_FPLL_DESKEW_CAL_ERROR",
                        "Error in caliberating the deskew for either A or B side" ],
            0xcd913b: [ "RC_RCS_INVALID_SIDE",
                        "User selected side is not valid" ],
            0xe33d4b: [ "RC_P10_OMI_TRAIN_ERR",
                        "p10_omi_train_check did not see expected trained status from OMI status register" ],
            0xb100bd: [ "RC_P10_MFG_OMI_SCREEN_UPSTREAM_CRC",
                        "Manufacturing OMI screen test upstream CRC count was above threshhold set in ATTR_MFG_SCREEN_OMI_CRC_ALLOWED" ],
            0xd55e23: [ "RC_P10_MFG_OMI_SCREEN_DOWNSTREAM_CRC",
                        "Manufacturing OMI screen test downstream CRC count was above threshhold set in ATTR_MFG_SCREEN_OMI_CRC_ALLOWED" ],
            0x0fb912: [ "RC_P10_MFG_OMI_SCREEN_UPSTREAM_EDPL",
                        "Manufacturing OMI screen test upstream EDPL count was above threshhold set in ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED" ],
            0x136948: [ "RC_P10_MFG_OMI_SCREEN_DOWNSTREAM_EDPL",
                        "Manufacturing OMI screen test downstream EDPL count was above threshhold set in ATTR_MFG_SCREEN_OMI_EDPL_ALLOWED" ],
            0x8c3a53: [ "RC_P10_SBE_CORE_SPR_SETUP_MASTER_CORE_NOT_FOUND",
                        "Procedure: p10_sbe_core_spr_setup Unable to match ATTR_MASTER_CORE attribute value with any child core chiplet of master processor chip passed to HWP" ],
            0x689f5d: [ "RC_P10_SBE_CORE_SPR_SETUP_MASTER_CORE_ECO_MODE",
                        "Procedure: p10_sbe_core_spr_setup Master core not expected to be in ECO mode" ],
            0x3359e7: [ "RC_P10_SBE_INSTRUCT_START_MASTER_CORE_ECO_MODE",
                        "Procedure: p10_sbe_instruct_start Master core not expected to be in ECO mode" ],
            0x2f549d: [ "RC_P10_SBE_CORE_SPR_SETUP_MASTER_FUSED_CORE_PARTNER_NOT_FOUND",
                        "Procedure: p10_sbe_core_spr_setup Unable to find partner fused core for identified master core" ],
            0xcb640b: [ "RC_P10_SBE_CORE_SPR_SETUP_NOT_MASTER_CHIP",
                        "Procedure: p10_sbe_core_spr_setup HWP called on SBE which is not designated as drawer master chip" ],
            0xdcf578: [ "RC_P10_IO_TX_TDR_SCREEN_ERROR",
                        "Tx TDR screen found an error" ],
            0x10b7dd: [ "RC_P10_IO_TX_TDR_SCREEN_MULTI_GROUP_ERROR",
                        "Tx TDR screen found an error on both degrade groups" ],
            0x383ff8: [ "RC_P10_IO_TDR_EDGE_ERROR",
                        "No horizontal edge was found within the TDR pattern" ],
            0x6c4704: [ "RC_P10_IO_TDR_DAC_RANGE_ERROR",
                        "The DAC calibrated outside of the acceptable range" ],
            0x255564: [ "RC_P10_IO_LOAD_PPE_HW_IMG_ERROR",
                        "Invalid NULL pointer to HW reference image passed to HWP" ],
            0x602ac3: [ "RC_P10_IO_LOAD_PPE_IOPPE_IMG_ERROR",
                        "Null pointer or zero size section encountered when searching nested IOPPE XIP image extracted from HW reference image pointer" ],
            0xbe10dd: [ "RC_P10_IO_LOAD_PPE_IOPXRAM_IMG_ERROR",
                        "Null pointer or zero size section encountered when searching nested IOPXRAM XIP image extracted from HW reference image pointer" ],
            0xb10985: [ "RC_FBC_CORE_TOPO_SIZE_ERROR",
                        "The size of the topology vector is not as expected." ],
            0x53fef7: [ "RC_FBC_CORE_TOPO_HOMER_TARGET_ERROR",
                        "Target type must be CORE for HOMER actions." ],
            0x2e4ffb: [ "RC_FBC_CORE_TOPO_HOMER_SCOM_ERROR",
                        "Adding topology SCOM to HOMER image failed." ],
            0x29b6e0: [ "RC_P10_GETPUTMEMPROC_INVALID_FLAGS",
                        "Procedure: p10_getmemproc, p10_putmemproc Invalid flag specified for ADU access" ],
            0xb07a52: [ "RC_P10_GETPUTMEMPROC_UNSUPPORTED_FLAGS",
                        "Procedure: p10_getmemproc, p10_putmemproc Unsupported flag specified for ADU access" ],
            0x7d7fcc: [ "RC_P10_GETPUTMEMPROC_INVALID_SIZE_CI",
                        "Procedure: p10_getmemproc, p10_putmemproc Invalid byte count specified for cache inhibited ADU access" ],
            0x6826b8: [ "RC_P10_GETPUTMEMPROC_INVALID_SIZE_DMA",
                        "Procedure: p10_getmemproc, p10_putmemproc Invalid byte count specified for DMA partial write ADU access" ],
            0x33d30f: [ "RC_BAD_PROC_TARGET",
                        "Processor target passed as input is either not functional or not valid." ],
            0x47f2f4: [ "RC_BAD_INPUT_BUFFER",
                        "Input buffer which should point to HOMER base is not valid." ],
            0xeca800: [ "RC_P10_IO_QUIESCE_LANE_MULTIPLE_RX_IDENTIFIED_ERR",
                        "p10_io_quiesce_lane: Multiple lanes identified in DL RX Lane Control Register which meet criteria for powerdown. Skip PHY lane quiesce in order to avoid action which may bring down the link." ],
            0x166f62: [ "RC_P10_IO_QUIESCE_LANE_NO_RX_IDENTIFIED_ERR",
                        "p10_io_quiesce_lane: No lanes identified in DL RX Lane Control Register which meet criteria for powerdown. No PHY lane quiesce action is taken." ],
            0xc2379c: [ "RC_P10_IO_QUIESCE_LANE_CALCULATION_ERR",
                        "p10_io_quiesce_lane: Lane number calculated for powerdown is out of range." ],
            0xa880e6: [ "RC_P10_IO_QUIESCE_LANE_RX_LANE_BUSY_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete recal" ],
            0xdd082c: [ "RC_PGPE_BAD_MODE",
                        "Unknown mode passed to p10_pm_pgpe_init." ],
            0xa6debc: [ "RC_PGPE_INIT_TIMEOUT",
                        "Pstate GPE init timed out while waiting for PGPE Active in OCC Flag 2." ],
            0xc544a8: [ "RC_PGPE_INIT_PSTATE_AUTOSTART_TIMEOUT",
                        "Pstate GPE Protocol Auto Start timeout. This is only used in lab test modes." ],
            0x8b2c5c: [ "RC_PGPE_INIT_HALT",
                        "PGPE init detected a Halt condition. This can happen if the boot image in memory is not accessible." ],
            0x2a6c9a: [ "RC_PGPE_INIT_DEBUG_HALT",
                        "Pstate GPE init detected a Debug Halt condition. This should only assert in a development debug environment." ],
            0xea41ca: [ "RC_PGPE_RESET_TIMEOUT",
                        "Pstate GPE init timed out while waiting for HALT status in XSR register." ],
            0x697f4e: [ "RC_PGPE_PBA_INIT_FAILED",
                        "p10_pm_pba_init failed in PM_INIT mode." ],
            0x6c76c0: [ "RC_P10_SBE_LOAD_BOOTLOADER_INVALID_TARGET_ADDRESS",
                        "Procedure: p10_sbe_load_bootloader Target base address is not cacheline aligned." ],
            0x5101bc: [ "RC_P10_SBE_LOAD_BOOTLOADER_INVALID_ECO_TARGET",
                        "Procedure: p10_sbe_load_bootloader Master core target provided is configured for ECO mode." ],
            0x7f4256: [ "RC_P10_SBE_LOAD_BOOTLOADER_INVALID_PAYLOAD_SIZE",
                        "Procedure: p10_sbe_load_bootloader Payload size is invalid." ],
            0xefcd68: [ "RC_PM_QME_FIRINIT_BAD_MODE",
                        "Unknown mode passed to p10_pm_qme_firinit." ],
            0x28b88a: [ "RC_P10_GEN_XSCOM_INIT_UNSUPPORTED_SCOM_ERR",
                        "Unsupported indirect/multicast SCOM address" ],
            0xc853fb: [ "RC_P10_GEN_XSCOM_INIT_SCOM_XLATE_ERR",
                        "Error translating chip unit relative SCOM address" ],
            0xaea191: [ "RC_L2_PURGE_DONE_TIMEOUT",
                        "L2 Purge Done Timeout." ],
            0x3d05f8: [ "RC_PMSR_SHIFT_INACTIVE_TIMEOUT",
                        "poll for drop of PMSR_SHIFT_INACTIVE Timeout." ],
            0xe255a8: [ "RC_QME_META_COREQ_PROTECT_FAIL",
                        "size of the attributes added are more than that of allocated protection buffer." ],
            0x572ad9: [ "RC_P10_IO_OMI_POLL_INIT_DONE_TIMEOUT_ERROR",
                        "Timed out waiting for PHY PPE to complete io init" ],
            0x1149d0: [ "RC_PPE_STATE_HALT_TIMEOUT_ERR",
                        "A HALT operation to a PPE timed out. This is indicative of hardware error." ],
            0xe23480: [ "RC_PM_BACKING_CACHEPOWER_DOWN_FAILED",
                        "sbe backing power down procedure failed" ],
            0x94f8fe: [ "RC_PM_BACKING_CACHEPOWER_DOWN_ECO_ERR",
                        "Backing cache unexpectedly configured in ECO mode" ],
            0x4fa153: [ "RC_PROC_GETTRACEARRAY_INVALID_BUS",
                        "The specified trace bus ID is invalid." ],
            0x541cb5: [ "RC_PROC_GETTRACEARRAY_INVALID_TARGET",
                        "An invalid target type was supplied for the requested trace array." ],
            0x6a8ab3: [ "RC_PROC_GETTRACEARRAY_CORE_NOT_DUMPABLE",
                        "An attempt was made to dump a core trace array, but this chip's core cannot be dumped via SCOM." ],
            0x52d218: [ "RC_PROC_GETTRACEARRAY_TRACE_RUNNING",
                        "An attempt was made to dump a trace array while it was still running." ],
            0x75ed57: [ "RC_PROC_GETTRACEARRAY_TRACE_MUX_INCORRECT",
                        "The requested trace array's primary trace mux is not set up to capture the requested trace bus." ],
            0x5b3efe: [ "RC_P10_L2ERR_EXTRACT_TA_WRONG_SIZE_ERR",
                        "Procedure: p10_l2err_extract Specified trace array length does not match expected length" ],
            0xbb6e27: [ "RC_P10_L2ERR_EXTRACT_DW_NOT_FOUND",
                        "Procedure: p10_l2err_extract Could not find DW" ],
            0x924a00: [ "RC_P10_L2ERR_EXTRACT_UNKNOWN_SYNDROME_ECC",
                        "Procedure: p10_l2err_extract Syndrome ECC is unknown" ],
            0x60f5ae: [ "RC_P10_L2ERR_EXTRACT_SYNDROME_NOT_FOUND",
                        "Procedure: p10_l2err_extract Could not find syndrome" ],
            0x85b027: [ "RC_OCC_CONTROL_MEM_BOOT_LENGTH_MISMATCH",
                        "The OCC PPC405 memory boot launcher length written did not match the expected value." ],
            0x7c7ab0: [ "RC_OCC_START_TIMEOUT",
                        "The OCC PPC405 failed to start as determined by the OCC Heartbeat enablement." ],
            0x938428: [ "RC_BAD_VPD_READ",
                        "Attempted to read #V data and got less data than we expected" ],
            0x539cf5: [ "RC_INVALID_POUNDV_VERSION",
                        "Read unknown version type from #V keyword in a LRP record" ],
            0x63de72: [ "RC_INVALID_BUCKET_ID",
                        "Encountered an invalid Bucket Id. Valid values are 1-6 inclusive." ],
            0x0406b1: [ "RC_P10_REVERT_SBE_MCS_SETUP_NO_MI_TARGETS_FOUND",
                        "Procedure: p10_revert_sbe_mcs_setup No MI targets were found to revert." ],
            0xdc86c1: [ "RC_P10_REVERT_SBE_MCS_SETUP_SELECTED_MC_NOT_FOUND",
                        "Procedure: p10_revert_sbe_mcs_setup The MC that was setup was not found and cannot be reverted" ],
            0x5dc7fd: [ "RC_P10_DOWNSTREAM_TMPL1_REQUIRED_ERR",
                        "Procedure: p10_omi_init Downstream template 1 required This info is determined by the OCMB. For P10 we only support the Explorer OCMBs who should always have this set, and if they do not it points to a software problem." ],
            0x692c21: [ "RC_P10_DOWNSTREAM_TMPL4OR7_REQUIRED_ERR",
                        "Procedure: p10_omi_init Downstream template 4 or/and 7 is required This info is determined by the OCMB. For P10 we only support the Explorer OCMBs who should always have this set, and if they do not it points to a software problem." ],
            0x67d049: [ "RC_P10_PHB_HV_UTILS_ETU_RESET_ACTIVE",
                        "ETU is in reset." ],
            0x8bb51e: [ "RC_P10_PHB_HV_UTILS_INVALID_ARGS",
                        "Invalid Arguments specified!" ],
            0xdfc2e0: [ "RC_P10_SBE_PLL_INITF_UNSUPPORTED_PLL_BUCKET",
                        "Unsupported PLL bucket select" ],
            0x2ed6ad: [ "RC_P10_EXIT_CACHE_CONTAINED_MULTIPLE_MASTER_ERR",
                        "Multiple chips found with ATTR_PROC_SBE_MASTER_CHIP set" ],
            0x728b53: [ "RC_P10_EXIT_CACHE_CONTAINED_NO_MASTER_ERR",
                        "No chips were found with ATTR_PROC_SBE_MASTER_CHIP set" ],
            0x7030eb: [ "RC_P10_EXIT_CACHE_CONTAINED_INVALID_MCD_GROUP_SIZE_ERR",
                        "Unsupported MCD group size" ],
            0x89c94a: [ "RC_P10_ATTR_UPDATE_MVPD_READ_ERR",
                        "Procedure: p10_attr_update Invalid MER0 record size read from MVPD" ],
            0x1cab9a: [ "RC_P10_ATTR_UPDATE_VD_KEYWORD_VERSION_ERR",
                        "Procedure: p10_attr_update Unsupported MER0 VD keyword version value found in MVPD" ],
            0xebd560: [ "RC_P10_ATTR_UPDATE_PDI_KEYWORD_HEADER_ERR",
                        "Procedure: p10_attr_update Unsupported MER0 #I keyword header content found in MVPD" ],
            0xe41bff: [ "RC_P10_ATTR_UPDATE_PDI_KEYWORD_CHIPLET_ID_ERR",
                        "Procedure: p10_attr_update Unsupported MER0 #I entry content found in MVPD" ],
            0xb352cc: [ "RC_HW_IMG_PTR_ERROR",
                        "HW Image pointer is either NULL or points to same location as HOMER base" ],
            0x630a6e: [ "RC_HOMER_IMG_PTR_ERROR",
                        "HOMER Image pointer is NULL" ],
            0x0e6cc2: [ "RC_HW_IMAGE_INVALID_SIZE",
                        "Hardware Image size is not in expected range" ],
            0x20f7f8: [ "RC_HCODE_INVALID_PHASE",
                        "Invalid or unsupported build phase passed to the HOMER build procedure" ],
            0x78987a: [ "RC_HCODE_INVALID_TEMP1_BUF",
                        "Temporary buffer1 is invalid" ],
            0x779683: [ "RC_HCODE_INVALID_TEMP1_BUF_SIZE",
                        "Invalid size for temp buf1" ],
            0xf1f3a1: [ "RC_HCODE_INVALID_TEMP2_BUF",
                        "Temporary buffer2 is invalid" ],
            0x7e4864: [ "RC_HCODE_INVALID_TEMP2_BUF_SIZE",
                        "Invalid size for temp buf2" ],
            0xb343fb: [ "RC_HCODE_INVALID_TEMP3_BUF",
                        "Temporary buffer3 is invalid." ],
            0x868695: [ "RC_HCODE_INVALID_TEMP3_BUF_SIZE",
                        "Invalid size for temp buf3" ],
            0x4fe0ae: [ "RC_HCODE_INVALID_TEMP4_BUF",
                        "Temporary buffer4 is invalid." ],
            0x0d05b3: [ "RC_HCODE_INVALID_TEMP4_BUF_SIZE",
                        "Invalid size for temp buf4" ],
            0x507384: [ "RC_HCODE_INVALID_IMG_TYPE",
                        "Invalid image type passed for hcode image build." ],
            0xe80e4d: [ "RC_XGPE_IMG_NOT_FOUND_IN_HW_IMG",
                        "XGPE Image not found in hardware image" ],
            0x459f12: [ "RC_XPMR_HDR_BUILD_FAIL",
                        "Failed to update XPMR Header region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0xb05f6b: [ "RC_XGPE_BOOT_COPIER_BUILD_FAIL",
                        "Failed to update XGPE boot copier region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x2f992f: [ "RC_XGPE_BOOT_LOADER_BUILD_FAIL",
                        "Failed to update XGPE boot loader region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x1a514c: [ "RC_XGPE_HCODE_BUILD_FAIL",
                        "Failed to update XGPE Hcode region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x2a64b0: [ "RC_SELF_REST_IMG_NOT_FOUND_IN_HW_IMG",
                        "Self Restore Image not found in hardware image" ],
            0x1a2c24: [ "RC_SELF_REST_IMG_BUILD_FAIL",
                        "Failed to update Self Restore region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0xe972be: [ "RC_CPMR_HDR_BUILD_FAIL",
                        "Failed to update CPMR Header region HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x983d8d: [ "RC_QME_IMG_NOT_FOUND_IN_HW_IMG",
                        "QME Image not found in hardware image." ],
            0x06b597: [ "RC_QME_HCODE_BUILD_FAIL",
                        "hcode image build procedure failed to update QME Hcode region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x9f10b7: [ "RC_QME_META_NOT_FOUND_IN_HW_IMG",
                        "QME Meta Data not found in hardware image. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x068e80: [ "RC_QME_META_QMEATMT_MAGIC_MISMATCH",
                        "hcode image build procedure checks magic header of meta data failed." ],
            0xb1982f: [ "RC_PGPE_IMG_NOT_FOUND_IN_HW_IMG",
                        "PGPE Image not found in hardware image" ],
            0x7c997c: [ "RC_P10_XIP_SECTION_PGPE_PPMR",
                        "hcode image build procedure failed to update PPMR region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x0b4fb3: [ "RC_P10_PGPE_BOOT_COPIER_BUILD_FAIL",
                        "hcode image build procedure failed to update PGPE boot copier region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x23e6b5: [ "RC_P10_PGPE_BOOT_LOADER_BUILD_FAIL",
                        "hcode image build procedure failed to update PGPE boot loader region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x0ec36c: [ "RC_P10_PGPE_HCODE_BUILD_FAIL",
                        "hcode image build procedure failed to update PGPE hcode region of HOMER. Note: 0xFFFFFFFF in field MAX_ALLOWED_SIZE is an invalid size suggesting that image section is not found" ],
            0x1bc56a: [ "RC_QME_IMG_EXCEED_SRAM_SIZE",
                        "Size of QME image exceeded the SRAM size. Note: 0xFFFFFFFF in field MAX_QME_IMG_SIZE_ALLOWED indicates an invalid size." ],
            0xe763ce: [ "RC_XGPE_IMG_EXCEED_SRAM_SIZE",
                        "Size of XGPE image exceeded the size allowed in OCC SRAM" ],
            0x4d0241: [ "RC_PGPE_IMG_EXCEED_SRAM_SIZE",
                        "Size of PGPE image exceeded the size allowed in OCC SRAM" ],
            0x72ca7a: [ "RC_SELF_RESTORE_INIT_FAILED",
                        "hcode image build procedure failed to initialize self-restore region." ],
            0xbd2e56: [ "RC_SELF_SAVE_INIT_FAILED",
                        "hcode image build procedure failed to initialize self-save region." ],
            0x0189d6: [ "RC_AUTO_WAKEUP_VECTOR_CREATION_FAILED",
                        "hcode image build failed to create auto wakeup vector in CPMR header" ],
            0xd3cbfb: [ "RC_BAD_OVERRIDE_SIZE",
                        "Override binary is bigger then temp buffer. It may mean override binary is not built correct. It is not expected to be more than 2KB." ],
            0x32d0ed: [ "RC_BCE_BUF_SMALLER_FOR_NON_HCODE_SECTION",
                        "Buffer allocated for block copy at runtime cannot accomodate core common rings, repair ring or SCOM restore entries." ],
            0x3e739b: [ "RC_XIP_SECTION_APPEND_INVALID_PARAMETERS",
                        "Error calling p10_xip_section_append when checking input parameters" ],
            0xe8eab2: [ "RC_XIP_SECTION_APPEND_APPEND_RC",
                        "Error calling p10_xip_section_append when running p9_xip_append" ],
            0x7b8738: [ "RC_XIP_SECTION_APPEND_SIZE_RC",
                        "Error calling p10_xip_section_append when running p9_xip_image_size" ],
            0xac269e: [ "RC_PM_BLOCK_WAKEUP_INTR_OP",
                        "Unknown operation passed to p10_block_wakeup_intr" ],
            0x5fb0c3: [ "RC_PM_BLOCK_WAKEUP_INTR_FAILED",
                        "Block wakeup procedure failed" ],
            0x42bd20: [ "RC_PM_PBA_FIRINIT_BAD_MODE",
                        "Unknown mode passed to p10_pm_pba_firinit." ],
            0x69a93b: [ "RC_LPC_ACCESS_TIMEOUT",
                        "An attempt to read/write data in the LPC address space via the Alter/Display unit timed out." ],
            0x8b524f: [ "RC_LPC_HELD_IN_RESET",
                        "LPC bus is held in reset." ],
            0xb412a6: [ "RC_LPC_OPB_ERROR",
                        "After LPC initialization, the OPB master indicated an error." ],
            0x93ee24: [ "RC_P10_PAU_SCOMINIT_IOHS_OCAPI_CONFIG_ERR",
                        "The IOHS link cannot be configured for OpenCAPI operations." ],
            0x561134: [ "RC_P10_PAU_SCOMINIT_IOHS_OCAPI_NO_PAU",
                        "Unable to map IOHS0/IOHS3 to a valid PAU for OCAPI operations." ],
            0x96089d: [ "RC_P10_PAU_SCOMINIT_IOHS_OCAPI_NOT_ENOUGH_PAUS",
                        "Not enough PAU chiplets for IOHS OCAPI link(s) within corner." ],
            0x06e1af: [ "RC_PM_QME_ADDR_OUT_OF_RANGE",
                        "QME Address beyond permissible range" ],
            0xef2fd1: [ "RC_PM_QME_ADDR_ALIGNMENT_ERROR",
                        "qme BAR must be on a 1MB boundary" ],
            0xd73889: [ "RC_PM_QME_BAR_SIZE_INVALID",
                        "Non-zero QME BAR defined with region size of 0. Size must be 2MB or greater" ],
            0x4d5caa: [ "RC_P10_FBC_EFF_CONFIG_AGGREGATE_INVALID_CONFIG_ERR",
                        "Procedure: p10_fbc_eff_config_aggregate Invalid aggregate link conifguration detected Each chip may have at most: One aggregate X link destination One aggregate A link destination" ],
            0x0cdb4c: [ "RC_P10_FBC_EFF_CONFIG_AGGREGATE_CONSISTENCY_ERR",
                        "Procedure: p10_fbc_eff_config_aggregate X or A aggregate attribute state computed currently does not match with calculations performed in this hardware procedure" ],
            0xfb2394: [ "RC_P10_SBE_SCRATCH_REGS_MC_FREQ_LOOKUP_ERR",
                        "Frequency requested via ATTR_FREQ_MC_MHZ was not found in list of supported frequency values" ],
            0xf122c2: [ "RC_P10_SBE_SCRATCH_REGS_IOHS_FREQ_LOOKUP_ERR",
                        "Frequency requested via ATTR_FREQ_IOHS_MHZ was not found in list of supported frequency values" ],
            0x42f035: [ "RC_P10_SBE_SCRATCH_REGS_PCIE_FREQ_LOOKUP_ERR",
                        "Frequency requested via ATTR_FREQ_PCIE_MHZ was not found in list of supported frequency values" ],
            0xc1b24f: [ "RC_P10_SBE_SCRATCH_REGS_PAUC_GARD_ERR",
                        "Requested PAUC GARD state is not supported by current IPL type" ],
            0xf4865f: [ "RC_P10_SBE_ATTR_SETUP_NMMU1_ERR",
                        "NMMU1 unit is logically required by PAU unit configuration, but is disabled in N1 chiplet ATTR_PG_MVPD data" ],
            0x42c3e8: [ "RC_P10_HW549287_WAR_ERR",
                        "Workaround for HW549287 failed" ],
            0x42fa0e: [ "RC_P10_SBE_SCRATCH_REGS_INVALID_ACCESS_ERR",
                        "Requested hardware access method is not supported by platform" ],
            0x68a7a9: [ "RC_P10_SBE_FABRICINIT_FBC_STOPPED",
                        "Pervasive stop control (pb_stop) is asserted, fabric init will not be attempted. This signal will prohbit all fabric commands from being broadcast, so fabric init will fail." ],
            0xb048e5: [ "RC_CHTM_PURGE_DONE_TIMEOUT",
                        "CHTM Purge Done Timeout." ],
            }

    rc, i=intConcat(data, i, i+4)
    decodeList = RCDesc.get(rc)
    if decodeList is None:
        d["Unrecognized Error ID"] = f'0x{rc:X}'
    else:
        d["HwpReturnCode"] = decodeList[0]
        d["HWP Error Description"] = decodeList[1]

    jsonStr = json.dumps(d)
    return jsonStr
