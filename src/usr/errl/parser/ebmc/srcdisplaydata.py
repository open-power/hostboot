# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/errl/parser/ebmc/srcdisplaydata.py $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2024
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG
# The content of this file, srcdisplaydata.py, is automatically
# generated by src/usr/errl/parser/genErrlParsers.pl and output to
# obj/genfiles/plugins/srcdisplaydata.py.

# At this time, the generated file must be manually copied from the
# obj/genfiles/plugins directory to the src/usr/errl/parser/ebmc directory and
# then manually checked in to be picked up by the Hostboot build.

# To pull the parser change into a BMC image, update the commit pointer in the
# openbmc project's meta-openpower/recipes-phosphor/logging/hostboot-pel-parsers_git.bb
# file to reference the Hostboot commit with the change.

# The following dictionary is used by bsrc.py to parse SRC data.

srcInfo = {
            0x1B0100: {    "devdesc": "Kernel has asserted",
                           "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                           "reasoncode": "KERNEL::RC_ASSERT",
                           "userdata1":  "Failing address",
                           "userdata2":  "<unused>",
                      },
            0x1B0200: {    "devdesc": "Kernel encountered an unhandled exception.",
                           "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                           "reasoncode": "KERNEL::RC_SHUTDOWN",
                           "userdata1":  "Failing address",
                           "userdata2":  "<unused>",
                      },
            0x1B0300: {    "devdesc": "Kernel encountered an unhandled exception.",
                           "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                           "reasoncode": "KERNEL::RC_UNHANDLED_EX",
                           "userdata1":  "Exception type",
                           "userdata2":  "<unused>",
                      },
            0x1B9900: {    "devdesc": "Unknown TI from Hostboot",
                           "moduleid": "KERNEL::MOD_KERNEL_INVALID",
                           "reasoncode": "KERNEL::RC_EARLY_BOOT_FAIL",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x230200: {    "devdesc": "Invalid GPIO device type",
                           "moduleid": "GPIO_PERFORM_OP",
                           "reasoncode": "GPIO_I2C_TARGET_NOT_FOUND",
                           "userdata1":  "Device type",
                           "userdata2":  "HUID of target",
                      },
            0x230300: {    "devdesc": "Invalid GPIO device type",
                           "moduleid": "GPIO_PERFORM_OP",
                           "reasoncode": "GPIO_INVALID_OP",
                           "userdata1":  "OP type",
                           "userdata2":  "HUID of target",
                      },
            0x262500: {    "devdesc": "OCCs were not loaded/started successfully",
                           "moduleid": "HTMGT_MOD_LOAD_START_STATUS",
                           "reasoncode": "HTMGT_RC_OCC_START_FAIL",
                           "userdata1":  "Failing OCC HUID",
                      },
            0x262600: {    "devdesc": "OCC needs reset after initial poll",
                           "moduleid": "HTMGT_MOD_LOAD_START_STATUS",
                           "reasoncode": "HTMGT_RC_OCC_UNEXPECTED_STATE",
                      },
            0x265500: {    "devdesc": "No OCC master was found",
                           "moduleid": "HTMGT_MOD_LOAD_START_STATUS",
                           "reasoncode": "HTMGT_RC_OCC_MASTER_NOT_FOUND",
                           "userdata1":  "number of OCCs",
                      },
            0x10201: {    "devdesc": "User Details unit test - create string user detail data.",
                           "moduleid": "ERRL_USERDATA_TEST_MOD_ID",
                           "reasoncode": "ERRL_TEST_STRING_UD",
                           "userdata1":  "Test data 1",
                           "userdata2":  "Test data 2",
                      },
            0x10401: {    "devdesc": "User Details unit test - create string user detail data.",
                           "moduleid": "ERRL_USERDATA_TEST_MOD_ID",
                           "reasoncode": "ERRL_TEST_ATTRIBUTE_UD",
                           "userdata1":  "Test data 1",
                           "userdata2":  "Test data 2",
                      },
            0x10501: {    "devdesc": "User Details unit test - create log register user detail data.",
                           "moduleid": "ERRL_USERDATA_TEST_MOD_ID",
                           "reasoncode": "ERRL_TEST_LOGREGISTER_UD",
                           "userdata1":  "Test data 1",
                           "userdata2":  "Test data 2",
                      },
            0x20201: {    "devdesc": "A device driver operation was attempted for which no driver has been registered.",
                           "moduleid": "DEVFW_MOD_ASSOCIATOR",
                           "reasoncode": "DEVFW_RC_NO_ROUTE_FOUND",
                           "userdata1":  "(OpType << 32) | (AccessType)",
                           "userdata2":  "(SCOM_SWITCHES << 32) | TargetType",
                      },
            0x20301: {    "devdesc": "A device driver operation on a NULL target.",
                           "moduleid": "DEVFW_MOD_ASSOCIATOR",
                           "reasoncode": "DEVFW_RC_NULL_TARGET",
                           "userdata1":  "OpType",
                           "userdata2":  "AccessType",
                      },
            0x20401: {    "devdesc": "A double registration was attempted with the routing framework.",
                           "moduleid": "DEVFW_MOD_ASSOCIATOR",
                           "reasoncode": "DEVFW_RC_DOUBLE_REGISTRATION",
                           "userdata1[0:31]":  "OpType",
                           "userdata1[32:63]":  "AccessType",
                           "userdata2":  "TargetType",
                      },
            0x50101: {    "devdesc": "Initialization Service failed to start a task.",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "START_TASK_FAILED",
                           "userdata1":  "0",
                           "userdata2":  "task id or task return code",
                      },
            0x50201: {    "devdesc": "Initialization Service attempted to start a function within a module but the function failed to launch",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "START_FN_FAILED",
                           "userdata1":  "task return code",
                           "userdata2":  "0",
                      },
            0x50401: {    "devdesc": "Could not FLUSH virtual memory.",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "SHUTDOWN_FLUSH_FAILED",
                           "userdata1":  "returncode from mm_remove_pages()",
                           "userdata2":  "0",
                      },
            0x50501: {    "devdesc": "Initialization Service launched a task and the task returned an error.",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "WAIT_TASK_FAILED",
                           "userdata1":  "task id or task return code",
                           "userdata2":  "returned status from task",
                      },
            0x50601: {    "devdesc": "Initialization Service launched a function and the task returned an error.",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "WAIT_FN_FAILED",
                           "userdata1":  "task id or task return code",
                           "userdata2":  "returned status from task",
                      },
            0x50701: {    "devdesc": "Initialization Service failed to load a module needed to load a function or task. UserDetails will contain the name of the function or task.",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "INITSVC_LOAD_MODULE_FAILED",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x50e01: {    "devdesc": "Hostboot code called doShutdown() directly",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "SBE_EXTRACT_RC_REQUEST_REIPL",
                           "userdata1":  "UNDEFINED",
                           "userdata2":  "UNDEFINED",
                      },
            0x51301: {    "devdesc": "Hostboot code called doShutdown() directly to request a reconfig loop",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "SHUTDOWN_DO_RECONFIG_LOOP",
                           "userdata1":  "UNDEFINED",
                           "userdata2":  "UNDEFINED",
                      },
            0x51401: {    "devdesc": "Hostboot code called doShutdown() directly because an error was committed in manufacturing mode",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "SHUTDOWN_MFG_TERM",
                           "userdata1":  "UNDEFINED",
                           "userdata2":  "UNDEFINED",
                      },
            0x51501: {    "devdesc": "Hostboot code called doShutdown() directly after a SBE Update where the security keys were updated",
                           "moduleid": "BASE_INITSVC_MOD_ID",
                           "reasoncode": "SHUTDOWN_KEY_TRANSITION",
                           "userdata1":  "UNDEFINED",
                           "userdata2":  "UNDEFINED",
                      },
            0x51701: {    "devdesc": "Timing information from the boot sequence",
                           "moduleid": "INITSERVICE::BASE_INITSVC_MOD_ID",
                           "reasoncode": "INITSERVICE::ISTEP_IPL_STATS",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x60101: {    "devdesc": "PnorRP::waitForMessage> Unrecognized message type",
                           "moduleid": "PNOR::MOD_PNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_INVALID_MESSAGE_TYPE",
                           "userdata1":  "Message type",
                           "userdata2":  "Requested Virtual Address",
                      },
            0x60201: {    "devdesc": "PnorRP::computeDeviceAddr> Virtual Address outside known PNOR range",
                           "moduleid": "PNOR::MOD_PNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1":  "Virtual Address",
                           "userdata2":  "Base PNOR Address",
                      },
            0x60601: {    "devdesc": "PnorRP::waitForMessage> Unrecognized message type",
                           "moduleid": "PNOR::MOD_PNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_INVALID_ASYNC_MESSAGE",
                           "userdata1":  "Message type",
                           "userdata2":  "Requested Virtual Address",
                      },
            0x70201: {    "devdesc": "Invalid operation type.",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_OP_TYPE",
                           "userdata1":  "i_opType",
                           "userdata2[0:15]":  "Offset Length",
                           "userdata2[16:31]":  "Master Port",
                           "userdata2[32:47]":  "Master Engine",
                           "userdata2[48:63]":  "Slave Device Address",
                      },
            0x70701: {    "devdesc": "Master Sentinel chip was used as a target for an I2C operation.  This is not permitted.",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_MASTER_SENTINEL_TARGET",
                           "userdata1":  "Operation Type requested",
                           "userdata2":  "<UNUSED>",
                      },
            0x70D01: {    "devdesc": "I2C read/write interface not linked.",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_RUNTIME_INTERFACE_ERR",
                           "userdata1":  "0",
                           "userdata2":  "Op type",
                      },
            0x70E01: {    "devdesc": "I2C access error",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_RUNTIME_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2":  "Op type",
                      },
            0x71201: {    "devdesc": "I2C master encountered an error while trying to unlock the eepromPage",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_FAILURE_UNLOCKING_EEPROM_PAGE",
                           "userdata1":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0x71801: {    "devdesc": "Invalid input buffer length for send byte request",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_SEND_BYTE_LENGTH",
                           "userdata1":  "Size of request",
                      },
            0x71901: {    "devdesc": "Invalid input buffer length for write byte or write word request",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_WRITE_BYTE_OR_WORD_LENGTH",
                           "userdata1":  "Size of request",
                           "userdata2":  "Sub-op",
                      },
            0x71A01: {    "devdesc": "Invalid input buffer length for block write request",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_BLOCK_WRITE_LENGTH",
                           "userdata1":  "Size of request",
                      },
            0x71B01: {    "devdesc": "Invalid input buffer length for read byte or read word request",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_READ_BYTE_OR_WORD_LENGTH",
                           "userdata1":  "Size of request",
                           "userdata2":  "Sub-op",
                      },
            0x71C01: {    "devdesc": "Invalid input buffer length for block read request",
                           "moduleid": "I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_BLOCK_READ_LENGTH",
                           "userdata1":  "Size of request",
                      },
            0x80101: {    "devdesc": "Could not load/unload module.",
                           "moduleid": "VFS_MODULE_ID",
                           "reasoncode": "VFS_LOAD_FAILED",
                           "userdata1":  "returncode from msg_sendrecv()",
                           "userdata2":  "VfsMessages type [LOAD | UNLOAD]",
                      },
            0x80301: {    "devdesc": "Could not allocate virtual memory.",
                           "moduleid": "VFS_MODULE_ID",
                           "reasoncode": "VFS_ALLOC_VMEM_FAILED",
                           "userdata1":  "returncode from mm_alloc_block()",
                           "userdata2":  "Size of memory to allocate",
                      },
            0x80401: {    "devdesc": "Could not set permissions on virtual memory.",
                           "moduleid": "VFS_MODULE_ID",
                           "reasoncode": "VFS_PERMS_VMEM_FAILED",
                           "userdata1":  "returncode from mm_set_permission()",
                           "userdata2":  "message type (LOAD or UNLOAD)",
                      },
            0x80501: {    "devdesc": "Requested module does not exist.",
                           "moduleid": "VFS_MODULE_ID",
                           "reasoncode": "VFS_MODULE_DOES_NOT_EXIST",
                           "userdata1":  "first 8 bytes of module name",
                           "userdata2":  "next 8 bytes of module name",
                      },
            0x80601: {    "devdesc": "Module is not a data module",
                           "moduleid": "VFS_MODULE_ID",
                           "reasoncode": "VFS_INVALID_DATA_MODULE",
                           "userdata1":  "First 8 bytes of module name",
                           "userdata2":  "Next 8 bytes of module name",
                      },
            0x90101: {    "devdesc": "InitFile HW Procedure requested an invalid attribute",
                           "moduleid": "MOD_FAPI_RC_TO_ERRL",
                           "reasoncode": "RC_INVALID_ATTR_GET",
                      },
            0x90201: {    "devdesc": "Request for EC features on an attribute without EC features",
                           "moduleid": "MOD_FAPI_RC_TO_ERRL",
                           "reasoncode": "RC_INVALID_CHIP_EC_FEATURE_GET",
                      },
            0x90601: {    "devdesc": "SBE HW Procedure generated error. Check User Data.",
                           "moduleid": "MOD_FAPI2_RC_TO_ERRL",
                           "reasoncode": "RC_HWP_GENERATED_SBE_ERROR",
                           "userdata1":  "RC value from the SBE HWP",
                           "userdata2":  "<unused>",
                      },
            0x90f01: {    "devdesc": "HW Procedure generated error. Check User Data.",
                           "moduleid": "MOD_FAPI2_RC_TO_ERRL",
                           "reasoncode": "RC_HWP_GENERATED_ERROR",
                           "userdata1":  "RC value from HWP",
                           "userdata2":  "<unused>",
                      },
            0xB0101: {    "devdesc": "User Details unit test - create target user detail data",
                           "moduleid": "TARG_MOD_TEST",
                           "reasoncode": "TARG_RC_TEST_TARGET_FFDC",
                           "userdata1":  "Test data 1",
                           "userdata2":  "Test data 2",
                      },
            0xC0101: {    "devdesc": "Attempt to deconfigure a target that is not deconfigurable or not present.",
                           "moduleid": "HWAS::MOD_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_TARGET_NOT_DECONFIGURABLE",
                           "userdata1[00:31]":  "HUID of input target",
                           "userdata1[32:63]":  "GARD errlog EID",
                           "userdata2[00:31]":  "ATTR_DECONFIG_GARDABLE",
                           "userdata2[32:63]":  "ATTR_HWAS_STATE.present",
                      },
            0xD0101: {    "devdesc": "fsiScomPerformOp> Error returned from SCOM Engine after write",
                           "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                           "reasoncode": "FSISCOM::RC_WRITE_ERROR",
                           "userdata1":  "SCOM Addr",
                           "userdata2[00:31]":  "Target HUID",
                           "userdata2[32:63]":  "SCOM Status Reg",
                      },
            0xD0201: {    "devdesc": "fsiScomPerformOp> Error returned from SCOM Engine after read.",
                           "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                           "reasoncode": "FSISCOM::RC_READ_ERROR",
                           "userdata1":  "SCOM Addr",
                           "userdata2[00:31]":  "Target HUID",
                           "userdata2[32:63]":  "SCOM Status Reg",
                      },
            0xD0301: {    "devdesc": "fsiScomPerformOp> Invalid data length (!= 8 bytes)",
                           "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                           "reasoncode": "FSISCOM::RC_INVALID_LENGTH",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Data Length",
                      },
            0xD0401: {    "devdesc": "fsiScomPerformOp> Address contains more than 31 bits.",
                           "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                           "reasoncode": "FSISCOM::RC_INVALID_ADDRESS",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Target HUID",
                      },
            0xD0501: {    "devdesc": "fsiScomPerformOp> Unsupported Operation Type specified",
                           "moduleid": "FSISCOM::MOD_FSISCOM_PERFORM_OP",
                           "reasoncode": "FSISCOM::RC_INVALID_OPTYPE",
                           "userdata1[0:31]":  "Operation Type (i_opType) : 0=READ, 1=WRITE",
                           "userdata1[32:64]":  "Input scom address",
                           "userdata2":  "Target HUID",
                      },
            0xE0101: {    "devdesc": "Invalid operation type.",
                           "moduleid": "EEPROM_PERFORM_OP",
                           "reasoncode": "EEPROM_INVALID_OPERATION",
                           "userdata1":  "Operation Type",
                           "userdata2":  "Chip to Access",
                      },
            0xE0801: {    "devdesc": "I2C Buffer Length + Offset > Max Size",
                           "moduleid": "EEPROM_PERFORM_OP",
                           "reasoncode": "EEPROM_OVERFLOW_ERROR",
                           "userdata1[0:31]":  "Offset",
                           "userdata1[32:63]":  "Buffer Length",
                           "userdata2":  "Device Max Size (in KB)",
                      },
            0xE1601: {    "devdesc": "No functional EEPROM source available",
                           "moduleid": "EEPROM_PERFORM_OP",
                           "reasoncode": "EEPROM_NO_FUNCTIONAL_EEPROM",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Operation type (0 -> read, 1 -> write)",
                           "userdata2[0:31]":  "EEPROM role",
                           "userdata2[32:63]":  "EEPROM source",
                      },
            0xF0301: {    "devdesc": "Interrupt resource provider not initialized yet.",
                           "moduleid": "INTR::MOD_INTR_ENABLE",
                           "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                           "userdata1":  "MSG_INTR_ENABLE",
                           "userdata2":  "0",
                      },
            0x120201: {    "devdesc": "Invalid address and size returned from HDAT",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_NO_HDAT_ADDR",
                           "userdata1":  "Address returned",
                           "userdata2":  "Table type Requested",
                      },
            0x120401: {    "devdesc": "Cannot unmap the source table section",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_CANNOT_UNMAP_SRC",
                           "userdata1":  "VA address of the MDST to unmap",
                           "userdata2":  "rc value from unmap",
                      },
            0x120501: {    "devdesc": "Cannot unmap the source table section",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_CANNOT_UNMAP_DEST",
                           "userdata1":  "VA address of the MDDT to unmap",
                           "userdata2":  "rc value from unmap",
                      },
            0x120701: {    "devdesc": "MDRT table is not big enough to hold all entries",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_MDRT_INSUFFICIENT_SPACE",
                           "userdata1":  "Index into the MDRT",
                           "userdata2":  "max entries allowed given space allocated",
                      },
            0x120901: {    "devdesc": "MDDT table is not big enough to hold all src entries",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_MDDT_INSUFFICIENT_SPACE",
                           "userdata1":  "Source Entires bytes left to copy",
                           "userdata2":  "Index into the MDST table",
                      },
            0x120A01: {    "devdesc": "MDDT table is not big enough to hold all src entries",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_MDDT_INSUFFICIENT_ENTRIES",
                           "userdata1":  "Source Entires bytes left to copy",
                           "userdata2":  "Index into the MDST table",
                      },
            0x120B01: {    "devdesc": "MDST table entry with page aligned is greater than 32GB",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_MDST_INVALID_TABLE_SIZE",
                           "userdata1":  "Size of Source Table Entry",
                           "userdata2":  "Size of Page Aligned Source Table Entry",
                      },
            0x120C01: {    "devdesc": "MDDT table entry with page aligned is greater than 32GB",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_MDDT_INVALID_TABLE_SIZE",
                           "userdata1":  "Size of Destination Table Entry",
                           "userdata2":  "Size of Page Aligned Destination Table Entry",
                      },
            0x121401: {    "devdesc": "MDDT table entry is inside hostboot region",
                           "moduleid": "DUMP::DUMP_COLLECT",
                           "reasoncode": "DUMP::DUMP_MDDT_INVALID_REGION",
                           "userdata1":  "Address of destination table write",
                      },
            0x130101: {    "devdesc": "Unexpected data from LPC-UART interface.",
                           "moduleid": "CONSOLE::MOD_CONSOLE_UART_PUTC",
                           "reasoncode": "CONSOLE::RC_INVALID_DATA",
                      },
            0x130201: {    "devdesc": "Timeout from LPC-UART interface.",
                           "moduleid": "CONSOLE::MOD_CONSOLE_UART_PUTC",
                           "reasoncode": "CONSOLE::RC_TIMEOUT",
                      },
            0x140101: {    "devdesc": "A maint command HW timed out",
                           "moduleid": "MDIA::PROCESS_COMMAND_TIMEOUT",
                           "reasoncode": "MDIA::MAINT_COMMAND_HW_TIMED_OUT",
                           "userData1":  "Associated memory diag work item",
                           "userData2":  "Target HUID",
                      },
            0x140201: {    "devdesc": "A maint command SW timed out",
                           "moduleid": "MDIA::PROCESS_COMMAND_TIMEOUT",
                           "reasoncode": "MDIA::MAINT_COMMAND_SW_TIMED_OUT",
                           "userData1":  "Associated memory diag work item",
                           "userData2":  "Target HUID",
                      },
            0x160201: {    "devdesc": "Bad memory pointer received.",
                           "moduleid": "Util::UTIL_MOD_MEM_READ",
                           "reasoncode": "Util::UTIL_ERC_BAD_PTR",
                           "userdata1[0:31]":  "Task ID.",
                           "userdata1[31:64]":  "End of File (boolean)",
                           "userdata2":  "Address of memory buffer.",
                      },
            0x160301: {    "devdesc": "End of file reached.",
                           "moduleid": "Util::UTIL_MOD_MEM_READ",
                           "reasoncode": "Util::UTIL_ERC_EOF",
                           "userdata1[0:31]":  "Task ID.",
                           "userdata1[31:64]":  "End of File (boolean)",
                           "userdata2":  "Address of memory buffer.",
                      },
            0x170301: {    "devdesc": "IStep failed, Check other log(s) with the same PLID for reason.",
                           "moduleid": "MOD_REPORTING_ERROR",
                           "reasoncode": "RC_FAILURE",
                           "userdata1[0:31]":  "eid of first error",
                           "userdata1[32:63]":  "Reason code of first error",
                           "userdata2[0:31]":  "Total number of elogs included",
                           "userdata2[32:64]":  "iStep and SubStep that failed",
                      },
            0x175201: {    "devdesc": "Failed to update the SBE after an unsupported PSU operation error",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "ISTEP::RC_SBE_UPDATE_UNEXPECTEDLY_FAILED",
                      },
            0x180101: {    "devdesc": "ATTN test case failed",
                           "moduleid": "ATTN_TEST_FAKE_CALL_PRD",
                           "reasoncode": "ATTN_TEST_ATTN_FAIL",
                           "userdata1":  "Input attention list size",
                           "userdata2":  "Expected attention list size",
                      },
            0x1F0101: {    "devdesc": "IPC service provider received an unexpected message.",
                           "moduleid": "IPC::MOD_IPCSP_MSGHDLR",
                           "reasoncode": "IPC::RC_INVALID_MSG_TYPE",
                           "userdata1":  "Message type",
                           "userdata2":  "Data word 0 of message",
                      },
            0x1F0201: {    "devdesc": "Sender node's IPC_PCR_EXTEND message did not contain a valid physical address",
                           "moduleid": "IPC::MOD_IPCSP_MSGHDLR",
                           "reasoncode": "IPC::RC_BAD_PHYS_ADDR",
                           "userdata1":  "Node claimed to have sent the message",
                      },
            0x1F0301: {    "devdesc": "Failed to map physical address into the VMM",
                           "moduleid": "IPC::MOD_IPCSP_MSGHDLR",
                           "reasoncode": "IPC::RC_BLOCK_MAP_FAIL",
                           "userdata1":  "Physical address",
                           "userdata2":  "Size of mapping",
                      },
            0x1F0401: {    "devdesc": "Failed to unmap a virtual to physical memory mapping previously created via mm_block_map.",
                           "moduleid": "IPC::MOD_IPCSP_MSGHDLR",
                           "reasoncode": "IPC::RC_BLOCK_UNMAP_FAIL",
                           "userdata1":  "Return code from mm_block_unmap",
                           "userdata2":  "Virtual memory address to unmap",
                      },
            0x1F0501: {    "devdesc": "Sender node's IPC_PCR_EXTEND message was routed to an unintended receiver node.  This likely indicates a code bug.",
                           "moduleid": "IPC::MOD_IPCSP_MSGHDLR",
                           "reasoncode": "IPC::RC_INCORRECT_NODE_ROUTING",
                           "userdata1":  "Intended receiver node",
                           "userdata2":  "Actual receiver node",
                      },
            0x210101: {    "devdesc": "Devtree libfdt operation returned error",
                           "moduleid": "HANDLE_DEVTREE_ERRORS",
                           "reasoncode": "LIBFDT_ERROR_RC",
                           "userdata1":  "Return Code",
                           "userdata2":  "HUID",
                      },
            0x220601: {    "devdesc": "SBE partition contains unsupported version of Table of Contents",
                           "moduleid": "SBE_FIND_IN_PNOR",
                           "reasoncode": "SBE_UNSUPPORTED_TOC",
                           "userdata1[0:31]":  "CHIP EC",
                           "userdata1[32:63]":  "Expected TOC Version",
                           "userdata2[0:31]":  "SBE TOC Version",
                           "userdata2[32:63]":  "SBE TOC EyeCatch",
                      },
            0x220701: {    "devdesc": "Unsupported EYE-CATCHER found in TOC",
                           "moduleid": "SBE_FIND_IN_PNOR",
                           "reasoncode": "SBE_INVALID_EYECATCHER",
                           "userdata1":  "SBE TOC EYE-CATCHER",
                           "userdata2":  "Expected EYE-CATCHER",
                      },
            0x220801: {    "devdesc": "SBE image for current chip EC was not found in PNOR",
                           "moduleid": "SBE_FIND_IN_PNOR",
                           "reasoncode": "SBE_EC_NOT_FOUND",
                           "userdata1[0:31]":  "CHIP EC",
                           "userdata1[32:63]":  "PNOR Section ID",
                           "userdata2[0:31]":  "SBE TOC Version",
                           "userdata2[32:63]":  "SBE TOC EyeCatch",
                      },
            0x220D01: {    "devdesc": "Unsupported Target Type passed in",
                           "moduleid": "SBE_FIND_IN_PNOR",
                           "reasoncode": "SBE_INVALID_INPUT",
                           "userdata1":  "Target Unit Id",
                           "userdata2":  "Target Type",
                      },
            0x221D01: {    "devdesc": "EC level says 0, which is invalid",
                           "moduleid": "SBE_FIND_IN_PNOR",
                           "reasoncode": "SBE_UNSUPPORTED_EC",
                           "userdata1":  "Target Huid",
                           "userdata2":  "unused",
                      },
            0x240101: {    "devdesc": "LpcDD> LPC invalid address",
                           "moduleid": "LPC::MOD_LPCDD_CHECKADDR",
                           "reasoncode": "LPC::RC_INVALID_ADDR",
                           "userdata1[0:31]":  "LPC Address",
                           "userdata1[32:63]":  "LPC Transaction Type",
                      },
            0x270101: {    "devdesc": "Invalid operation type.",
                           "moduleid": "TPMDD_PERFORM_OP",
                           "reasoncode": "TPM_INVALID_OPERATION",
                           "userdata1":  "TPM",
                           "userdata2":  "Operation Type",
                      },
            0x270801: {    "devdesc": "TPM buffer length > 4 for read vendor op",
                           "moduleid": "TPMDD_PERFORM_OP",
                           "reasoncode": "TPM_OVERFLOW_ERROR",
                           "userdata1":  "TPM",
                           "userdata2[0-31]":  "Operation",
                           "userdata2[32-63]":  "Buffer Length (in Bytes)",
                      },
            0x270B01: {    "devdesc": "Invalid operation type.",
                           "moduleid": "TPMDD_PERFORM_OP",
                           "reasoncode": "TPM_DISABLED_VIA_MRW",
                           "userdata1":  "TPM",
                           "userdata2":  "Operation Type",
                      },
            0x280101: {    "devdesc": "Timeout waiting for PSU command to complete",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_PSU_RESPONSE_TIMEOUT",
                           "userdata1[00:15]":  "Primary Status in mbox4",
                           "userdata1[16:31]":  "Secondary Status",
                           "userdata1[32:63]":  "Processor Target",
                           "userdata2":  "Failing Request",
                      },
            0x280201: {    "devdesc": "Unexpected sequence number or non zero primary or secondary status",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_PSU_RESPONSE_ERROR",
                           "userdata1[0:31]":  "Indirect size or 9 for direct command",
                           "userdata1[32:47]":  "Request Sequence ID",
                           "userdata1[48:55]":  "Request Command Class",
                           "userdata1[56:63]":  "Request Command",
                           "userdata2[0:15]":  "Response Primary Status",
                           "userdata2[16:31]":  "Response Secondary Status",
                           "userdata2[32:47]":  "Response Sequence ID",
                           "userdata2[48:55]":  "Response Command Class",
                           "userdata2[56:63]":  "Response Command",
                      },
            0x280301: {    "devdesc": "SBE PSU device driver not ready to receive next command.",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_PSU_NOT_READY",
                           "userdata1[0:15]":  "Reserved",
                           "userdata1[16:31]":  "Request Control Flags",
                           "userdata1[32:47]":  "Request Sequence ID",
                           "userdata1[48:55]":  "Request Command Class",
                           "userdata1[56:63]":  "Request Command",
                           "userdata2":  "Host to SBE door bell register",
                      },
            0x280701: {    "devdesc": "Invalid operation. Only PSU Scom Reads are supported",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_PSU_INVALID_OPERATION",
                           "userdata1":  "Request Address",
                           "userdata2":  "Request operation",
                      },
            0x280901: {    "devdesc": "Unexpected counts during getMemConfigInfo",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_PSU_COUNT_UNEXPECTED",
                           "userdata1[00:31]":  "The PROC Target HUID",
                           "userdata1[32:63]":  "l_TargetList.size MAX",
                           "userdata2[00:31]":  "i_type TYPE_PMIC TYPE_GENERIC_I2C_DEVICE TYPE_OCMB_CHIP",
                           "userdata2[32:63]":  "l_max  How many of the TYPE we expected as MAX",
                      },
            0x280A01: {    "devdesc": "Timeout waiting for PSU command to complete, SBE not responding",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_PSU_RESPONSE_SBE_NOT_RESPONDING",
                           "userdata1[00:15]":  "Primary Status in mbox4",
                           "userdata1[16:31]":  "Sequence Id in mbox4",
                           "userdata1[32:63]":  "Processor Target",
                           "userdata2":  "Failing Request",
                      },
            0x285F01: {    "devdesc": "Call to PSU Chip Op returned an unexpected message type.",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_RECEIVED_UNEXPECTED_MSG",
                           "userdata1":  "Target HUID",
                           "userdata2[0:15]":  "Requested command class",
                           "userdata2[16:31]":  "Requested command",
                           "userdata2[32:47]":  "Returned command class",
                           "userdata2[48:63]":  "Returned command",
                      },
            0x286101: {    "devdesc": "Could not register mailbox message queue",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_RC_KERNEL_REG_FAILED",
                           "userdata1":  "rc from msq_q_register",
                      },
            0x286501: {    "devdesc": "Current SBE version does not support the attempted PSU command",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_COMMAND_NOT_SUPPORTED",
                           "userdata1":  "PSU command class",
                           "userdata2":  "PSU command",
                      },
            0x286901: {    "devdesc": "Blocking attempt to send a PSU chipop due to a previous fatal error.",
                           "moduleid": "SBEIO_PSU",
                           "reasoncode": "SBEIO_EARLY_ERROR",
                           "userdata1[00:31]":  "PSU command class",
                           "userdata1[32:63]":  "PSU command",
                      },
            0x334A01: {    "devdesc": "Failed to translate a FAPI return code back into a platform error log due to a logic bug in the firmware.  Creating substitute error log to prevent a crash and allow FFDC to be gathered",
                           "moduleid": "MOD_FAPI2_RC_TO_ERRL",
                           "reasoncode": "RC_INVALID_ERROR_LOG",
                           "userdata1":  "FAPI return code value",
                           "userdata2":  "Creator of the FAPI return code",
                      },
            0x340301: {    "devdesc": "Exception occurred during execution of HBBL",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                           "reasoncode": "Bootloader::RC_STD_EXCEPTION",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Exception vector address",
                           "userdata2":  "NIP / SRR0",
                      },
            0x340401: {    "devdesc": "Exception occurred during execution of HBBL",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                           "reasoncode": "Bootloader::RC_STD_EX_W_DSISR",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Exception vector address",
                           "userdata2":  "NIP / SRR0",
                      },
            0x340501: {    "devdesc": "Exception occurred during execution of HBBL",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                           "reasoncode": "Bootloader::RC_STD_EX_W_SRR1",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Exception vector address",
                           "userdata2":  "NIP / SRR0",
                      },
            0x340601: {    "devdesc": "Exception occurred during execution of HBBL",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_TERMINATE",
                           "reasoncode": "Bootloader::RC_HYPE_EXCEPTION",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Exception vector address",
                           "userdata2":  "NIP / HSRR0",
                      },
            0x350101: {    "devdesc": "Invalid operation type.",
                           "moduleid": "NVDIMM_PERFORM_OP",
                           "reasoncode": "NVDIMM_INVALID_OPERATION",
                           "userdata1":  "Operation Type",
                           "userdata2":  "Chip to Access",
                      },
            0x350801: {    "devdesc": "I2C Buffer Length + Offset > Max Size",
                           "moduleid": "NVDIMM_PERFORM_OP",
                           "reasoncode": "NVDIMM_OVERFLOW_ERROR",
                           "userdata1[0:31]":  "Offset",
                           "userdata1[32:63]":  "Buffer Length",
                           "userdata2":  "Device Max Size (in KB)",
                      },
            0x360101: {    "devdesc": "validateInputs> Invalid data length (!= 8 bytes)",
                           "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                           "reasoncode": "EXPSCOM::RC_INVALID_LENGTH",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Data Length",
                      },
            0x360201: {    "devdesc": "validateInputs> Invalid target type (!= OCMB_CHIP)",
                           "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                           "reasoncode": "EXPSCOM::RC_INVALID_MODEL_TYPE",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Model Type",
                      },
            0x360301: {    "devdesc": "validateInputs> Invalid OP type (!= READ or WRITE)",
                           "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                           "reasoncode": "EXPSCOM::RC_INVALID_OPTYPE",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Access Type",
                      },
            0x360401: {    "devdesc": "validateInputs> Invalid scom address, first 4 bytes should be 0's",
                           "moduleid": "EXPSCOM::MOD_OCMB_UTILS",
                           "reasoncode": "EXPSCOM::RC_INVALID_ADDRESS",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Target HUID",
                      },
            0x370B01: {    "devdesc": "Mismatch between calculated map value and what is in attribute xml",
                           "moduleid": "MMIO::MOD_MMIO_SETUP",
                           "reasoncode": "MMIO::RC_BAR_OFFSET_MISMATCH",
                           "userdata1":  "Calculated Bar Offset",
                           "userdata2":  "Bar offset from attribute",
                      },
            0x390101: {    "devdesc": "nvram_check failed during an attempt to read the NVRAM PNOR partition.",
                           "moduleid": "NVRAM::MOD_NVRAM_READ",
                           "reasoncode": "NVRAM::RC_NVRAM_CHECK_FAILED",
                           "userdata1":  "rc from nvram_check",
                           "userdata2":  "NVRAM virtual address",
                      },
            0x390201: {    "devdesc": "A nullptr was passed for i_key to nvramRead",
                           "moduleid": "NVRAM::MOD_NVRAM_READ",
                           "reasoncode": "NVRAM::RC_NVRAM_READ_NULL_KEY",
                      },
            0x410101: {    "devdesc": "A device read from the UCD didn't read the expected number of bytes.",
                           "moduleid": "UCD_RC::MOD_UCD_INIT",
                           "reasoncode": "UCD_RC::RC_DEVICE_READ_UNEXPECTED_SIZE_DEVICE_ID",
                           "userdata1[00:31]":  "Expected read size",
                           "userdata1[32:63]":  "Actual read size",
                           "userdata2":  "HUID of the UCD",
                      },
            0x410201: {    "devdesc": "A device read from the UCD didn't read the expected number of bytes.",
                           "moduleid": "UCD_RC::MOD_UCD_INIT",
                           "reasoncode": "UCD_RC::RC_DEVICE_READ_UNEXPECTED_SIZE_MFR_REVISION",
                           "userdata1[00:31]":  "Expected read size",
                           "userdata1[32:63]":  "Actual read size",
                           "userdata2":  "HUID of the UCD",
                      },
            0x420101: {    "devdesc": "Invalid size or address for OCMB Flash Image",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::INVALID_PARMS",
                           "userdata1":  "i_imageStart",
                           "userdata2":  "i_imageSize",
                      },
            0x420201: {    "devdesc": "Invalid eye catcher value for OCMB Flash Image",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::INVALID_EYE_CATCHER",
                           "userdata1":  "Expected Value",
                           "userdata2":  "Actual Value",
                      },
            0x420301: {    "devdesc": "Invalid header version for OCMB Flash Image",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::INVALID_HEADER_VERSION",
                           "userdata1":  "majorVersion",
                           "userdata2":  "minorVersion",
                      },
            0x420401: {    "devdesc": "Invalid header size for OCMB Flash Image",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::INVALID_HEADER_SIZE",
                           "userdata1":  "header size",
                           "userdata2":  "maximum allowed size",
                      },
            0x420501: {    "devdesc": "Missing SHA512 hash in OCMB Flash Image",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::MISSING_SHA512_HASH",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x420d01: {    "devdesc": "Unsupported OCMBFW extended header version.",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::OCMB_INVALID_EXT_HEADER_VERSION",
                           "userdata1":  "Unsupported OCMBFW extended header version",
                           "userdata2":  "Unused.",
                      },
            0x420e01: {    "devdesc": "Explorer firmware image not found in OCMB PNOR partition.",
                           "moduleid": "OCMBUPD::MOD_OCMB_FW_VALIDATE_IMAGE",
                           "reasoncode": "OCMBUPD::FW_IMAGE_MISSING",
                           "userdata1[0:15]":  "Number of images in OCMBFW PNOR partition",
                           "userdata1[16:23]":  "OCMB type searched for",
                           "userdata1[24:31]":  "Image type searched for",
                           "userdata1[32:39]":  "Major DD level searched for",
                           "userdata1[40:47]":  "Minor DD level searched for",
                           "userdata2":  "Unused",
                      },
            0x450101: {    "devdesc": "The length of the buffer to write/read changed from the expected length.",
                           "moduleid": "SPI::SPI_OP_READ",
                           "reasoncode": "SPI::SPI_BUFFER_SIZE_MISMATCH",
                           "userdata1":  "Target HUID of the SPI Master",
                           "userdata2[00:31]":  "Length of the request",
                           "userdata2[32:63]":  "Expected length",
                      },
            0x470301: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_METADATA",
                           "reasoncode": "RC_UNSUPPORTED_MAJOR_VERSION",
                           "userdata1":  "Actual Major Version",
                           "userdata2":  "Expected Major Version",
                      },
            0x470401: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_METADATA",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x473401: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_METADATA",
                           "reasoncode": "RC_UNSUPPORTED_MINOR_VERSION",
                           "userdata1":  "Actual Minor Version",
                           "userdata2":  "Expected Minor Version",
                      },
            0x480101: {    "devdesc": "MDS_ACCESS::validateMdsI2cScomInputs> Invalid buffer data length (!= 8 bytes)",
                           "moduleid": "MDS_ACCESS::MOD_MDS_UTILS",
                           "reasoncode": "MDS_ACCESS::RC_INVALID_BUFFER_LENGTH",
                           "userdata1[0:31]":  "Target's HUID",
                           "userdata1[32:63]":  "Buffer data length",
                           "userdata2":  "SCOM Address",
                      },
            0x480201: {    "devdesc": "MDS_ACCESS::validateMdsI2cScomInputs> Invalid data buffer (== nullptr)",
                           "moduleid": "MDS_ACCESS::MOD_MDS_UTILS",
                           "reasoncode": "MDS_ACCESS::RC_INVALID_DATA_BUFFER",
                           "userdata1[0:31]":  "Target's HUID",
                           "userdata1[32:63]":  "Buffer data length",
                           "userdata2":  "SCOM Address",
                      },
            0x480301: {    "devdesc": "MDS_ACCESS::validateMdsI2cScomInputs> Invalid target type (!= MDS_CTLR)",
                           "moduleid": "MDS_ACCESS::MOD_MDS_UTILS",
                           "reasoncode": "MDS_ACCESS::RC_INVALID_TARGET_TYPE",
                           "userdata1[0:31]":  "Target's HUID",
                           "userdata1[32:63]":  "Buffer data length",
                           "userdata2":  "SCOM Address",
                      },
            0x480401: {    "devdesc": "MDS_ACCESS::validateMdsI2cScomInputs> Invalid Operation type (!= READ or WRITE)",
                           "moduleid": "MDS_ACCESS::MOD_MDS_UTILS",
                           "reasoncode": "MDS_ACCESS::RC_INVALID_OPTYPE",
                           "userdata1[0:31]":  "Target's HUID",
                           "userdata1[32:47]":  "Buffer data length",
                           "userdata1[47:63]":  "Operation Type",
                           "userdata2":  "SCOM Address",
                      },
            0x480501: {    "devdesc": "MDS_ACCESS::validateMdsI2cScomInputs> Invalid scom address, first 4 bytes should be 0's",
                           "moduleid": "MDS_ACCESS::MOD_MDS_UTILS",
                           "reasoncode": "MDS_ACCESS::RC_INVALID_SCOM_ADDRESS",
                           "userdata1[0:31]":  "Target's HUID",
                           "userdata1[32:63]":  "Buffer data length",
                           "userdata2":  "SCOM Address",
                      },
            0x490301: {    "devdesc": "i2crCfamPerformOp> Unsupported OCMB Type specified",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_INVALID_OCMBTYPE",
                           "userdata1[0:31]":  "Operation Type (i_opType) : 0=READ, 1=WRITE",
                           "userdata1[32:64]":  "Input Scom address",
                           "userdata2":  "Target HUID",
                      },
            0x490401: {    "devdesc": "i2crPerformOp> Address contains more than 31 bits.",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_INVALID_ADDRESS",
                           "userdata1":  "SCOM Address",
                           "userdata2":  "Target HUID",
                      },
            0x490501: {    "devdesc": "i2crPerformOp> Unsupported Operation Type specified",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_INVALID_OPTYPE",
                           "userdata1[0:31]":  "Operation Type (i_opType) : 0=READ, 1=WRITE",
                           "userdata1[32:64]":  "Input Scom address",
                           "userdata2":  "Target HUID",
                      },
            0x490601: {    "devdesc": "i2crPerformOp> Unsupported Access Type specified",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_INVALID_ACCESSTYPE",
                           "userdata1[0:31]":  "Access type: I2CR_SCOM or I2CR_CFAM",
                           "userdata1[32:64]":  "Input Scom address",
                           "userdata2":  "Target HUID",
                      },
            0x490701: {    "devdesc": "Invalid I2C master path",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_INVALID_MASTER_TARGET",
                           "userdata1":  "HUID of target with FAPI_I2C_CONTROL_INFO",
                      },
            0x490801: {    "devdesc": "FAPI_I2C_CONTROL_INFO attribute was not found",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_ATTR_NOT_FOUND",
                           "userdata1":  "HUID of target",
                      },
            0x490901: {    "devdesc": "i2crCheckErrors> Status indicates errors",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_STATUS_CONCURRENT",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Error Register Value",
                           "userdata2":  "First Error Log Register Value",
                      },
            0x490A01: {    "devdesc": "i2crCheckErrors> Status indicates security issue",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_ERROR_SECURITY",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Error Register Value",
                           "userdata2":  "First Error Log Register Value",
                      },
            0x490B01: {    "devdesc": "i2crCheckErrors> Error Register shows piberr",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_ERROR_PIBERR",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Error Register Value",
                           "userdata2":  "First Error Log Register Value",
                      },
            0x490C01: {    "devdesc": "i2crCheckErrors> Error Register indicates a problem but no specific explanation was found",
                           "moduleid": "I2CR::MOD_I2CR_PERFORM_OP",
                           "reasoncode": "I2CR::RC_ERROR_GENERAL",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Error Register Value",
                           "userdata2":  "First Error Log Register Value",
                      },
            0x900101: {    "devdesc": "Input Target Pointer is nullptr",
                           "moduleid": "HDAT::MOD_UTIL_IS_FUNCTIONAL",
                           "reasoncode": "HDAT::RC_INVALID_OBJECT",
                      },
            0x10302: {    "devdesc": "Errl test. Error with non-decoded string and lots of trace buffers.",
                           "moduleid": "ERRORLOG::ERRL_TEST_MOD_ID",
                           "reasoncode": "ERRORLOG::ERRL_TEST_REASON_CODE",
                      },
            0x40402: {    "devdesc": "Read back value doesn't match write",
                           "moduleid": "XSCOM::XSCOM_TEST_XSCOM1",
                           "reasoncode": "XSCOM::XSCOM_DATA_UNMATCHED",
                           "userdata1":  "Write value",
                           "userdata2":  "Read back value",
                      },
            0x70302: {    "devdesc": "Timed out waiting for data in FIFO to read",
                           "moduleid": "I2C_READ",
                           "reasoncode": "I2C_FIFO_TIMEOUT",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Master Target",
                           "userdata2[0:7]":  "Master Engine",
                           "userdata2[8:15]":  "Master Port",
                           "userdata2[16:31]":  "Slave Device Address",
                           "userdata2[32:47]":  "Bus Speed",
                           "userdata2[48:63]":  "Bit Rate Devisor",
                      },
            0x80502: {    "devdesc": "Module does not exist",
                           "moduleid": "VFS_RT_MODULE_ID",
                           "reasoncode": "VFS_MODULE_DOES_NOT_EXIST",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x80602: {    "devdesc": "Module is not a data module",
                           "moduleid": "VFS_RT_MODULE_ID",
                           "reasoncode": "VFS_INVALID_DATA_MODULE",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x90802: {    "devdesc": "When coverting from FAPI2::target to Targeting::target the resulting                                     Targeting::target's was incorrect",
                           "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                           "reasoncode": "RC_MISMATCHED_FAPI_TARG_TARGET",
                           "userdata1[0:31]":  "Actual Type",
                           "userdata1[32:63]":  "Expected Type",
                           "userdata2[0:31]":  "Initial FAPI2 Type",
                           "userdata2[32:47]":  "Is Chip",
                           "userdata2[48:63]":  "Is Chiplet",
                      },
            0x90902: {    "devdesc": "HB target found with unknown model attribute",
                           "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                           "reasoncode": "RC_UNKNOWN_MODEL",
                           "userdata1[0:31]":  "FAPI2 Type",
                           "userdata1[32:63]":  "HB Target HUID",
                           "userdata2[0:31]":  "HB Type",
                           "userdata2[32:63]":  "HB Model",
                      },
            0x90A02: {    "devdesc": "Unable to resolve FapiTarget from input",
                           "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                           "reasoncode": "RC_NULL_FAPI_TARGET",
                           "userdata1[0:31]":  "Fapi2 Expected Type",
                           "userdata1[32:63]":  "<unused>",
                           "userdata2[0:7]":  "Is Chip",
                           "userdata2[8:15]":  "Is Chiplet",
                           "userdata2[16:63]":  "<unused>",
                      },
            0xB0702: {    "devdesc": "The attribute synchronization code on the FSP side was unable to complete the sync operation successfully.",
                           "moduleid": "TARG_MOD_ATTR_SYNC",
                           "reasoncode": "TARG_RC_ATTR_SYNC_TO_FSP_FAIL",
                           "userdata1":  "return code from FSP attribute sync",
                           "userdata2[0:31]":  "page count for this section",
                           "userdata2[31:63]":  "section ID of for section being sync'd",
                      },
            0xB0802: {    "devdesc": "The attribute synchronization code on the FSP side was unable to fulfill the sync to HostBoot request.",
                           "moduleid": "TARG_MOD_ATTR_SYNC",
                           "reasoncode": "TARG_RC_ATTR_SYNC_REQUEST_TO_HB_FAIL",
                           "userdata1":  "return code from FSP",
                           "userdata2":  "section to sync",
                      },
            0xB0902: {    "devdesc": "The attribute synchronization from the FSP failed.",
                           "moduleid": "TARG_MOD_ATTR_SYNC",
                           "reasoncode": "TARG_RC_ATTR_SYNC_TO_HB_FAIL",
                           "userdata1":  "return code",
                           "userdata2":  "section to sync",
                      },
            0xC0302: {    "devdesc": "Invalid target encountered in processing of HW callout",
                           "moduleid": "HWAS::MOD_PROCESS_CALLOUT",
                           "reasoncode": "HWAS::RC_INVALID_TARGET",
                           "userdata1":  "callout errlog PLID",
                      },
            0xD0602: {    "devdesc": "Hypervisor firmware request interface not linked",
                           "moduleid": "MOD_FSISCOM_RT_SEND_SCOM_TO_FSP",
                           "reasoncode": "RC_RT_INTERFACE_ERR",
                           "userdata1":  "target's HUID",
                           "userdata2":  "SCOM address",
                      },
            0xD0702: {    "devdesc": "Unable to allocate firmware request messages",
                           "moduleid": "MOD_FSISCOM_RT_SEND_SCOM_TO_FSP",
                           "reasoncode": "RC_RT_NULL_FW_MSG_PTR",
                           "userdata1":  "target's HUID",
                           "userdata2":  "SCOM address",
                      },
            0xF0302: {    "devdesc": "Interrupt resource provider not initialized yet.",
                           "moduleid": "INTR::MOD_INTR_DISABLE",
                           "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                           "userdata1":  "MSG_INTR_DISABLE",
                           "userdata2":  "0",
                      },
            0x100202: {    "devdesc": "MDMT could not find a functional node",
                           "moduleid": "TOD_BUILD_TOD_DRAWERS",
                           "reasoncode": "TOD_NO_FUNC_NODE_AVAILABLE",
                           "userdata1":  "system target's HUID",
                      },
            0x100302: {    "devdesc": "No TOD drawer could be configured for this topology type",
                           "moduleid": "TOD_BUILD_TOD_DRAWERS",
                           "reasoncode": "TOD_NO_DRAWERS",
                           "userdata1":  "TOD configuration",
                      },
            0x110102: {    "devdesc": "MboxDD::write> Invalid data length (> msg_t size)",
                           "moduleid": "MBOX::MOD_MBOXDD_WRITE",
                           "reasoncode": "MBOX::RC_INVALID_LENGTH",
                           "userdata1":  "Target ID String...",
                           "userdata2":  "Data Length",
                      },
            0x110402: {    "devdesc": "MboxDD::write> Message still pending",
                           "moduleid": "MBOX::MOD_MBOXDD_WRITE",
                           "reasoncode": "MBOX::RC_MSG_PENDING",
                           "userdata1":  "Target ID String...",
                           "userdata2":  "Status/Control Register",
                      },
            0x120202: {    "devdesc": "Invalid address and size returned from HDAT",
                           "moduleid": "DUMP::DUMP_SEND_MBOX_MSG",
                           "reasoncode": "DUMP::DUMP_NO_HDAT_ADDR",
                           "userdata1":  "Address returned",
                           "userdata2":  "Table type Requested",
                      },
            0x140302: {    "devdesc": "MDIA monitor task crashed",
                           "moduleid": "MONITOR_MAIN_THREAD",
                           "reasoncode": "MONITOR_THREAD_CRASHED",
                           "userdata1":  "tidRc",
                           "userdata2":  "Task Id that crashed",
                      },
            0x160202: {    "devdesc": "Bad memory pointer received.",
                           "moduleid": "Util::UTIL_MOD_MEM_WRITE",
                           "reasoncode": "Util::UTIL_ERC_BAD_PTR",
                           "userdata1[0:31]":  "Task ID.",
                           "userdata1[31:64]":  "End of File (boolean)",
                           "userdata2":  "Address of memory buffer.",
                      },
            0x160302: {    "devdesc": "End of file reached.",
                           "moduleid": "Util::UTIL_MOD_MEM_WRITE",
                           "reasoncode": "Util::UTIL_ERC_EOF",
                           "userdata1[0:31]":  "Task ID.",
                           "userdata1[31:64]":  "End of File (boolean)",
                           "userdata2":  "Address of memory buffer.",
                      },
            0x170402: {    "devdesc": "System target was NULL!",
                           "moduleid": "MOD_START_PAYLOAD_CALL_SHUTDOWN",
                           "reasoncode": "RC_TARGET_NULL",
                           "userdata1":  "<UNUSED>",
                           "userdata2":  "<UNUSED>",
                      },
            0x173702: {    "devdesc": "Write of HID SPR failed",
                           "moduleid": "MOD_START_PAYLOAD_CALL_SHUTDOWN",
                           "reasoncode": "RC_FAILED_WRITE_SPR",
                           "userdata1":  "current value of HID",
                           "userdata2":  "write value attempted to HID",
                      },
            0x180202: {    "devdesc": "A hardware procedure failed with the assumption that there were active attentions. However, no attentions were found. Check the other log with matching PLID.",
                           "moduleid": "ATTN_CHK_IPL_ATTNS_MODULE",
                           "reasoncode": "ATTN_SEE_HW_ERROR",
                           "userdata1":  "HUID of target containing ATTR_PRD_HWP_PLID",
                           "userdata2":  "Value of ATTR_PRD_HWP_PLID",
                      },
            0x1E0502: {    "devdesc": "mm_set_permission(EXECUTABLE) failed for Secure ROM",
                           "moduleid": "SECUREBOOT::MOD_SECURE_ROM_INIT",
                           "reasoncode": "SECUREBOOT::RC_SET_PERMISSION_FAIL_EXE",
                           "userdata1":  "l_rc",
                           "userdata2":  "iv_securerom",
                      },
            0x1E0B02: {    "devdesc": "Valid securerom not present",
                           "moduleid": "SECUREBOOT::MOD_SECURE_ROM_INIT",
                           "reasoncode": "SECUREBOOT::RC_SECROM_INVALID",
                      },
            0x210202: {    "devdesc": "Invalid attribute size of 0",
                           "moduleid": "DEVTREE_SYNC_ATTRS",
                           "reasoncode": "TARGET_ATTR_ZERO_SIZE",
                           "userdata1":  "HUID",
                           "userdata2":  "Attribute ID",
                      },
            0x210302: {    "devdesc": "Error reading targeting attribute",
                           "moduleid": "DEVTREE_SYNC_ATTRS",
                           "reasoncode": "GET_TARGET_ATTR_FAILED",
                           "userdata1":  "HUID",
                           "userdata2":  "Attribute ID",
                      },
            0x220402: {    "devdesc": "updateProcessorSbeSeeproms> mm_remove_pages RELEASE failed",
                           "moduleid": "SBE_UPDATE_SEEPROMS",
                           "reasoncode": "SBE_REMOVE_PAGES_FOR_EC",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_remove_pages",
                      },
            0x221B02: {    "devdesc": "SBE update is being skipped during MPIPL",
                           "moduleid": "SBE_UPDATE_SEEPROMS",
                           "reasoncode": "SBE_UPDATE_DURING_MPIPL",
                           "userdata1":  "Target huid id",
                           "userdata2[0:31]":  "Update actions",
                           "userdata2[32:63]":  "SEEPROM side to update",
                      },
            0x222302: {    "devdesc": "SBE image Hostboot read back after SBE update has integrity issues",
                           "moduleid": "SBE_UPDATE_SEEPROMS",
                           "reasoncode": "SBE_IMG_MISCOMPARE",
                           "userdata1":  "ECC compare status",
                           "userdata2":  "Image compare status",
                      },
            0x222402: {    "devdesc": "Data Miscompare Fail Reading Back SBE Version Information",
                           "moduleid": "SBE_UPDATE_SEEPROMS",
                           "reasoncode": "SBE_DATA_MISCOMPARE",
                           "userdata1[0:31]":  "Proc Target HUID",
                           "userdata1[32:63]":  "SEEPROM Side",
                           "userdata2[0:31]":  "Size - No Ecc",
                           "userdata2[32:63]":  "Size - ECC",
                      },
            0x222702: {    "devdesc": "Another thread is already performing an SBE update",
                           "moduleid": "SBE_UPDATE_SEEPROMS",
                           "reasoncode": "SBE_UPDATE_ALREADY_IN_PROGRESS",
                           "userdata1":  "UNUSED",
                           "userdata2":  "UNUSED",
                      },
            0x240302: {    "devdesc": "LpcDD::_readLPC> Invalid buffer size requested (>4 bytes)",
                           "moduleid": "LPC::MOD_LPCDD_READLPC",
                           "reasoncode": "LPC::RC_BAD_ARG",
                           "userdata1[0:31]":  "LPC Address",
                           "userdata1[32:63]":  "LPC Transaction Type",
                           "userdata2":  "Requested buffer size",
                      },
            0x260502: {    "devdesc": "OCC not ready for target state",
                           "moduleid": "HTMGT_MOD_WAIT_FOR_OCC_READY",
                           "reasoncode": "HTMGT_RC_OCC_NOT_READY",
                           "userdata1[0:15]":  "OCC instance",
                           "userdata1[16:31]":  "poll attempts",
                           "userdata2[0:15]":  "target ready bit",
                      },
            0x281002: {    "devdesc": "Timeout waiting for upstream FIFO to have room to write",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_UPSTREAM_TIMEOUT",
                           "userdata1":  "Timeout in NS",
                           "userdata2[00:31]":  "Failing Target",
                           "userdata2[32:63]":  "FIFO Status",
                      },
            0x281102: {    "devdesc": "EOT not received before downstream buffer full.",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_NO_DOWNSTREAM_EOT",
                           "userdata1[00:31]":  "HUID of SBE that failed",
                           "userdata1[32:63]":  "FIFO command class and command",
                           "userdata2":  "Response buffer size",
                      },
            0x281202: {    "devdesc": "Invalid data, may be short read, etc.",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_INVALID_STATUS_DISTANCE",
                           "userdata1[00:31]":  "HUID of SBE that failed",
                           "userdata1[32:63]":  "FIFO command class and command",
                           "userdata2[00:15]":  "o_fifoBuffer.getState() indicates unexpected condition",
                           "userdata2[16:31]":  "Bytes received",
                      },
            0x281302: {    "devdesc": "Status header does not start with magic number or non-zero primary or secondary status",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_RESPONSE_ERROR",
                           "userdata1[00:31]":  "HUID of SBE that failed",
                           "userdata1[32:63]":  "FIFO command class and command",
                           "userdata2[00:15]":  "<unused>",
                           "userdata2[16:31]":  "Should be magic value 0xC0DE",
                           "userdata2[32:47]":  "Primary Status",
                           "userdata2[48:63]":  "Secondary Status",
                      },
            0x281402: {    "devdesc": "Timeout waiting for downstream FIFO to have data to receive",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_DOWNSTREAM_TIMEOUT",
                           "userdata1":  "Timeout in NS",
                           "userdata2[00:31]":  "Failing Target",
                           "userdata2[32:63]":  "FIFO Status",
                      },
            0x281502: {    "devdesc": "Request length must be 8 bytes",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_INVALID_LENGTH",
                           "userdata1":  "Request Address",
                           "userdata2":  "Invalid request length",
                      },
            0x281602: {    "devdesc": "Invalid operation. Read and Write supported.",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_INVALID_OPERATION",
                           "userdata1":  "Request Address",
                           "userdata2":  "Request operation",
                      },
            0x281702: {    "devdesc": "Null target passed",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_NULL_TARGET",
                           "userdata1":  "Request Address or unused",
                           "userdata2[0:7]":  "SBE FIFO Command Class",
                           "userdata2[8:15]":  "SBE FIFO Command",
                      },
            0x281802: {    "devdesc": "Primary Proc is not supported",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_MASTER_TARGET",
                           "userdata1":  "Request Address or unused",
                           "userdata2[0:31]":  "HUID of boot proc",
                           "userdata2[32:39]":  "SBE FIFO Command Class",
                           "userdata2[40:47]":  "SBE FIFO Command",
                      },
            0x281902: {    "devdesc": "Primary Sentinel target is not supported",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_SENTINEL_TARGET",
                           "userdata1":  "Request Address or unused",
                           "userdata2[0:7]":  "SBE FIFO Command Class",
                           "userdata2[8:15]":  "SBE FIFO Command",
                      },
            0x281D02: {    "devdesc": "non-Odyssey OCMB is not supported",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_NOT_ODYSSEY_OCMB",
                           "userdata1[0:31]":  "HUID of OCMB chip",
                           "userdata1[32:63]":  "ATTR_CHIP_ID of OCMB chip",
                           "userdata2[0:7]":  "SBE FIFO Command Class",
                           "userdata2[8:15]":  "SBE FIFO Command",
                      },
            0x281E02: {    "devdesc": "Odyssey target is expected",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_NOT_ODYSSEY_OR_NOT_OCMB",
                           "userdata1[0:31]":  "HUID of OCMB chip",
                           "userdata1[32:63]":  "ATTR_CHIP_ID of OCMB chip",
                           "userdata2[0:7]":  "SBE FIFO Command Class",
                           "userdata2[8:15]":  "SBE FIFO Command",
                      },
            0x281F02: {    "devdesc": "An SBE returned FFDC as part of a FIFO message response.",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_FIFO_PLATFORM_ERROR",
                           "userdata1[00:31]":  "HUID of SBE which FFDC originates from",
                           "userdata1[32:63]":  "FIFO command class and command",
                           "userdata2[00:15]":  "<unused>",
                           "userdata2[16:31]":  "Should be magic value 0xC0DE",
                           "userdata2[32:47]":  "Primary Status",
                           "userdata2[48:63]":  "Secondary Status",
                      },
            0x285F02: {    "devdesc": "Call to FIFO Chip Op returned an unexpected message type.",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_RECEIVED_UNEXPECTED_MSG",
                           "userdata1":  "Target HUID",
                           "userdata2[0:15]":  "Requested command class",
                           "userdata2[16:31]":  "Requested command",
                           "userdata2[32:47]":  "Returned command class",
                           "userdata2[48:63]":  "Returned command",
                      },
            0x287002: {    "devdesc": "Call to FIFO Chip Op returned an unexpected message type.",
                           "moduleid": "SBEIO_FIFO",
                           "reasoncode": "SBEIO_RECEIVE_CODE_LEVELS_BAD_MSG",
                           "userdata1":  "Target HUID",
                           "userdata2[0:15]":  "Requested command class",
                           "userdata2[16:31]":  "Requested command",
                           "userdata2[32:47]":  "Returned command class",
                           "userdata2[48:63]":  "Returned command",
                      },
            0x2BA002: {    "devdesc": "TPM_Startup operation failure.",
                           "moduleid": "MOD_TPM_CMD_STARTUP",
                           "reasoncode": "RC_TPM_START_FAIL",
                           "userdata1":  "responseCode",
                           "userdata2":  "TPM HUID",
                      },
            0x2BBF02: {    "devdesc": "SBE failed to setup the TPM",
                           "moduleid": "MOD_TPM_CMD_STARTUP",
                           "reasoncode": "RC_TPM_START_SBE_SETUP_FAILED",
                           "userdata1":  "responseCode",
                           "userdata2":  "TPM HUID",
                      },
            0x334202: {    "devdesc": "HB OCMB_CHIP target found with unknown model based on ATTR_CHIP_ID",
                           "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_TARGET",
                           "reasoncode": "RC_UNKNOWN_OCMB_CHIP_TYPE",
                           "userdata1[0:31]":  "FAPI2 Type",
                           "userdata1[32:63]":  "HB Target HUID",
                           "userdata2[0:31]":  "HB Type",
                           "userdata2[32:63]":  "HB Target CHIP_ID",
                      },
            0x340702: {    "devdesc": "Uncorrectable ECC error found in HBB",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_MAIN",
                           "reasoncode": "Bootloader::RC_REMOVE_ECC_FAIL",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Word7 = 0",
                           "userdata2[32:63]":  "Word8 = 0",
                      },
            0x340F02: {    "devdesc": "Not enough memory to load boot firmware",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_MAIN",
                           "reasoncode": "Bootloader::RC_BAD_WORK_LEN",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Length of data from TOC (bytes)",
                           "userdata2[32:63]":  "Working length (bytes)",
                      },
            0x342802: {    "devdesc": "Not enough memory to load boot firmware",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_MAIN",
                           "reasoncode": "Bootloader::RC_BAD_PROTECTED_SIZE_LEN",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Protected Size Length from Secure Header",
                           "userdata2[32:63]":  "Length of data from TOC (bytes)",
                      },
            0x360502: {    "devdesc": "Debug saved explorer log for image A",
                           "moduleid": "EXPSCOM::MOD_CREATE_EXPLORER_LOGS",
                           "reasoncode": "EXPSCOM::RC_EXPLORER_SAVED_A",
                           "userdata1":  "OCMB target",
                      },
            0x360602: {    "devdesc": "Debug saved explorer log for image B",
                           "moduleid": "EXPSCOM::MOD_CREATE_EXPLORER_LOGS",
                           "reasoncode": "EXPSCOM::RC_EXPLORER_SAVED_B",
                           "userdata1":  "OCMB target",
                      },
            0x360702: {    "devdesc": "Debug active log",
                           "moduleid": "EXPSCOM::MOD_CREATE_EXPLORER_LOGS",
                           "reasoncode": "EXPSCOM::RC_EXPLORER_ACTIVE",
                           "userdata1":  "OCMB target",
                      },
            0x370802: {    "devdesc": "OCMB MMIO read failed",
                           "moduleid": "MMIO::MOD_MMIO_PERFORM_OP",
                           "reasoncode": "MMIO::RC_BAD_MMIO_READ",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370902: {    "devdesc": "OCMB MMIO write failed",
                           "moduleid": "MMIO::MOD_MMIO_PERFORM_OP",
                           "reasoncode": "MMIO::RC_BAD_MMIO_WRITE",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370C02: {    "devdesc": "OCMB MMIO read failed due to channel checkstop",
                           "moduleid": "MMIO::MOD_MMIO_PERFORM_OP",
                           "reasoncode": "MMIO::RC_MMIO_CHAN_CHECKSTOP",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x410302: {    "devdesc": "The UCD flash image's eyecatcher did not match the expected value",
                           "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                           "reasoncode": "UCD_RC::UCD_INVALID_EYECATCHER",
                           "userdata1":  "Expected eyecatcher",
                           "userdata2":  "Actual eyecatcher",
                      },
            0x410402: {    "devdesc": "The UCD flash image's major version number is not supported.",
                           "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                           "reasoncode": "UCD_RC::UCD_INVALID_MAJOR_VER",
                           "userdata1":  "Current major version supported",
                           "userdata2":  "Advertised major version",
                      },
            0x410502: {    "devdesc": "The UCD flash image's TOC entry size is smaller than expected.",
                           "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                           "reasoncode": "UCD_RC::UCD_TOC_ENTRY_TOO_SMALL",
                           "userdata1":  "Minimum required TOC entry size",
                           "userdata2":  "Advertised TOC entry size",
                      },
            0x410602: {    "devdesc": "The UCD device's device ID did not match the expected device ID from the UCD sub-flash image.  This likely implies an escape of new parts into systems that are not supported by firmware.  UCD will be marked as non-functional.",
                           "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                           "reasoncode": "UCD_RC::UCD_UNSUPPORTED_DEVICE_ID",
                           "userdata1":  "UCD's HUID",
                      },
            0x410702: {    "devdesc": "Advertised UCD sub-flash image offset+size would pass the end of the UCD flash image.",
                           "moduleid": "UCD_RC::MOD_UPDATE_ALL_UCD_FLASH_IMAGES",
                           "reasoncode": "UCD_RC::UCD_EOF",
                           "userdata1":  "UCD's HUID",
                      },
            0x420602: {    "devdesc": "Tagged data triplet size is too big or misaligned",
                           "moduleid": "OCMBUPD::MOD_PARSE_TAGGED_DATA_TRIPLET",
                           "reasoncode": "OCMBUPD::INVALID_DATA_TRIPLET_SIZE",
                           "userdata1":  "allocated size",
                           "userdata2":  "required size",
                      },
            0x420702: {    "devdesc": "Incorrect hash size in OCMB image header",
                           "moduleid": "OCMBUPD::MOD_PARSE_TAGGED_DATA_TRIPLET",
                           "reasoncode": "OCMBUPD::INVALID_HASH_TRIPLET_SIZE",
                           "userdata1":  "Expected Size",
                           "userdata2":  "Actual Size",
                      },
            0x420802: {    "devdesc": "Invalid tag id found in OCMB image header",
                           "moduleid": "OCMBUPD::MOD_PARSE_TAGGED_DATA_TRIPLET",
                           "reasoncode": "OCMBUPD::INVALID_TAG_ID",
                           "userdata1":  "tag id",
                           "userdata2":  "<unused>",
                      },
            0x450102: {    "devdesc": "The length of the buffer to write/read changed from the expected length.",
                           "moduleid": "SPI::SPI_OP_WRITE",
                           "reasoncode": "SPI::SPI_BUFFER_SIZE_MISMATCH",
                           "userdata1":  "Target HUID of the SPI Master",
                           "userdata2[00:31]":  "Length of the request",
                           "userdata2[32:63]":  "Expected length",
                      },
            0x460202: {    "devdesc": "Software problem while sending pldm message",
                           "moduleid": "MOD_HANDLE_OUTBOUND",
                           "reasoncode": "RC_SEND_PLDM_FAIL",
                           "userdata1":  "Return code returned by MCTP core logic",
                           "userdata2":  "First 8 bytes of MCTP payload",
                      },
            0x470402: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_TABLE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x470502: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_TABLE",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Actual table length",
                           "userdata2":  "Table length from metadata",
                      },
            0x470D02: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_TABLE",
                           "reasoncode": "RC_BAD_TRANSFER_FLAG",
                           "userdata1":  "Actual Transfer Flag",
                           "userdata2":  "Expected Transfer Flag",
                      },
            0x473302: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_TABLE",
                           "reasoncode": "RC_BAD_NEXT_TRANSFER_HANDLE",
                           "userdata1":  "Actual Next Transfer Handle",
                           "userdata2":  "Expected Next Transfer Handle",
                      },
            0x473602: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FRU_TABLE",
                           "reasoncode": "RC_CRC_MISMATCH",
                           "userdata1":  "Actual CRC",
                           "userdata2":  "Expected CRC",
                      },
            0x900202: {    "devdesc": "Top level target not found",
                           "moduleid": "HDAT::MOD_PCIA_LOAD",
                           "reasoncode": "HDAT::RC_TOP_LVL_TGT_NOT_FOUND",
                      },
            0x10303: {    "devdesc": "Errl test. Error with non-decoded string and lots of trace buffers.",
                           "moduleid": "ERRORLOG::ERRL_RT_TEST_MOD_ID",
                           "reasoncode": "ERRORLOG::ERRL_TEST_REASON_CODE",
                      },
            0x40503: {    "devdesc": "mmio_dev_unmap() returns error",
                           "moduleid": "XSCOM_GET_TARGET_VIRT_ADDR",
                           "reasoncode": "XSCOM_MMIO_UNMAP_ERR",
                           "userdata1":  "Return Code",
                           "userdata2":  "Unmap address",
                      },
            0x50803: {    "devdesc": "Request to send Istep Complete msg to Fsp, but no outstanding message from Fsp found.",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "NO_MSG_PRESENT",
                           "userdata1":  "Current Istep",
                           "userdata2":  "Current SubStep",
                      },
            0x50903: {    "devdesc": "IStep failed and HW deconfigured. Looped back to an earlier istep (Reconfigure loop).",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_RECONFIG_LOOP_ENTERED",
                           "userdata1[0:15]":  "Istep that failed",
                           "userdata1[16:31]":  "Substep that failed",
                           "userdata1[32:47]":  "Istep that reconfig looped back to",
                           "userdata1[48:63]":  "Substep that reconfig looped back to",
                           "userdata2":  "The number of reconfigs loops tried",
                      },
            0x50a03: {    "devdesc": "Hostboot has requested a reconfig loop due to a hardware error. Causes could be: - deconfiguration during an istep outside of the the reconfig loop - deconfiguration while running in istep mode - deconfiguration in mfg mode - exceeded the number of allowed reconfig attempts - recoverable hardware error that requires a reboot to clear out",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_FAILED_DUE_TO_DECONFIG",
                           "userdata1[00:15]":  "Istep that failed",
                           "userdata1[16:31]":  "SubStep that failed",
                           "userdata1[32:47]":  "Desired istep",
                           "userdata1[48:63]":  "Desired substep",
                           "userdata2[00:07]":  "Value of ATTR_RECONFIGURE_LOOP - 0x01 = DECONFIGURE; - 0x02 = BAD_DQ_BIT_SET; - 0x04 = RCD_PARITY_ERROR - 0x08 = OCMB_FW_UPDATE; - 0x10 = TOPOLOGY_SWAP;",
                           "userdata2[08:15]":  "Manufacturing Mode (MNFG_FLAG_SRC_TERM)",
                           "userdata2[16:23]":  "Largest number of RCD reboots (ATTR_RCD_PARITY_RECONFIG_LOOP_COUNT)",
                           "userdata2[24:31]":  "Number of RCD reboots allowed (ATTR_RCD_PARITY_RECONFIG_LOOPS_ALLOWED)",
                           "userdata2[32:39]":  "RCD parity error threshold (ATTR_MNFG_TH_RCD_PARITY_ERRORS)",
                           "userdata2[40:63]":  "Unused",
                      },
            0x50b03: {    "devdesc": "Received shutdown request from FSP",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "SHUTDOWN_REQUESTED_BY_FSP",
                           "userdata1":  "Current IStep",
                           "userdata2":  "Current SubStep",
                      },
            0x50c03: {    "devdesc": "handleProcFabIovalidMsg called during MPIPL, which is illegal.",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_INVALID_ON_MPIPL",
                           "userdata1[0:31]":  "MPIPL State",
                           "userdata1[32:63]":  "N/A",
                           "userdata2[0:31]":  "N/A",
                           "userdata2[32:63]":  "N/A.",
                      },
            0x50d03: {    "devdesc": "Istep messaged received by non-master node.",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_NON_MASTER_NODE_MSG",
                           "userdata1":  "Istep Requested",
                           "userdata2":  "Substep Requested",
                      },
            0x51003: {    "devdesc": "Received shutdown request due to deconfigure outside of reconfig loop",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "SHUTDOWN_NOT_RECONFIG_LOOP",
                           "userdata1":  "Current IStep",
                           "userdata2":  "Current SubStep",
                      },
            0x51103: {    "devdesc": "Istep skip prevented in secure mode",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_SKIP_ATTEMPTED",
                           "userdata1[00:31]":  "istep requested",
                           "userdata1[32:64]":  "substep requested",
                           "userdata2[00:31]":  "highest istep allowed",
                           "userdata2[32:64]":  "highest substep allowed",
                      },
            0x51203: {    "devdesc": "Istep processing has terminated due to normal shutdown activity, secure boot key transition, or terminating error",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_PROCESSING_DISABLED",
                           "userdata1":  "Istep Requested",
                           "userdata2":  "Substep Requested",
                      },
            0x51603: {    "devdesc": "sendAttnMonitorChipIdMsg failed at the FSP level.  Potential checkstops may not be properly handled.",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_ATTN_MONITOR_MSG_FAILED",
                           "userdata1":  "PLID of failure on FSP",
                           "userdata2":  "Number of huids in msg",
                      },
            0x51903: {    "devdesc": "Module initialization failed",
                           "moduleid": "ISTEP_INITSVC_MOD_ID",
                           "reasoncode": "ISTEP_MODULE_INIT_FAILED",
                           "userdata1[00:63]":  "istep requested",
                      },
            0x60303: {    "devdesc": "PnorRP::getSectionInfo> Invalid Address for read/write or prohibited by secureboot",
                           "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                           "reasoncode": "PNOR::RC_INVALID_SECTION",
                           "userdata1":  "Size of section",
                           "userdata2[0:7]":  "TOC used",
                           "userdata2[8:15]":  "Inhibited flag",
                           "userdata2[16:23]":  "Requested Section",
                           "userdata2[24:63]":  "<Unused/Reserved>",
                      },
            0x60503: {    "devdesc": "PnorRP::getSectionInfo> RP not properly initialized",
                           "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                           "reasoncode": "PNOR::RC_STARTUP_FAIL",
                           "userdata1":  "Requested Section",
                           "userdata2":  "Startup RC",
                      },
            0x61D03: {    "devdesc": "Protected Payload Size is 0",
                           "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                           "reasoncode": "PNOR::RC_SECTION_SIZE_IS_ZERO",
                           "userdata1":  "PNOR section",
                           "userdata2":  "Section's secure flag",
                      },
            0x64103: {    "devdesc": "No lid mapping found for requested section",
                           "moduleid": "PNOR::MOD_PNORRP_GETSECTIONINFO",
                           "reasoncode": "PNOR::RC_NO_LID_MAPPING",
                           "userdata1":  "Requested Section",
                           "userdata2":  "Unused",
                      },
            0x70303: {    "devdesc": "Timed out waiting for space to write into FIFO.",
                           "moduleid": "I2C_WRITE",
                           "reasoncode": "I2C_FIFO_TIMEOUT",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Master Target",
                           "userdata2[0:7]":  "Master Engine",
                           "userdata2[8:15]":  "Master Port",
                           "userdata2[16:31]":  "Slave Device Address",
                           "userdata2[32:47]":  "Bus Speed",
                           "userdata2[48:63]":  "Bit Rate Devisor",
                      },
            0x80703: {    "devdesc": "VFS RP Task crashed.",
                           "moduleid": "VFS_WATCHER",
                           "reasoncode": "VFS_TASK_CRASHED",
                           "userdata1":  "tidRc",
                           "userdata2":  "task Rc",
                      },
            0xB0c03: {    "devdesc": "Targeting target's type not supported by runtime code",
                           "moduleid": "TARG_RT_GET_RT_TARGET",
                           "reasoncode": "TARG_RT_TARGET_TYPE_NOT_SUPPORTED",
                           "userdata1":  "Target's HUID",
                           "userdata2":  "target's targeting type",
                      },
            0xC0403: {    "devdesc": "Insufficient hardware to continue.",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_INSUFFICIENT_HW",
                      },
            0xC0503: {    "devdesc": "checkMinimumHardware did not find enough cores for execution and backing cache on the master proc",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_NO_CORES_FUNC",
                           "userdata1[00:31]":  "bitstring of present cores",
                           "userdata1[32:63]":  "bitstring of present, functional non-ECO cores",
                           "userdata2[00:31]":  "bitstring of present, functional ECO cores",
                           "userdata2[32:63]":  "bitstring of present, FCO cores",
                      },
            0xC0603: {    "devdesc": "checkMinimumHardware found no functional dimm cards.",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_NO_MEMORY_FUNC",
                           "userdata1[00:31]":  "HUID of node",
                           "userdata2[00:31]":  "number of present, non-functional dimms",
                      },
            0xC0703: {    "devdesc": "checkMinimumHardware found no functional master processor on this node",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_NO_PROCS_FUNC",
                           "userdata1[00:31]":  "HUID of node",
                           "userdata2[00:31]":  "number of present procs",
                           "userdata2[32:63]":  "number of present functional non-master procs",
                      },
            0xC0803: {    "devdesc": "checkMinimumHardware found no functional nodes on the system",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_NO_NODES_FUNC",
                      },
            0xC0B03: {    "devdesc": "checkCriticalResources found a critical resource to be deconfigured",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_MISSING_CRITICAL_RESOURCE",
                           "userdata1[00:31]":  "Number of critical resources",
                           "userdata1[32:63]":  "HUID of first critical resource found",
                           "userdata2[00:31]":  "HUID of second critical resource found, if present",
                           "userdata2[32:63]":  "HUID of third critical resource found, if present",
                      },
            0xC0E03: {    "devdesc": "checkMinimumHardware found no functional NX chiplets",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_NO_NX_FUNC",
                           "userdata1[00:31]":  "HUID of node",
                           "userdata2[00:31]":  "number of present nonfunctional NX chiplets",
                      },
            0xC2603: {    "devdesc": "Failed to update the SBE after SBE did not report enough available backing cache but HB found enough cores to satisfy the requirment",
                           "moduleid": "MOD_CHECK_MIN_HW",
                           "reasoncode": "RC_SYSAVAIL_SBE_NOT_ENOUGH_BACKING_CACHE",
                           "userdata1[00:31]":  "HUID of master proc",
                           "userdata1[32:63]":  "minimum required backing cache in MB",
                           "userdata2[00:31]":  "available cache provided from SBE in MB",
                           "userdata2[32:63]":  "available cache found by HB in MB",
                      },
            0xD0303: {    "devdesc": "Multi-SCOM read did not return correct SCOMs",
                           "moduleid": "MOD_FSISCOM_RT_SEND_MULTI_SCOM_TO_FSP",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "target's HUID",
                           "userdata2[00:31]":  "# of SCOMs requested",
                           "userdata2[32:63]":  "# of SCOMs returned",
                      },
            0xD0603: {    "devdesc": "Hypervisor firmware request interface not linked",
                           "moduleid": "MOD_FSISCOM_RT_SEND_MULTI_SCOM_TO_FSP",
                           "reasoncode": "RC_RT_INTERFACE_ERR",
                           "userdata1":  "target's HUID",
                           "userdata2":  "# of SCOMs to read",
                      },
            0xD0703: {    "devdesc": "Unable to allocate firmware request messages",
                           "moduleid": "MOD_FSISCOM_RT_SEND_MULTI_SCOM_TO_FSP",
                           "reasoncode": "RC_RT_NULL_FW_MSG_PTR",
                           "userdata1":  "target's HUID",
                           "userdata2":  "# of SCOMs to read",
                      },
            0xE0903: {    "devdesc": "I2C write page size is zero.",
                           "moduleid": "EEPROM_WRITE",
                           "reasoncode": "EEPROM_I2C_WRITE_PAGE_SIZE_ZERO",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Chip to Access",
                      },
            0xF0203: {    "devdesc": "Interrupt resource provider not initialized yet.",
                           "moduleid": "INTR::MOD_INTR_REGISTER",
                           "reasoncode": "INTR::RC_REGISTRY_NOT_READY",
                           "userdata1":  "Interrupt type to register",
                           "userdata2":  "0",
                      },
            0x101303: {    "devdesc": "No valid MDMT found on either topology",
                           "moduleid": "TOD_QUERY_ACTIVE_CONFIG",
                           "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                      },
            0x101403: {    "devdesc": "MDMT not found on active toplology",
                           "moduleid": "TOD_QUERY_ACTIVE_CONFIG",
                           "reasoncode": "TOD_NO_MDMT_ON_ACTIVE_CONFIG",
                           "userdata1":  "Active configuration",
                      },
            0x110503: {    "devdesc": "Invalid message or message queue",
                           "moduleid": "MBOX::MOD_MBOXSRV_SEND",
                           "reasoncode": "MBOX::RC_INVALID_QUEUE",
                           "userdata1":  "returncode from msg_sendrecv()",
                      },
            0x110D03: {    "devdesc": "Host boot mailbox service is not available at this time.",
                           "moduleid": "MBOX::MOD_MBOXSRV_SEND",
                           "reasoncode": "MBOX::RC_MBOX_SERVICE_NOT_READY",
                           "userdata1":  "The destination message queue id",
                      },
            0x120D03: {    "devdesc": "Invalid address and size returned from HDAT",
                           "moduleid": "DUMP::DUMP_ARCH_REGS",
                           "reasoncode": "DUMP::DUMP_PDAT_INVALID_ADDR",
                           "userdata1":  "Table address returned",
                           "userdata2":  "Table size returned",
                      },
            0x121003: {    "devdesc": "Insufficient space to copy architected registers",
                           "moduleid": "DUMP::DUMP_ARCH_REGS",
                           "reasoncode": "DUMP::DUMP_PDAT_INSUFFICIENT_SPACE",
                           "userdata1[00:31]":  "Hypervisor reserved memory size",
                           "userdata1[32:63]":  "Memory needed to copy architected register data",
                           "userdata2":  "Minimum memory required for copy architected register data(PRE_INIT failure case)",
                      },
            0x121103: {    "devdesc": "Mismatch between the version of structure supported by both SBE and HB.",
                           "moduleid": "DUMP::DUMP_ARCH_REGS",
                           "reasoncode": "DUMP::DUMP_PDAT_VERSION_MISMATCH",
                           "userdata1":  "Structure version obtained from SBE",
                           "userdata2":  "Structure version supported by HB",
                      },
            0x121203: {    "devdesc": "SBE failed to collect architected register (ref userdata 1)",
                           "moduleid": "DUMP::DUMP_ARCH_REGS",
                           "reasoncode": "DUMP::DUMP_INVALID_ARCH_REG_DATA",
                           "userdata1[00:31]":  "PIR value",
                           "userdata1[32:63]":  "Register Address/Offset",
                           "userdata2":  "Failure FAPI RC",
                      },
            0x121303: {    "devdesc": "HYP Pre-Init scenario. No memory allocated for theode",
                           "moduleid": "DUMP::DUMP_ARCH_REGS",
                           "reasoncode": "DUMP::DUMP_PDAT_INSUF_SPACE_FOR_NODE",
                           "userdata1":  "NODE ORDINAL ID",
                      },
            0x121503: {    "devdesc": "Cannot unmap the virtual address",
                           "moduleid": "DUMP::DUMP_ARCH_REGS",
                           "reasoncode": "DUMP::DUMP_MM_BLOCK_UNMAP_FAIL",
                           "userdata1":  "VA to unmap",
                           "userdata2":  "rc value from unmap",
                      },
            0x121603: {    "devdesc": "PHYP did not allocate storage for HW dump; Odyssey dump skipped.",
                           "moduleid": "DUMP_ARCH_REGS",
                           "reasoncode": "DUMP_ODY_HW_NOT_COLLECTED",
                      },
            0x160403: {    "devdesc": "The LID transfer code on the FSP side was unable to fulfill the LID SEND_TO_HB request.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLID",
                           "reasoncode": "Util::UTIL_LIDMGR_RC_FAIL",
                           "userdata1":  "return code from FSP",
                           "userdata2":  "LID ID",
                      },
            0x160503: {    "devdesc": "DMA message contains data for wrong LID.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLID",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_DATA",
                           "userdata1[0:31]":  "received LID ID",
                           "userdata1[32:63]":  "expected LID ID",
                           "userdata2[0:31]":  "pointer to extra data",
                      },
            0x160603: {    "devdesc": "Insufficient space provided for LID by calling function.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLID",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE",
                           "userdata1[0:31]":  "Allocated Size",
                           "userdata1[32:63]":  "Size needed for current data page",
                           "userdata2[32:63]":  "Lid ID",
                      },
            0x160703: {    "devdesc": "Invalid Message type received from FSP when transferring LID pages.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLID",
                           "reasoncode": "Util::UTIL_LIDMGR_UNSUP_MSG",
                           "userdata1":  "LID ID",
                           "userdata2":  "Message Type",
                      },
            0x174E03: {    "devdesc": "Kernel returned error when trying to activate core.",
                           "moduleid": "MOD_HOST_ACTIVATE_SECONDARY_CORES",
                           "reasoncode": "RC_SECONDARY_CORE_WAKEUP_ERROR",
                           "userdata1[00:31]":  "PIR of failing core.",
                           "userdata2[32:63]":  "HUID of failing core.",
                           "userdata2[00:31]":  "EID from p10_check_idle_stop_done().",
                           "userdata2[32:63]":  "rc of cpu_start_core().",
                      },
            0x180303: {    "devdesc": "PRD task crashed",
                           "moduleid": "ATTN_PRD_TASK_MODULE",
                           "reasoncode": "ATTN_PRD_TASK_CRASHED",
                           "userdata1":  "tidRc",
                           "userdata2":  "Task Id that crashed",
                      },
            0x1A0203: {    "devdesc": "HDAT Header data not as expected",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_CHECK_HEADER",
                           "reasoncode": "RUNTIME::RC_BAD_HDAT_HEADER",
                           "userdata1[0:15]":  "Actual Header: id",
                           "userdata1[16:31]":  "Actual Header: version",
                           "userdata1[32:63]":  "Actual Header: name",
                           "userdata2[0:15]":  "Expected Header: id",
                           "userdata2[16:31]":  "Expected Header: version",
                           "userdata2[32:63]":  "Expected Header: name",
                      },
            0x1E0703: {    "devdesc": "ROM_verify() Call Failed",
                           "moduleid": "SECUREBOOT::MOD_SECURE_ROM_VERIFY",
                           "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                           "userdata1":  "l_rc",
                           "userdata2":  "l_hw_parms.log",
                      },
            0x210403: {    "devdesc": "Error reading devtree data",
                           "moduleid": "DEBUG_READ_CMP_DATA",
                           "reasoncode": "TARGET_DTREE_SIZE_MISMATCH",
                           "userdata1[00:31]":  "HUID",
                           "userdata1[32:63]":  "Attribute ID",
                           "userdata2[00:31]":  "Target attribute size",
                           "userdata2[32:63]":  "Devtree attribute size",
                      },
            0x220A03: {    "devdesc": "SB Keyword in MVPD has invalid size",
                           "moduleid": "SBE_GETSET_MVPD_VERSION",
                           "reasoncode": "SBE_MVPD_LEN_INVALID",
                           "userdata1":  "Discovered VPD Size",
                           "userdata2":  "Expected VPD Size",
                      },
            0x230003: {    "devdesc": "Invalid GPIO device type",
                           "moduleid": "GPIO_READATTRIBUTES",
                           "reasoncode": "GPIO_INVALID_DEVICE_TYPE",
                           "userdata1":  "Device type",
                           "userdata2":  "HUID of target",
                      },
            0x230103: {    "devdesc": "GPIO device attribute was not found",
                           "moduleid": "GPIO_READATTRIBUTES",
                           "reasoncode": "GPIO_ATTR_INFO_NOT_FOUND",
                           "userdata1":  "HUID of target",
                           "userdata2":  "GPIO device type",
                      },
            0x260603: {    "devdesc": "Failed to read throttle settings",
                           "moduleid": "HTMGT_MOD_MEMTHROTTLE",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "ocmb instance",
                           "userdata2":  "occ instance",
                      },
            0x281A03: {    "devdesc": "If the size of the FFDC package exceeds our allocated buffer size, we log it.",
                           "moduleid": "SBEIO_FFDC_PARSER",
                           "reasoncode": "SBEIO_FFDC_PARSER_BUFF_OVERFLOW",
                           "userdata1[00:63]":  "Size of FFDC package that overflows the buffer",
                           "userdata2[00:31]":  "Magic Byte",
                           "userdata2[32:63]":  "SBE FFDC MAX PAGES",
                      },
            0x2BA203: {    "devdesc": "Command failure reading TPM FW version.",
                           "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                           "reasoncode": "RC_TPM_GETCAP_FAIL",
                           "userdata1":  "responseCode",
                           "userdata2":  "0",
                      },
            0x2BA303: {    "devdesc": "Command failure reading TPM FW version.",
                           "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                           "reasoncode": "RC_TPM_GETCAP_FW_INVALID_RESP",
                           "userdata1":  "capability",
                           "userdata2":  "property",
                      },
            0x2BA403: {    "devdesc": "Command failure reading TPM FW version.",
                           "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                           "reasoncode": "RC_TPM_GETCAP2_FAIL",
                           "userdata1":  "responseCode",
                           "userdata2":  "0",
                      },
            0x2BA503: {    "devdesc": "Command failure reading TPM FW version.",
                           "moduleid": "MOD_TPM_CMD_GETCAPFWVERSION",
                           "reasoncode": "RC_TPM_GETCAP2_FW_INVALID_RESP",
                           "userdata1":  "capability",
                           "userdata2":  "property",
                      },
            0x340903: {    "devdesc": "FFS header checksum error",
                           "moduleid": "Bootloader::MOD_PNORACC_READTOC",
                           "reasoncode": "Bootloader::RC_HDR_CHECKSUM_ERR",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Pointer to FFS header",
                           "userdata2[32:63]":  "Error code",
                      },
            0x340A03: {    "devdesc": "Check FFS header error(s)",
                           "moduleid": "Bootloader::MOD_PNORACC_READTOC",
                           "reasoncode": "Bootloader::RC_CHECK_HEADER_ERR",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Pointer to FFS header",
                           "userdata2[32:63]":  "Error code",
                      },
            0x340B03: {    "devdesc": "Parse FFS entries error",
                           "moduleid": "Bootloader::MOD_PNORACC_READTOC",
                           "reasoncode": "Bootloader::RC_PARSE_ENTRIES_ERR",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Pointer to FFS entry with error",
                           "userdata2[32:63]":  "Error code",
                      },
            0x350903: {    "devdesc": "I2C write page size is zero.",
                           "moduleid": "NVDIMM_WRITE",
                           "reasoncode": "NVDIMM_I2C_WRITE_PAGE_SIZE_ZERO",
                           "userdata1":  "HUID of target",
                      },
            0x370A03: {    "devdesc": "Unable to find parent mcc for target.",
                           "moduleid": "MMIO::MOD_MMIO_GET_MCC_SCOM",
                           "reasoncode": "MMIO::RC_MCC_NOT_FOUND",
                           "userdata1":  "Target huid",
                           "userdata2":  "SCOM address",
                      },
            0x410803: {    "devdesc": "The UCD flash image commandline is not supported",
                           "moduleid": "UCD_RC::MOD_UPDATE_UCD_FLASH_IMAGE",
                           "reasoncode": "UCD_RC::UCD_UNSUPPORTED_OPERATION_REQUEST",
                           "userdata1":  "HUID of UCD Target",
                           "userdata2":  "The order of the operation",
                      },
            0x410903: {    "devdesc": "A 'new line' character was not found while processing this UCD flash image's command line",
                           "moduleid": "UCD_RC::MOD_UPDATE_UCD_FLASH_IMAGE",
                           "reasoncode": "UCD_RC::UCD_INVALID_COMMANDLINE",
                           "userdata1":  "HUID of UCD Target",
                           "userdata2":  "The order of this operation",
                      },
            0x410D03: {    "devdesc": "There was an error while parsing a field in this UCD flash image's command line",
                           "moduleid": "UCD_RC::MOD_UPDATE_UCD_FLASH_IMAGE",
                           "reasoncode": "UCD_RC::UCD_FIELD_PARSE_ERROR",
                           "userdata1[0:31]":  "HUID of UCD Target",
                           "userdata1[32:63]":  "The Field Location of the parse error",
                           "userdata2":  "The order of this operation",
                      },
            0x450203: {    "devdesc": "The combination of the offset and amount to copy given would have caused a buffer overrun.",
                           "moduleid": "SPI::SPI_COPY_TO_BUFFER",
                           "reasoncode": "SPI::SPI_INVALID_PARAMETERS",
                           "userdata1[00:15]":  "The offset from which to begin copying data",
                           "userdata1[16:31]":  "The amount of data to copy to the destination",
                           "userdata1[32:47]":  "Unused",
                           "userdata1[48:63]":  "The length of the source buffer.",
                      },
            0x460303: {    "devdesc": "MCTP message of unknown type received",
                           "moduleid": "MOD_RX_CALLBACK",
                           "reasoncode": "RC_INVALID_MSG_TYPE",
                           "userdata1":  "MCTP Message Type (first byte of MCTP payload)",
                           "userdata2":  "Source MCTP Endpoint ID",
                      },
            0x460403: {    "devdesc": "Unable to process PLDM message from the BMC",
                           "moduleid": "MOD_RX_CALLBACK",
                           "reasoncode": "RC_ERROR_CACHING_MSG",
                           "userdata1[0:31]":  "HBRT PLDM RP Return Code",
                           "userdata1[32:63]":  "Source MCTP Endpoint ID",
                           "userdata2":  "Header of PLDM message",
                      },
            0x473803: {    "devdesc": "Duplicate PLDM Record Handle from PLDM getPDR",
                           "moduleid": "MOD_GET_PDR_REPO",
                           "reasoncode": "RC_DEFENSIVE_LIMIT",
                           "userdata1":  "Duplicate Record Handle that has already been seen",
                           "userdata2":  "Unused",
                      },
            0x473A03: {    "devdesc": "Bad data in PLDM message decode, response record handle not as expected",
                           "moduleid": "MOD_GET_PDR_REPO",
                           "reasoncode": "RC_INVALID_RECORD_HANDLE",
                           "userdata1":  "Requested record handle",
                           "userdata2":  "Response record handle",
                      },
            0x900103: {    "devdesc": "Input Target Pointer is NULL",
                           "moduleid": "HDAT::MOD_PCIA_SET_CORE_INF",
                           "reasoncode": "HDAT::RC_INVALID_OBJECT",
                           "userdata1":  "Index of proc target",
                      },
            0x900303: {    "devdesc": "Invalid input target attribute",
                           "moduleid": "HDAT::MOD_PCIA_SET_CORE_INF",
                           "reasoncode": "HDAT::RC_INVALID_TGT_ATTR",
                           "userdata1":  "Index of proc target",
                           "userdata2":  "Target HUID",
                      },
            0x900603: {    "devdesc": "Target List is Empty",
                           "moduleid": "HDAT::MOD_PCIA_SET_CORE_INF",
                           "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                      },
            0x30504: {    "devdesc": "Indirect SCOM Read error",
                           "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                           "reasoncode": "SCOM::SCOM_INDIRECT_READ_FAIL",
                           "userdata1":  "Address",
                           "userdata2":  "Indirect Scom Status Register",
                      },
            0x30604: {    "devdesc": "Indirect SCOM complete bit did not come on",
                           "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                           "reasoncode": "SCOM::SCOM_INDIRECT_READ_TIMEOUT",
                           "userdata1":  "Address",
                           "userdata2":  "Indirect Scom Status Register",
                      },
            0x30704: {    "devdesc": "Indirect SCOM Write failed for this address",
                           "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                           "reasoncode": "SCOM::SCOM_INDIRECT_WRITE_FAIL",
                           "userdata1":  "Address",
                           "userdata2":  "Indirect Scom Status Register",
                      },
            0x30804: {    "devdesc": "Indirect SCOM complete bit did not come on",
                           "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                           "reasoncode": "SCOM::SCOM_INDIRECT_WRITE_TIMEOUT",
                           "userdata1":  "Address",
                           "userdata2":  "Indirect Scom Status Register",
                      },
            0x30E04: {    "devdesc": "Unsupported indirect scom form",
                           "moduleid": "SCOM::SCOM_CHECK_INDIRECT_AND_DO_SCOM",
                           "reasoncode": "SCOM::SCOM_INVALID_FORM",
                           "userdata1":  "Address",
                           "userdata2":  "HUID of Target",
                      },
            0x40404: {    "devdesc": "Read back value doesn't match write",
                           "moduleid": "XSCOM::XSCOM_TEST_XSCOM2",
                           "reasoncode": "XSCOM::XSCOM_DATA_UNMATCHED",
                           "userdata1":  "Write value",
                           "userdata2":  "Read back value",
                      },
            0x50304: {    "devdesc": "One or more CxxTest Unit Tests failed.",
                           "moduleid": "CXXTEST_MOD_ID",
                           "reasoncode": "CXXTEST_FAILED_TEST",
                           "userdata1":  "number of failed tests",
                           "userdata2":  "<UNUSED>",
                      },
            0x60204: {    "devdesc": "PnorRP::computeSection> Invalid Address",
                           "moduleid": "PNOR::MOD_PNORRP_COMPUTESECTION",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1":  "Requested Virtual Address",
                           "userdata2":  "<unused>",
                      },
            0x80704: {    "devdesc": "VFS Task crashed.",
                           "moduleid": "VFS_MODULE_LOAD_MONITOR",
                           "reasoncode": "VFS_TASK_CRASHED",
                           "userdata1":  "tidRc",
                           "userdata2":  "Task Status",
                      },
            0xA0404: {    "devdesc": "FsiDD::handleOpbErrors> Error during FSI access",
                           "moduleid": "FSI::MOD_FSIDD_HANDLEOPBERRORS",
                           "reasoncode": "FSI::RC_OPB_ERROR",
                           "userdata1[00:31]":  "Relative FSI Address",
                           "userdata1[32:63]":  "Absolute FSI Address",
                           "userdata2[00:31]":  "OPB Status Register",
                           "userdata2[32:63]":  "FSI Master HUID",
                      },
            0xC0A04: {    "devdesc": "Gard record(s) not applied due to a lack of resources.",
                           "moduleid": "MOD_DECONFIG_TARGETS_FROM_GARD",
                           "reasoncode": "RC_RESOURCE_RECOVERED",
                           "userdata1":  "Number of gard records not applied",
                           "userdata2":  "0",
                      },
            0xE0204: {    "devdesc": "The Device type not supported (addrSize)",
                           "moduleid": "EEPROM_PREPAREADDRESS",
                           "reasoncode": "EEPROM_INVALID_DEVICE_TYPE",
                           "userdata1":  "Address Size (aka Device Type)",
                           "userdata2":  "EEPROM chip",
                      },
            0x100104: {    "devdesc": "No master proc set for this drawer",
                           "moduleid": "TOD_FIND_MASTER_PROC",
                           "reasoncode": "TOD_NO_MASTER_PROC",
                           "userdata1":  "TOD drawer id",
                      },
            0x101204: {    "devdesc": "Either processor or drawer object was not found for the  MDMT found by reading the processor registers.",
                           "moduleid": "TOD_FIND_MASTER_PROC",
                           "reasoncode": "TOD_MASTER_TARGET_NOT_FOUND",
                           "userdata1[32:64]":  "1 = Master proc was not found , zero otherwise",
                           "userdata1[32:63]":  "1 = Master drawer was not found, zero otherwise",
                           "userdata2[0:31]":  "EMOD_TOD_SET_ACTIVE_MDMT",
                           "userdata2[32:64]":  "Active topology",
                      },
            0x110904: {    "devdesc": "Retry failed. Bad status indicated in PIB status reg.",
                           "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                           "reasoncode": "MBOX::RC_ILLEGAL_OP",
                           "userdata1":  "Status from MB device driver",
                      },
            0x110A04: {    "devdesc": "Mailbox Data Write attempted before ACK.",
                           "moduleid": "MOD_MBOXSRV_HNDLR",
                           "reasoncode": "RC_DATA_WRITE_ERR",
                           "userdata1":  "Status from MB device driver",
                      },
            0x110B04: {    "devdesc": "Mailbox Hardware detected parity error.",
                           "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                           "reasoncode": "MBOX::RC_PARITY_ERR",
                           "userdata1":  "Status from MB device driver",
                      },
            0x110C04: {    "devdesc": "Invalid message type sent to mailbox msgQ",
                           "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                           "reasoncode": "MBOX::RC_INVALID_MBOX_MSG_TYPE",
                           "userdata1":  "Message type",
                      },
            0x111304: {    "devdesc": "IPC Message data corrupted",
                           "moduleid": "MBOX::MOD_MBOXSRV_HNDLR",
                           "reasoncode": "MBOX::RC_IPC_INVALID_DATA",
                           "userdata1":  "IPC Data Area MSG Queue ID",
                      },
            0x160404: {    "devdesc": "The LID transfer code on the FSP side was unable to fulfill the LID GET_INFO request.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLIDSIZE",
                           "reasoncode": "Util::UTIL_LIDMGR_RC_FAIL",
                           "userdata1":  "return code from FSP",
                           "userdata2":  "LID ID",
                      },
            0x170504: {    "devdesc": "The proc_stop_save_cpureg procedure failed.",
                           "moduleid": "ISTEP::MOD_BUILD_HCODE_IMAGES",
                           "reasoncode": "ISTEP::RC_BAD_RC",
                           "userdata1":  "Hi 32 bits: return code from proc_stop_save_cpureg Lo 32 bits: SPR number being processed",
                           "userdata2":  "Hi 32 bits: ID of core Lo 32 bits: Thread id",
                      },
            0x170704: {    "devdesc": "mm_block_unmap() returns error",
                           "moduleid": "ISTEP::MOD_BUILD_HCODE_IMAGES",
                           "reasoncode": "ISTEP::RC_MM_UNMAP_ERR",
                           "userdata1":  "Return Code",
                           "userdata2":  "Unmap address",
                      },
            0x175004: {    "devdesc": "Could not unmap unsecure HOMER's virtual address",
                           "moduleid": "ISTEP::MOD_BUILD_HCODE_IMAGES",
                           "reasoncode": "ISTEP::RC_MM_UNMAP_FAILED",
                           "userdata1":  "Unsecure HOMER addr",
                           "userdata2":  "RC from mm_block_unmap",
                      },
            0x180404: {    "devdesc": "PRD task crashed",
                           "moduleid": "ATTN_INTR_TASK_MODULE",
                           "reasoncode": "ATTN_INTR_TASK_CRASHED",
                           "userdata1":  "tidRc",
                           "userdata2":  "Task Id that crashed",
                      },
            0x1A0304: {    "devdesc": "Tuple is unallocated",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_CHECK_TUPLE",
                           "reasoncode": "RUNTIME::RC_BAD_HDAT_TUPLE",
                           "userdata1":  "Absolute address",
                           "userdata2[0:31]":  "Allocated Count",
                           "userdata2[32:63]":  "Allocated Size",
                      },
            0x220B04: {    "devdesc": "Image Version not found in PNOR SBE image.",
                           "moduleid": "SBE_READ_PNOR_VERSION",
                           "reasoncode": "SBE_VERSION_NOT_FOUND",
                           "userdata1":  "Not Used",
                           "userdata2":  "Not Used",
                      },
            0x240404: {    "devdesc": "LpcDD::checkLpcErrors> Error(s) found in OPB Status Register",
                           "moduleid": "LPC::MOD_LPCDD_CHECKFORLPCERRORS",
                           "reasoncode": "LPC::RC_OPB_ERROR",
                           "userdata1":  "OPBM Error Status Register",
                           "userdata2":  "Reset Level",
                      },
            0x240A04: {    "devdesc": "LpcDD::checkForLpcErrors> Error(s) found in LPCHC Status Register",
                           "moduleid": "LPC::MOD_LPCDD_CHECKFORLPCERRORS",
                           "reasoncode": "LPC::RC_LPCHC_ERROR",
                           "userdata1":  "LPCHC Error Status Register",
                           "userdata2":  "Reset Level",
                      },
            0x260104: {    "devdesc": "Unable to set state of master OCC",
                           "moduleid": "HTMGT_MOD_OCCMGR_SET_STATE",
                           "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                      },
            0x262304: {    "devdesc": "Invalid OCC state requested",
                           "moduleid": "HTMGT_MOD_OCCMGR_SET_STATE",
                           "reasoncode": "HTMGT_RC_INVALID_DATA",
                           "userdata1":  "requested state",
                      },
            0x262604: {    "devdesc": "OCC did not change to requested state",
                           "moduleid": "HTMGT_MOD_OCCMGR_SET_STATE",
                           "reasoncode": "HTMGT_RC_OCC_UNEXPECTED_STATE",
                           "userdata1[0-31]":  "requested state",
                           "userdata1[32-63]":  "OCC state",
                           "userdata2":  "OCC instance",
                      },
            0x281904: {    "devdesc": "Attempted FIFO chip op on Boot Chip",
                           "moduleid": "SBEIO_FIFO_CONTINUE_MPIPL",
                           "reasoncode": "SBEIO_FIFO_SENTINEL_TARGET",
                      },
            0x2BA604: {    "devdesc": "Unsupported command code during marshal",
                           "moduleid": "MOD_TPM_MARSHALCMDDATA",
                           "reasoncode": "RC_TPM_MARSHAL_INVALID_CMD",
                           "userdata1":  "Command Code",
                           "userdata2":  "0",
                      },
            0x2BA704: {    "devdesc": "Marshaling error detected",
                           "moduleid": "MOD_TPM_MARSHALCMDDATA",
                           "reasoncode": "RC_TPM_MARSHALING_FAIL",
                           "userdata1":  "stage",
                           "userdata2":  "0",
                      },
            0x340C04: {    "devdesc": "Invalid flash address for HBB",
                           "moduleid": "Bootloader::MOD_PNORACC_GETHBBSECT",
                           "reasoncode": "Bootloader::RC_NO_HBB_IN_TOC",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "Pointer to HBB Section data",
                           "userdata2[32:63]":  "HBB Section flash address",
                      },
            0x350204: {    "devdesc": "The Device type not supported (addrSize)",
                           "moduleid": "NVDIMM_PREPAREADDRESS",
                           "reasoncode": "NVDIMM_INVALID_DEVICE_TYPE",
                           "userdata1":  "Address Size (aka Device Type)",
                      },
            0x410A04: {    "devdesc": "The store default all operation, which commits configuration changes to the UCD flash, completed but with errors",
                           "moduleid": "UCD_RC::MOD_VERIFY_UPDATE",
                           "reasoncode": "UCD_RC::UCD_ERROR_STORING_TO_FLASH",
                           "userdata1[00:31]":  "MFR_STATUS value",
                           "userdata2":  "HUID of the UCD",
                      },
            0x410B04: {    "devdesc": "The store default all operation, which commits configuration changes to the UCD flash, did not complete",
                           "moduleid": "UCD_RC::MOD_VERIFY_UPDATE",
                           "reasoncode": "UCD_RC::UCD_TIMEDOUT_STORING_TO_FLASH",
                           "userdata1[00:31]":  "MFR_STATUS value",
                           "userdata2":  "HUID of the UCD",
                      },
            0x420a04: {    "devdesc": "Unsupported number of DDIMMs found tied to one OCMB in targeting layout.",
                           "moduleid": "OCMBUPD::MOD_WRITE_EXPLORER_FW_VERSION",
                           "reasoncode": "OCMBUPD::UNSUPPORTED_NUMBER_OF_DIMMS",
                           "userdata1":  "HUID of OCMB target whose DDIMM is being searched for",
                           "userdata2":  "Number of DDIMMs found",
                      },
            0x450304: {    "devdesc": "The SPI engine mutex requested couldn't be retrieved.",
                           "moduleid": "SPI::SPI_ENGINE_LOCK_OP",
                           "reasoncode": "SPI::SPI_FAILED_TO_RETRIEVE_ENGINE_MUTEX",
                           "userdata1":  "Target HUID of the SPI Master",
                           "userdata2":  "Requested SPI Engine",
                      },
            0x460704: {    "devdesc": "BMC is likely DOSing the Host with PLDM messages intended for PHYP or HBRT.",
                           "moduleid": "MOD_DRAIN_ODR",
                           "reasoncode": "RC_DRAINED_MAX_ODR_MSGS",
                           "userdata1":  "Number of KCS messages we drain from ODR before creating this error log.",
                           "userdata2":  "Unused",
                      },
            0x470504: {    "devdesc": "PLDM message from BMC is too small to process",
                           "moduleid": "MOD_ROUTE_MESSAGES",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "actual length",
                           "userdata2":  "minimum length",
                      },
            0x470804: {    "devdesc": "Error sending message to PLDM message q",
                           "moduleid": "MOD_ROUTE_MESSAGES",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "rc from msg_send",
                           "userdata2":  "ptr to message as uint64_t",
                      },
            0x900104: {    "devdesc": "Input Target Pointer is nullptr",
                           "moduleid": "HDAT::MOD_UTIL_CARD_ID",
                           "reasoncode": "HDAT::RC_INVALID_OBJECT",
                      },
            0x900404: {    "devdesc": "Target is not currently supported",
                           "moduleid": "HDAT::MOD_UTIL_CARD_ID",
                           "reasoncode": "HDAT::RC_TARGET_UNSUPPORTED",
                      },
            0x900604: {    "devdesc": "Target list is empty",
                           "moduleid": "HDAT::MOD_UTIL_CARD_ID",
                           "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                      },
            0x10905: {    "devdesc": "Commit of extra data tied to original log",
                           "moduleid": "ERRORLOG::ERRL_COMMIT_EXTRA_LOGS_ID",
                           "reasoncode": "ERRORLOG::ERRL_EXTRA_LOG_RC",
                           "userdata1":  "Original log reason code",
                           "userdata2":  "Extra log number",
                      },
            0x50f05: {    "devdesc": "This error log was intentionally created in order to induce a reconfigure loop for testing purposes.",
                           "moduleid": "RECONFIG_LOOP_TEST_ID",
                           "reasoncode": "RECONFIG_LOOP_TEST_RC",
                      },
            0x70505: {    "devdesc": "Timed out waiting for command complete.",
                           "moduleid": "I2C_WAIT_FOR_CMD_COMP",
                           "reasoncode": "I2C_CMD_COMP_TIMEOUT",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Master Target",
                           "userdata2[0:7]":  "Master Engine",
                           "userdata2[8:15]":  "Master Port",
                           "userdata2[16:31]":  "Slave Device Address",
                           "userdata2[32:47]":  "Bus Speed",
                           "userdata2[48:63]":  "Bit Rate Devisor",
                      },
            0x80705: {    "devdesc": "VFS Task crashed.",
                           "moduleid": "VFS_MODULE_EXEC_MONITOR",
                           "reasoncode": "VFS_TASK_CRASHED",
                           "userdata1":  "tidRc",
                           "userdata2":  "task Rc",
                      },
            0xA0105: {    "devdesc": "FsiDD::ddOp> Invalid data length (!= 4,2,1 bytes)",
                           "moduleid": "FSI::MOD_FSIDD_DDOP",
                           "reasoncode": "FSI::RC_INVALID_LENGTH",
                           "userdata1":  "FSI Address",
                           "userdata2":  "Data Length",
                      },
            0xA0805: {    "devdesc": "FsiDD::ddOp> Invalid operation type",
                           "moduleid": "FSI::MOD_FSIDD_DDOP",
                           "reasoncode": "FSI::RC_INVALID_OPERATION",
                           "userdata1":  "FSI Address",
                           "userdata2":  "Operation Type (i_opType)",
                      },
            0xA0905: {    "devdesc": "FsiDD::ddOp> Target is NULL",
                           "moduleid": "FSI::MOD_FSIDD_DDOP",
                           "reasoncode": "FSI::RC_NULL_TARGET",
                           "userdata1":  "FSI Address",
                           "userdata2":  "Operation Type (i_opType) : 0=READ, 1=WRITE",
                      },
            0xA0A05: {    "devdesc": "FsiDD::ddOp> Target is unsupported Master Sentinel",
                           "moduleid": "FSI::MOD_FSIDD_DDOP",
                           "reasoncode": "FSI::RC_MASTER_TARGET",
                           "userdata1":  "FSI Address",
                           "userdata2":  "Operation Type (i_opType) : 0=READ, 1=WRITE",
                      },
            0xB0d05: {    "devdesc": "AttrOverrideSection too big to fit in remaining chunk of pnor section",
                           "moduleid": "TARG_GET_ATTR_OVER",
                           "reasoncode": "TARG_RC_ATTR_OVER_PNOR_SEC_SPACE_FAIL",
                           "userdata1":  "PNOR Section specified",
                           "userdata2":  "Size of AttrOverrideSection",
                      },
            0xB0e05: {    "devdesc": "Serialized attribute override chunk too big to fit in remaining chunck of pnor section",
                           "moduleid": "TARG_GET_ATTR_OVER",
                           "reasoncode": "TARG_RC_ATTR_OVER_ATTR_DATA_SIZE_FAIL",
                           "userdata1":  "PNOR Section specified",
                           "userdata2":  "Size of Serialized attribute override",
                      },
            0xB1105: {    "devdesc": "Attribute override is in the wrong pnor section needs to be moved to the section associated with its attribute tank layer",
                           "moduleid": "TARG_GET_ATTR_OVER",
                           "reasoncode": "TARG_RC_WRITE_ATTR_OVER_WRONG_PNOR_SEC",
                           "userdata1":  "Tank Layer of attribute",
                           "userdata2":  "PNOR Section specified",
                      },
            0xB1205: {    "devdesc": "No tank layer was specified for attribute override.",
                           "moduleid": "TARG_GET_ATTR_OVER",
                           "reasoncode": "TARG_RC_WRITE_ATTR_OVER_NO_TANK_LAYER",
                           "userdata1":  "PNOR Section specified",
                           "userdata2":  "Chunk location with no tank layer",
                      },
            0xB1905: {    "devdesc": "Attribute override is in the FAPI Tank which is not supported",
                           "moduleid": "TARG_GET_ATTR_OVER",
                           "reasoncode": "TARG_RC_ATTR_OVER_FAPI_TANK_NOT_SUPPORTED",
                           "userdata1":  "Tank Layer of attribute",
                           "userdata2":  "PNOR Section specified",
                      },
            0xC0F05: {    "devdesc": "Found a slave processor whose EC level did not match the master",
                           "moduleid": "MOD_VALIDATE_EC_LEVELS",
                           "reasoncode": "RC_EC_MISMATCH",
                           "userdata1[00:31]":  "HUID of slave chip",
                           "userdata1[32:63]":  "EC level of slave chip",
                           "userdata2[00:31]":  "HUID of master chip",
                           "userdata2[32:63]":  "EC level of master chip",
                      },
            0xC1005: {    "devdesc": "Found one or more slave processor whose EC level did not match the master",
                           "moduleid": "MOD_VALIDATE_EC_LEVELS",
                           "reasoncode": "RC_FAILED_EC_VALIDATION",
                           "userdata1[00:64]":  "Number of Procs",
                      },
            0xE0305: {    "devdesc": "EEPROM attribute was not found",
                           "moduleid": "EEPROM_READATTRIBUTES",
                           "reasoncode": "EEPROM_ATTR_INFO_NOT_FOUND",
                           "userdata1":  "HUID of target",
                           "userdata2":  "EEPROM chip",
                      },
            0xE0405: {    "devdesc": "Invalid EEPROM chip to access",
                           "moduleid": "EEPROM_READATTRIBUTES",
                           "reasoncode": "EEPROM_INVALID_CHIP",
                           "userdata1":  "EEPROM Chip",
                           "userdata2":  "HUID of target",
                      },
            0xE0705: {    "devdesc": "Invalid address offset size",
                           "moduleid": "EEPROM_READATTRIBUTES",
                           "reasoncode": "EEPROM_INVALID_ADDR_OFFSET_SIZE",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Byte Address Offset",
                      },
            0xF0105: {    "devdesc": "Interrupt type already registered",
                           "moduleid": "INTR::MOD_INTRRP_REGISTERINTERRUPT",
                           "reasoncode": "INTR::RC_ALREADY_REGISTERED",
                           "userdata1":  "XISR",
                           "userdata2":  "0",
                      },
            0x110205: {    "devdesc": "Message from FSP. Message type is not within a valid range. Message dropped.",
                           "moduleid": "MBOX::MOD_MBOXSRV_RCV",
                           "reasoncode": "MBOX::RC_INVALID_MESSAGE_TYPE",
                           "userdata1":  "msg queue",
                           "userdata2":  "msg type",
                      },
            0x111205: {    "devdesc": "Invalid msg or msg queue",
                           "moduleid": "MBOX::MOD_MBOXSRV_RCV",
                           "reasoncode": "MBOX::RC_MSG_SEND_ERROR",
                           "userdata1":  "rc from msg_send()",
                           "userdata2":  "msg queue id",
                      },
            0x160605: {    "devdesc": "Insufficient space provided for LID by calling function.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLIDPNOR",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE",
                           "userdata1[0:31]":  "LID size found in Ext Img",
                           "userdata1[32:63]":  "Reserved space provided",
                           "userdata2":  "LID ID",
                      },
            0x160805: {    "devdesc": "Insufficient space provided for LID by calling function.",
                           "moduleid": "Util::UTIL_LIDMGR_GETLIDPNOR",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE_PNOR",
                           "userdata1[0:31]":  "LID size found in pnor",
                           "userdata1[32:63]":  "Reserved space provided",
                           "userdata2":  "LID ID",
                      },
            0x1E0705: {    "devdesc": "ROM verification failed",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_VERIFY",
                           "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "First 4 bytes System's HW keys' Hash",
                           "userdata2[32:63]":  "First 4 bytes of Container Header",
                      },
            0x1E0B05: {    "devdesc": "Valid securerom not present",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_VERIFY",
                           "reasoncode": "SECUREBOOT::RC_SECROM_INVALID",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                      },
            0x240505: {    "devdesc": "LpcDD::hwReset> Unsupported Reset Level requested",
                           "moduleid": "LPC::MOD_LPCDD_HWRESET",
                           "reasoncode": "LPC::RC_UNSUPPORTED_OPERATION",
                           "userdata1":  "Unsupported Reset Level Parameter",
                           "userdata2":  "<unused>",
                      },
            0x260105: {    "devdesc": "Set state only allowed on master OCC",
                           "moduleid": "HTMGT_MOD_OCC_SET_STATE",
                           "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                           "userdata1":  "OCC instance",
                           "userdata2":  "Requested state",
                      },
            0x261B05: {    "devdesc": "Set of OCC state failed",
                           "moduleid": "HTMGT_MOD_OCC_SET_STATE",
                           "reasoncode": "HTMGT_RC_OCC_CMD_FAIL",
                           "userdata1[0-31]":  "OCC instance",
                           "userdata1[32-63]":  "Requested state",
                           "userdata2[0-31]":  "OCC response status",
                           "userdata2[32-63]":  "current OCC state",
                      },
            0x270305: {    "devdesc": "SPI_TPM_INFO attribute was not found for the requested target",
                           "moduleid": "TPMDD_READATTRIBUTES",
                           "reasoncode": "TPM_ATTR_INFO_NOT_FOUND",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Type of target",
                      },
            0x271005: {    "devdesc": "TPM_MODEL attribute was not found for the requested target",
                           "moduleid": "TPMDD_READATTRIBUTES",
                           "reasoncode": "TPM_ATTR_MODEL_NOT_FOUND",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Type of target",
                      },
            0x271105: {    "devdesc": "TPM_MODEL attribute was set to a value that is not currently supported",
                           "moduleid": "TPMDD_READATTRIBUTES",
                           "reasoncode": "TPM_ATTR_INVALID_MODEL",
                           "userdata1":  "TPM Model of target",
                           "userdata2":  "HUID of target",
                      },
            0x271305: {    "devdesc": "TPM_ENABLED attribute was not found for the requested target",
                           "moduleid": "TPMDD_READATTRIBUTES",
                           "reasoncode": "TPM_ATTR_TPM_ENABLED_NOT_FOUND",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Type of target",
                      },
            0x283105: {    "devdesc": "SBEIO RT Process Pass-through command function not set.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_FUNCTION_NOT_SET",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Request Command",
                           "userdata2":  "Sequence ID",
                      },
            0x283205: {    "devdesc": "SBEIO RT Process Pass-through command response data size too large.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_RSP_DATA_TOO_LARGE",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Request Command",
                           "userdata2[0:31]":  "Sequence ID",
                           "userdata2[32:63]":  "Response Data Size",
                      },
            0x283305: {    "devdesc": "SBEIO RT Read Pass-through command invalid version.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_INVALID_VERSION",
                           "userdata1[0:31]":  "SBE Header version",
                           "userdata1[32:63]":  "Command Header version",
                           "userdata2":  "Processor HUID",
                      },
            0x283405: {    "devdesc": "SBEIO RT Read Pass-through command message size is too large.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_MSG_SIZE_TOO_LARGE",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Message Size",
                           "userdata2":  "Reserved",
                      },
            0x283505: {    "devdesc": "SBEIO RT Read Pass-through command data offset is too small.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_DATA_OFFSET_TOO_SMALL",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Data Offset",
                           "userdata2":  "Minimum Data Offset",
                      },
            0x283605: {    "devdesc": "SBEIO RT Read Pass-through command data offset is too large.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_DATA_TOO_LARGE",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Data Offset",
                           "userdata2[0:31]":  "Message Size",
                           "userdata2[32:63]":  "Data Size",
                      },
            0x283705: {    "devdesc": "SBEIO RT Check Pass-through command response field was altered.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_RSP_FIELD_ALTERED",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Request Command",
                           "userdata2":  "Sequence ID",
                      },
            0x283805: {    "devdesc": "SBEIO RT Process Pass-through command SBE Communication buffer not set.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_NO_SBE_COMM_BUFFER",
                           "userdata1":  "Processor HUID",
                           "userdata2":  "Reserved",
                      },
            0x283905: {    "devdesc": "SBEIO RT Process Pass-through command function not found.",
                           "moduleid": "SBEIO::SBEIO_RUNTIME",
                           "reasoncode": "SBEIO::SBEIO_RT_FUNCTION_NOT_FOUND",
                           "userdata1[0:31]":  "Processor HUID",
                           "userdata1[32:63]":  "Request Command",
                           "userdata2":  "Sequence ID",
                      },
            0x2BA805: {    "devdesc": "Unsupported command code during unmarshal",
                           "moduleid": "MOD_TPM_UNMARSHALRESPDATA",
                           "reasoncode": "RC_TPM_UNMARSHAL_INVALID_CMD",
                           "userdata1":  "commandcode",
                           "userdata2":  "stage",
                      },
            0x2BA905: {    "devdesc": "Unmarshaling error detected",
                           "moduleid": "MOD_TPM_UNMARSHALRESPDATA",
                           "reasoncode": "RC_TPM_UNMARSHALING_FAIL",
                           "userdata1":  "Stage",
                           "userdata2":  "Remaining response buffer size",
                      },
            0x332305: {    "devdesc": "Could not find the parent PERV of this unit target or the pervasive did not map to expected PROC",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_PARENT_TEST",
                           "reasoncode": "fapi2::RC_UNIT_NO_PERV_FOUND",
                           "userdata1[0:31]":  "Actual PROC HUID",
                           "userdata1[32:63]":  "Actual PERV HUID",
                           "userdata2[0:31]":  "Source unit's chip unit",
                           "userdata2[32:63]":  "Source unit's targeting type",
                      },
            0x350305: {    "devdesc": "NVDIMM attribute was not found",
                           "moduleid": "NVDIMM_READATTRIBUTES",
                           "reasoncode": "NVDIMM_ATTR_INFO_NOT_FOUND",
                           "userdata1":  "HUID of target",
                      },
            0x350705: {    "devdesc": "Invalid address offset size",
                           "moduleid": "NVDIMM_READATTRIBUTES",
                           "reasoncode": "NVDIMM_INVALID_ADDR_OFFSET_SIZE",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Address Offset Size",
                      },
            0x370105: {    "devdesc": "A MMIO operation was attempted before MMIO was initialized.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INVALID_SETUP",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370205: {    "devdesc": "Invalid data buffer for a MMIO operation.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INVALID_BUFFER",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370305: {    "devdesc": "Data buffer too small for a MMIO operation.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INSUFFICIENT_BUFFER",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370405: {    "devdesc": "Buffer length not a multiple of access limit.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INCORRECT_BUFFER_LENGTH",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370505: {    "devdesc": "Invalid offset, requested address was out of range for a MMIO operation.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INVALID_OFFSET",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370605: {    "devdesc": "Requested MMIO address was not aligned properly for the associated device.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INVALID_OFFSET_ALIGNMENT",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370705: {    "devdesc": "Specified access limit was invalid for a MMIO operation.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_INVALID_ACCESS_LIMIT",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset, if >= 4GB then subtract 2GB (allows offsets to fit in 32 bits)",
                           "userdata2[0:0]":  "Operation Type",
                           "userdata2[28:31]":  "Access Limit",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x370D05: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                           "moduleid": "MMIO::MOD_VALIDATE_OCMB_MMIO_OP",
                           "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                           "userdata1":  "OCMB HUID",
                           "userdata2":  "OCMB chip ID",
                      },
            0x410C05: {    "devdesc": "A combination of arguments passed to ucdDeviceOp were not able to form a valid deviceOp() call.",
                           "moduleid": "UCD_RC::MOD_PERFORM_DEVICE_OP",
                           "reasoncode": "UCD_RC::UCD_INVALID_DEVICE_OP",
                           "userdata1[00:31]":  "command or 0x0 if none provided",
                           "userdata1[32:63]":  "smbus operation type",
                      },
            0x420b05: {    "devdesc": "Device read failed on OCMB target - indeterminate if OCMB is an MDS DDIMM",
                           "moduleid": "OCMBUPD::MOD_IS_MDS_DDIMM",
                           "reasoncode": "OCMBUPD::DEVICE_READ_FAIL",
                           "userdata1":  "HUID of OCMB target being examined",
                           "userdata2":  "<unused>",
                      },
            0x450405: {    "devdesc": "The requested op type is not supported.",
                           "moduleid": "SPI::SPI_PERFORM_OP",
                           "reasoncode": "SPI::SPI_UNKNOWN_OP_TYPE",
                           "userdata1":  "Target HUID of the SPI Master",
                           "userdata2":  "op type",
                      },
            0x450505: {    "devdesc": "The length of the buffer to write/read must be greater than zero.",
                           "moduleid": "SPI::SPI_PERFORM_OP",
                           "reasoncode": "SPI::SPI_INVALID_BUFFER_SIZE",
                           "userdata1":  "Target HUID of the SPI Master",
                      },
            0x30F06: {    "devdesc": "Bits 0:11 in user supplied data is not zero",
                           "moduleid": "SCOM::SCOM_DO_FORM_1_INDIRECT_SCOM",
                           "reasoncode": "SCOM::SCOM_FORM_1_INVALID_DATA",
                           "userdata1":  "Address",
                           "userdata2":  "User supplied data",
                      },
            0x31006: {    "devdesc": "No read op on form 1 indirect scom.",
                           "moduleid": "SCOM::SCOM_DO_FORM_1_INDIRECT_SCOM",
                           "reasoncode": "SCOM::SCOM_FORM_1_READ_REQUEST",
                           "userdata1":  "Address",
                           "userdata2":  "Operation Type",
                      },
            0x51806: {    "devdesc": "IStep failed and HW deconfigured in response to targeted error injection.",
                           "moduleid": "ISTEP_INJECT_MOD_ID",
                           "reasoncode": "ISTEP_ERROR_INJECTED",
                           "userdata1[00:07]":  "Istep of first injection target",
                           "userdata1[08:15]":  "Substep of first injection target",
                           "userdata1[16:23]":  "DeconfigEnum of first injection target",
                           "userdata1[24:31]":  "GARD ErrorType of first injection target",
                           "userdata1[32:63]":  "Reserved",
                           "userdata2":  "Injection target HUID",
                      },
            0x61906: {    "devdesc": "Hdr of TOC of PNOR failed series of tests",
                           "moduleid": "PNOR::MOD_PNORRP_READTOC",
                           "reasoncode": "PNOR::RC_BAD_TOC_HEADER",
                           "userdata1":  "Address of toc buffer",
                           "userdata2":  "Error Code",
                      },
            0x62306: {    "devdesc": "Could not set permissions of the given PNOR section to WRITABLE/WRITE_TRACKED",
                           "moduleid": "PNOR::MOD_PNORRP_READTOC",
                           "reasoncode": "PNOR::RC_WRITE_TRACKED_PERM_FAIL",
                           "userdata1":  "PNOR section id",
                           "userdata2":  "PNOR section vaddr",
                      },
            0x62B06: {    "devdesc": "Expected buffer to have contents of TOC, instead was NULL",
                           "moduleid": "PNOR::MOD_PNORRP_READTOC",
                           "reasoncode": "PNOR::RC_NULL_TOC_BUFFER",
                           "userdata1":  "Address of toc buffer",
                           "userdata2":  "Error code",
                      },
            0x62C06: {    "devdesc": "Hdr of TOC of PNOR failed checksum",
                           "moduleid": "PNOR::MOD_PNORRP_READTOC",
                           "reasoncode": "PNOR::RC_TOC_HDR_CHECKSUM_ERR",
                           "userdata1":  "Address of toc buffer",
                           "userdata2":  "Error Code",
                      },
            0x62D06: {    "devdesc": "Error while parsing pnor TOC entries",
                           "moduleid": "PNOR::MOD_PNORRP_READTOC",
                           "reasoncode": "PNOR::RC_PNOR_PARSE_ENTRIES_ERR",
                           "userdata1":  "Address of toc buffer",
                           "userdata2":  "Error Code",
                      },
            0x63D06: {    "devdesc": "Could not set permissions of the given PNOR section to READ_ONLY",
                           "moduleid": "PNOR::MOD_PNORRP_READTOC",
                           "reasoncode": "PNOR::RC_READ_ONLY_PERM_FAIL",
                           "userdata1":  "PNOR section id",
                           "userdata2":  "PNOR section vaddr",
                      },
            0x80806: {    "devdesc": "Secureboot page verify failure.",
                           "moduleid": "VFS_VERIFY_PAGE",
                           "reasoncode": "VFS_PAGE_VERIFY_FAILED",
                           "userdata1":  "Kernel RC",
                           "userdata2":  "virtual address accessed",
                      },
            0xA0306: {    "devdesc": "FsiDD::pollForComplete> Error during FSI access",
                           "moduleid": "FSI::MOD_FSIDD_POLLFORCOMPLETE",
                           "reasoncode": "FSI::RC_OPB_TIMEOUT",
                           "userdata1[0:31]":  "Relative FSI Address",
                           "userdata1[32:63]":  "Absolute FSI Address",
                           "userdata2":  "OPB Status Register",
                      },
            0xA0606: {    "devdesc": "FsiDD::pollForComplete> Read valid never came on",
                           "moduleid": "FSI::MOD_FSIDD_POLLFORCOMPLETE",
                           "reasoncode": "FSI::RC_OPB_NO_READ_VALID",
                           "userdata1[0:31]":  "Relative FSI Address",
                           "userdata1[32:63]":  "Absolute FSI Address",
                           "userdata2":  "OPB Status Register",
                      },
            0xB0f06: {    "devdesc": "Failure applying given attribute override on given target",
                           "moduleid": "TARG_WRITE_PERM_ATTR",
                           "reasoncode": "TARG_RC_WRITE_PERM_ATTR_FAIL",
                           "userdata1":  "Target specified",
                           "userdata2":  "Attribute specified",
                      },
            0xB1006: {    "devdesc": "Given target does not have given attribute to apply override",
                           "moduleid": "TARG_WRITE_PERM_ATTR",
                           "reasoncode": "TARG_RC_WRITE_PERM_ATTR_TARGET_FAIL",
                           "userdata1":  "Target specified",
                           "userdata2":  "Attribute specified",
                      },
            0xC0306: {    "devdesc": "Target is neiter TYPE_EQ, TYPE_FC nor TYPE_CORE",
                           "moduleid": "MOD_RUNTIME_DECONFIG",
                           "reasoncode": "RC_INVALID_TARGET",
                           "userdata1":  "target huid",
                      },
            0xC1106: {    "devdesc": "Caller passed invalid deconfigure action",
                           "moduleid": "MOD_RUNTIME_DECONFIG",
                           "reasoncode": "RC_INVALID_PARAM",
                           "userdata1":  "HUID of the target",
                           "userdata2":  "Target type",
                           "userdata3":  "Target class",
                           "userdata4":  "Deconfig Action",
                      },
            0xC1206: {    "devdesc": "deconfigureTargetAtRuntime is currently only supported in hostboot runtime, this error indicates the function was called outside of the hostboot runtime context.",
                           "moduleid": "MOD_RUNTIME_DECONFIG",
                           "reasoncode": "RC_NOT_AT_RUNTIME",
                           "userdata1":  "HUID of the target",
                           "userdata2":  "deconfig reason - either error log id, or DeconfigGard::DECONFIGURED_BY_PRD",
                      },
            0xC1306: {    "devdesc": "Target is NULL",
                           "moduleid": "MOD_RUNTIME_DECONFIG",
                           "reasoncode": "RC_NULL_TARGET",
                      },
            0xE0506: {    "devdesc": "I2C master entity path doesn't exist.",
                           "moduleid": "EEPROM_GET_MASTERTARGET",
                           "reasoncode": "EEPROM_MASTER_PATH_ERROR",
                           "userdata1[00:31]":  "Attribute Chip Type Enum",
                           "userdata1[32:63]":  "HUID of target",
                           "userdata2":  "Compressed Entity Path",
                      },
            0xE0606: {    "devdesc": "Master path target is null.",
                           "moduleid": "EEPROM_GET_MASTERTARGET",
                           "reasoncode": "EEPROM_TARGET_NULL",
                           "userdata1[00:31]":  "Eeprom role",
                           "userdata1[32:63]":  "HUID of target",
                           "userdata2":  "Compressed Entity Path",
                      },
            0xF0306: {    "devdesc": "Interrupt resource provider not initialized yet.",
                           "moduleid": "INTR::MOD_INTR_ENABLE_PSI_INTR",
                           "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                           "userdata1":  "MSG_INTR_ENABLE_PSI_INTR",
                           "userdata2":  "0",
                      },
            0x101306: {    "devdesc": "MDMT could not be found",
                           "moduleid": "TOD_SAVEREGS_HWP",
                           "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                           "userdata1":  "Topology type (primary/secondary)",
                      },
            0x110706: {    "devdesc": "Message queue already registered with mailbox using a different queue.",
                           "moduleid": "MBOX::MOD_MBOXREGISTER",
                           "reasoncode": "MBOX::RC_ALREADY_REGISTERED",
                           "userdata1":  "queue_id_t queueId",
                           "userdata2":  "0",
                      },
            0x110D06: {    "devdesc": "Mailbox service is not available now.",
                           "moduleid": "MBOX::MOD_MBOXREGISTER",
                           "reasoncode": "MBOX::RC_MBOX_SERVICE_NOT_READY",
                           "userdata1":  "queue_id_t queueId",
                           "userdata2":  "0",
                      },
            0x160406: {    "devdesc": "Unable to load LID via host interface.",
                           "moduleid": "Util::UTIL_LIDMGR_RT",
                           "reasoncode": "Util::UTIL_LIDMGR_RC_FAIL",
                           "userdata1":  "Return code from lid_load call.",
                           "userdata2":  "Lid number",
                      },
            0x160906: {    "devdesc": "Unable to unload LID via host interface.",
                           "moduleid": "Util::UTIL_LIDMGR_RT",
                           "reasoncode": "Util::UTIL_LIDMGR_UNLOAD_RC_FAIL",
                           "userdata1":  "Return code from lid_unload call.",
                      },
            0x160A06: {    "devdesc": "Unable to find Lid.",
                           "moduleid": "Util::UTIL_LIDMGR_RT",
                           "reasoncode": "Util::UTIL_LIDMGR_NOT_FOUND",
                           "userdata1":  "Lid number",
                           "userdata2[00:07]":  "Lid is in reserved memory",
                           "userdata2[08:15]":  "Lid is in VFS",
                           "userdata2[16:23]":  "lid_load interface is available",
                           "userdata2[24:31]":  "PAYLOAD_KIND",
                      },
            0x170606: {    "devdesc": "cpu_master_winkle returned an error",
                           "moduleid": "MOD_HOST_ACTIVATE_BOOT_CORE",
                           "reasoncode": "RC_FAIL_BOOT_CORE_WINKLE",
                           "userdata1":  "return code from cpu_master_winkle",
                           "userdata2":  "Fused core indicator",
                      },
            0x171F06: {    "devdesc": "activate_boot_core> Could not find a target for the boot-fused core",
                           "moduleid": "ISTEP::MOD_HOST_ACTIVATE_BOOT_CORE",
                           "reasoncode": "ISTEP::RC_NO_FUSED_CORE_TARGET",
                           "userdata1":  "Boot-fused core id",
                           "userdata2":  "Boot-fused processor chip huid",
                      },
            0x1A0406: {    "devdesc": "Section is not valid in standalone mode",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_GET_STANDALONE_SECTION",
                           "reasoncode": "RUNTIME::RC_INVALID_STANDALONE",
                           "userdata1":  "Section ID",
                           "userdata2":  "Section Instance Number",
                      },
            0x1E0906: {    "devdesc": "Invalid target used to read security switch register.",
                           "moduleid": "SECUREBOOT::MOD_SECURE_READ_REG",
                           "reasoncode": "SECUREBOOT::RC_SECURE_BAD_TARGET",
                           "userdata1":  "Target pointer value",
                           "userdata2":  "Target's HUID or 0 if null target pointer.",
                      },
            0x1E1006: {    "devdesc": "Processor security register read too early",
                           "moduleid": "SECUREBOOT::MOD_SECURE_READ_REG",
                           "reasoncode": "SECUREBOOT::RC_PROC_NOT_SCOMABLE",
                           "userdata1":  "Use XSCOM bool",
                           "userdata2":  "Target's HUID",
                      },
            0x1E1106: {    "devdesc": "Processor security register read too early",
                           "moduleid": "SECUREBOOT::MOD_SECURE_READ_REG",
                           "reasoncode": "SECUREBOOT::RC_DEVICE_READ_ERR",
                           "userdata1":  "Actual size read",
                           "userdata2":  "Expected size read",
                      },
            0x220106: {    "devdesc": "updateProcessorSbeSeeproms> Error from mm_alloc_block",
                           "moduleid": "SBE_CREATE_SBE_VMM_SPACE",
                           "reasoncode": "SBE_ALLOC_BLOCK_FAIL",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_alloc_block",
                      },
            0x220206: {    "devdesc": "updateProcessorSbeSeeproms> Error from mm_set_permission on creation",
                           "moduleid": "SBE_CREATE_SBE_VMM_SPACE",
                           "reasoncode": "SBE_SET_PERMISSION_FAIL",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_set_permission",
                      },
            0x240606: {    "devdesc": "create_altmaster_objects> Alt-master object already exists",
                           "moduleid": "LPC::MOD_CREATE_ALTMASTER",
                           "reasoncode": "LPC::RC_ALTMASTER_EXISTS",
                           "userdata1":  "Requested proc",
                           "userdata2":  "<unused>",
                      },
            0x240706: {    "devdesc": "create_altmaster_objects> Cannot create another object using master proc",
                           "moduleid": "LPC::MOD_CREATE_ALTMASTER",
                           "reasoncode": "LPC::RC_CANT_USE_MASTER",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x240806: {    "devdesc": "create_altmaster_objects> Cannot create another object using master sentinel",
                           "moduleid": "LPC::MOD_CREATE_ALTMASTER",
                           "reasoncode": "LPC::RC_CANT_USE_SENTINEL",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x264506: {    "devdesc": "No OCC target found for proc Target,",
                           "moduleid": "HTMGT_MOD_PROCESS_OCC_RESET",
                           "reasoncode": "HTMGT_RC_INVALID_PARAMETER",
                           "userdata1":  "Processor HUID",
                      },
            0x285006: {    "devdesc": "Unsecure Memory Region Does Not Exist",
                           "moduleid": "SBEIO_MEM_REGION",
                           "reasoncode": "SBEIO_MEM_REGION_DOES_NOT_EXIST",
                           "userdata1":  "Starting Address of Unsecure Memory Region",
                           "userdata2":  "Number of Unsecure Memory Regions",
                      },
            0x285106: {    "devdesc": "Attempt To Open Too Many Unsecure Memory Regions",
                           "moduleid": "SBEIO_MEM_REGION",
                           "reasoncode": "SBEIO_EXCEEDS_MAXIMUM_MEM_REGIONS",
                           "userdata1":  "Current Count of Unsecure Memory Regions",
                           "userdata2":  "Maximum Number of Unsecure Memomory Regions",
                      },
            0x2BAD06: {    "devdesc": "The system (or node, if multi-node system) is configured in the hardware (via processor secure jumpers) to enable Secure Boot, and the system's/node's TPM required policy is configured to require at least one functional boot processor TPM in order to boot with Trusted Boot enabled. Therefore, the system (or node, if multi-node system) will terminate due to lack of functional boot processor TPM.",
                           "moduleid": "MOD_TPM_VERIFYFUNCTIONAL",
                           "reasoncode": "RC_TPM_NOFUNCTIONALTPM_FAIL",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x332206: {    "devdesc": "Invalid amount of child cores found on a proc",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_CHILDREN_TEST",
                           "reasoncode": "fapi2::RC_INVALID_CHILD_COUNT",
                           "userdata1[0:31]":  "Expected Child Count",
                           "userdata1[32:63]":  "Actual Child Count",
                           "userdata2":  "Parent HUID",
                      },
            0x350506: {    "devdesc": "I2C master entity path doesn't exist.",
                           "moduleid": "NVDIMM_GETI2CMASTERTARGET",
                           "reasoncode": "NVDIMM_I2C_MASTER_PATH_ERROR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Compressed Entity Path",
                      },
            0x350606: {    "devdesc": "I2C master path target is null.",
                           "moduleid": "NVDIMM_GETI2CMASTERTARGET",
                           "reasoncode": "NVDIMM_TARGET_NULL",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Compressed Entity Path",
                      },
            0x410D06: {    "devdesc": "There was an error while parsing a field in this UCD flash image's command line",
                           "moduleid": "UCD_RC::MOD_CONVERT_STRING_TO_OP",
                           "reasoncode": "UCD_RC::UCD_FIELD_PARSE_ERROR",
                           "userdata1[0:31]":  "HUID of UCD Target",
                           "userdata1[32:63]":  "The Field Location of the parse error",
                           "userdata2":  "The order of this operation",
                      },
            0x420f06: {    "devdesc": "The Odyssey code update FSM requested to deconfigure this OCMB.",
                           "moduleid": "MOD_ODY_UPD_FSM",
                           "reasoncode": "ODY_UPD_DECONFIGURE_OCMB",
                           "userdata1[0:31]":  "The OCMB's HUID",
                           "userdata1[32:39]":  "OCMB state.update_performed",
                           "userdata1[40:47]":  "OCMB state.golden_boot_performed",
                           "userdata1[48:55]":  "OCMB state.ocmb_boot_side",
                           "userdata1[56:63]":  "OCMB state.ocmb_fw_up_to_date",
                           "userdata2[0:15]":  "The OCMB event that caused this transition",
                           "userdata2[16:31]":  "The OCMB event pattern that the event matched",
                           "userdata2[32:39]":  "The state pattern in the FSM table that the state matched (State.update_performed)",
                           "userdata2[40:47]":  "Matching state pattern's State.golden_boot_performed",
                           "userdata2[48:55]":  "Matching state pattern's State.ocmb_boot_side",
                           "userdata2[56:63]":  "Matching state pattern's ocmb_fw_up_to_date",
                      },
            0x421006: {    "devdesc": "The Odyssey code update FSM experienced an internal error; this is a code bug.",
                           "moduleid": "MOD_ODY_UPD_FSM",
                           "reasoncode": "ODY_UPD_INTERNAL_ERROR",
                           "userdata1[0:31]":  "The OCMB's HUID",
                           "userdata1[32:39]":  "OCMB state.update_performed",
                           "userdata1[40:47]":  "OCMB state.golden_boot_performed",
                           "userdata1[48:55]":  "OCMB state.ocmb_boot_side",
                           "userdata1[56:63]":  "OCMB state.ocmb_fw_up_to_date",
                           "userdata2[0:15]":  "The OCMB event that caused this transition",
                           "userdata2[16:31]":  "The OCMB event pattern that the event matched",
                           "userdata2[32:39]":  "The state pattern in the FSM table that the state matched (State.update_performed)",
                           "userdata2[40:47]":  "Matching state pattern's State.golden_boot_performed",
                           "userdata2[48:55]":  "Matching state pattern's State.ocmb_boot_side",
                           "userdata2[56:63]":  "Matching state pattern's ocmb_fw_up_to_date",
                      },
            0x421106: {    "devdesc": "The OCMB firmware is up to date but invalid.",
                           "moduleid": "MOD_ODY_UPD_FSM",
                           "reasoncode": "ODY_UPD_BAD_FIRMWARE",
                           "userdata1[0:31]":  "The OCMB's HUID",
                           "userdata1[32:39]":  "OCMB state.update_performed",
                           "userdata1[40:47]":  "OCMB state.golden_boot_performed",
                           "userdata1[48:55]":  "OCMB state.ocmb_boot_side",
                           "userdata1[56:63]":  "OCMB state.ocmb_fw_up_to_date",
                           "userdata2[0:15]":  "The OCMB event that caused this transition",
                           "userdata2[16:31]":  "The OCMB event pattern that the event matched",
                           "userdata2[32:39]":  "The state pattern in the FSM table that the state matched (State.update_performed)",
                           "userdata2[40:47]":  "Matching state pattern's State.golden_boot_performed",
                           "userdata2[48:55]":  "Matching state pattern's State.ocmb_boot_side",
                           "userdata2[56:63]":  "Matching state pattern's ocmb_fw_up_to_date",
                      },
            0x421206: {    "devdesc": "An Odyssey OCMB was updated during the boot.",
                           "moduleid": "MOD_ODY_UPD_FSM",
                           "reasoncode": "ODY_UPD_FIRMWARE_UPDATED",
                           "userdata1[0:31]":  "The OCMB's HUID",
                           "userdata1[32:39]":  "OCMB state.update_performed",
                           "userdata1[40:47]":  "OCMB state.golden_boot_performed",
                           "userdata1[48:55]":  "OCMB state.ocmb_boot_side",
                           "userdata1[56:63]":  "OCMB state.ocmb_fw_up_to_date",
                           "userdata2[0:15]":  "The OCMB event that caused this transition",
                           "userdata2[16:31]":  "The OCMB event pattern that the event matched",
                           "userdata2[32:39]":  "The state pattern in the FSM table that the state matched (State.update_performed)",
                           "userdata2[40:47]":  "Matching state pattern's State.golden_boot_performed",
                           "userdata2[48:55]":  "Matching state pattern's State.ocmb_boot_side",
                           "userdata2[56:63]":  "Matching state pattern's ocmb_fw_up_to_date",
                      },
            0x421306: {    "devdesc": "The Odyssey code update FSM experienced an internal error; this is a code bug.",
                           "moduleid": "MOD_ODY_UPD_FSM",
                           "reasoncode": "ODY_UPD_UNKNOWN_STATE",
                           "userdata1[0:31]":  "The OCMB's HUID",
                           "userdata1[32:39]":  "OCMB state.update_performed",
                           "userdata1[40:47]":  "OCMB state.golden_boot_performed",
                           "userdata1[48:55]":  "OCMB state.ocmb_boot_side",
                           "userdata1[56:63]":  "OCMB state.ocmb_fw_up_to_date",
                           "userdata2[0:15]":  "The OCMB event that caused this transition",
                           "userdata2[16:31]":  "The OCMB event pattern that the event matched",
                           "userdata2[32:39]":  "The state pattern in the FSM table that the state matched (State.update_performed)",
                           "userdata2[40:47]":  "Matching state pattern's State.golden_boot_performed",
                           "userdata2[48:55]":  "Matching state pattern's State.ocmb_boot_side",
                           "userdata2[56:63]":  "Matching state pattern's ocmb_fw_up_to_date",
                      },
            0x450606: {    "devdesc": "An unsupported engine was provided to attempt presence detection on.",
                           "moduleid": "SPI::SPI_PRESENCE",
                           "reasoncode": "SPI::SPI_PRESENCE_UNSUPPORTED_ENGINE",
                           "userdata1":  "Target HUID of the SPI Master",
                           "userdata2":  "SPI Engine",
                      },
            0x470106: {    "devdesc": "Software problem, failed to decode PLDM message",
                           "moduleid": "MOD_DECODE_RESPONSE",
                           "reasoncode": "RC_MSG_DECODE_FAIL",
                           "userdata1":  "RC returned from decode function",
                           "userdata2":  "PLDM Header",
                      },
            0x900506: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_PCIA_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x10C07: {    "devdesc": "The size of the buffer is insufficient to contain the MI keyword",
                           "moduleid": "ERRL_GET_MARKER_LID_MI_KEYWORD",
                           "reasoncode": "ERRL_MARKER_LID_INVALID_BUFFER_SIZE",
                           "userdata1":  "Size of the buffer the caller provided",
                           "userdata2":  "Size of MI keyword, the minimum size needed for the buffer",
                      },
            0x10D07: {    "devdesc": "The size of the buffer is not 0 but buffer is a nullptr",
                           "moduleid": "ERRL_GET_MARKER_LID_MI_KEYWORD",
                           "reasoncode": "ERRL_MARKER_LID_INVALID_BUFFER",
                           "userdata1":  "Size of the buffer the caller provided",
                           "userdata2":  "unused",
                      },
            0x31D07: {    "devdesc": "Invalid mode parm for wakeup operation.",
                           "moduleid": "SCOM_HANDLE_SPECIAL_WAKEUP",
                           "reasoncode": "SCOM_INVALID_WAKEUP_PARM",
                           "userdata1":  "Wakeup Argument",
                           "userdata2":  "Input Target",
                      },
            0x32207: {    "devdesc": "Supplied core chiplet had an invalid ECO mode setting.",
                           "moduleid": "SCOM_HANDLE_SPECIAL_WAKEUP",
                           "reasoncode": "SCOM_INVALID_ECO_TYPE",
                           "userdata1":  "ECO mode",
                           "userdata2[0:31]":  "Core huid",
                      },
            0x40107: {    "devdesc": "XSCom access error",
                           "moduleid": "XSCOM_DO_OP",
                           "reasoncode": "XSCOM_STATUS_ERR",
                           "userdata1":  "HMER value (piberr in bits 21:23)",
                           "userdata2":  "XSCom address",
                      },
            0x70607: {    "devdesc": "Error was found in I2C status register. Check userdata to determine what the error was.",
                           "moduleid": "I2C_CHECK_FOR_ERRORS",
                           "reasoncode": "I2C_HW_ERROR_FOUND",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Master Target",
                           "userdata2[0:7]":  "Master Engine",
                           "userdata2[8:15]":  "Master Port",
                           "userdata2[16:31]":  "Slave Device Address",
                           "userdata2[32:47]":  "Bus Speed",
                           "userdata2[48:63]":  "Bit Rate Devisor",
                      },
            0x70B07: {    "devdesc": "a NACK Error was found in the I2C status register.",
                           "moduleid": "I2C_CHECK_FOR_ERRORS",
                           "reasoncode": "I2C_NACK_ONLY_FOUND",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Master Target",
                           "userdata2[0:7]":  "Master Engine",
                           "userdata2[8:15]":  "Master Port",
                           "userdata2[16:31]":  "Slave Device Address",
                           "userdata2[32:47]":  "Bus Speed",
                           "userdata2[48:63]":  "Bit Rate Devisor",
                      },
            0x70C07: {    "devdesc": "Bus Arbitration Lost Error was found in the I2C status register.",
                           "moduleid": "I2C_CHECK_FOR_ERRORS",
                           "reasoncode": "I2C_ARBITRATION_LOST_ONLY_FOUND",
                           "userdata1[0:31]":  "Status Register Value",
                           "userdata1[32:63]":  "Master Target",
                           "userdata2[0:7]":  "Master Engine",
                           "userdata2[8:15]":  "Master Port",
                           "userdata2[16:31]":  "Slave Device Address",
                           "userdata2[32:47]":  "Bus Speed",
                           "userdata2[48:63]":  "Bit Rate Devisor",
                      },
            0x90707: {    "devdesc": "verifyCfamAccessTarget> Attempt to access CFAM on the master processor",
                           "moduleid": "fapi2::MOD_FAPI2_VERIFYCFAMACCESSTARGET",
                           "reasoncode": "fapi2::RC_INVALID_TARG_TARGET",
                           "userdata1":  "CFAM Address",
                           "userdata2":  "HUID of input target",
                      },
            0xB0207: {    "devdesc": "The eyecatch value observed in PNOR does not match the expected value of PNOR_TARG_EYE_CATCHER and therefore the contents of the Attribute PNOR section are unable to be parsed.",
                           "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                           "reasoncode": "TARG_RC_BAD_EYECATCH",
                           "userdata1":  "Observed Header Eyecatch Value",
                           "userdata2":  "Expected Eyecatch Value",
                      },
            0xB1507: {    "devdesc": "While attempting to unmap a virtual addr for our targeting information the kernel returned an error",
                           "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                           "reasoncode": "TARG_RC_MM_BLOCK_UNMAP_FAIL",
                           "userdata1":  "return code",
                           "userdata2":  "Unmap virtual address",
                      },
            0xB1D07: {    "devdesc": "Mapping TOC section failed",
                           "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                           "reasoncode": "TARG_RC_TOC_MAPPING_FAIL",
                           "userdata1":  "Table of Contents pointer",
                      },
            0xB1E07: {    "devdesc": "Attribute region found was below the table of contents region",
                           "moduleid": "TARG_PARSE_ATTR_SECT_HEADER",
                           "reasoncode": "TARG_RC_RSVD_MEM_LABEL_FAIL",
                           "userdata1":  "attribute region address",
                           "userdata2":  "toc region",
                      },
            0xE0507: {    "devdesc": "buildEepromRecordHeader invalid master target",
                           "moduleid": "EEPROM_CACHE_EEPROM",
                           "reasoncode": "EEPROM_MASTER_PATH_ERROR",
                           "userdata1":  "HUID of target we want to cache",
                           "userdata2":  "Type of EEPROM we are caching",
                      },
            0xE0C07: {    "devdesc": "buildEepromRecordHeader invalid mux target",
                           "moduleid": "EEPROM_CACHE_EEPROM",
                           "reasoncode": "EEPROM_I2C_MUX_PATH_ERROR",
                           "userdata1":  "HUID of target we want to cache",
                           "userdata2":  "Type of EEPROM we are caching",
                      },
            0xE1407: {    "devdesc": "Attempting to overwrite eeprom cache with a buffer that is larger than the eeprom device itself",
                           "moduleid": "EEPROM_CACHE_EEPROM",
                           "reasoncode": "EEPROM_INVALID_LENGTH",
                           "userdata1[0:63]":  "Size of buffer",
                           "userdata2[0:31]":  "HUID of Master",
                           "userdata2[32:39]":  "Port (or 0xFF)",
                           "userdata2[40:47]":  "Engine",
                           "userdata2[48:55]":  "devAddr    (or byte 0 of offset_KB)",
                           "userdata2[56:63]":  "mux_select (or byte 1 of offset_KB)",
                      },
            0x100507: {    "devdesc": "Error: Unsupported bus type was detected Possible Causes: Invalid bus configuration in targeting, or getBusPort method has not been updated to support all the bus type on a given system. Resolution:Development team should be contacted.",
                           "moduleid": "TOD_LOG_UNSUPPORTED_BUSTYPE",
                           "reasoncode": "TOD_UNSUPPORTED_BUSTYPE",
                           "userdata1":  "Bus type that is not currently supported",
                      },
            0x110207: {    "devdesc": "Message from FSP to HB MBOX of an unknown type",
                           "moduleid": "MBOX::MOD_MBOXSRV_FSP_MSG",
                           "reasoncode": "MBOX::RC_INVALID_MESSAGE_TYPE",
                           "userdata1":  "msg type",
                           "userdata2":  "msg queue id",
                      },
            0x110507: {    "devdesc": "Message from FSP. An invalid message queue ID or mesage type was sent to the FSP.",
                           "moduleid": "MOD_MBOXSRV_FSP_MSG",
                           "reasoncode": "RC_INVALID_QUEUE",
                           "userdata1":  "msg queue",
                           "userdata2":  "msg type",
                      },
            0x160B07: {    "devdesc": "Error returned from mm_remove_pages when evicting lid from memory.",
                           "moduleid": "Util::UTIL_LIDMGR_CLEANUP",
                           "reasoncode": "Util::UTIL_LIDMGR_MM_FAIL",
                           "userdata1[00:31]":  "LID ID",
                           "userdata1[32:63]":  "rc from mm_remove_pages",
                           "userdata2":  "Virtual address being removed",
                      },
            0x1A0807: {    "devdesc": "There is no host data for specified kind of payload",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION",
                           "reasoncode": "RUNTIME::RC_INVALID_PAYLOAD_KIND",
                           "userdata1":  "ATTR_PAYLOAD_KIND",
                           "userdata2":  "Requested Section",
                      },
            0x1A0C07: {    "devdesc": "Unknown section requested",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION",
                           "reasoncode": "RUNTIME::RC_INVALID_SECTION",
                           "userdata1":  "Section Id",
                           "userdata2":  "<unused>",
                      },
            0x1A2007: {    "devdesc": "Invalid instance requested for Reserved Hostboot Memory section",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_GETHOSTDATASECTION",
                           "reasoncode": "RUNTIME::RC_INVALID_RHB_INSTANCE",
                           "userdata1":  "Requested instance (reserved mem array index)",
                           "userdata2":  "maximum array index allowed",
                      },
            0x1E0707: {    "devdesc": "Container component ID verification failed.",
                           "moduleid": "Bootloader::MOD_BOOTLOADER_VERIFY_COMP_ID",
                           "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "First 4 bytes of observed component ID",
                           "userdata2[32:63]":  "Last 4 bytes of observed component ID",
                      },
            0x1E0907: {    "devdesc": "Invalid target used to write security register.",
                           "moduleid": "SECUREBOOT::MOD_SECURE_WRITE_REG",
                           "reasoncode": "SECUREBOOT::RC_SECURE_BAD_TARGET",
                           "userdata1":  "Target pointer value",
                           "userdata2":  "Target's HUID or 0 if NULL target pointer",
                      },
            0x1E0F07: {    "devdesc": "Device write did not return expected size",
                           "moduleid": "SECUREBOOT::MOD_SECURE_WRITE_REG",
                           "reasoncode": "SECUREBOOT::RC_DEVICE_WRITE_ERR",
                           "userdata1":  "Actual size written",
                           "userdata2":  "Expected size written",
                      },
            0x220207: {    "devdesc": "updateProcessorSbeSeeproms> Error from mm_set_permission on cleanup",
                           "moduleid": "SBE_CLEANUP_SBE_VMM_SPACE",
                           "reasoncode": "SBE_SET_PERMISSION_FAIL",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_set_permission",
                      },
            0x220307: {    "devdesc": "updateProcessorSbeSeeproms> mm_remove_pages RELEASE failed",
                           "moduleid": "SBE_CLEANUP_SBE_VMM_SPACE",
                           "reasoncode": "SBE_REMOVE_PAGES_FAIL",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_remove_pages",
                      },
            0x240907: {    "devdesc": "readLPC> Unexpected target",
                           "moduleid": "LPC::MOD_READLPC",
                           "reasoncode": "LPC::RC_BAD_TARGET",
                           "userdata1[00:31]":  "Requested target",
                           "userdata1[00:31]":  "Current alt target",
                           "userdata2":  "Read address",
                      },
            0x261507: {    "devdesc": "OCCs will be reset",
                           "moduleid": "HTMGT_MOD_OCC_RESET",
                           "reasoncode": "HTMGT_RC_OCC_RESET",
                           "userdata1":  "reset reason | safe src",
                           "userdata2":  "safe instance | huid",
                      },
            0x261607: {    "devdesc": "OCC reset threshold reached. Leaving OCCs in reset state",
                           "moduleid": "HTMGT_MOD_OCC_RESET",
                           "reasoncode": "HTMGT_RC_OCC_CRIT_FAILURE",
                           "userdata1":  "return code triggering safe mode",
                           "userdata2":  "OCC instance",
                      },
            0x270A07: {    "devdesc": "Timeout waiting for TPM to enter command ready state.",
                           "moduleid": "TPMDD_POLLFORCOMMMANDREADY",
                           "reasoncode": "TPM_TIMEOUT",
                           "userdata1":  "TPM",
                           "userdata2":  "STS Reg",
                      },
            0x2BAE07: {    "devdesc": "Command failure performing PCR extend.",
                           "moduleid": "MOD_TPM_CMD_PCREXTEND",
                           "reasoncode": "RC_TPM_COMMAND_FAIL",
                           "userdata1":  "responseCode",
                           "userdata2":  "dataSize",
                      },
            0x2BAF07: {    "devdesc": "PCR Extend invalid arguments detected",
                           "moduleid": "MOD_TPM_CMD_PCREXTEND",
                           "reasoncode": "RC_TPM_INVALID_ARGS",
                           "userdata1":  "Digest Ptr",
                           "userdata2[0:15]":  "Full Digest Size 1",
                           "userdata2[16:31]":  "Full Digest Size 2",
                           "userdata2[32:63]":  "PCR",
                      },
            0x350A07: {    "devdesc": "NVDIMM register offset out of bound",
                           "moduleid": "NVDIMM_CROSSESNVDIMMPAGEBOUNDARY",
                           "reasoncode": "NVDIMM_INVALID_OFFSET",
                           "userdata1":  "Offset attempting to access",
                           "userdata2":  "Requested buffer length",
                      },
            0x370D07: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                           "moduleid": "MMIO::MOD_CHECK_OCMB_ERROR",
                           "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                           "userdata1":  "OCMB HUID",
                           "userdata2":  "OCMB chip ID",
                      },
            0x450707: {    "devdesc": "There was a detected mismatch between what Hostboot thought the status of the root ctrl register was set to and what it actually was set to. See user detail sections for reg contents.",
                           "moduleid": "SPI::SPI_CHECK_FOR_MUX_MISMATCH",
                           "reasoncode": "SPI::SPI_MUX_MISMATCH_FOUND",
                           "userdata1[00:31]":  "Proc HUID",
                           "userdata1[32:63]":  "1 = use PIB, 0 = use FSI",
                           "userdata2":  "Root Control Register contents",
                      },
            0x470507: {    "devdesc": "Software problem, PLDM response message was too short",
                           "moduleid": "MOD_MAKE_PLDM_REQUEST",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Length of response in bytes",
                           "userdata2":  "First bytes of PLDM header",
                      },
            0x10E08: {    "devdesc": "Unable to make firmware request",
                           "moduleid": "ERRL_NOTIFY_HYPERVISOR_OF_RESOURCE_GARD",
                           "reasoncode": "ERRL_RT_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "PLID of error log that called out the resource",
                           "userdata2":  "HUID of the resource",
                      },
            0x10F08: {    "devdesc": "Unable to get resource ID for runtime guard, this is a code bug",
                           "moduleid": "ERRL_NOTIFY_HYPERVISOR_OF_RESOURCE_GARD",
                           "reasoncode": "ERRL_RT_GARD_RESOURCE_ID_NOT_FOUND",
                           "userdata1":  "PLID of error log that called out the resource",
                           "userdata2":  "HUID of the resource",
                      },
            0xB0508: {    "devdesc": "The attribute resource provider was unable to satisfy a message request from the VMM portion of the kernel.  This was either due to an address outside a valid range or a message request that is invalid for the attribute section containing the address.",
                           "moduleid": "TARG_MSG_SERVICE_TASK",
                           "reasoncode": "TARG_RC_ATTR_MSG_FAIL",
                           "userdata1":  "Virtual Address",
                           "userdata2":  "(Msg Type << 32) | Section #",
                      },
            0xF0708: {    "devdesc": "Error mapping in memory",
                           "moduleid": "INTR::MOD_INTR_INIT_MPIPLAREA",
                           "reasoncode": "INTR::RC_CANNOT_MAP_MEMORY",
                           "userdata1":  "physical address",
                           "userdata2":  "Size",
                      },
            0x100608: {    "devdesc": "Error: Unsupported bus port was detected for the specified bus type. Possible Causes: Invalid bus configuration in targeting, or getBusPort method has not been updated to support all the possible port for a particular type of bus on the system. Resolution:Development team should be contacted.",
                           "moduleid": "TOD_LOG_UNSUPPORTED_BUSPORT",
                           "reasoncode": "TOD_UNSUPPORTED_BUSPORT",
                           "userdata1":  "Bus port that is not currently supported",
                           "userdata2":  "Bus Type for which the unsupported port has been reported",
                      },
            0x110E08: {    "devdesc": "Failed to allocate a DMA buffer. Message dropped.",
                           "moduleid": "MOD_MBOXSRV_SENDMSG",
                           "reasoncode": "RC_INVALID_DMA_LENGTH",
                           "userdata1":  "DMA length requested",
                           "userdata2[00:31]":  "message type",
                           "userdata2[32:63]":  "queue_id",
                      },
            0x111008: {    "devdesc": "Mailbox is disabled, message dropped.",
                           "moduleid": "MOD_MBOXSRV_SENDMSG",
                           "reasoncode": "RC_MAILBOX_DISABLED",
                           "userdata1":  "queue_id",
                           "userdata2":  "message type",
                      },
            0x1A0B08: {    "devdesc": "HDAT data block falls outside valid range",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_VERIFY_HDAT_ADDRESS",
                           "reasoncode": "RUNTIME::RC_INVALID_ADDRESS",
                           "userdata1":  "Start of address range under test",
                           "userdata2":  "Size of address range under test",
                      },
            0x220E08: {    "devdesc": "Invalid Boot SEEPROM Side Found",
                           "moduleid": "SBE_GET_TARGET_INFO_STATE",
                           "reasoncode": "SBE_INVALID_SEEPROM_SIDE",
                           "userdata1":  "Temporary Current Side",
                           "userdata2":  "SBE State Current Side",
                      },
            0x221A08: {    "devdesc": "Unexpected HW Key Hash found in SBE Image",
                           "moduleid": "SBE_GET_TARGET_INFO_STATE",
                           "reasoncode": "SBE_MISMATCHED_HW_KEY_HASH",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "HW Key Hash found in Customized SBE Image",
                           "userdata2[32:63]":  "Expected HW Key Hash",
                      },
            0x222108: {    "devdesc": "Unexpected Secure Version found in SBE Image",
                           "moduleid": "SBE_GET_TARGET_INFO_STATE",
                           "reasoncode": "SBE_MISMATCHED_SECURE_VERSION",
                           "userdata1":  "Target HUID",
                           "userdata2[0:15]":  "Secure Version found in Customized SBE Image",
                           "userdata2[16:31]":  "Expected Secure Version",
                           "userdata2[32:47]":  "Minimum Secure Version",
                           "userdata2[48:63]":  "ATTR_SECURE_VERSION_LOCKIN_POLICY",
                      },
            0x222208: {    "devdesc": "Invalid Security Setting where lesser Secure Version found from securely loaded PNOR partitions",
                           "moduleid": "SBE_GET_TARGET_INFO_STATE",
                           "reasoncode": "SBE_SECUREBOOT_ESCAPE",
                           "userdata1[0:31]":  "Security Setting (isSecurityEnabled)",
                           "userdata1[32:63]":  "Secure Version Lock-in Policy",
                           "userdata2[0:31]":  "Minimum Secure Version",
                           "userdata2[32:63]":  "Incoming Secure Version from PNOR",
                      },
            0x240908: {    "devdesc": "writeLPC> Unexpected target",
                           "moduleid": "LPC::MOD_WRITELPC",
                           "reasoncode": "LPC::RC_BAD_TARGET",
                           "userdata1[00:31]":  "Requested target",
                           "userdata1[00:31]":  "Current alt target",
                           "userdata2":  "Write address",
                      },
            0x261608: {    "devdesc": "Homer pointer is nullptr, unable to communicate with the OCCs. Leaving system in safe mode.",
                           "moduleid": "HTMGT_MOD_BUILD_OCCS",
                           "reasoncode": "HTMGT_RC_OCC_CRIT_FAILURE",
                           "userdata1":  "OCC Instance",
                           "userdata2":  "homer virtual address",
                      },
            0x262408: {    "devdesc": "No functional OCCs were found",
                           "moduleid": "HTMGT_MOD_BUILD_OCCS",
                           "reasoncode": "HTMGT_RC_OCC_UNAVAILABLE",
                           "userdata1":  "functional processor count",
                      },
            0x270A08: {    "devdesc": "Timeout waiting for TPM data available.",
                           "moduleid": "TPMDD_POLLFORDATAAVAIL",
                           "reasoncode": "TPM_TIMEOUT",
                           "userdata1":  "TPM",
                           "userdata2":  "STS Reg",
                      },
            0x2BAE08: {    "devdesc": "Command failure performing PCR read.",
                           "moduleid": "MOD_TPM_CMD_PCRREAD",
                           "reasoncode": "RC_TPM_COMMAND_FAIL",
                           "userdata1":  "responseCode",
                           "userdata2":  "dataSize",
                      },
            0x2BAF08: {    "devdesc": "pcr read invalid arguments",
                           "moduleid": "MOD_TPM_CMD_PCRREAD",
                           "reasoncode": "RC_TPM_INVALID_ARGS",
                           "userdata1":  "Digest Ptr",
                           "userdata2[0:31]":  "Full Digest Size",
                           "userdata2[32:63]":  "PCR",
                      },
            0x341008: {    "devdesc": "LPC error detected.",
                           "moduleid": "Bootloader::MOD_PNORACC_FINDTOC",
                           "reasoncode": "Bootloader::RC_LPC_ERR",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2[0:31]":  "LPC error/status",
                           "userdata2[32:63]":  "Error code",
                      },
            0x341108: {    "devdesc": "TOC not found",
                           "moduleid": "Bootloader::MOD_PNORACC_FINDTOC",
                           "reasoncode": "Bootloader::RC_TOC_NOT_FOUND_ERR",
                           "userdata1[0:15]":  "TI_WITH_SRC",
                           "userdata1[16:31]":  "TI_BOOTLOADER",
                           "userdata1[32:63]":  "Failing address = 0",
                           "userdata2":  "MMIO Address",
                      },
            0x370D08: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                           "moduleid": "MMIO::MOD_DETERMINE_CALLOUTS",
                           "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                           "userdata1":  "OCMB HUID",
                           "userdata2":  "OCMB chip ID",
                      },
            0x470108: {    "devdesc": "Software problem, failed to decode PLDM getPDR request",
                           "moduleid": "MOD_HANDLE_GET_PDR",
                           "reasoncode": "RC_MSG_DECODE_FAIL",
                           "userdata1":  "RC returned from decode function",
                      },
            0x31209: {    "devdesc": "SCOM runtime interface not linked.",
                           "moduleid": "SCOM_RT_SEND_SCOM_TO_HYP",
                           "reasoncode": "SCOM_RUNTIME_INTERFACE_ERR",
                           "userdata1":  "SCOM Op Type",
                           "userdata2":  "SCOM address",
                      },
            0x31509: {    "devdesc": "Error from Hypervisor attempting SCOM",
                           "moduleid": "SCOM_RT_SEND_SCOM_TO_HYP",
                           "reasoncode": "SCOM_RUNTIME_HYP_ERR",
                           "userdata1[0:31]":  "Hypervisor return code",
                           "userdata1[32:63]":  "Chipid sent to Hyp",
                           "userdata2[0:63]":  "SCOM address",
                           "userdata2[1]":  "SCOM Op Type: 0=read, 1=write",
                      },
            0x60909: {    "devdesc": "PNOR startup task returned an error.",
                           "moduleid": "PNOR::MOD_PNORRP_DIDSTARTUPFAIL",
                           "reasoncode": "PNOR::RC_BAD_STARTUP_RC",
                           "userdata1":  "return code pnorrp",
                           "userdata2":  "return code spnorrp",
                      },
            0x70A09: {    "devdesc": "ATTR_I2C_BUS_SPEED_ARRAY not found",
                           "moduleid": "I2C_SEND_SLAVE_STOP",
                           "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                           "userdata1":  "Target for the attribute",
                           "userdata2":  "<UNUSED>",
                      },
            0xA0B09: {    "devdesc": "FsiDD::genFullFsiAddr> Master Type is not supported",
                           "moduleid": "FSI::MOD_FSIDD_GENFULLFSIADDR",
                           "reasoncode": "FSI::RC_FSI_NOT_SUPPORTED",
                           "userdata1":  "Target of FSI Operation",
                           "userdata2[32:39]":  "Physical Node of FSI Master processor",
                           "userdata2[40:47]":  "Physical Position of FSI Master processor",
                           "userdata2[48:55]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER)",
                           "userdata2[56:63]":  "Slave link/port number",
                      },
            0xA0C09: {    "devdesc": "FsiDD::genFullFsiAddr> Cannot chain 2 masters",
                           "moduleid": "FSI::MOD_FSIDD_GENFULLFSIADDR",
                           "reasoncode": "FSI::RC_INVALID_FSI_PATH_1",
                           "userdata1[0:31]":  "Target of FSI Operation",
                           "userdata1[32:63]":  "Target's FSI Master Chip",
                           "userdata2[0:7]":  "Physical Node of FSI Master processor  [target's master]",
                           "userdata2[8:15]":  "Physical Position of FSI Master processor  [target's master]",
                           "userdata2[16:23]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER)  [target's master]",
                           "userdata2[24:31]":  "Slave link/port number  [target's master]",
                           "userdata2[32:39]":  "Physical Node of FSI Master processor  [master's master]",
                           "userdata2[40:47]":  "Physical Position of FSI Master processor  [master's master]",
                           "userdata2[48:55]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER)  [master's master]",
                           "userdata2[56:63]":  "Slave link/port number  [master's master]",
                      },
            0xA0D09: {    "devdesc": "FsiDD::genFullFsiAddr> Invalid master type for the target's master",
                           "moduleid": "FSI::MOD_FSIDD_GENFULLFSIADDR",
                           "reasoncode": "FSI::RC_INVALID_FSI_PATH_2",
                           "userdata1[0:31]":  "Target of FSI Operation",
                           "userdata1[32:63]":  "Target's FSI Master Chip",
                           "userdata2[0:7]":  "Physical Node of FSI Master processor  [target's master]",
                           "userdata2[8:15]":  "Physical Position of FSI Master processor  [target's master]",
                           "userdata2[16:23]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER)  [target's master]",
                           "userdata2[24:31]":  "Slave link/port number  [target's master]",
                           "userdata2[32:39]":  "Physical Node of FSI Master processor  [master's master]",
                           "userdata2[40:47]":  "Physical Position of FSI Master processor  [master's master]",
                           "userdata2[48:55]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER)  [master's master]",
                           "userdata2[56:63]":  "Slave link/port number  [master's master]",
                      },
            0xB0309: {    "devdesc": "While attempting to allocate a virtual memory block for an attribute section, the kernel returned an error.",
                           "moduleid": "TARG_CREATE_VMM_SECTIONS",
                           "reasoncode": "TARG_RC_MM_BLOCK_FAIL",
                           "userdata1":  "vAddress attempting to allocate.",
                           "userdata2":  "RC from kernel.",
                      },
            0xE0109: {    "devdesc": "cacheEeprom invalid op type",
                           "moduleid": "EEPROM_CACHE_PERFORM_OP",
                           "reasoncode": "EEPROM_INVALID_OPERATION",
                           "userdata1[0:31]":  "Op Type that was invalid",
                           "userdata1[32:63]":  "Eeprom Role",
                           "userdata2":  "Offset we are attempting to perfrom op on",
                      },
            0xE0809: {    "devdesc": "cacheEeprom invalid op type",
                           "moduleid": "EEPROM_CACHE_PERFORM_OP",
                           "reasoncode": "EEPROM_OVERFLOW_ERROR",
                           "userdata1":  "Length of Operation",
                           "userdata2":  "Offset we are attempting to read/write",
                      },
            0xE0D09: {    "devdesc": "Tried to lookup eeprom not in cache",
                           "moduleid": "EEPROM_CACHE_PERFORM_OP",
                           "reasoncode": "EEPROM_NOT_IN_CACHE",
                           "userdata1[0:31]":  "Op Type",
                           "userdata1[32:63]":  "Eeprom Role",
                           "userdata2":  "Offset we are attempting to read/write",
                      },
            0xE2309: {    "devdesc": "Attempted operation on entry marked invalid",
                           "moduleid": "EEPROM_CACHE_PERFORM_OP",
                           "reasoncode": "EEPROM_ENTRY_MARKED_INVALID",
                           "userdata1[0:31]":  "Op Type",
                           "userdata1[32:63]":  "Eeprom Role",
                           "userdata2":  "Offset we are attempting to read/write",
                      },
            0xF0709: {    "devdesc": "Error mapping in memory",
                           "moduleid": "INTR::MOD_INTR_SYNC_NODES",
                           "reasoncode": "INTR::RC_CANNOT_MAP_MEMORY",
                           "userdata1":  "physical address",
                           "userdata2":  "Block size requested",
                      },
            0xF0F09: {    "devdesc": "Remote node is failing to fill out its IPC section or this node is failing to read it.",
                           "moduleid": "INTR::MOD_INTR_SYNC_NODES",
                           "reasoncode": "INTR::RC_NODE_SYNC_TIMEOUT",
                           "userdata1[0:31]":  "This Node",
                           "userdata1[0:31]":  "Remote Node we canot get HRMOR from",
                           "userdata2":  "Remote IPC Address",
                      },
            0x100709: {    "devdesc": "Error: Creation of TOD topology required when TOD HW is running",
                           "moduleid": "TOD_SETUP",
                           "reasoncode": "TOD_INVALID_ACTION",
                           "userdata1":  "ChipTOD logic HW state, 1=running, zero otherwise",
                      },
            0x110F09: {    "devdesc": "Could not register mailbox message queue",
                           "moduleid": "MBOX::MOD_MBOXSRV_INIT",
                           "reasoncode": "MBOX::RC_KERNEL_REG_FAILED",
                           "userdata1":  "rc from msq_q_register",
                      },
            0x1A0A09: {    "devdesc": "NACA data doesn't seem right",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_FINDSPIRA",
                           "reasoncode": "RUNTIME::RC_BAD_NACA",
                           "userdata1":  "Mainstore address of NACA",
                           "userdata2[0:31]":  "Payload Base Address",
                           "userdata2[32:63]":  "Payload Kind",
                      },
            0x1A1609: {    "devdesc": "Could not find a valid SPIRA of any type",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_FINDSPIRA",
                           "reasoncode": "RUNTIME::RC_NO_SPIRA",
                           "userdata1[0:31]":  "RC for Legacy SPIRA fail",
                           "userdata1[32:64]":  "EID for Legacy SPIRA fail",
                           "userdata2[0:31]":  "RC for SPIRA-S fail",
                           "userdata2[32:64]":  "EID for SPIRA-S fail",
                      },
            0x1E0709: {    "devdesc": "Container's component ID does not match expected component ID",
                           "moduleid": "SECUREBOOT::MOD_SECURE_VERIFY_COMPONENT",
                           "reasoncode": "SECUREBOOT::RC_ROM_VERIFY",
                      },
            0x220F09: {    "devdesc": "ECC or Data Miscompare Fail Reading Back SBE Version Information",
                           "moduleid": "SBE_GET_SEEPROM_INFO",
                           "reasoncode": "SBE_ECC_FAIL",
                           "userdata1[0:15]":  "ECC Status",
                           "userdata1[16:31]":  "SEEPROM Side",
                           "userdata1[32:47]":  "RC on Data Compare with ECC",
                           "userdata1[48:63]":  "<unused>",
                           "userdata2[0:31]":  "Size - No Ecc",
                           "userdata2[32:63]":  "Size - ECC",
                      },
            0x240B09: {    "devdesc": "An XSCOM LPC operation timed out; resetting LPC complex to recover.",
                           "moduleid": "LPC::MOD_XSCOMLPC_LPCRW",
                           "reasoncode": "LPC::RC_LPC_TIMEOUT",
                           "userdata1[00:15]":  "Read (1) or write (0)",
                           "userdata1[16:31]":  "Size of request, in bytes",
                           "userdata1[32:63]":  "Effective LPC space address",
                           "userdata2":  "Status register",
                      },
            0x260F09: {    "devdesc": "SET_MODE not supported (use BMC)",
                           "moduleid": "HTMGT_MOD_PASS_THRU",
                           "reasoncode": "HTMGT_RC_NO_SUPPORT",
                           "userdata1":  "command data[0-7]",
                           "userdata2":  "command data length",
                      },
            0x262309: {    "devdesc": "Invalid pass thru command",
                           "moduleid": "HTMGT_MOD_PASS_THRU",
                           "reasoncode": "HTMGT_RC_INVALID_DATA",
                           "userdata1":  "command data[0-7]",
                           "userdata2":  "command data length",
                      },
            0x262409: {    "devdesc": "Specified OCC not available",
                           "moduleid": "HTMGT_MOD_PASS_THRU",
                           "reasoncode": "HTMGT_RC_OCC_UNAVAILABLE",
                           "userdata1":  "command data[0-7]",
                           "userdata2":  "command data length",
                      },
            0x264509: {    "devdesc": "Invalid pass thru command data",
                           "moduleid": "HTMGT_MOD_PASS_THRU",
                           "reasoncode": "HTMGT_RC_INVALID_PARAMETER",
                           "userdata1":  "command data[0-7]",
                           "userdata2":  "command data length",
                      },
            0x270809: {    "devdesc": "TPM expected less data during FIFO write",
                           "moduleid": "TPMDD_WRITEFIFO",
                           "reasoncode": "TPM_OVERFLOW_ERROR",
                           "userdata1":  "TPM",
                           "userdata2[0:31]":  "Current byte",
                           "userdata2[32:63]":  "Buffer Length      (in Bytes)",
                      },
            0x270909: {    "devdesc": "TPM expected more data during FIFO write",
                           "moduleid": "TPMDD_WRITEFIFO",
                           "reasoncode": "TPM_UNDERFLOW_ERROR",
                           "userdata1":  "TPM",
                           "userdata2[0:31]":  "Current Byte",
                           "userdata2[32:63]":  "Buffer Length      (in Bytes)",
                      },
            0x270A09: {    "devdesc": "TPM timeout writing to FIFO",
                           "moduleid": "TPMDD_WRITEFIFO",
                           "reasoncode": "TPM_TIMEOUT",
                           "userdata1":  "TPM",
                           "userdata2[0:31]":  "Current Byte",
                           "userdata2[32:63]":  "Buffer Length      (in Bytes)",
                      },
            0x2BA909: {    "devdesc": "Unmarshal error while replaying tpm log.",
                           "moduleid": "MOD_TPM_REPLAY_LOG",
                           "reasoncode": "RC_TPM_UNMARSHALING_FAIL",
                           "userdata1":  "Starting address of event that caused error",
                           "userdata2":  "0",
                      },
            0x332509: {    "devdesc": "Unable to resolve other end of bus",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_OTHER_END",
                           "reasoncode": "fapi2::RC_FOUND_TOO_MANY_PEERS",
                           "userdata1[0:31]":  "Unused",
                           "userdata1[32:63]":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x332609: {    "devdesc": "Unable to resolve other end of bus",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_OTHER_END",
                           "reasoncode": "fapi2::RC_FOUND_NO_PEERS",
                           "userdata1[0:31]":  "Unused",
                           "userdata1[32:63]":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x370809: {    "devdesc": "OCMB MMIO read failed",
                           "moduleid": "MMIO::MOD_DETERMINE_EXP_CALLOUTS",
                           "reasoncode": "MMIO::RC_BAD_MMIO_READ",
                           "userdata1":  "OCMB huid",
                           "userdata2":  "Address offset",
                      },
            0x470109: {    "devdesc": "Software problem, failed to decode PLDM message",
                           "moduleid": "MOD_SEND_PLDM_RESPONSE",
                           "reasoncode": "RC_MSG_DECODE_FAIL",
                           "userdata1":  "RC returned from decode function",
                           "userdata2":  "PLDM Header (3 bytes)",
                      },
            0x470809: {    "devdesc": "Software problem, failed to send PLDM resp over MCTP",
                           "moduleid": "MOD_SEND_PLDM_RESPONSE",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "Return code returned by MCTP::send_message",
                           "userdata2":  "Header of pldm request",
                      },
            0x900509: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_SLCA_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x3010A: {    "devdesc": "The provided address is over 32 bits long which makes it invalid.",
                           "moduleid": "SCOM_OP_SANITY_CHECK",
                           "reasoncode": "SCOM_INVALID_ADDR",
                           "userdata1":  "Scom address",
                           "userdata2":  "Scom target",
                      },
            0x3160A: {    "devdesc": "Buffer size is less than allowed or NULL data buffer",
                           "moduleid": "SCOM_OP_SANITY_CHECK",
                           "reasoncode": "SCOM_INVALID_DATA_BUFFER",
                           "userdata1[0:31]":  "Buffer size",
                           "userdata1[32:63]":  "Minimum allowed buffer size",
                           "userdata2":  "Scom address",
                      },
            0x3170A: {    "devdesc": "Scom invalid operation type",
                           "moduleid": "SCOM_OP_SANITY_CHECK",
                           "reasoncode": "SCOM_INVALID_OP_TYPE",
                           "userdata1":  "Operation type",
                           "userdata2":  "Scom address",
                      },
            0x61E0A: {    "devdesc": "mm_remove_pages failed",
                           "moduleid": "PNOR::MOD_PNORRP_FLUSH",
                           "reasoncode": "PNOR::RC_MM_REMOVE_PAGES_FAILED",
                           "userdata1":  "section Id",
                           "userdata2":  "RC",
                      },
            0x6310A: {    "devdesc": "Error parsing secure header",
                           "moduleid": "SECUREBOOT::MOD_SECURE_CONT_HDR_PARSE",
                           "reasoncode": "PNOR::RC_BAD_SECURE_MAGIC_NUM",
                           "userdata1":  "Actual magic number",
                           "userdata2":  "Expected magic number",
                      },
            0x70A0A: {    "devdesc": "ATTR_I2C_BUS_SPEED_ARRAY not found",
                           "moduleid": "I2C_PROCESS_ACTIVE_MASTERS",
                           "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                           "userdata1":  "Target for the attribute",
                           "userdata2[0:31]":  "Operation",
                           "userdata2[32:64]":  "Type",
                      },
            0x90D0A: {    "devdesc": "Attempt to read an MVPD field using an invalid record",
                           "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                           "reasoncode": "RC_INVALID_RECORD",
                           "userdata1":  "Record enumerator",
                      },
            0x90E0A: {    "devdesc": "Attempt to read an MVPD field using an invalid keyword",
                           "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                           "reasoncode": "RC_INVALID_KEYWORD",
                           "userdata1":  "Keyword enumerator",
                      },
            0x9100A: {    "devdesc": "Attempt to read an MVPD field using an invalid record",
                           "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                           "reasoncode": "RC_RECORD_OUT_OF_BOUNDS",
                           "userdata1":  "Record enumerator",
                           "userdata2[0:31]":  "Index",
                           "userdata2[32:63]":  "Max Index",
                      },
            0x9110A: {    "devdesc": "Attempt to read an MVPD field using an invalid keyword",
                           "moduleid": "MOD_FAPI2_MVPD_ACCESS",
                           "reasoncode": "RC_KEYWORD_OUT_OF_BOUNDS",
                           "userdata1":  "Keyword enumerator",
                           "userdata2[0:31]":  "Index",
                           "userdata2[32:63]":  "Max Index",
                      },
            0xA110A: {    "devdesc": "FsiDD::checkForErrors> Error discovered in MAEB",
                           "moduleid": "FSI::MOD_FSIDD_CHECKFORERRORS",
                           "reasoncode": "FSI::RC_ERROR_IN_MAEB",
                           "userdata1[0:7]":  "Physical Node of FSI Master processor",
                           "userdata1[8:15]":  "Physical Position of FSI Master processor",
                           "userdata1[16:23]":  "FSI Master type (0=MFSI,1=CMFSI)",
                           "userdata1[24:31]":  "Slave link/port number",
                           "userdata2":  "MAEB from master",
                      },
            0xB140A: {    "devdesc": "PnorRP::getSectionInfo> Skipping attribute override because of secureboot enablement",
                           "moduleid": "TARG_APPLY_ATTR_OVER",
                           "reasoncode": "TARG_RC_APPLY_ATTR_OVER_NOT_ALLOWED",
                      },
            0xC160A: {    "devdesc": "To enforce all target types have partial good rules and logic, all targets must be included in the rules table. A combination of target type, chip type, and chip unit produced an empty set of logic for the target.",
                           "moduleid": "HWAS::MOD_FIND_RULES_FOR_TARGET",
                           "reasoncode": "HWAS::RC_NO_PG_LOGIC",
                           "userdata1":  "target type attribute",
                           "userdata2":  "HUID of the target",
                      },
            0xC190A: {    "devdesc": "A rule called for the use of the MRW's supplied CHIPLET_ID for an index into the PG vector. That value has gone unexpectedly out-of-range.",
                           "moduleid": "HWAS::MOD_FIND_RULES_FOR_TARGET",
                           "reasoncode": "HWAS::RC_PG_INDEX_INVALID",
                           "userdata1":  "PG Index value",
                           "userdata2":  "HUID of the target",
                      },
            0xE0F0A: {    "devdesc": "invalidateCache failed to find cache in map",
                           "moduleid": "EEPROM_INVALIDATE_CACHE",
                           "reasoncode": "EEPROM_CACHE_NOT_FOUND_IN_MAP",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:31]":  "size of eeprom",
                           "userdata2[32:63]":  "access type",
                      },
            0xE100A: {    "devdesc": "invalidateCache failed to find cache in pnor",
                           "moduleid": "EEPROM_INVALIDATE_CACHE",
                           "reasoncode": "EEPROM_CACHE_NOT_FOUND_IN_PNOR",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:31]":  "size of eeprom",
                           "userdata2[32:63]":  "access type",
                      },
            0xF070A: {    "devdesc": "Error mapping in memory",
                           "moduleid": "INTR::MOD_INTR_SYNC_ADDNODE",
                           "reasoncode": "INTR::RC_CANNOT_MAP_MEMORY",
                           "userdata1":  "physical address",
                           "userdata2":  "Size",
                      },
            0x11050A: {    "devdesc": "Message from FSP. Message not claimed by any Hostboot service.",
                           "moduleid": "MBOX::MOD_MBOXSRC_UNCLAIMED",
                           "reasoncode": "MBOX::RC_INVALID_QUEUE",
                           "userdata1":  "msg queue",
                           "userdata2":  "msg type",
                      },
            0x160C0A: {    "devdesc": "The size requested is too large for the TCE table",
                           "moduleid": "Util::UTIL_TCE_ALLOCATE",
                           "reasoncode": "Util::UTIL_TCE_INVALID_SIZE",
                           "userdata1[0:31]":  "Number of TCEs Needed",
                           "userdata2":  "Size of the address space trying to get TCEs",
                      },
            0x160D0A: {    "devdesc": "The Physical Address for the TCE entry is not page aligned.",
                           "moduleid": "Util::UTIL_TCE_ALLOCATE",
                           "reasoncode": "Util::UTIL_TCE_ADDR_NOT_ALIGNED",
                           "userdata1":  "Address to start TCE",
                           "userdata2":  "Size of the address space trying to get TCEs for.",
                      },
            0x16100A: {    "devdesc": "Requested size is too large to fit into TCE Table",
                           "moduleid": "Util::UTIL_TCE_ALLOCATE",
                           "reasoncode": "Util::UTIL_TCE_NOT_ENOUGH_FREE_ENTRIES",
                           "userdata1[0:31]":  "Number of TCEs Needed",
                           "userdata2":  "Size of address space TCEs are tying to map to",
                      },
            0x16120A: {    "devdesc": "The starting address was previously allocated",
                           "moduleid": "Util::UTIL_TCE_ALLOCATE",
                           "reasoncode": "Util::UTIL_TCE_PREVIOUSLY_ALLOCATED",
                           "userdata1":  "Starting Address",
                           "userdata2":  "Starting TCE position in TCE Table",
                      },
            0x1A080A: {    "devdesc": "There is no host data for specified kind of payload",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL",
                           "reasoncode": "RUNTIME::RC_INVALID_PAYLOAD_KIND",
                           "userdata1":  "ATTR_PAYLOAD_KIND",
                           "userdata2":  "Requested Section",
                      },
            0x1A0C0A: {    "devdesc": "Unknown section requested",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_UPDATE_SECTION_ACTUAL",
                           "reasoncode": "RUNTIME::RC_INVALID_SECTION",
                           "userdata1":  "Section Id",
                           "userdata2":  "<unused>",
                      },
            0x22100A: {    "devdesc": "Bad Path in decisionUpdateTree: cur=PERM/DIRTY",
                           "moduleid": "SBE_DECISION_TREE",
                           "reasoncode": "SBE_PERM_SIDE_DIRTY_BAD_PATH",
                           "userdata1":  "System Situation",
                           "userdata2":  "Update Actions",
                      },
            0x221C0A: {    "devdesc": "Bad Path in decisionUpdateTree: cur=DIRTY, alt=CLEAN",
                           "moduleid": "SBE_DECISION_TREE",
                           "reasoncode": "SBE_BOOT_SIDE_DIRTY_BAD_PATH",
                           "userdata1":  "System Situation",
                           "userdata2":  "Update Actions",
                      },
            0x24050A: {    "devdesc": "Caller passed unsupported reset level into XscomLpc::hwReset()",
                           "moduleid": "LPC::MOD_XSCOMLPC_HWRESET",
                           "reasoncode": "LPC::RC_UNSUPPORTED_OPERATION",
                           "userdata1":  "Unsupported reset level parameter",
                      },
            0x26260A: {    "devdesc": "Failed to send all required config data",
                           "moduleid": "HTMGT_MOD_SEND_OCC_CONFIG",
                           "reasoncode": "HTMGT_RC_OCC_UNEXPECTED_STATE",
                           "userdata1":  "requested config format",
                      },
            0x26B90A: {    "devdesc": "Power cap calculations have completed",
                           "moduleid": "HTMGT_MOD_SEND_OCC_CONFIG",
                           "reasoncode": "HTMGT_RC_PCAP_CALC_COMPLETE",
                           "userdata1":  "None",
                      },
            0x27080A: {    "devdesc": "TPM provided more data during FIFO read then buffer space provided",
                           "moduleid": "TPMDD_READFIFO",
                           "reasoncode": "TPM_OVERFLOW_ERROR",
                           "userdata1":  "TPM",
                           "userdata2[0:15]":  "Operation",
                           "userdata2[16:31]":  "Current Byte",
                           "userdata2[32:63]":  "Buffer Length      (in Bytes)",
                      },
            0x270A0A: {    "devdesc": "TPM timeout reading from FIFO",
                           "moduleid": "TPMDD_READFIFO",
                           "reasoncode": "TPM_TIMEOUT",
                           "userdata1":  "TPM",
                           "userdata2[0:15]":  "Operation",
                           "userdata2[16:31]":  "Current Byte",
                           "userdata2[32:63]":  "Buffer Length      (in Bytes)",
                      },
            0x27140A: {    "devdesc": "Either the available STS from TPM is wrong or responseSize was wrong",
                           "moduleid": "TPMDD_READFIFO",
                           "reasoncode": "TPM_EXTRA_DATA_AVAILABLE",
                           "userdata1":  "TPM",
                           "userdata2[0:31]":  "responseSize returned in first data bytes",
                           "userdata2[32:63]":  "Buffer Length (in Bytes)",
                      },
            0x28520A: {    "devdesc": "SBE booted from unexpected side.",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_BOOTED_UNEXPECTED_SIDE",
                           "userdata1[00:07]":  "Current SBE boot side",
                           "userdata1[08:15]":  "Current SBE measurement side",
                           "userdata1[16:31]":  "Switch Sides Count",
                           "userdata1[32:63]":  "Switch Sides Count Mseeprom",
                           "userdata2[00:31]":  "Current Action",
                           "userdata2[32:63]":  "HUID of proc",
                      },
            0x28530A: {    "devdesc": "There is no recovery action on the SBE. We're deconfiguring this proc",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_NO_RECOVERY_ACTION",
                           "userdata1":  "SBE current error",
                           "userdata2":  "HUID of proc",
                      },
            0x285C0A: {    "devdesc": "We have already flipped seeprom sides once and we should not have attempted to flip again",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_EXCEED_MAX_SIDE_SWITCHES",
                           "userdata1[00:31]":  "Switch Sides Count",
                           "userdata1[32:63]":  "Switch Sides Count Mseeprom",
                           "userdata2[00:31]":  "Current Action",
                           "userdata2[32:63]":  "HUID of proc",
                      },
            0x285D0A: {    "devdesc": "We have already done the max attempts for the current seeprom side. For some reason we are attempting to do another boot.",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_EXCEED_MAX_SIDE_BOOTS",
                           "userdata1":  "# of boots attempts on this side",
                           "userdata2":  "HUID of proc",
                      },
            0x285E0A: {    "devdesc": "There was a problem attempting to boot SBE on the slave processor",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_SLAVE_FAILED_TO_BOOT",
                           "userdata1":  "Bool to describe if FFDC data is found",
                           "userdata2":  "HUID of proc",
                      },
            0x28620A: {    "devdesc": "Attempted to swap seeprom sides and boot using hreset but version mismatched",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_SEEPROM_VERSION_MISMATCH",
                           "userdata1":  "HUID of proc",
                           "userdata2":  "unused",
                      },
            0x28660A: {    "devdesc": "We failed trying to READ the MVPD",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_MVPD_READ_FAILURE",
                           "userdata1":  "l_mvpdSbKeyword.flags",
                           "userdata2":  "HUID of proc",
                      },
            0x28670A: {    "devdesc": "We failed trying to READ the MVPD",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_MVPD_WRITE_FAILURE",
                           "userdata1":  "l_mvpdSbKeyword.flags",
                           "userdata2":  "HUID of proc",
                      },
            0x286C0A: {    "devdesc": "Deconfiguring processor due to clock guard",
                           "moduleid": "SBEIO_EXTRACT_RC_HANDLER",
                           "reasoncode": "SBEIO_RECONFIG_WITH_CLOCK_GUARD",
                           "userdata1":  "SBE current error",
                           "userdata2":  "HUID of proc",
                      },
            0x2BB10A: {    "devdesc": "msg_sendrecv() failed",
                           "moduleid": "MOD_TPM_PCREXTEND",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msq_sendrecv()",
                      },
            0x2BB20A: {    "devdesc": "msg_send() failed",
                           "moduleid": "MOD_TPM_PCREXTEND",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "rc from msq_send()",
                      },
            0x37040A: {    "devdesc": "Unsupported buffer length for SCOM offset. Only lengths 4 and 8 supported.",
                           "moduleid": "MMIO::RT_OCMB_MMIO_PERFORM_OP",
                           "reasoncode": "MMIO::RC_INCORRECT_BUFFER_LENGTH",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset",
                           "userdata2[0:31]":  "Operation Type",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x37050A: {    "devdesc": "Invalid offset, requested address was out of range for a MMIO operation.",
                           "moduleid": "MMIO::RT_OCMB_MMIO_PERFORM_OP",
                           "reasoncode": "MMIO::RC_INVALID_OFFSET",
                           "userdata1[0:31]":  "Target huid",
                           "userdata1[32:63]":  "Data Offset",
                           "userdata2[0:31]":  "Operation Type",
                           "userdata2[32:63]":  "Buffer Length",
                      },
            0x47050A: {    "devdesc": "Software problem, PLDM message is too short",
                           "moduleid": "MOD_HANDLE_INBOUND_REQ",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "The length of the short PLDM message",
                           "userdata2":  "Minimum length of a PLDM message",
                      },
            0x47090A: {    "devdesc": "Software problem, unknown PLDM message category",
                           "moduleid": "MOD_HANDLE_INBOUND_REQ",
                           "reasoncode": "RC_INVALID_MSG_CATEGORY",
                           "userdata1":  "The unsupported category of the PLDM message",
                           "userdata2":  "PLDM message header",
                      },
            0x470A0A: {    "devdesc": "Software problem, unrecognized PLDM command",
                           "moduleid": "MOD_HANDLE_INBOUND_REQ",
                           "reasoncode": "RC_INVALID_COMMAND",
                           "userdata1":  "Unrecognized PLDM command",
                           "userdata2":  "PLDM message category",
                      },
            0x470B0A: {    "devdesc": "Software problem, invalid PLDM request type",
                           "moduleid": "MOD_HANDLE_INBOUND_REQ",
                           "reasoncode": "RC_INVALID_MSG_TYPE",
                           "userdata1":  "Unrecognized PLDM message type",
                           "userdata2":  "PLDM message header",
                      },
            0x470C0A: {    "devdesc": "Software problem, cannot unpack PLDM header",
                           "moduleid": "MOD_HANDLE_INBOUND_REQ",
                           "reasoncode": "RC_INVALID_HEADER",
                           "userdata1":  "Return code from unpack routine",
                           "userdata2":  "PLDM message header",
                      },
            0x47250A: {    "devdesc": "Software problem, Hostboot got a PLDM request before we were ready to handle it.",
                           "moduleid": "MOD_HANDLE_INBOUND_REQ",
                           "reasoncode": "RC_NOT_READY",
                           "userdata1":  "Unrecognized PLDM command",
                           "userdata2":  "PLDM message category",
                      },
            0x90050A: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_IPLPARMS_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x6210B: {    "devdesc": "Non ECC protected section is passed to fixECC",
                           "moduleid": "PNOR::MOD_PNORRP_FIXECC",
                           "reasoncode": "PNOR::RC_NON_ECC_PROTECTED_SECTION",
                           "userdata1":  "Section ID",
                           "userdata2":  "0",
                      },
            0x70A0B: {    "devdesc": "ATTR_I2C_BUS_SPEED_ARRAY not found",
                           "moduleid": "I2C_FORCE_RESET_AND_UNLOCK",
                           "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                           "userdata1":  "Target for the attribute",
                           "userdata2":  "<UNUSED>",
                      },
            0xA0E0B: {    "devdesc": "FsiDD::verifyPresent> Target was never detected during FSI Init",
                           "moduleid": "FSI::MOD_FSIDD_VERIFYPRESENT",
                           "reasoncode": "FSI::RC_TARGET_NEVER_DETECTED",
                           "userdata1[0:31]":  "HUID of Master Proc",
                           "userdata1[32:63]":  "Detected Slaves",
                           "userdata2[0:31]":  "HUID of FSI Target",
                           "userdata2[32:63]":  "HUID of FSI Master",
                      },
            0xB160B: {    "devdesc": "Invalid enum value for attribute.",
                           "moduleid": "TARGETING::TARG_HANDLE_ENUM_CHECK_FAILURE",
                           "reasoncode": "TARGETING::TARG_RC_ATTRIBUTE_ENUM_CHECK_FAIL",
                           "userdata1[00:31]":  "Target's HUID",
                           "userdata1[32:63]":  "Attribute ID",
                           "userdata2":  "Invalid value",
                      },
            0xC1A0B: {    "devdesc": "Informational log that contains information about which targets, procs, and entries in the processor module vpd PG vector are marked as nonfunctional.  This is NOT an indication of a problem in this part.",
                           "moduleid": "MOD_DISCOVER_TARGETS",
                           "reasoncode": "RC_PARTIAL_GOOD_INFORMATION",
                           "userdata1":  "Processor HUID",
                           "userdata2":  "None",
                      },
            0xE0F0B: {    "devdesc": "resolveSource failed to find cache in map during runtime",
                           "moduleid": "EEPROM_RESOLVE_SOURCE",
                           "reasoncode": "EEPROM_CACHE_NOT_FOUND_IN_MAP",
                           "userdata1[0:31]":  "master Huid",
                           "userdata1[32:39]":  "port (or 0xFF)",
                           "userdata1[40:47]":  "engine",
                           "userdata1[48:55]":  "devAddr of eeprom slave   (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "muxSelect of eeprom slave (or byte 1 offset_KB)",
                           "userdata2[0:31]":  "size of eeprom",
                      },
            0xF030B: {    "devdesc": "Interrupt resource provider not initialized yet.",
                           "moduleid": "INTR::MOD_INTR_ADDHBNODE",
                           "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                           "userdata1":  "MSG_INTR_ADD_HBNODE",
                           "userdata2":  "hbNode to add",
                      },
            0x10080B: {    "devdesc": "Error: Erroneous TOD configuration Possible Causes: Programming issue Resolution: Development team should be contacted.",
                           "moduleid": "TOD_LOG_INVALID_CONFIG",
                           "reasoncode": "TOD_INVALID_CONFIG",
                           "userdata1":  "The problematic configuration ( Primary/Secondary)",
                      },
            0x11050B: {    "devdesc": "Error sending IPC message",
                           "moduleid": "MBOX::MOD_MBOX_SEND",
                           "reasoncode": "MBOX::RC_INVALID_QUEUE",
                           "userdata1":  "returncode from msg_send()",
                           "userdata2":  "q_handle",
                      },
            0x11110B: {    "devdesc": "An invalid node was specified",
                           "moduleid": "MBOX::MOD_MBOX_SEND",
                           "reasoncode": "MBOX::RC_IPC_INVALID_NODE",
                           "userdata1":  "The destination queue id",
                           "userdata2":  "The node",
                      },
            0x160C0B: {    "devdesc": "The size requested is too large based on the startingAddress the space avilable in the table",
                           "moduleid": "Util::UTIL_TCE_DEALLOCATE",
                           "reasoncode": "Util::UTIL_TCE_INVALID_SIZE",
                           "userdata1[0:31]":  "starting index",
                           "userdata1[32:63]":  "number of TCEs needed for this request",
                           "userdata2":  "Number of Entries Current TCE Table Supports",
                      },
            0x16110B: {    "devdesc": "The deallocate went across TCE Allocate space.",
                           "moduleid": "Util::UTIL_TCE_DEALLOCATE",
                           "reasoncode": "Util::UTIL_TCE_ENTRY_NOT_CONTIGUOUS",
                           "userdata1":  "Starting address of the TCEs to be deallocated",
                           "userdata2":  "Size of the address space to be deallocated",
                      },
            0x17000B: {    "devdesc": "Request given to load payload into mirrored memory, but no mirrored memory exists at that location.",
                           "moduleid": "ISTEP::MOD_EXIT_CACHE_CONTAINED",
                           "reasoncode": "ISTEP::RC_NO_MIRRORED_MEMORY",
                           "userdata1":  "Mirrored Memory Address",
                           "userdata2":  "0",
                      },
            0x17010B: {    "devdesc": "Failure extending memory to after exiting cache contained mode.",
                           "moduleid": "ISTEP::MOD_EXIT_CACHE_CONTAINED",
                           "reasoncode": "ISTEP::RC_MM_EXTEND_FAILED",
                           "userdata1":  "rc from mm_extend",
                           "userdata2":  "<UNUSED>",
                      },
            0x171E0B: {    "devdesc": "There is no functional memory",
                           "moduleid": "ISTEP::MOD_EXIT_CACHE_CONTAINED",
                           "reasoncode": "ISTEP::RC_NO_FUNCTIONAL_MEMORY",
                           "userdata1":  "Bottom of memory",
                           "userdata2":  "Top of memory",
                      },
            0x1A050B: {    "devdesc": "Error mapping in memory",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_MAPREGION",
                           "reasoncode": "RUNTIME::RC_CANNOT_MAP_MEMORY",
                           "userdata1":  "Starting Address",
                           "userdata2":  "Size",
                      },
            0x1E0C0B: {    "devdesc": "Error parsing secure header; requested copy size starting at current offset would exceed the header size or the max transaction size.  Reinstall boot firmware.",
                           "moduleid": "SECUREBOOT::MOD_SECURE_CONT_HDR_CPY_INC",
                           "reasoncode": "SECUREBOOT::RC_CONT_HDR_NO_SPACE",
                           "userdata1[00:31]":  "Total bytes read so far",
                           "userdata1[32:63]":  "Requested size to copy",
                           "userdata2[00:31]":  "Max header size",
                           "userdata2[32:63]":  "Max transaction size",
                      },
            0x221E0B: {    "devdesc": "Did not find the HBBL ID signature in customized image",
                           "moduleid": "SBE_CUSTOMIZE_IMG",
                           "reasoncode": "SBE_HBBL_ID_NOT_FOUND",
                           "userdata1":  "i_SourceBfrLen",
                           "userdata2":  "Unused",
                      },
            0x22250B: {    "devdesc": "Unsuccessful in creating Customized SBE Image. Unable to get the desired minimum cores.",
                           "moduleid": "SBE_CUSTOMIZE_IMG",
                           "reasoncode": "SBE_INSUFFICIENT_SPACE_FOR_REQUESTED_CORES",
                           "userdata1[0:31]":  "HUID of target",
                           "userdata1[32:63]":  "The desired min cores",
                           "userdata2[0:15]":  "The number of cores successfully gathered",
                           "userdata2[16:31]":  "Max system cores available",
                           "userdata2[32:63]":  "Core mask of cores gathered",
                      },
            0x22260B: {    "devdesc": "Desired minimum cores exceeds max cores available on system",
                           "moduleid": "SBE_CUSTOMIZE_IMG",
                           "reasoncode": "SBE_DESIRED_MIN_CORES_EXCEED_MAX_CORES",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "Desired minimum cores",
                           "userdata2[32:63]":  "Max cores available on system",
                      },
            0x240A0B: {    "devdesc": "Error(s) found in LPCHC LPCIRQ Status Register when performing an LPC operation.",
                           "moduleid": "LPC::MOD_XSCOMLPC_CHECKFORLPCERRORS",
                           "reasoncode": "LPC::RC_LPCHC_ERROR",
                           "userdata1":  "LPCHC Error Status Register",
                           "userdata2":  "Reset Level",
                      },
            0x26050B: {    "devdesc": "Set of OCC state failed",
                           "moduleid": "HTMGT_MOD_WAIT_FOR_CHECKPOINT",
                           "reasoncode": "HTMGT_RC_OCC_NOT_READY",
                           "userdata1":  "OCC instance",
                           "userdata2":  "last OCC checkpoint",
                      },
            0x270A0B: {    "devdesc": "TPM timeout waiting for stsValid",
                           "moduleid": "TPMDD_READSTSREGVALID",
                           "reasoncode": "TPM_TIMEOUT",
                           "userdata1":  "TPM",
                           "userdata2[0:31]":  "Operation",
                           "userdata2[32:63]":  "STS Reg",
                      },
            0x2BB30B: {    "devdesc": "msg_respond() failed",
                           "moduleid": "MOD_TPM_TPMDAEMON",
                           "reasoncode": "RC_MSGRESPOND_FAIL",
                           "userdata1":  "rc from msq_respond()",
                      },
            0x2BBA0B: {    "devdesc": "Unable to reach the TPM",
                           "moduleid": "MOD_TPM_TPMDAEMON",
                           "reasoncode": "RC_UNREACHABLE_TPM",
                           "userdata1":  "TPM HUID or nullptr",
                      },
            0x2BBB0B: {    "devdesc": "Attempted to request a random number that is bigger than the max a TPM can provide",
                           "moduleid": "MOD_TPM_TPMDAEMON",
                           "reasoncode": "RC_RAND_NUM_TOO_BIG",
                           "userdata1":  "The size of requested random number",
                           "userdata2":  "The maximum random number size",
                      },
            0x33220B: {    "devdesc": "Invalid amount of child cores found on a proc",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_CHILDREN_FILTER_TEST",
                           "reasoncode": "fapi2::RC_INVALID_CHILD_COUNT",
                           "userdata1[0:31]":  "Expected Child Count",
                           "userdata1[32:63]":  "Actual Child Count",
                           "userdata2":  "Parent HUID",
                      },
            0x37080B: {    "devdesc": "OCMB MMIO read failed",
                           "moduleid": "MMIO::MOD_DETERMINE_ODY_CALLOUTS",
                           "reasoncode": "MMIO::RC_BAD_MMIO_READ",
                           "userdata1":  "OCMB huid",
                           "userdata2":  "Address offset",
                      },
            0x47040B: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SEND_REPO_CHANGED_EVENT",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x7070C: {    "devdesc": "Master Sentinel chip was used as a target for an I2C operation.  This is not permitted.",
                           "moduleid": "I2C_PAGE_SWITCH_OP",
                           "reasoncode": "I2C_MASTER_SENTINEL_TARGET",
                           "userdata1":  "Operation Type requested",
                           "userdata2":  "<UNUSED>",
                      },
            0x70A0C: {    "devdesc": "ATTR_EEPROM_PAGE_ARRAY not found",
                           "moduleid": "I2C_PAGE_SWITCH_OP",
                           "reasoncode": "I2C_ATTRIBUTE_NOT_FOUND",
                           "userdata1":  "Target HUID for the attribute",
                           "userdata2":  "<UNUSED>",
                      },
            0x7100C: {    "devdesc": "There was an error retrieving the EEPROM page mutex for this i2c master engine",
                           "moduleid": "I2C_PAGE_SWITCH_OP",
                           "reasoncode": "I2C_INVALID_EEPROM_PAGE_MUTEX",
                           "userdata1":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0xA120C: {    "devdesc": "FsiDD::initializeHardware> Unexpected attribute data for remote FSI link",
                           "moduleid": "FSI::MOD_FSIDD_INITIALIZEHARDWARE",
                           "reasoncode": "FSI::RC_BAD_ATTRIBUTES",
                           "userdata1[00:31]":  "Slave HUID",
                           "userdata1[32:63]":  "Slave FSI LinkId",
                           "userdata2[00:31]":  "Master HUID",
                           "userdata2[32:63]":  "Master FSI LinkId",
                      },
            0xB170C: {    "devdesc": "Invalid range for attribute value.",
                           "moduleid": "TARGETING::TARG_HANDLE_RANGE_CHECK_FAILURE",
                           "reasoncode": "TARGETING::TARG_RC_ATTRIBUTE_RANGE_CHECK_FAIL",
                           "userdata1[00:31]":  "Target's HUID",
                           "userdata1[32:64]":  "Attribute ID",
                           "userdata2":  "Value that was out of range",
                      },
            0xE110C: {    "devdesc": "Attempted to lookup VPD in reserved memory and failed",
                           "moduleid": "EEPROM_CACHE_INIT_RT",
                           "reasoncode": "EEPROM_CACHE_NO_VPD_IN_RSV_MEM",
                           "userdata1":  "Node Id",
                           "userdata2":  "Unused",
                      },
            0xE120C: {    "devdesc": "Attempted to lookup VPD in reserved memory and failed",
                           "moduleid": "EEPROM_CACHE_INIT_RT",
                           "reasoncode": "EEPROM_DUPLICATE_CACHE_ENTRY",
                           "userdata1[0:31]":  "master Huid",
                           "userdata1[32:39]":  "port (or 0xFF)",
                           "userdata1[40:47]":  "engine",
                           "userdata1[48:55]":  "devAddr of eeprom slave   (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "muxSelect of eeprom slave (or byte 1 offset_KB)",
                           "userdata2[0:31]":  "size of eeprom",
                           "userdata2[32:63]":  "Node Id",
                      },
            0x10090C: {    "devdesc": "Error: The ordinal Id of one of the TOD procs did not fall in the range 0 <= Ordinal Id < getMaxProcsOnSystem Possible Causes: TOD logic has not been updated to support the latest system type where the no. of processor chips is either equal to or more than getMaxProcsOnSystem Resolution: Development team should be contacted.",
                           "moduleid": "TOD_LOG_UNSUPORTED_ORDINALID",
                           "reasoncode": "TOD_UNSUPORTED_ORDINALID",
                           "userdata1":  "Ordinal Id for which the error is logged",
                      },
            0x11050C: {    "devdesc": "Invalid message queue ID",
                           "moduleid": "MOD_MBOXSRV_IPC_MSG",
                           "reasoncode": "RC_INVALID_QUEUE",
                           "userdata1":  "msg queue",
                           "userdata2":  "msg type",
                      },
            0x11120C: {    "devdesc": "Invalid msg or msg queue",
                           "moduleid": "MBOX::MOD_MBOXSRV_IPC_MSG",
                           "reasoncode": "MBOX::RC_MSG_SEND_ERROR",
                           "userdata1":  "rc from msg_send()",
                           "userdata2":  "msg queue id",
                      },
            0x16020C: {    "devdesc": "TCE Table Could Not Be Block-Mapped",
                           "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                           "reasoncode": "Util::UTIL_ERC_BAD_PTR",
                           "userdata1":  "Physical Address of the TCE Table",
                           "userdata2":  "Requested Size of the TCE Table",
                      },
            0x160C0C: {    "devdesc": "TCE Table size requested too large.",
                           "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                           "reasoncode": "Util::UTIL_TCE_INVALID_SIZE",
                           "userdata1":  "Size of of the table that is too large",
                           "userdata2":  "Max TCE Table Size",
                      },
            0x160D0C: {    "devdesc": "TCE Table not page aligned.",
                           "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                           "reasoncode": "Util::UTIL_TCE_ADDR_NOT_ALIGNED",
                           "userdata1":  "Phyiscal Address of the TCE Table",
                           "userdata2":  "<unused>",
                      },
            0x16130C: {    "devdesc": "TCE Table size requested too large.",
                           "moduleid": "Util::UTIL_TCE_CREATE_TABLE",
                           "reasoncode": "Util::UTIL_TCE_INVALID_COUNT",
                           "userdata1":  "Number of TCEs Requested",
                           "userdata2":  "Max Number of TCEs that TCE Table can hold",
                      },
            0x17100C: {    "devdesc": "Could not find a functional boot core.",
                           "moduleid": "ISTEP::MOD_HOST_GARD",
                           "reasoncode": "ISTEP::RC_BOOT_CORE_NULL",
                           "userdata1[00:31]":  "Boot processor HUID",
                           "userdata1[32:63]":  "Current PIR",
                           "userdata2[00:15]":  "Number of present cores",
                           "userdata2[16:31]":  "Number of functional cores",
                           "userdata2[32:63]":  "HUID of present boot core (if found)",
                      },
            0x17520C: {    "devdesc": "Failed to update the SBE after missing bootcore",
                           "moduleid": "ISTEP::MOD_HOST_GARD",
                           "reasoncode": "ISTEP::RC_SBE_UPDATE_UNEXPECTEDLY_FAILED",
                           "userdata1[00:31]":  "Boot processor HUID",
                           "userdata1[32:63]":  "Current PIR",
                           "userdata2[00:15]":  "Number of present cores",
                           "userdata2[16:31]":  "Number of functional cores",
                           "userdata2[32:63]":  "HUID of present boot core (if found)",
                      },
            0x176F0C: {    "devdesc": "Original bootcore is not functional but we found a viable replacement. Forcing a reconfig loop to boot from the new core.",
                           "moduleid": "ISTEP::MOD_HOST_GARD",
                           "reasoncode": "ISTEP::RC_BOOT_CORE_REPLACEMENT",
                           "userdata1[00:31]":  "Original boot core HUID",
                           "userdata1[32:63]":  "Current PIR",
                           "userdata2[00:15]":  "Number of present cores",
                           "userdata2[16:31]":  "Number of functional cores",
                           "userdata2[32:63]":  "HUID of replacement boot core",
                      },
            0x1A230C: {    "devdesc": "Unsupported section requested",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_GETINSTANCECOUNT",
                           "reasoncode": "RUNTIME::RC_INSTANCES_UNSUPPORTED",
                           "userdata1":  "Section Id",
                           "userdata2":  "<unused>",
                      },
            0x1E0D0C: {    "devdesc": "Error parsing secure header",
                           "moduleid": "SECUREBOOT::MOD_SECURE_CONT_VALIDATE",
                           "reasoncode": "SECUREBOOT::RC_CONT_HDR_INVALID",
                           "userdata1[0::31]":  "Magic Number",
                           "userdata1[32::63]":  "ROM version",
                           "userdata2[0:15]":  "Algorithm version",
                           "userdata2[16:31]":  "Hash algorithm",
                           "userdata2[32:47]":  "Signature algorithm",
                           "userdata2[48:63]":  "SW key count",
                      },
            0x22120C: {    "devdesc": "Successful Update of SBE SEEPROM SBE Version Information",
                           "moduleid": "SBE_PERFORM_UPDATE_ACTIONS",
                           "reasoncode": "SBE_INFO_LOG",
                           "userdata1[0:31]":  "Update Actions Enum",
                           "userdata1[32:63]":  "Customized Data CRC",
                           "userdata2[0:31]":  "Original SEEPROM 0 CRC",
                           "userdata2[32:63]":  "Original SEEPROM 1 CRC",
                      },
            0x24040C: {    "devdesc": "Found error(s) in OPB Master Accumulated Status Register after attempting an XSCOM LPC operation.",
                           "moduleid": "LPC::MOD_XSCOMLPC_CHECK_OPBM_ERRORS",
                           "reasoncode": "LPC::RC_OPB_ERROR",
                           "userdata1":  "OPB Master Accumulated Status Register",
                           "userdata2":  "Reset Level",
                      },
            0x27010C: {    "devdesc": "presenceDetect> Invalid data length (!= 1 bytes)",
                           "moduleid": "TPMDD_TPMPRESENCEDETECT",
                           "reasoncode": "TPM_INVALID_OPERATION",
                           "userdata1":  "Data Length",
                      },
            0x28570C: {    "devdesc": "FFDC returned by SBE after failing to reach runtime",
                           "moduleid": "SBEIO_GET_FFDC_HANDLER",
                           "reasoncode": "SBEIO_RETURNED_FFDC",
                           "userdata1":  "Processor Target",
                           "userdata2":  "Number of FFDC packages",
                      },
            0x285B0C: {    "devdesc": "Unexpected number of FFDC packages in buffer",
                           "moduleid": "SBEIO_GET_FFDC_HANDLER",
                           "reasoncode": "SBEIO_MORE_FFDC_THAN_EXPECTED",
                           "userdata1":  "Maximum expected packages",
                           "userdata2":  "Number of FFDC packages",
                      },
            0x2BB30C: {    "devdesc": "msg_respond() failed",
                           "moduleid": "MOD_TPM_SYNCRESPONSE",
                           "reasoncode": "RC_MSGRESPOND_FAIL",
                           "userdata1":  "rc from msq_respond()",
                      },
            0x332A0C: {    "devdesc": "Invalid attribute read request",
                           "moduleid": "fapi2::MOD_FAPI2_GET_TARGETING_ATTR",
                           "reasoncode": "RC_INVALID_ATTRIBUTE",
                           "userdata1[0:31]":  "FAPI2 Target Type",
                           "userdata1[32:63]":  "HB Target HUID",
                           "userdata2":  "Requested attribute ID",
                      },
            0x370D0C: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                           "moduleid": "MMIO::MOD_CHECK_OCMB_ERRORS",
                           "reasoncode": "MMIO::RC_UNSUPPORTED_CHIPID",
                           "userdata1":  "OCMB HUID",
                           "userdata2":  "OCMB chip ID",
                      },
            0x47040C: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FILE_TABLE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x470D0C: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FILE_TABLE",
                           "reasoncode": "RC_BAD_TRANSFER_FLAG",
                           "userdata1":  "Actual Transfer Flag",
                           "userdata2":  "Expected Transfer Flag",
                      },
            0x47330C: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_FILE_TABLE",
                           "reasoncode": "RC_BAD_NEXT_TRANSFER_HANDLE",
                           "userdata1":  "Actual Next Transfer Handle",
                           "userdata2":  "Expected Next Transfer Handle",
                      },
            0x6270D: {    "devdesc": "PnorRP::getSideInfo> Side not supported",
                           "moduleid": "PNOR::MOD_PNORRP_GETSIDEINFO",
                           "reasoncode": "PNOR::RC_INVALID_PNOR_SIDE",
                           "userdata1":  "Requested SIDE",
                           "userdata2":  "0",
                      },
            0x7100D: {    "devdesc": "There was an error retrieving the EEPROM page mutex for this i2c master engine",
                           "moduleid": "I2C_PAGE_UNLOCK_OP",
                           "reasoncode": "I2C_INVALID_EEPROM_PAGE_MUTEX",
                           "userdata1":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0xB040D: {    "devdesc": "While attempting to set permissions on a virtual memory block for an attribute section, the kernel returned an error.",
                           "moduleid": "TARG_EDIT_PAGE_PERMISSIONS",
                           "reasoncode": "TARG_RC_MM_PERM_FAIL",
                           "userdata1":  "vAddress attempting to allocate.",
                           "userdata2":  "(kernel-rc << 32) | (Permissions)",
                      },
            0xB060D: {    "devdesc": "Found unhandled attribute section type",
                           "moduleid": "TARG_EDIT_PAGE_PERMISSIONS",
                           "reasoncode": "TARG_RC_UNHANDLED_ATTR_SEC_TYPE",
                           "userdata1":  "Section type",
                      },
            0xC1E0D: {    "devdesc": "A target was not found in the map of states kept by the PG checking algorithm. Therefore, it did not have PG checks run against it.",
                           "moduleid": "MOD_CHECK_PG_FOR_DESC",
                           "reasoncode": "RC_PARTIAL_GOOD_MISSING_TARGET",
                           "userdata1":  "huid of the target",
                      },
            0xE130D: {    "devdesc": "Not sure how to perform operation with unknown access method type",
                           "moduleid": "EEPROM_PERFORM_OP_HW",
                           "reasoncode": "EEPROM_INVALID_ACCESS_METHOD",
                           "userdata1[0:31]":  "Target device associated w/ the EEPROM",
                           "userdata1[32:63]":  "Access method",
                           "userdata2":  "Operation type",
                      },
            0xF080D: {    "devdesc": "Unexpected RC from issuing PSIHB EOI store",
                           "moduleid": "INTR::MOD_INTRRP_SENDEOI",
                           "reasoncode": "INTR::RC_PSIHB_ESB_EOI_FAIL",
                           "userdata1":  "Value read from EOI load",
                           "userdata2":  "Interrupt Source to issue EOI to",
                      },
            0xF100D: {    "devdesc": "Error encountered searching for a proc to send EOI to",
                           "moduleid": "INTR::MOD_INTRRP_SENDEOI",
                           "reasoncode": "INTR::RC_PROC_IS_NULLPTR",
                           "userdata1":  "Input Source",
                           "userdata2":  "Input PIR",
                      },
            0x11120D: {    "devdesc": "Message send to mailbox sp failed",
                           "moduleid": "MBOX::MOD_MBOX_MSGQ_FAIL",
                           "reasoncode": "MBOX::RC_MSG_SEND_ERROR",
                           "userdata1":  "kernel errno",
                           "userdata2":  "<unused>",
                      },
            0x16150D: {    "devdesc": "mm_block_unmap failed for TCE Table",
                           "moduleid": "Util::UTIL_TCE_DISABLE_TCES",
                           "reasoncode": "Util::UTIL_TCE_BLOCK_UNMAP_FAIL",
                           "userdata1":  "Starting virtual address of pages to be removed",
                           "userdata2":  "Return Code from mm_block_unmap",
                      },
            0x17110D: {    "devdesc": "Mixed bus connection of two types",
                           "moduleid": "MOD_EDI_EI_IO_RUN_TRAINING",
                           "reasoncode": "RC_MIXED_PBUS_CONNECTION",
                           "userdata1":  "Endpoint1 bus type",
                           "userdata2":  "Endpoint2 bus type",
                      },
            0x17120D: {    "devdesc": "Both endpoint connections of same chip",
                           "moduleid": "MOD_EDI_EI_IO_RUN_TRAINING",
                           "reasoncode": "RC_SAME_CHIP_PBUS_CONNECTION",
                      },
            0x17130D: {    "devdesc": "Connection is conflicting. endp1 -> endp2 but endp2 -> endp3. endp1 -> endp2 but endp2 -> endp2 (itself) or not existing",
                           "moduleid": "MOD_EDI_EI_IO_RUN_TRAINING",
                           "reasoncode": "RC_CONFLICT_PBUS_CONNECTION",
                           "userdata1":  "Bus endpoint target pointer1",
                           "userdata2":  "Bus endpoint target pointer2",
                      },
            0x1A260D: {    "devdesc": "Unsupported section requested",
                           "moduleid": "RUNTIME::MOD_HDATSERVICE_GETANDCHECKTUPLE",
                           "reasoncode": "RUNTIME::RC_GETTUPLE_UNSUPPORTED",
                           "userdata1":  "Section Id",
                           "userdata2":  "<unused>",
                      },
            0x1E0E0D: {    "devdesc": "Invalid SBE security mode",
                           "moduleid": "SECUREBOOT::MOD_SECURE_SET_SBE_SECURE_MODE",
                           "reasoncode": "SECUREBOOT::RC_SBE_INVALID_SEC_MODE",
                           "userdata1":  "Security mode to set",
                           "userdata2":  "0",
                      },
            0x22130D: {    "devdesc": "SBE Version Miscompare with Master Target",
                           "moduleid": "SBE_MASTER_VERSION_COMPARE",
                           "reasoncode": "SBE_MISCOMPARE_WITH_MASTER_VERSION",
                           "userdata1":  "Master Target HUID",
                           "userdata2":  "Comparison Target HUID",
                      },
            0x22140D: {    "devdesc": "Error Associated with Updating this Target",
                           "moduleid": "SBE_MASTER_VERSION_COMPARE",
                           "reasoncode": "SBE_ERROR_ON_UPDATE",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Original Error PLID",
                           "userdata2[0:31]":  "Original Error EID",
                           "userdata2[32:63]":  "Original Error Reason Code",
                      },
            0x22150D: {    "devdesc": "SBE Image Version Miscompare with Master Target",
                           "moduleid": "SBE_MASTER_VERSION_COMPARE",
                           "reasoncode": "SBE_MASTER_VERSION_DOWNLEVEL",
                           "userdata1":  "Master Target HUID",
                           "userdata2":  "Master Target Loop Index",
                      },
            0x270D0D: {    "devdesc": "The system's TPM Required policy is set to TPM Required and a TPM that was expected to be present was not detected properly.  The TPM in question will eventually be flagged as TPM_UNUSABLE for redundancy calculations, Possible causes: (1) absent or improperly seated TPM, (2) TPM hardware failure, (3) firmware bug, (4) incorrect TPM part, (5) SPI failure, (6) processor failure, See earlier error logs with same PLID for additional details.",
                           "moduleid": "TPMDD_TPMPRESENCE",
                           "reasoncode": "TPM_RC_TPM_NOT_DETECTED",
                           "userdata1":  "TPM HUID",
                      },
            0x270E0D: {    "devdesc": "Unexpected vendor ID read from TPM",
                           "moduleid": "TPMDD_TPMPRESENCE",
                           "reasoncode": "TPM_RC_UNEXPECTED_VENDOR_ID",
                           "userdata1[0:31]":  "Expected vendor ID",
                           "userdata1[32:63]":  "Actual vendor ID",
                           "userdata2":  "TPM HUID",
                      },
            0x2BB10D: {    "devdesc": "msg_sendrecv() failed",
                           "moduleid": "MOD_TPM_SEPARATOR",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msq_sendrecv()",
                      },
            0x2BB20D: {    "devdesc": "msg_send() failed",
                           "moduleid": "MOD_TPM_SEPARATOR",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "rc from msq_send()",
                      },
            0x332A0D: {    "devdesc": "Invalid attribute write request",
                           "moduleid": "fapi2::MOD_FAPI2_SET_TARGETING_ATTR",
                           "reasoncode": "RC_INVALID_ATTRIBUTE",
                           "userdata1[0:31]":  "FAPI2 Target Type",
                           "userdata1[32:63]":  "HB Target HUID",
                           "userdata2":  "Requested attribute ID",
                      },
            0x47040D: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_LID_FILE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x90010D: {    "devdesc": "input Target pointer is NULL",
                           "moduleid": "HDAT::MOD_IOHUB_FETCH_DAUGHTER",
                           "reasoncode": "HDAT::RC_INVALID_OBJECT",
                      },
            0x90040D: {    "devdesc": "Target class not supported",
                           "moduleid": "HDAT::MOD_IOHUB_FETCH_DAUGHTER",
                           "reasoncode": "HDAT::RC_TARGET_UNSUPPORTED",
                      },
            0x90060D: {    "devdesc": "node returned empty Target list",
                           "moduleid": "HDAT::MOD_IOHUB_FETCH_DAUGHTER",
                           "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                      },
            0x3110E: {    "devdesc": "Hypervisor wakeup failed.",
                           "moduleid": "SCOM_CALL_WAKEUP_HYP",
                           "reasoncode": "SCOM_RUNTIME_WAKEUP_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2[0:31]":  "Runtime Target ID",
                           "userdata2[32:63]":  "Wakeup Mode",
                      },
            0x3120E: {    "devdesc": "Wakeup runtime interface not linked.",
                           "moduleid": "SCOM_CALL_WAKEUP_HYP",
                           "reasoncode": "SCOM_RUNTIME_INTERFACE_ERR",
                           "userdata1":  "Target HUID",
                           "userdata2":  "Wakeup Enable",
                      },
            0x60C0E: {    "devdesc": "PNOR::validateAltMaster> Fail verifying FFS Header on Master Candidate PNOR TOC0",
                           "moduleid": "PNOR::MOD_PNORVALID_MAIN",
                           "reasoncode": "PNOR::RC_PARTITION_TABLE_INVALID",
                           "userdata1":  "Master Candidate Processor Target",
                           "userdata2":  "<unused>",
                      },
            0x6290E: {    "devdesc": "PnorRP::setSideInfo> No valid TOCs found",
                           "moduleid": "PNOR::MOD_PNORRP_SETSIDEINFO",
                           "reasoncode": "PNOR::RC_INVALID_TOC",
                           "userdata1":  "Side Id",
                           "userdata2[00:31]":  "primary toc",
                           "userdata2[32:63]":  "backup toc",
                      },
            0x7110E: {    "devdesc": "There was a request for an invalid EEPROM page",
                           "moduleid": "I2C_CHOOSE_EEPROM_PAGE",
                           "reasoncode": "I2C_INVALID_EEPROM_PAGE_REQUEST",
                           "userdata1":  "Target Huid",
                           "userdata2[00:31]":  "Requested Page",
                           "userdata2[32:63]":  "Current Page",
                      },
            0xC1F0E: {    "devdesc": "The EC (Revision) info read from the OCMB and SPD did not match the expected values.",
                           "moduleid": "MOD_OCMB_IDEC",
                           "reasoncode": "RC_OCMB_SPD_REVISION_MISMATCH",
                           "userdata1[00:31]":  "OCMB IDEC register EC",
                           "userdata1[32:63]":  "Translated SPD EC",
                           "userdata2[00:31]":  "OCMB Chip ID Attribute",
                           "userdata2[32:63]":  "HUID of OCMB target",
                      },
            0xC210E: {    "devdesc": "The ID read from the SPD didn't match any known OCMB chip types.",
                           "moduleid": "MOD_OCMB_IDEC",
                           "reasoncode": "RC_OCMB_UNKNOWN_CHIP_TYPE",
                           "userdata1[0:7]":  "SPD Module Revision",
                           "userdata1[8:15]":  "DRAM Interface Type Presented or Emulated",
                           "userdata1[16:23]":  "Memory Module Interface Type",
                           "userdata1[24:31]":  "Unused",
                           "userdata1[32:63]":  "SPD Chip Id",
                           "userdata2":  "HUID of OCMB target",
                      },
            0xC220E: {    "devdesc": "The memory interface type read from the SPD did not match the DDIMM value. Setting the appropriate IDEC values for this target cannot continue.",
                           "moduleid": "MOD_OCMB_IDEC",
                           "reasoncode": "RC_OCMB_INTERFACE_TYPE_MISMATCH",
                           "userdata1[0:7]":  "SPD Module Revision",
                           "userdata1[8:15]":  "DRAM Interface Type Presented or Emulated",
                           "userdata1[16:23]":  "Memory Module Interface Type",
                           "userdata1[24:31]":  "Unused",
                           "userdata1[32:47]":  "Expected memory interface type DDIMM",
                           "userdata1[48:63]":  "Expected memory interface type PLANAR",
                           "userdata2":  "HUID of OCMB target",
                      },
            0xC230E: {    "devdesc": "The IDEC info read from the OCMB and SPD did not match the expected values.",
                           "moduleid": "MOD_OCMB_IDEC",
                           "reasoncode": "RC_OCMB_CHIP_ID_MISMATCH",
                           "userdata1[00:31]":  "OCMB IDEC Register ID",
                           "userdata1[32:63]":  "Translated SPD ID",
                           "userdata2[32:63]":  "HUID of OCMB target",
                      },
            0xE010E: {    "devdesc": "Operation type is not supported",
                           "moduleid": "EEPROM_PERFORM_SPI_OP",
                           "reasoncode": "EEPROM_INVALID_OPERATION",
                           "userdata1":  "EEPROM operation type",
                           "userdata2":  "target",
                      },
            0xE170E: {    "devdesc": "Invalid offset in SPI operation",
                           "moduleid": "EEPROM_PERFORM_SPI_OP",
                           "reasoncode": "EEPROM_INVALID_OFFSET",
                           "userdata1[0:31]":  "Operation offset",
                           "userdata1[32:47]":  "Operation type (0 = read, 1 = write)",
                           "userdata1[48:63]":  "Operation length in KB (rounded down)",
                           "userdata2[0:15]":  "Device size in KB",
                           "userdata2[16:31]":  "SPI engine",
                           "userdata2[32:63]":  "Target HUID",
                      },
            0x100B0E: {    "devdesc": "nullptr is passed in for node target",
                           "moduleid": "TOD_GETFUNCNODETARGETSONSYSTEM",
                           "reasoncode": "TOD_NULL_INPUT_TARGET",
                      },
            0x100C0E: {    "devdesc": "Input target is not a node or sys target",
                           "moduleid": "TOD_GETFUNCNODETARGETSONSYSTEM",
                           "reasoncode": "TOD_INVALID_TARGET",
                           "userdata1":  "Target HUID",
                      },
            0x160E0E: {    "devdesc": "PSI Bridge device Map failed",
                           "moduleid": "Util::UTIL_TCE_MAP_PSIHB",
                           "reasoncode": "Util::UTIL_TCE_DEV_MAP_FAIL",
                           "userdata1":  "Address to be mapped PsiBridgeAddr",
                           "userdata2":  "Target Unit Id",
                      },
            0x1A310E: {    "devdesc": "No content after Section header or size was parsed from secure header incorrectly.",
                           "moduleid": "RUNTIME::MOD_PREVERLIDMGR_LOAD_FROM_PNOR",
                           "reasoncode": "RUNTIME::RC_PREVER_INVALID_SIZE",
                           "userdata1":  "PNOR section",
                           "userdata2":  "Size of section including header",
                      },
            0x1E0F0E: {    "devdesc": "Device write did not return expected size",
                           "moduleid": "SECUREBOOT::MOD_SECURE_GET_ALL_SEC_REGS",
                           "reasoncode": "SECUREBOOT::RC_DEVICE_WRITE_ERR",
                           "userdata1":  "Actual size written",
                           "userdata2":  "Expected size written",
                      },
            0x27060E: {    "devdesc": "SPI controller path target is null.",
                           "moduleid": "TPMDD_GETSPICONTROLLERTARGET",
                           "reasoncode": "TPM_TARGET_NULL",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Compressed Entity Path",
                      },
            0x27120E: {    "devdesc": "SPI controller entity path doesn't exist.",
                           "moduleid": "TPMDD_GETSPICONTROLLERTARGET",
                           "reasoncode": "TPM_SPI_CONTROLLER_PATH_ERROR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Compressed Entity Path",
                      },
            0x283D0E: {    "devdesc": "Unable to inform OPAL of SBE failure",
                           "moduleid": "SBEIO_HANDLE_VITAL_ATTN",
                           "reasoncode": "SBEIO_RT_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "none",
                      },
            0x28530E: {    "devdesc": "PRD detected an error with the SBE and HB failed to recover",
                           "moduleid": "SBEIO_HANDLE_VITAL_ATTN",
                           "reasoncode": "SBEIO_NO_RECOVERY_ACTION",
                           "userdata1":  "Huid of processor",
                           "userdata2":  "Unused",
                      },
            0x28540E: {    "devdesc": "We expected an error log to be returned from                           p10_extract_rc but there wasn't one",
                           "moduleid": "SBEIO_HANDLE_VITAL_ATTN",
                           "reasoncode": "SBEIO_EXTRACT_RC_ERROR",
                           "userdata1":  "Huid of processor",
                           "userdata2":  "Return action from extract_rc",
                      },
            0x2BA20E: {    "devdesc": "Command failure reading TPM capability.",
                           "moduleid": "MOD_TPM_CMD_GETCAPNVINDEX",
                           "reasoncode": "RC_TPM_GETCAP_FAIL",
                           "userdata1":  "responseCode",
                           "userdata2":  "0",
                      },
            0x2BA30E: {    "devdesc": "Command failure reading TPM NV indexes.",
                           "moduleid": "MOD_TPM_CMD_GETCAPNVINDEX",
                           "reasoncode": "RC_TPM_GETCAP_FW_INVALID_RESP",
                           "userdata1":  "capability",
                           "userdata2":  "0",
                      },
            0x2BB50E: {    "devdesc": "Command failure reading TPM NV indexes. TPM is likely provisioned incorrectly.",
                           "moduleid": "MOD_TPM_CMD_GETCAPNVINDEX",
                           "reasoncode": "RC_TPM_NVINDEX_VALIDATE_FAIL",
                           "userdata1[0:7]":  "foundRSAEKCert",
                           "userdata1[8:15]":  "ECC EK cert found mask (0x80/0x40 = P256/P384)",
                           "userdata1[16:23]":  "Plat cert found mask (0x80/0x40/0x20 = cert 0/1/2)",
                           "userdata1[24:31]":  "moreData",
                           "userdata1[32:63]":  "0",
                      },
            0x470B0E: {    "devdesc": "Software problem, invalid event class received from BMC",
                           "moduleid": "MOD_HANDLE_REPO_CHANGED_EVENT",
                           "reasoncode": "RC_INVALID_MSG_TYPE",
                           "userdata1":  "Expected event class",
                           "userdata2":  "Actual event class",
                      },
            0x900B0E: {    "devdesc": "memory alloc failed in calloc",
                           "moduleid": "HDAT::MOD_IOHUB_BUILD_DAUGHTER",
                           "reasoncode": "HDAT::RC_MEM_ALLOC_FAIL",
                      },
            0x3130F: {    "devdesc": "Disabling special wakeup when not enabled.",
                           "moduleid": "SCOM_CALL_WAKEUP_HWP",
                           "reasoncode": "SCOM_SPCWKUP_COUNT_ERR",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "Wakeup Enable",
                           "userdata2[32:63]":  "Wakeup Count (ATTR_SPCWKUP_COUNT)",
                      },
            0x31B0F: {    "devdesc": "Invalid target type for wakeup call.",
                           "moduleid": "SCOM_CALL_WAKEUP_HWP",
                           "reasoncode": "SCOM_BAD_TARGET",
                           "userdata1":  "Target HUID",
                           "userdata2":  "Target Type",
                      },
            0x31E0F: {    "devdesc": "Unexpectedly forcing wakeup off when the counter is non-zero, implies a bug in the code flow.",
                           "moduleid": "SCOM_CALL_WAKEUP_HWP",
                           "reasoncode": "SCOM_UNEXPECTED_FORCE_WAKEUP",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "Wakeup Enable",
                           "userdata2[32:63]":  "Wakeup Count (ATTR_SPCWKUP_COUNT)",
                      },
            0x3230F: {    "devdesc": "Unexpectedly forcing wakeup off when the counter is non-zero, implies a bug in the code flow.",
                           "moduleid": "SCOM_CALL_WAKEUP_HWP",
                           "reasoncode": "SCOM_SPCWKUP_COUNT_INCONSISTENT",
                           "userdata1[00:31]":  "Processor Target HUID",
                           "userdata1[32:63]":  "Core Target HUID",
                           "userdata2[00:31]":  "Wakeup Enable",
                           "userdata2[32:47]":  "Previous Wakeup Count (ATTR_SPCWKUP_COUNT)",
                           "userdata2[48:63]":  "Current Wakeup Count (ATTR_SPCWKUP_COUNT)",
                      },
            0x60C0F: {    "devdesc": "PNOR::validateMagic> Fail verifying FFS Magic Number in Header on Master",
                           "moduleid": "PNOR::MOD_PNORVALID_MAGIC",
                           "reasoncode": "PNOR::RC_PARTITION_TABLE_INVALID",
                           "userdata1":  "Magic Number read",
                           "userdata2":  "<unused>",
                      },
            0x7020F: {    "devdesc": "Invalid I2C device type",
                           "moduleid": "I2C::FAPI_I2C_PERFORM_OP",
                           "reasoncode": "I2C::I2C_INVALID_OP_TYPE",
                           "userdata1":  "OP type",
                           "userdata2":  "HUID of target",
                      },
            0x7130F: {    "devdesc": "Invalid I2C master path",
                           "moduleid": "I2C::FAPI_I2C_PERFORM_OP",
                           "reasoncode": "I2C::INVALID_MASTER_TARGET",
                           "userdata1":  "HUID of target with FAPI_I2C_CONTROL_INFO",
                      },
            0xB1A0F: {    "devdesc": "Invalid message type requested through the attribute resource provider's attribute synchronization sync daemon.",
                           "moduleid": "TARG_ATTR_SYNC_TASK",
                           "reasoncode": "TARG_RC_UNSUPPORTED_ATTR_SYNC_MSG",
                           "userdata1":  "Return code",
                           "userdata2":  "Message type",
                      },
            0xB1B0F: {    "devdesc": "Shutdown just occurred so the mailbox service is down. Messages can not be handled at this time.",
                           "moduleid": "TARG_ATTR_SYNC_TASK",
                           "reasoncode": "TARG_RC_ATTR_SYNC_SERVICE_DOWN",
                           "userdata1":  "Return code",
                           "userdata2":  "Message type",
                      },
            0xE140F: {    "devdesc": "Attempting to cache empty buffer in EEACHE",
                           "moduleid": "EEPROM_GENERIC_CACHE",
                           "reasoncode": "EEPROM_INVALID_LENGTH",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "1 if target is present, 0 if not",
                           "userdata2[32:63]":  "EEPROM::EEPROM_ROLE",
                      },
            0xE220F: {    "devdesc": "Unable to sync target with PNOR EECACHE",
                           "moduleid": "EEPROM_GENERIC_CACHE",
                           "reasoncode": "EEPROM_PNOR_CACHE_SYNC",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "1 if target is present, 0 if not",
                           "userdata2[32:63]":  "EEPROM::EEPROM_ROLE",
                      },
            0xF090F: {    "devdesc": "Error unmasking interrupt source",
                           "moduleid": "INTR::MOD_INTRRP_UNMASKINTERRUPT",
                           "reasoncode": "INTR::RC_XIVE_ESB_WRONG_STATE",
                           "userdata1[0:31]":  "Huid of processor",
                           "userdata1[32:63]":  "Interrupt Source Number",
                           "userdata2":  "MMIO Read Value for unmasking",
                      },
            0x100D0F: {    "devdesc": "TOD master drawer not found",
                           "moduleid": "TOD_TOPOLOGY_CREATE",
                           "reasoncode": "TOD_CREATION_ERR",
                           "userdata1":  "Topology type : primary/secondary",
                      },
            0x160F0F: {    "devdesc": "PSI Bridge device Map failed",
                           "moduleid": "Util::UTIL_TCE_UNMAP_PSIHB",
                           "reasoncode": "Util::UTIL_TCE_DEV_UNMAP_FAIL",
                           "userdata1":  "Address to be unmapped",
                           "userdata2":  "Return Code of mmio_dev_unmap",
                      },
            0x1A310F: {    "devdesc": "No space left for fake header injection",
                           "moduleid": "RUNTIME::MOD_PREVERLIDMGR_LOAD_IMAGE",
                           "reasoncode": "RUNTIME::RC_PREVER_INVALID_SIZE",
                           "userdata1":  "Size of section including space for header",
                           "userdata2":  "Size of header",
                      },
            0x1E120F: {    "devdesc": "Hostboot Base Image Header not valid",
                           "moduleid": "SECUREBOOT::MOD_SECURE_LOAD_HEADER",
                           "reasoncode": "SECUREBOOT::RC_INVALID_BASE_HEADER",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x27150F: {    "devdesc": "TPM timeout waiting for good sts register",
                           "moduleid": "TPMDD_READSTSREG",
                           "reasoncode": "TPM_TIMEOUT_REG",
                           "userdata1[0:31]":  "TPM HUID",
                           "userdata1[32:63]":  "Unused",
                           "userdata2[0:31]":  "i_tpmInfo.operation",
                           "userdata2[32:63]":  "o_stsReg.value",
                      },
            0x28060F: {    "devdesc": "Caller requested PSU quiesce against an unassigned target or a target that is not a processor.",
                           "moduleid": "SBEIO_SEND_PSU_QUIESCE_SBE",
                           "reasoncode": "SBEIO_PSU_INVALID_TARGET",
                           "userdata1":  "Target HUID (0, if invalid pointer)",
                           "userdata2":  "Target type (TYPE_NA, if invalid pointer)",
                      },
            0x2BB10F: {    "devdesc": "msg_sendrecv() failed trying to send flush message to TPM daemon",
                           "moduleid": "MOD_FLUSH_TPM_QUEUE",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msq_sendrecv()",
                      },
            0x35120F: {    "devdesc": "Encountered error setting the energy source policy Make sure the connection between energy source and NVDIMM is intact",
                           "moduleid": "NVDIMM_SET_ES",
                           "reasoncode": "NVDIMM_SET_ES_ERROR",
                           "userdata1[0:31]":  "Related ops (0xff = NA)",
                           "userdata1[32:63]":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0x47070F: {    "devdesc": "msg_sendrecv() failed",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1[0:31]":  "Return code from msg_sendrecv",
                           "userdata1[32:63]":  "Message type for registered callback",
                           "userdata2[0:31]":  "PLDM effecter ID",
                           "userdata2[32:63]":  "PLDM composite effecter ID",
                      },
            0x47080F: {    "devdesc": "Software problem, failed to send IPC message",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "Return code from message send routine",
                      },
            0x47200F: {    "devdesc": "Software problem, multiple awaits on PDR manager",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_MULTIPLE_AWAIT",
                      },
            0x47280F: {    "devdesc": "Could not find Terminus Locator PDR in the PDR repo",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_TERM_LOCATOR_NOT_FOUND",
                      },
            0x47290F: {    "devdesc": "Software problem, invalid state sensor/effecter ID received from BMC",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_INVALID_STATE_QUERY_ID",
                           "userdata1[0:31]":  "Sensor/effecter ID",
                           "userdata1[32:63]":  "Query type (1 = sensor, 2 = effecter)",
                           "userdata2":  "Unused",
                      },
            0x47370F: {    "devdesc": "Software problem, overrun state sensor/effecter IDs",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_INVALID_OFFSET_ID",
                           "userdata1":  "HB_PLDM_SENSOR_EFFECTER_ID_RANGE_END",
                           "userdata2":  "The Out of Range Next Query ID",
                      },
            0x47390F: {    "devdesc": "Timeout while waiting for BMC PDR repo changed event",
                           "moduleid": "MOD_PDR_MANAGER",
                           "reasoncode": "RC_TIMEOUT",
                           "userdata1":  "Timeout in milliseconds",
                           "userdata2":  "Time left in milliseconds (usually 0)",
                      },
            0x90050F: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_IOHUB_LOAD_DATA",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x31F10: {    "devdesc": "Unsupported multicast op",
                           "moduleid": "SCOM::SCOM_DO_MULTICAST_WORKAROUND",
                           "reasoncode": "SCOM::SCOM_UNSUPPORTED_MULTICAST_OP",
                           "userdata1":  "Address",
                           "userdata1":  "Target huid",
                      },
            0x32510: {    "devdesc": "Unsupported multicast write operation",
                           "moduleid": "SCOM::SCOM_DO_MULTICAST_WORKAROUND",
                           "reasoncode": "SCOM::SCOM_MULTICAST_WRITE_INVALID",
                           "userdata1":  "Address",
                           "userdata1":  "Target huid",
                      },
            0x70A10: {    "devdesc": "FAPI_I2C_CONTROL_INFO attribute was not found",
                           "moduleid": "I2C::READ_I2C_ATTRIBUTES",
                           "reasoncode": "I2C::I2C_ATTRIBUTE_NOT_FOUND",
                           "userdata1":  "HUID of target",
                      },
            0xB0510: {    "devdesc": "Failed to either send/(receive) the requested message to/from the attribute resource provider OR the provider failed executing the message request.",
                           "moduleid": "TARG_SEND_ATTR_SYNC_MSG",
                           "reasoncode": "TARG_RC_ATTR_MSG_FAIL",
                           "userdata1[00:31]":  "Message type",
                           "userdata1[32:63]":  "API return code (from msg_send or msg_sendrecv; 0=N/A)",
                           "userdata2[00:31]":  "Message return code (0=N/A)",
                           "userdata2[32:63]":  "Message error PLID (0=N/A)",
                      },
            0xE1510: {    "devdesc": "flushToPnor mm_remove_pages FLUSH failed",
                           "moduleid": "EEPROM_FLUSH_TO_PNOR",
                           "reasoncode": "EEPROM_FAILED_TO_FLUSH_PAGE",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_remove_pages",
                      },
            0x100D10: {    "devdesc": "TOD drawer has one or more disconnected procs",
                           "moduleid": "TOD_WIRE_PROCS",
                           "reasoncode": "TOD_CREATION_ERR",
                           "userdata1[0:31]":  "Topology type : primary/secondary",
                           "userdata1[32:63]":  "TOD drawer id",
                           "userdata2":  "HUID of first disconnected proc",
                      },
            0x101110: {    "devdesc": "TOD drawer not specified",
                           "moduleid": "TOD_WIRE_PROCS",
                           "reasoncode": "TOD_INVALID_PARAM",
                           "userdata1":  "Topology type : primary/secondary",
                      },
            0x161610: {    "devdesc": "Error calling mm_block_map for Mcl Mgr",
                           "moduleid": "Util::UTIL_MCL_INIT_MEM",
                           "reasoncode": "Util::UTIL_MM_BLOCK_MAP_FAILED",
                           "userdata1":  "Address being allocated",
                           "userdata2":  "Size of block allocation",
                      },
            0x171610: {    "devdesc": "activate_threads> Could not find a target for the master core",
                           "moduleid": "ISTEP::MOD_THREAD_ACTIVATE",
                           "reasoncode": "ISTEP::RC_NO_MASTER_CORE_TARGET",
                           "userdata1":  "Master cpu id",
                           "userdata2":  "Master processor chip huid",
                      },
            0x171F10: {    "devdesc": "activate_threads> Could not find a target for the master-fused core",
                           "moduleid": "ISTEP::MOD_THREAD_ACTIVATE",
                           "reasoncode": "ISTEP::RC_NO_FUSED_CORE_TARGET",
                           "userdata1":  "Master-fused core id",
                           "userdata2":  "Master-fused processor chip huid",
                      },
            0x1E1310: {    "devdesc": "Error parsing secure header; ECID count field of specified type was non-zero.  Reinstall boot firmware.",
                           "moduleid": "SECUREBOOT::MOD_SECURE_VALIDATE_ECID_COUNT",
                           "reasoncode": "SECUREBOOT::RC_INVALID_ECID_COUNT",
                           "userdata1":  "ECID count field type",
                           "userdata2":  "Actual ECID count",
                      },
            0x231010: {    "devdesc": "Setting of LED value did not appear to work",
                           "moduleid": "GPIO_PCA9551_SET_LED",
                           "reasoncode": "GPIO_PCA9551_DATA_MISMATCH",
                           "userdata1[0:31]":  "HUID of Master Processor Target",
                           "userdata1[32:63]":  "Input LED to Set",
                           "userdata2[0:31]":  "Expected Data (aka data written)",
                           "userdata2[32:63]":  "Data Read Back",
                      },
            0x266310: {    "devdesc": "Invalid OCC error log data",
                           "moduleid": "HTMGT_MODID_PROCESS_ELOG",
                           "reasoncode": "HTMGT_RC_INVALID_OCC_ELOG",
                           "userdata1":  "instance",
                           "userdata2":  "error source",
                           "userdata3":  "OCC RC",
                           "userdata4":  "OCC severity / actions",
                      },
            0x267D10: {    "devdesc": "Bad FRU data received in OCC error log",
                           "moduleid": "HTMGT_MODID_PROCESS_ELOG",
                           "reasoncode": "HTMGT_RC_BAD_FRU_CALLOUTS",
                           "userdata1[0:15]":  "OCC elog id",
                           "userdata1[16:31]":  "Bad callout index",
                      },
            0x267F10: {    "devdesc": "No FRU callouts found for non-info OCC Error",
                           "moduleid": "HTMGT_MODID_PROCESS_ELOG",
                           "reasoncode": "HTMGT_RC_MISMATCHING_SEVERITY",
                           "userdata1[0:15]":  "OCC elog id",
                           "userdata1[16:31]":  "OCC severity",
                      },
            0x286310: {    "devdesc": "startDeadmanLoop was called twice in a row",
                           "moduleid": "SBEIO_DEAD_MAN_TIMER",
                           "reasoncode": "SBEIO_START_DMT_CALLED_TWICE",
                      },
            0x332B10: {    "devdesc": "WOF image header magic value mismatch",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                           "reasoncode": "fapi2::RC_WOF_IMAGE_MAGIC_MISMATCH",
                           "userdata1[00:31]":  "Image header magic value",
                           "userdata1[32:63]":  "Expected magic value",
                           "userdata2[00:63]":  "Image header version",
                      },
            0x332C10: {    "devdesc": "WOF tables header magic value mismatch",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                           "reasoncode": "fapi2::RC_WOF_TABLES_MAGIC_MISMATCH",
                           "userdata1[00:31]":  "WOF tables header magic value",
                           "userdata1[32:63]":  "Expected magic value",
                           "userdata2[00:63]":  "WOF tables header version",
                      },
            0x332E10: {    "devdesc": "Image header version not supported",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                           "reasoncode": "fapi2::RC_WOF_IMAGE_VERSION_MISMATCH",
                           "userdata1[00:31]":  "Image header version",
                           "userdata1[32:63]":  "Supported header version",
                      },
            0x332F10: {    "devdesc": "WOF tables header version not supported",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_PARSE_WOF_TABLES",
                           "reasoncode": "fapi2::RC_WOF_TABLES_VERSION_MISMATCH",
                           "userdata1[00:31]":  "WOF tables header version",
                           "userdata1[32:63]":  "Max supported header version",
                           "userdata2":  "WOF tables entry number if WOF img was retrieved from PNOR. 0 if WOF img was retrieved from EEPROM.",
                      },
            0x351810: {    "devdesc": "Encountered error arming the catastrophic save trigger on NVDIMM. Make sure an energy source is connected to the NVDIMM and the ES policy is set properly",
                           "moduleid": "NVDIMM_SET_ARM",
                           "reasoncode": "NVDIMM_ARM_FAILED",
                           "userdata1[0:31]":  "Related ops (0xff = NA)",
                           "userdata1[32:63]":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0x470E10: {    "devdesc": "Software problem, failed to encode PLDM message",
                           "moduleid": "MOD_PLDM_FRU_TO_IPZ",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1[0:15]":  "Record set ID of current record i",
                           "userdata1[16:31]":  "Record type of current record i",
                           "userdata2":  "unused",
                      },
            0x471210: {    "devdesc": "BMC sent fru info host does not understand",
                           "moduleid": "MOD_PLDM_FRU_TO_IPZ",
                           "reasoncode": "RC_UNSUPPORTED_FIELD",
                           "userdata1":  "record name (ascii)",
                           "userdata2":  "PLDM Fru field type",
                      },
            0x30111: {    "devdesc": "The scom address provided was invalid, check to see if the address matches a target in the scomdef file.",
                           "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                           "reasoncode": "SCOM::SCOM_INVALID_ADDR",
                           "userdata1":  "Address",
                           "userdata2[0:15]":  "Target's Type",
                           "userdata2[16:31]":  "Instance of this type",
                           "userdata2[32:39]":  "Is this SCOM addr related to a chip unit?",
                           "userdata2[40:47]":  "Does the target type and addr type match?",
                           "userdata2[48:55]":  "Chip unit of the target",
                           "userdata2[56:63]":  "Model of the target (ex: POWER10)",
                      },
            0x30A11: {    "devdesc": "Scom Translation did not modify the address",
                           "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                           "reasoncode": "SCOM::SCOM_INVALID_TRANSLATION",
                           "userdata1":  "Original Address",
                           "userdata2[0:15]":  "l_chipUnit",
                           "userdata2[16:31]":  "instance of target",
                           "userdata2[32:63]":  "HUID of target",
                      },
            0x30C11: {    "devdesc": "The scom target did not match the provided address",
                           "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                           "reasoncode": "SCOM::SCOM_TARGET_ADDR_MISMATCH",
                           "userdata1":  "Address",
                           "userdata2[0:15]":  "Target's Type",
                           "userdata2[16:31]":  "Instance of this type",
                           "userdata2[32:39]":  "Is this SCOM addr related to a chip unit?",
                           "userdata2[40:47]":  "Does the target type and addr type match?",
                           "userdata2[48:55]":  "Chip unit of the target",
                           "userdata2[56:63]":  "Model of the target (ex: POWER10)",
                      },
            0x30D11: {    "devdesc": "EKB code has detected and error in the scom",
                           "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                           "reasoncode": "SCOM::SCOM_ISCHIPUNITSCOM_INVALID",
                           "userdata1":  "Input address",
                           "userdata2[0:31]":  "Target huid",
                           "userdata2[32:63]":  "Target Type",
                      },
            0x32011: {    "devdesc": "Scom Translate not supported for this type",
                           "moduleid": "SCOM::SCOM_TRANSLATE_P10",
                           "reasoncode": "SCOM::SCOM_P10_TRANS_INVALID_TYPE",
                           "userdata1":  "Address",
                           "userdata2[0:31]":  "Target's Type",
                           "userdata2[32:63]":  "Target's Huid",
                      },
            0x71411: {    "devdesc": "I2C mux path target is null",
                           "moduleid": "I2C_ACCESS_MUX",
                           "reasoncode": "I2C_MUX_TARGET_NOT_FOUND",
                      },
            0x71511: {    "devdesc": "I2C mux path target is not functional",
                           "moduleid": "I2C_ACCESS_MUX",
                           "reasoncode": "I2C_MUX_TARGET_NON_FUNCTIONAL",
                           "userdata1":  "I2C MUX Target Huid",
                      },
            0xB1C11: {    "devdesc": "Can't find targeting target for given runtime target ID",
                           "moduleid": "TARGETING::TARG_TRANSLATE_TARGET",
                           "reasoncode": "TARGETING::TARG_RC_TARGET_TYPE_NOT_SUPPORTED",
                           "userdata1":  "Runtime target ID",
                      },
            0xE0E11: {    "devdesc": "New part has likely been loaded into the system.",
                           "moduleid": "EEPROM_FIND_EEPROM_HEADER_IN_CACHE",
                           "reasoncode": "EEPROM_NEW_DEVICE_DETECTED",
                           "userdata1[0:31]":  "Old Size of Eeprom",
                           "userdata1[32:63]":  "New Size of Eeprom",
                           "userdata2[0:31]":  "HUID of Master",
                           "userdata2[32:39]":  "Port (or 0xFF)",
                           "userdata2[40:47]":  "Engine",
                           "userdata2[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata2[56:63]":  "mux_select (or byte 1 offset_KB)",
                      },
            0xE1911: {    "devdesc": "Max records allowable has been reached in PNOR EECACHE",
                           "moduleid": "EEPROM_FIND_EEPROM_HEADER_IN_CACHE",
                           "reasoncode": "EEPROM_REACHED_MAX_CAPACITY",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:63]":  "Capcity is FULL at MAX_EEPROMS_LATEST",
                      },
            0xE1C11: {    "devdesc": "Expecting nullptr for o_recordHeaderFromPnor",
                           "moduleid": "EEPROM_FIND_EEPROM_HEADER_IN_CACHE",
                           "reasoncode": "EEPROM_NEED_O_RECORD_PTR_EMPTY",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2":  "Target HUID",
                      },
            0x100D11: {    "devdesc": "TOD drawer couldn't be wired",
                           "moduleid": "TOD_WIRE_DRAWERS",
                           "reasoncode": "TOD_CREATION_ERR",
                           "userdata1":  "Topology type : primary/secondary",
                           "userdata2":  "TOD drawer id",
                      },
            0x101111: {    "devdesc": "TOD drawer not specified",
                           "moduleid": "TOD_WIRE_DRAWERS",
                           "reasoncode": "TOD_INVALID_PARAM",
                           "userdata1":  "Topology type : primary/secondary",
                      },
            0x101211: {    "devdesc": "MDMT could not be found",
                           "moduleid": "TOD_WIRE_DRAWERS",
                           "reasoncode": "TOD_MASTER_TARGET_NOT_FOUND",
                           "userdata1":  "Topology type : primary/secondary",
                      },
            0x161711: {    "devdesc": "Error calling mm_block_unmap for Mcl Mgr",
                           "moduleid": "Util::UTIL_MCL_REL_MEM",
                           "reasoncode": "Util::UTIL_MM_BLOCK_UNMAP_FAILED",
                           "userdata1":  "Address being removed",
                           "userdata2":  "rc from mm_block_unmap",
                      },
            0x173811: {    "devdesc": "Failed to boot a slave SBE",
                           "moduleid": "MOD_CHECK_SECONDARY_SBE_SEEPROM_COMPLETE",
                           "reasoncode": "RC_FAILED_TO_BOOT_SBE",
                           "userdata1":  "HUID of proc that failed to boot its SBE",
                           "userdata2":  "Unused",
                      },
            0x1E1411: {    "devdesc": "Failed to lock secure mailboxes on target processor.",
                           "moduleid": "MOD_LOCK_SECURE_MAILBOXES",
                           "reasoncode": "RC_LOCK_MAILBOXES_FAILED",
                           "userdata1":  "Target HUID",
                      },
            0x280611: {    "devdesc": "Invalid target attempted for SBE hw register access",
                           "moduleid": "SBEIO_PSU_GET_HW_REG",
                           "reasoncode": "SBEIO_PSU_INVALID_TARGET",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Target Type",
                           "userdata2":  "HwReg Address",
                      },
            0x286411: {    "devdesc": "Invalid target attempted for SBE hw register access",
                           "moduleid": "SBEIO_PSU_GET_HW_REG",
                           "reasoncode": "SBEIO_NO_PARENT_PROC",
                           "userdata1":  "Target HUID",
                           "userdata2":  "HwReg Address",
                      },
            0x2BAA11: {    "devdesc": "TPM log buffer add failure.",
                           "moduleid": "MOD_TPMLOGMGR_ADDEVENT",
                           "reasoncode": "RC_TPMLOGMGR_ADDEVENT_FAIL",
                           "userdata1[0:31]":  "Max log size",
                           "userdata1[32:63]":  "Log buffer NULL",
                           "userdata2[0:15]":  "Current Log Size",
                           "userdata2[16:31]":  "Max TPM Log Message Size",
                           "userdata2[32:63]":  "New entry size",
                      },
            0x2BAB11: {    "devdesc": "log buffer marshal failure.",
                           "moduleid": "MOD_TPMLOGMGR_ADDEVENT",
                           "reasoncode": "RC_TPMLOGMGR_ADDEVENTMARSH_FAIL",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x470511: {    "devdesc": "Software problem, unable to translate PLDM Fru Table from BMC to IPZ format",
                           "moduleid": "MOD_GENERATE_VTOC_RECORD",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Estimated size of the PT entry",
                           "userdata2":  "unused",
                      },
            0x900D11: {    "devdesc": "Device read failed",
                           "moduleid": "HDAT::MOD_UTIL_VPD",
                           "reasoncode": "HDAT::RC_DEV_READ_FAIL",
                      },
            0x71712: {    "devdesc": "ocmbPresenceDetect> Master i2c path returned nullptr",
                           "moduleid": "I2C::I2C_GENERIC_PRES_DETECT",
                           "reasoncode": "I2C::I2C_NULL_MASTER_TARGET",
                           "userdata1":  "HUID of target being detected",
                           "userdata2":  "Unused",
                      },
            0x93012: {    "devdesc": "Extra bad bits set for DIMM",
                           "moduleid": "MOD_FAPI2_BAD_DQ_BITMAP",
                           "reasoncode": "RC_BAD_DQ_MFG_MODE_BITS",
                           "userdata1":  "DIMM Target HUID",
                           "userdata2":  "<unused>",
                      },
            0xB0212: {    "devdesc": "Incorrect pointer to targeting was passed",
                           "moduleid": "TARG_GET_ATTR_METADATA_PTR",
                           "reasoncode": "TARG_RC_BAD_EYECATCH",
                           "userdata1":  "Expected targeting eye catcher",
                           "userdata2":  "Actual eye catcher",
                      },
            0xB1F12: {    "devdesc": "HBD metadata section was not found in targeting image",
                           "moduleid": "TARG_GET_ATTR_METADATA_PTR",
                           "reasoncode": "TARG_RC_NO_METADATA",
                           "userdata1":  "The number of sections included in the HBD image",
                      },
            0xB2012: {    "devdesc": "nullptr was passed as the targeting pointer",
                           "moduleid": "TARG_GET_ATTR_METADATA_PTR",
                           "reasoncode": "TARG_RC_BAD_TARGETING_PTR",
                      },
            0xC2412: {    "devdesc": "SBE and HB targets configuration do not match.",
                           "moduleid": "MOD_DECONFIG_TARGETS_FROM_GARD_AND_VPD",
                           "reasoncode": "RC_HB_SBE_DECONFIG_MISMATCH",
                           "userdata1":  "Target HUID",
                           "userdata2[0:31]":  "SBE target functional? (0: no, 1: yes)",
                           "userdata2[32:63]":  "HB target functional? (0: no, 1: yes)",
                      },
            0xC2512: {    "devdesc": "One or more SBE/HB deconfiguration mismatches exist; see other logs",
                           "moduleid": "MOD_DECONFIG_TARGETS_FROM_GARD_AND_VPD",
                           "reasoncode": "RC_HB_SBE_DECONFIG_MISMATCHES_EXIST",
                      },
            0xE1612: {    "devdesc": "No functional EEPROM source available",
                           "moduleid": "EEPROM_DISABLE_NEXT_MVPD_SOURCE",
                           "reasoncode": "EEPROM_NO_FUNCTIONAL_EEPROM",
                           "userdata1":  "Mask from ATTR_EEPROM_VPD_ACCESSIBILITY",
                           "userdata2":  "HUID of target",
                      },
            0xF0C12: {    "devdesc": "Error encountered sending coalesce message to INTRP",
                           "moduleid": "INTR::MOD_INTRRP_XIVE_SENDEOI",
                           "reasoncode": "INTR::RC_MESSAGE_SEND_ERROR",
                           "userdata1":  "RC from msg_send command",
                      },
            0x101312: {    "devdesc": "No MDMT present on the system",
                           "moduleid": "TOD_INIT_HWP",
                           "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                           "userdata1":  "EMOD_TOD_INIT_HWP",
                           "userdata2":  "PRIMARY topology type",
                      },
            0x160612: {    "devdesc": "Error processing component for Mcl Mgr",
                           "moduleid": "Util::UTIL_MCL_PROCESS_COMP",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_SIZE",
                           "userdata1[0:31]":  "Total Size of Component",
                           "userdata1[32:63]":  "Max size of memory region",
                           "userdata2":  "Component ID [truncated to 8 bytes]",
                      },
            0x161812: {    "devdesc": "Error processing component for Mcl Mgr",
                           "moduleid": "Util::UTIL_MCL_PROCESS_COMP",
                           "reasoncode": "Util::UTIL_MCL_SIZE_MISMATCH",
                           "userdata1[0:31]":  "Total Size of Component",
                           "userdata1[32:63]":  "Size read by FSP",
                           "userdata2":  "Component ID [truncated to 8 bytes]",
                      },
            0x1A1A12: {    "devdesc": "The targeting type of the input targeting target is not supported by runtime code",
                           "moduleid": "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET",
                           "reasoncode": "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED",
                           "userdata1":  "Targeting target's HUID",
                           "userdata2":  "Targeting target's type",
                      },
            0x1A1B12: {    "devdesc": "No processor targeting target was found for the given targeting target",
                           "moduleid": "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET",
                           "reasoncode": "RUNTIME::RT_NO_PROC_TARGET",
                           "userdata1":  "Input targeting target's HUID",
                      },
            0x1A4912: {    "devdesc": "No associated OMI targeting target(s) found for given OCMB targeting target",
                           "moduleid": "RUNTIME::MOD_CUST_COMP_NON_PHYP_RT_TARGET",
                           "reasoncode": "RUNTIME::RT_NO_OMI_TARGET_FOUND",
                           "userdata1":  "OCMB targeting target's HUID",
                      },
            0x1D3f12: {    "devdesc": "ocmbPresenceDetect> Invalid master i2c path",
                           "moduleid": "I2C::I2C_GENERIC_PRES_DETECT",
                           "reasoncode": "VPD::VPD_INVALID_MASTER_I2C_PATH",
                           "userdata1":  "HUID of target being detected",
                           "userdata2":  "Unused",
                      },
            0x1E1512: {    "devdesc": "Planar jumper configuration and other security info",
                           "moduleid": "SECUREBOOT::MOD_SECURE_LOG_PLAT_SECURITY_CONFIG",
                           "reasoncode": "SECUREBOOT::RC_SECURE_LOG_PLAT_SECURITY_CONFIG",
                           "userdata1":  "Minimum FW Secure Version",
                           "userdata2[0:31]":  "Measurement Seeprom Version",
                           "userdata2[32:63]":  "System HW Keys' Hash",
                      },
            0x2BB012: {    "devdesc": "TPM log header entry is missing.",
                           "moduleid": "MOD_TPMLOGMGR_INITIALIZEEXISTLOG",
                           "reasoncode": "RC_TPMLOGMGR_LOGWALKFAIL",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x470512: {    "devdesc": "Software problem during fru record table translation",
                           "moduleid": "MOD_GENERATE_PT_ENTRIES",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Expected Size",
                           "userdata2":  "Actual Size",
                      },
            0x470F12: {    "devdesc": "Software problem during fru record table translation",
                           "moduleid": "MOD_GENERATE_PT_ENTRIES",
                           "reasoncode": "RC_INVALID_IPZ_FORMAT",
                           "userdata1":  "Bytes 0:7 of ipz_record",
                           "userdata2":  "IPZ record size",
                      },
            0x32413: {    "devdesc": "A MMIO operation was attempted on an unsupported OCMB chip.",
                           "moduleid": "SCOM::MOD_ROUTE_IBSCOM",
                           "reasoncode": "SCOM::SCOM_UNSUPPORTED_CHIPID",
                           "userdata1[00:31]":  "OCMB HUID",
                           "userdata1[32:63]":  "OCMB chip ID",
                           "userdata2":  "SCOM Address",
                      },
            0x71D13: {    "devdesc": "A bad PEC byte was found during the device operation.",
                           "moduleid": "I2C_BAD_PEC_BYTE_ERROR",
                           "reasoncode": "I2C_BAD_PEC_BYTE",
                           "userdata1[00:31]":  "Expected PEC byte",
                           "userdata1[32:63]":  "Actual PEC byte",
                      },
            0xB2113: {    "devdesc": "nullptr passed for RW attribute data pointer",
                           "moduleid": "TARG_PARSE_RW_ATTR_DATA",
                           "reasoncode": "TARG_RC_BAD_RW_ATTR_PTR",
                      },
            0xC0F13: {    "devdesc": "Found a chip which has an EC level that is not in the MSL list from the MRW",
                           "moduleid": "MOD_VALIDATE_EC_MSL_LEVELS",
                           "reasoncode": "RC_EC_MISMATCH",
                           "userdata1[00:31]":  "HUID of the chip",
                           "userdata1[32:63]":  "EC level of the chip",
                           "userdata2":  "Unused",
                      },
            0xC2713: {    "devdesc": "One or more chips had an unsupported EC level compared to the given MRW values.",
                           "moduleid": "MOD_VALIDATE_EC_MSL_LEVELS",
                           "reasoncode": "RC_FAILED_MSL_EC_VALIDATION",
                           "userdata1[00:63]":  "Number of failing chips",
                           "userdata2[00:31]":  "MSL_CHECK MNFG flag state 1=set,0=unset",
                           "userdata2[32:63]":  "Unused",
                      },
            0xC2813: {    "devdesc": "The MRW provided MSL values array was found to be empty.",
                           "moduleid": "MOD_VALIDATE_EC_MSL_LEVELS",
                           "reasoncode": "RC_EMPTY_MRW_MSL_ARRAY",
                           "userdata1[00:31]":  "MSL_CHECK MNFG flag state 1=set,0=unset",
                           "userdata1[32:63]":  "Unused",
                      },
            0xE1813: {    "devdesc": "A new EECACHE layout found and Hostboot must rebuild EECACHE",
                           "moduleid": "EEPROM_CACHE_INIT",
                           "reasoncode": "EEPROM_VERSION_UPDATED",
                           "userdata1":  "Old Version of EECACHE",
                           "userdata2":  "New Version of EEACHE",
                      },
            0xF0D13: {    "devdesc": "Error encountered routing IPC message",
                           "moduleid": "INTR::MOD_INTRRP_IPC",
                           "reasoncode": "INTR::RC_IPC_DATA_INVALID",
                           "userdata1":  "IPC Data Area MSG Queue ID",
                           "userdata2":  "PIR",
                      },
            0x100713: {    "devdesc": "Error: Initialization of chip TOD logic cannot be done when its already in the running state",
                           "moduleid": "TOD_INIT_ALREADY_RUNNING",
                           "reasoncode": "TOD_INVALID_ACTION",
                           "userdata1":  "EMOD_TOD_INIT",
                           "userdata2":  "ChipTOD logic HW state, 1=running, zero otherwise",
                      },
            0x1A1A13: {    "devdesc": "Targeting target's type not supported by runtime code",
                           "moduleid": "RUNTIME::MOD_CUST_CONF_HBRT_HYP_IDS",
                           "reasoncode": "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED",
                           "userdata1":  "Target's HUID",
                           "userdata2":  "Target's targeting type",
                      },
            0x1D3e13: {    "devdesc": "getVpdLocation> VPD_REC_NUM is invalid, bad MRW",
                           "moduleid": "VPD_GET_VPD_LOCATION",
                           "reasoncode": "VPD_BAD_REC_NUM",
                           "userdata1":  "Target HUID",
                           "userdata2":  "VPD_REC_NUM",
                      },
            0x280513: {    "devdesc": "Software problem, call to performPsuChipOp failed when sending Topology Id Table",
                           "moduleid": "SBEIO_PSUSYNCFABTOPOIDTABLE",
                           "reasoncode": "SBEIO_PSU_SEND",
                           "userdata1":  "The PROC Target HUID",
                           "userdata2[00:31]":  "PSU response, primary status",
                           "userdata2[32:63]":  "PSU response, secondary status",
                      },
            0x333913: {    "devdesc": "Detecting more than 1 parent proc targets",
                           "moduleid": "fapi2::MOD_FAPI2_GET_CHIP_CFAM_TARGET",
                           "reasoncode": "fapi2::RC_INVALID_PARENT_TARGET_FOUND",
                           "userdata1":  "Number of parent proc chips found",
                           "userdata2":  "HUID of input target",
                      },
            0x351A13: {    "devdesc": "NVDIMM failed to restore data. This is likely due to failure entering self-refresh and/or restore timeout (Controller error)",
                           "moduleid": "NVDIMM_RESTORE",
                           "reasoncode": "NVDIMM_RESTORE_FAILED",
                           "userdata1":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0x470513: {    "devdesc": "Location code length found from the FRU Record Table exceeds the maximum size set for the location code",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Fru record TLV length",
                           "userdata2":  "Size of location code buffer",
                      },
            0x471013: {    "devdesc": "Unable to find correct record set ID(s) for PLDM entity",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_INVALID_RSI_COUNT",
                           "userdata1":  "# of Record Set Ids found",
                           "userdata2":  "Entity Type",
                      },
            0x471313: {    "devdesc": "Unable to find records associated with record set id in fru record table",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_INVALID_RECORD_COUNT",
                           "userdata1":  "record set id we are looking up",
                           "userdata2[0:31]":  "entity type",
                           "userdata2[32:64]":  "fru record type",
                      },
            0x471413: {    "devdesc": "Unable to find records associated with record set id in fru record table",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_INVALID_LOCATION_CODE",
                           "userdata1":  "record set id we are looking up",
                           "userdata2":  "entity type",
                      },
            0x471E13: {    "devdesc": "Location code from BMC is too long to store in attribute",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_OVERLONG_LOCATION_CODE",
                           "userdata1":  "Max length of location codes",
                           "userdata2":  "Length of location code",
                      },
            0x473F13: {    "devdesc": "Part number from BMC was not found from the FRU Record Table",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_PN_NOT_FOUND",
                           "userdata1":  "Record Set Index",
                           "userdata2":  "Size of part number vector",
                      },
            0x474013: {    "devdesc": "Serial number from BMC was not found from the FRU Record Table",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_SN_NOT_FOUND",
                           "userdata1":  "Record Set Index",
                           "userdata2":  "Size of serial number vector",
                      },
            0x474113: {    "devdesc": "CCIN from BMC was not found from the FRU Record Table",
                           "moduleid": "MOD_CACHE_REMOTE_FRU_VPD",
                           "reasoncode": "RC_CCIN_NOT_FOUND",
                           "userdata1":  "Record Set Index",
                           "userdata2":  "Size of ccin vector",
                      },
            0x901013: {    "devdesc": "Failed to fetch the raw SPD data for the dimm",
                           "moduleid": "HDAT::MOD_UTIL_SPD_READ_FUNC",
                           "reasoncode": "HDAT::RC_SPD_READ_FAIL",
                           "userdata1":  "spd keyword",
                           "userdata2":  "raw spd keyword size returned",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0x30114: {    "devdesc": "The scom address provided was invalid, check to see if the address matches a target in the scomdef file.",
                           "moduleid": "SCOM::SCOM_TRANSLATE_ODY",
                           "reasoncode": "SCOM::SCOM_INVALID_ADDR",
                           "userdata1":  "Scom Address",
                           "userdata2[00:15]":  "Target's Type",
                           "userdata2[16:31]":  "Instance of this type",
                           "userdata2[32:39]":  "Is this SCOM addr related to a chip unit?",
                           "userdata2[40:47]":  "Does the target type and addr type match?",
                           "userdata2[48:55]":  "Chip unit of the target",
                           "userdata2[56:63]":  "<unused>",
                      },
            0x30A14: {    "devdesc": "Scom Translation did not modify the address",
                           "moduleid": "SCOM::SCOM_TRANSLATE_ODY",
                           "reasoncode": "SCOM::SCOM_INVALID_TRANSLATION",
                           "userdata1":  "Original Address",
                           "userdata2[0:15]":  "l_chipUnit",
                           "userdata2[16:31]":  "instance of target",
                           "userdata2[32:63]":  "HUID of target",
                      },
            0x30C14: {    "devdesc": "The scom target did not match the provided address",
                           "moduleid": "SCOM::SCOM_TRANSLATE_ODY",
                           "reasoncode": "SCOM::SCOM_TARGET_ADDR_MISMATCH",
                           "userdata1":  "Address",
                           "userdata2[0:15]":  "Target's Type",
                           "userdata2[16:31]":  "Instance of this type",
                           "userdata2[32:39]":  "Is this SCOM addr related to a chip unit?",
                           "userdata2[40:47]":  "Does the target type and addr type match?",
                           "userdata2[48:55]":  "Chip unit of the target",
                           "userdata2[56:63]":  "<unused>",
                      },
            0x30D14: {    "devdesc": "EKB code has detected and error in the scom",
                           "moduleid": "SCOM::SCOM_TRANSLATE_ODY",
                           "reasoncode": "SCOM::SCOM_ISCHIPUNITSCOM_INVALID",
                           "userdata1":  "Input address",
                           "userdata2[0:31]":  "Target huid",
                           "userdata2[32:63]":  "Target Type",
                      },
            0x32614: {    "devdesc": "Scom Translate not supported for this type",
                           "moduleid": "SCOM::SCOM_TRANSLATE_ODY",
                           "reasoncode": "SCOM::SCOM_ODY_TRANS_INVALID_TYPE",
                           "userdata1":  "Address",
                           "userdata2[0:31]":  "Target's Type",
                           "userdata2[32:63]":  "Target's Huid",
                      },
            0x70214: {    "devdesc": "Invalid operation type.",
                           "moduleid": "RT_I2C_PERFORM_OP",
                           "reasoncode": "I2C_INVALID_OP_TYPE",
                           "userdata1":  "i_opType",
                           "userdata2[0:15]":  "Offset Length",
                           "userdata2[16:31]":  "Master Port",
                           "userdata2[32:47]":  "Master Engine",
                           "userdata2[48:63]":  "Slave Device Address",
                      },
            0x70714: {    "devdesc": "Master Sentinel chip was used as a target for an I2C operation.  This is not permitted.",
                           "moduleid": "RT_I2C_PERFORM_OP",
                           "reasoncode": "I2C_MASTER_SENTINEL_TARGET",
                           "userdata1":  "Operation Type requested",
                           "userdata2":  "<UNUSED>",
                      },
            0x70D14: {    "devdesc": "I2C read/write interface not linked.",
                           "moduleid": "RT_I2C_PERFORM_OP",
                           "reasoncode": "I2C_RUNTIME_INTERFACE_ERR",
                           "userdata1":  "0",
                           "userdata2":  "Op type",
                      },
            0x70E14: {    "devdesc": "I2C access error",
                           "moduleid": "RT_I2C_PERFORM_OP",
                           "reasoncode": "I2C_RUNTIME_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2":  "Op type",
                      },
            0x70F14: {    "devdesc": "I2C offset length is invalid",
                           "moduleid": "RT_I2C_PERFORM_OP",
                           "reasoncode": "I2C_RUNTIME_INVALID_OFFSET_LENGTH",
                           "userdata1":  "Offset length",
                           "userdata2[0:31]":  "Operation Type",
                           "userdata2[32:64]":  "Target",
                      },
            0x71E14: {    "devdesc": "a valid pointer for io_buffer was passed for a runtime Page Switch op. Runtime Page Switch ops must be called with io_buflen set to nullptr so it can be used for the special device write to switch eeprom pages",
                           "moduleid": "RT_I2C_PERFORM_OP",
                           "reasoncode": "I2C_RUNTIME_INVALID_PAGE_OP_BUFFER",
                           "userdata1":  "io_buflen",
                           "userdata2":  "Up to first 8 bytes of io_buffer",
                      },
            0xB2214: {    "devdesc": "nullptr passed for metadata section pointer",
                           "moduleid": "TARG_PARSE_ATTR_METADATA",
                           "reasoncode": "TARG_RC_BAD_METADATA_PTR",
                      },
            0xC2914: {    "devdesc": "An uneven number of spare core bits were set in the partial good for a chip.",
                           "moduleid": "MOD_COUNT_SPARE_CORES",
                           "reasoncode": "RC_UNEVEN_SPARE_CORE_COUNT",
                           "userdata1":  "HUID of the chip",
                           "userdata2":  "Number of spare bits set",
                      },
            0xE1A14: {    "devdesc": "Attempted to create a new eecache entry without a PNOR slot",
                           "moduleid": "EEPROM_CREATE_NEW_EECACHE_ENTRY",
                           "reasoncode": "EEPROM_CREATE_PNOR_ENTRY_EMPTY",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:63]":  "size of buffer",
                      },
            0xE1D14: {    "devdesc": "Mismatch between cached_copy_valid and target presence",
                           "moduleid": "EEPROM_CREATE_NEW_EECACHE_ENTRY",
                           "reasoncode": "EEPROM_MISMATCH_TARGET_PRESENCE",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:31]":  "i_updateContents",
                           "userdata2[32:63]":  "copyValid",
                      },
            0xE1E14: {    "devdesc": "Out of space for adding to PNOR EECACHE",
                           "moduleid": "EEPROM_CREATE_NEW_EECACHE_ENTRY",
                           "reasoncode": "EEPROM_EECACHE_OUT_OF_SPACE",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:63]":  "Size of EECACHE in PNOR",
                      },
            0xE2014: {    "devdesc": "Attempt to add an already existing EECACHE entry",
                           "moduleid": "EEPROM_CREATE_NEW_EECACHE_ENTRY",
                           "reasoncode": "EEPROM_DUP_EECACHE_UPDATE",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                      },
            0xF0314: {    "devdesc": "Interrupt resource provider not initialized yet.",
                           "moduleid": "INTR::MOD_INTR_DUMP",
                           "reasoncode": "INTR::RC_RP_NOT_INITIALIZED",
                           "userdata1":  "MSG_INTR_DUMP",
                           "userdata2":  "0",
                      },
            0xF0C14: {    "devdesc": "Error encountered sending print intr info message to INTRP",
                           "moduleid": "INTR::MOD_INTR_DUMP",
                           "reasoncode": "INTR::RC_MESSAGE_SEND_ERROR",
                           "userdata1":  "RC from msg_send command",
                      },
            0x100714: {    "devdesc": "Error: TOD HW logic is not running, only use case of resetBackup is when TOD is already running",
                           "moduleid": "TOD::TOD_RESET_BACKUP",
                           "reasoncode": "TOD::TOD_INVALID_ACTION",
                           "userdata1":  "ChipTOD logic HW state, 1 means running, zero otherwise",
                      },
            0x161A14: {    "devdesc": "Unable to find frequency list",
                           "moduleid": "UTIL_MOD_GET_OBUS_PLL_BUCKET",
                           "reasoncode": "UTIL_ERC_NO_FREQ_LIST",
                           "userdata1":  "HB Target HUID",
                           "userdata1[0:31]":  "Chip model",
                           "userdata2[32:63]":  "Chip EC level",
                      },
            0x161B14: {    "devdesc": "No matching frequency for PLL bucket",
                           "moduleid": "UTIL_MOD_GET_OBUS_PLL_BUCKET",
                           "reasoncode": "UTIL_ERC_NO_MATCHING_FREQ",
                           "userdata1":  "HB Target HUID",
                           "userdata2":  "Input frequency",
                      },
            0x171C14: {    "devdesc": "Timeout waiting for OCC checkpoint",
                           "moduleid": "ISTEP::MOD_PM_VERIFY_OCC_CHKPT",
                           "reasoncode": "ISTEP::RC_PM_OCC_CHKPT_TIMEOUT",
                           "userdata1":  "HUID",
                           "userdata2":  "Checkpoint value",
                      },
            0x1E1714: {    "devdesc": "Could not allocate any requested SMF memory. The system may not have enough available memory.",
                           "moduleid": "SECUREBOOT::MOD_SMF_SPLIT_SMF_MEM",
                           "reasoncode": "SECUREBOOT::RC_COULD_NOT_ALLOCATE_SMF_MEM",
                           "userdata1":  "Requested amount of SMF memory",
                           "userdata2":  "Total amount of mem available on the system",
                      },
            0x1E1814: {    "devdesc": "The amount of SMF memory alocated does not match the requested SMF memory amount. A rounding error may have occurred or there is not enough of memory on the system.",
                           "moduleid": "SECUREBOOT::MOD_SMF_SPLIT_SMF_MEM",
                           "reasoncode": "SECUREBOOT::RC_ALLOCATED_NE_REQUESTED",
                           "userdata1":  "Requested amount of SMF memory",
                           "userdata2":  "Actual allocated amount of SMF memory",
                      },
            0x220F14: {    "devdesc": "Error Associated with Updating this Target",
                           "moduleid": "SBE_GET_HW_KEY_HASH",
                           "reasoncode": "SBE_ECC_FAIL",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Seeprom Side",
                           "userdata2[0:15]":  "ECC Status",
                           "userdata2[16:31]":  "No-ECC Data Size",
                           "userdata2[32:63]":  "Offset into Seeprom Data Came From",
                      },
            0x221914: {    "devdesc": "Error Associated with Target's SBE Seeprom",
                           "moduleid": "SBE_GET_HW_KEY_HASH",
                           "reasoncode": "ERROR_FROM_XIP_FIND",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Seeprom Side",
                           "userdata2[0:15]":  "Offset of sb_settings Section in Seeprom Image",
                           "userdata2[16:31]":  "Size of sb_settings Section in Seeprom Image",
                           "userdata2[32:63]":  "Return Code from p9_xip_get_section",
                      },
            0x281814: {    "devdesc": "Attempted FIFO chip op on invalid chip",
                           "moduleid": "SBEIO_FIFO_HALT",
                           "reasoncode": "SBEIO_FIFO_MASTER_TARGET",
                           "userdata1":  "The chip HUID",
                      },
            0x2BB414: {    "devdesc": "Failed to set SEEPROM lock and/or TPM deconfig protection for this processor, so we cannot guarrantee platform secuirty for this processor",
                           "moduleid": "TRUSTEDBOOT::MOD_TPM_MARK_FAILED",
                           "reasoncode": "TRUSTEDBOOT::RC_UPDATE_SECURITY_CTRL_HWP_FAIL",
                           "userdata1":  "Processor Target",
                           "userdata2":  "TPM Target",
                      },
            0x351614: {    "devdesc": "NVDIMM OpenPage timed out, likely due to controller error",
                           "moduleid": "NVDIMM_OPEN_PAGE",
                           "reasoncode": "NVDIMM_OPEN_PAGE_TIMEOUT",
                           "userdata1[0:31]":  "Related ops (0xff = NA)",
                           "userdata1[32:63]":  "Target Huid",
                           "userdata2[0:31]":  "Polled value",
                           "userdata2[32:63]":  "Timeout value",
                      },
            0x470514: {    "devdesc": "Unable to find the location code in the record set provided by caller",
                           "moduleid": "MOD_GET_LOCATION_CODE",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "record set id of record set passed by caller (or 0xFFFFFFFF if the record set is empty)",
                           "userdata2":  "unused",
                      },
            0x901114: {    "devdesc": "Exceeded limit of number of mainstore VPD In Memory Trace array entries",
                           "moduleid": "MOD_ADD_IMT_ADDR_RANGE",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current number of array entries",
                           "userdata2":  "maximum number of array entries",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0x60215: {    "devdesc": "PnorSfcDD::eraseFlash> Address not on erase boundary",
                           "moduleid": "PNOR::MOD_PNORDD_ERASEFLASH",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1":  "Flash Address",
                           "userdata2":  "Nearest Erase Boundary",
                      },
            0x92615: {    "devdesc": "The hwsv found an error while processing the message so it sent an error message back to indicate to HostBoot to stop the IPL. Userdata1 will have the error PLID from hwsv's errorlog",
                           "moduleid": "fapi::MOD_VDDR_PROC_MSG",
                           "reasoncode": "fapi::RC_VDDR_ERROR_MSG",
                           "userdata1":  "error PLID from hwsv",
                           "userdata2":  "0",
                      },
            0x92815: {    "devdesc": "HB got an incorrect type message. HWSV did not populate the message correctly or mbox corrupted the message",
                           "moduleid": "fapi::MOD_VDDR_PROC_MSG",
                           "reasoncode": "fapi::RC_INCORRECT_MSG_TYPE",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0xB2315: {    "devdesc": "The computed hash of RW partition doesn't match the hash in the image (probably indicates image corruption)",
                           "moduleid": "TARG_PARSE_RW_DATA",
                           "reasoncode": "TARG_RC_BAD_HASH",
                           "userdata1":  "The computed hash of the data",
                           "userdata2":  "The hash of the data in the image",
                      },
            0xB2415: {    "devdesc": "The HBD persistent data has unexpected version. The data can no longer be used and will be updated to the current version.",
                           "moduleid": "TARG_PARSE_RW_DATA",
                           "reasoncode": "TARG_RC_BAD_VERSION",
                           "userdata1":  "Expected persistent data version",
                           "userdata2":  "Actual persistent data version",
                      },
            0xE1B15: {    "devdesc": "Attempted to add a duplicate entry from the PNOR to the global eecache",
                           "moduleid": "EEPROM_CACHE_EECACHE_PARTITION",
                           "reasoncode": "EEPROM_CACHE_PNOR_DUP_FOUND",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                      },
            0xF0E15: {    "devdesc": "Attempted to unregsister a source that is not registered",
                           "moduleid": "INTR::MOD_INTRRP_UNREGISTERINTERRUPT",
                           "reasoncode": "INTR::RC_SOURCE_NOT_REGISTERED",
                           "userdata1":  "LSI Interrupt Source to Unregister",
                           "userdata2":  "Number of unregistered LSI sources",
                      },
            0x101315: {    "devdesc": "Error: Could not find MDMT on active topology even though TOD HW logic is running",
                           "moduleid": "TOD_MDMT_TOPOLOGY",
                           "reasoncode": "TOD_NO_VALID_MDMT_FOUND",
                           "userdata1":  "EMOD_TOD_SET_ACTIVE_MDMT",
                           "userdata2":  "Topology type on which MDMT was searched",
                      },
            0x172115: {    "devdesc": "The primary SBE HW Keys' hash does not match the the backup SBE HW Keys' hash, so we cannot guarantee platform security for the system",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PRIMARY_PROC_SBE_KEYS_HASH_MISMATCH",
                           "userdata1":  "Primary Processor Target",
                      },
            0x172215: {    "devdesc": "Unable to read the primary processor primary hash from the SBE",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PRIMARY_PROC_PRIMARY_HASH_READ_FAIL",
                           "userdata1":  "Primary Processor Target",
                      },
            0x172315: {    "devdesc": "Unable to read the primary processor backup hash from the SBE",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PRIMARY_PROC_BACKUP_HASH_READ_FAIL",
                           "userdata1":  "Processor Target",
                      },
            0x172415: {    "devdesc": "Unable to read the primary processor CBS control register",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PRIMARY_PROC_CBS_CONTROL_READ_FAIL",
                           "userdata1":  "Primary Processor Target",
                      },
            0x172515: {    "devdesc": "Unable to read the secondary processor primary hash from the SBE",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_SECONDARY_PROC_PRIMARY_HASH_READ_FAIL",
                           "userdata1":  "Secondary Processor Target",
                      },
            0x172615: {    "devdesc": "Unable to read the secondary processor backup hash from the SBE",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_SECONDARY_PROC_BACKUP_HASH_READ_FAIL",
                           "userdata1":  "Secondary Processor Target",
                      },
            0x172715: {    "devdesc": "Unable to read the secondary processor CBS control register",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_SECONDARY_PROC_CBS_CONTROL_READ_FAIL",
                           "userdata1":  "Secondary Processor Target",
                      },
            0x172815: {    "devdesc": "Mismatch processor state was detected for this processor, so we cannot guarantee platform security for the system",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PROC_SECURITY_STATE_MISMATCH",
                           "userdata1":  "Processor Target",
                           "userdata2[63]":  "Backup SBE hash mismatch",
                           "userdata2[62]":  "Primary SBE hash mismatch",
                           "userdata2[61]":  "Jumper (SMD) bit mismatch",
                           "userdata2[60]":  "SAB bit mismatch",
                           "userdata2[59]":  "Backup SBE Secure Version mismatch",
                           "userdata2[58]":  "Primary SBE Secure Version mismatch",
                      },
            0x174815: {    "devdesc": "Unable to get the primary SBE boot seeprom side",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PRIMARY_GET_SBE_BOOT_SEEPROM_FAIL",
                           "userdata1":  "Primary Processor Target",
                      },
            0x174915: {    "devdesc": "Unable to get the secondary proc SBE boot seeprom side",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_SECONDARY_GET_SBE_BOOT_SEEPROM_FAIL",
                           "userdata1":  "Secondary Processor Target",
                      },
            0x175D15: {    "devdesc": "The primary SBE HW Keys' hash does not match the backup SBE HW Keys' hash, so we cannot guarantee platform security for the system",
                           "moduleid": "ISTEP::MOD_VALIDATE_SECURITY_SETTINGS",
                           "reasoncode": "ISTEP::RC_PRIMARY_PROC_SECURE_VERSION_MISMATCH",
                           "userdata1":  "Primary Processor Target",
                      },
            0x1A1D15: {    "devdesc": "PM load complex unknown mode",
                           "moduleid": "MOD_PM_RT_LOAD_PM_COMPLEX",
                           "reasoncode": "RC_PM_RT_UNKNOWN_MODE",
                           "userdata1":  "HBRT PM Mode",
                           "userdata2":  "HUID",
                      },
            0x1D3315: {    "devdesc": "Unexpected target type for FRU property",
                           "moduleid": "VPD_GET_FRU_RECS_AND_KWS",
                           "reasoncode": "VPD_UNEXPECTED_TARGET_TYPE",
                           "userdata1":  "Target HUID",
                           "userdata2":  "<UNUSED>",
                      },
            0x1D4F15: {    "devdesc": "Unexpected FRU property requested",
                           "moduleid": "VPD_GET_FRU_RECS_AND_KWS",
                           "reasoncode": "VPD_UNSUPPORTED_FRU_PROPERTY",
                           "userdata1[00:31]":  "Target HUID",
                           "userdata1[32:63]":  "Target Type",
                           "userdata2":  "First 2 bad property attributes",
                      },
            0x220D15: {    "devdesc": "Caller passed in nullptr for append SBE Section operation",
                           "moduleid": "SBE_MODIFY_SBE_SECTION",
                           "reasoncode": "SBE_INVALID_INPUT",
                           "userdata1":  "SBE Section",
                           "userdata2":  "unused",
                      },
            0x221815: {    "devdesc": "Bad RC from p9_xip_delete",
                           "moduleid": "SBE_MODIFY_SBE_SECTION",
                           "reasoncode": "ERROR_FROM_XIP_DELETE",
                           "userdata1":  "rc from p9_xip_delete",
                           "userdata2":  "SBE Section",
                      },
            0x221915: {    "devdesc": "Bad RC from p9_xip_get_section",
                           "moduleid": "SBE_MODIFY_SBE_SECTION",
                           "reasoncode": "ERROR_FROM_XIP_FIND",
                           "userdata1":  "rc from p9_xip_get_section",
                           "userdata2":  "SBE Section",
                      },
            0x286815: {    "devdesc": "No reserved memory reserved for runtime SBE PSU operations (ATTR_SBE_HBRT_PSU_PHYS_ADDR==0).",
                           "moduleid": "SBEIO_RT_PSU",
                           "reasoncode": "SBEIO_NO_RUNTIME_BUFFER",
                           "userdata1":  "Return code from get_reserved_mem_phys",
                           "userdata2":  "ATTR_SBE_HBRT_PSU_VIRT_ADDR",
                      },
            0x2BB115: {    "devdesc": "msg_sendrecv() failed",
                           "moduleid": "MOD_INIT_BACKUP_TPM",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msq_sendrecv()",
                      },
            0x351715: {    "devdesc": "Encountered timeout while performing operation on NVDIMM Refer to userdata1 for which operation it timed out.",
                           "moduleid": "NVDIMM_POLL_STATUS",
                           "reasoncode": "NVDIMM_STATUS_TIMEOUT",
                           "userdata1[0:31]":  "Related ops (0xff = NA)",
                           "userdata1[32:63]":  "Target Huid",
                           "userdata2[0:31]":  "Polled value",
                           "userdata2[32:63]":  "Timeout value",
                      },
            0x470415: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SEND_SENSOR_STATE_CHANGED_EVENT",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x901115: {    "devdesc": "Exceeded limit of number of mainstore VPD In Memory Trace array entries",
                           "moduleid": "MOD_ADD_UE_ADDR_RANGE",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current number of array entries",
                           "userdata2":  "maximum number of array entries",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0x92516: {    "devdesc": "The hwsv returned a message where the extra data was null.  This should not happen so need to tell HostBoot to stop the ipl",
                           "moduleid": "fapi::MOD_VDDR_PROC_VDDR_MSG",
                           "reasoncode": "fapi::RC_VDDR_EMPTY_MSG",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x92716: {    "devdesc": "The hwsv returned a message where there was an error when the powr function was called. userdata1 contains the errorlog plid from hwsv generated by the powr function",
                           "moduleid": "fapi::MOD_VDDR_PROC_VDDR_MSG",
                           "reasoncode": "fapi::RC_VDDR_POWR_ERR",
                           "userdata1":  "l_errPlid",
                           "userdata2":  "0",
                      },
            0xB2516: {    "devdesc": "Metadata not found for an attribute",
                           "moduleid": "TARG_SET_PERSISTENT_ATTR",
                           "reasoncode": "TARG_RC_NO_METADATA_FOUND",
                           "userdata1":  "Return code (0)",
                           "userdata2":  "attr ID",
                      },
            0xB2616: {    "devdesc": "Persistent attribute is being updated when it is not allowed.",
                           "moduleid": "TARG_SET_PERSISTENT_ATTR",
                           "reasoncode": "TARG_RC_SET_PERSIST_ATTR_DISABLED",
                           "userdata1":  "Return code (0)",
                           "userdata2":  "attr ID",
                      },
            0xE1F16: {    "devdesc": "Size of data in l_eepromLen is not matching requester",
                           "moduleid": "EEPROM_UPDATE_EECACHE_CONTENTS",
                           "reasoncode": "EEPROM_UPDATE_BUFFER_MISMATCH",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:31]":  "i_eepromBuflen",
                           "userdata2[32:63]":  "l_eepromLen",
                      },
            0x161D16: {    "devdesc": "Could not find requested component ID in master container LID",
                           "moduleid": "Util::UTIL_MCL_PROCESS_SINGLE_COMP",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_COMP",
                           "userdata1":  "Component ID [truncated to 8 bytes]",
                      },
            0x172916: {    "devdesc": "call_proc_exit_cache_contained: did not find minimum hardware to continue",
                           "moduleid": "ISTEP::MOD_PROC_EXIT_CACHE_CONTAINED",
                           "reasoncode": "ISTEP::RC_MIN_HW_CHECK_FAILED",
                      },
            0x174716: {    "devdesc": "call_proc_exit_cache_contained: did not find valid memory configuration",
                           "moduleid": "ISTEP::MOD_PROC_EXIT_CACHE_CONTAINED",
                           "reasoncode": "ISTEP::RC_NO_VALID_MEM_CONFIG",
                      },
            0x1A1E16: {    "devdesc": "HCODE scom update runtime interface not linked.",
                           "moduleid": "MOD_PM_RT_HCODE_UPDATE",
                           "reasoncode": "RC_PM_RT_INTERFACE_ERR",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "SCOM restore section",
                           "userdata2":  "SCOM address",
                      },
            0x1A1F16: {    "devdesc": "HCODE SCOM update error",
                           "moduleid": "MOD_PM_RT_HCODE_UPDATE",
                           "reasoncode": "RC_PM_RT_HCODE_UPDATE_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2":  "SCOM address",
                      },
            0x1E1916: {    "devdesc": "Measurement SEEPROM version for the given proc did not meet the minimum secure version. Manufacturing must update to required level",
                           "moduleid": "SECUREBOOT::MOD_VERIFY_MEASUREMENT_SEEPROM_SECURITY",
                           "reasoncode": "SECUREBOOT::RC_UNSECURE_MEASUREMENT_VERSION",
                           "userdata1[00:31]":  "Actual measurement SEEPROM version read from hardware",
                           "userdata1[32:63]":  "Required minimum measurement SEEPROM version",
                           "userdata2[00:31]":  "OTP_SPIM_MEAS_SEEPROM_LOCK bit. 1 is set, 0 is unset.",
                           "userdata2[32:63]":  "HUID of the proc.",
                      },
            0x1E1A16: {    "devdesc": "Measurement SEEPROM of the given proc has the minimum secure version of measurement SEEPROM code but the fuse remains intact. Manufacturing must blow the fuse.",
                           "moduleid": "SECUREBOOT::MOD_VERIFY_MEASUREMENT_SEEPROM_SECURITY",
                           "reasoncode": "SECUREBOOT::RC_UNBLOWN_MEASUREMENT_FUSE",
                           "userdata1[00:31]":  "HUID of Proc",
                           "userdata1[32:63]":  "Unused",
                      },
            0x286A16: {    "devdesc": "PMIC Health Check Data",
                           "moduleid": "SBEIO_PSU_PMIC_HEALTH_CHECK",
                           "reasoncode": "SBEIO_PMIC_HEALTH_CHECK_DATA",
                           "userdata1[00:31]":  "PROC Target HUID",
                           "userdata1[32:63]":  "First OCMB Target HUID",
                           "userdata2[00:31]":  "Last  OCMB Target HUID",
                           "userdata2[32:47]":  "Reserved 0xFFFF default",
                           "userdata2[48:55]":  "Number of OCMBs in log",
                           "userdata2[56:63]":  "Worst pmic status",
                      },
            0x286B16: {    "devdesc": "PMIC Health Check Data Failed in Mfg Mode",
                           "moduleid": "SBEIO_PSU_PMIC_HEALTH_CHECK",
                           "reasoncode": "SBEIO_PMIC_FAILED_HEALTH_CHECK",
                           "userdata1[00:31]":  "PROC Target HUID",
                           "userdata1[32:63]":  "OCMB Target HUID",
                           "userdata2[00:07]":  "PMIC Revision",
                           "userdata2[08:15]":  "PMIC Status (see pmic_n_mode_detect.H)",
                           "userdata2[16:23]":  "OCMB position relative to proc",
                           "userdata2[24:31]":  "True if we should have non-zero addFFDC data",
                           "userdata2[32:47]":  "deprecated: l_psuResponse.primaryStatus",
                           "userdata2[48:63]":  "deprecated: l_psuResponse.secondaryStatus",
                      },
            0x287616: {    "devdesc": "PMIC Telemetry Data",
                           "moduleid": "SBEIO_PSU_PMIC_HEALTH_CHECK",
                           "reasoncode": "SBEIO_PMIC_TELEMETRY_DATA_DDR5",
                           "userdata1[00:31]":  "PROC Target HUID",
                           "userdata1[32:63]":  "First OCMB Target HUID",
                           "userdata2[00:31]":  "Last  OCMB Target HUID",
                           "userdata2[32:47]":  "Reserved 0xFFFF default",
                           "userdata2[48:55]":  "Number of OCMBs in log",
                           "userdata2[56:63]":  "Worst pmic status",
                      },
            0x287716: {    "devdesc": "PMIC Health Check Data",
                           "moduleid": "SBEIO_PSU_PMIC_HEALTH_CHECK",
                           "reasoncode": "SBEIO_PMIC_HEALTH_CHECK_DATA_DDR5",
                           "userdata1[00:31]":  "PROC Target HUID",
                           "userdata1[32:63]":  "First OCMB Target HUID",
                           "userdata2[00:31]":  "Last  OCMB Target HUID",
                           "userdata2[32:47]":  "Reserved 0xFFFF default",
                           "userdata2[48:55]":  "Number of OCMBs in log",
                           "userdata2[56:63]":  "Worst pmic status",
                      },
            0x351916: {    "devdesc": "Encountered error erasing previously stored data image on NVDIMM. Likely due to timeout and/or controller error",
                           "moduleid": "NVDIMM_CHECK_ERASE",
                           "reasoncode": "NVDIMM_ERASE_FAILED",
                           "userdata1[0:31]":  "Related ops (0xff = NA)",
                           "userdata1[32:63]":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0x471D16: {    "devdesc": "Software problem, BMC requested OCC reset too soon",
                           "moduleid": "MOD_HANDLE_SET_STATE_EFFECTER_STATES_REQUEST",
                           "reasoncode": "RC_OCC_RESET_TOO_SOON",
                           "userdata1":  "HUID of the PROC with the OCC that was being reset",
                      },
            0x901116: {    "devdesc": "Exceeded limit of number of mainstore VPD Reserved Hostboot array entries",
                           "moduleid": "MOD_ADD_RES_HB_ADDR_RANGE",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current number of array entries",
                           "userdata2":  "maximum number of array entries",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0x92817: {    "devdesc": "HB got an incorrect type message.  HB did not provide the correct message type in the istep. Userdata1 shows the message type passed in",
                           "moduleid": "fapi::MOD_VDDR_SEND_MSG",
                           "reasoncode": "fapi::RC_INCORRECT_MSG_TYPE",
                           "userdata1":  "i_msgType",
                           "userdata2":  "0",
                      },
            0xE2117: {    "devdesc": "Unexpected cache address",
                           "moduleid": "EEPROM_CHECK_EECACHE_UPDATE",
                           "reasoncode": "EEPROM_UNEXPECTED_CACHE_ADDR",
                           "userdata1[0:31]":  "HUID of Master",
                           "userdata1[32:39]":  "Port (or 0xFF)",
                           "userdata1[40:47]":  "Engine",
                           "userdata1[48:55]":  "devAddr    (or byte 0 offset_KB)",
                           "userdata1[56:63]":  "mux_select (or byte 1 offset_KB)",
                           "userdata2[0:63]":  "i_eepromBuflen",
                      },
            0x101517: {    "devdesc": "This TOD end point target on processor is not receiving signal from the OSC.",
                           "moduleid": "TOD_ENDPOINT_CALLOUT",
                           "reasoncode": "TOD_MASTER_PATH_ERROR",
                           "userdata1":  "EMOD_CALLOUT_TOD_ENDPOINT",
                           "userdata2":  "HUID of the TOD end point that is not receiving signal HUID of the OSC from which signal is not received",
                      },
            0x161E17: {    "devdesc": "The child thread of a thread pool returned an error",
                           "moduleid": "Util::UTIL_MOD_TP_SHUTDOWN",
                           "reasoncode": "Util::UTIL_RC_CHILD_TASK_FAILED",
                           "userdata1":  "The return code of the child thread",
                           "userdata2[0:31]":  "The returned task ID of the child thread",
                           "userdata2[32:63]":  "The original task ID of the child thread",
                      },
            0x1A0517: {    "devdesc": "Error mapping a virtual memory map",
                           "moduleid": "RUNTIME::MOD_MAP_PHYS_ADDR",
                           "reasoncode": "RUNTIME::RC_CANNOT_MAP_MEMORY",
                           "userdata1":  "Phys address we are trying to map",
                           "userdata2":  "Size of memory we are trying to map",
                      },
            0x1D4F17: {    "devdesc": "Unexpected FRU property requested",
                           "moduleid": "VPD_CMP_EECACHE_TO_ATTRIBUTES",
                           "reasoncode": "VPD_UNSUPPORTED_FRU_PROPERTY",
                           "userdata1[00:31]":  "Target HUID",
                           "userdata1[32:63]":  "Target Type",
                           "userdata2[00:31]":  "Bad property",
                           "userdata2[32:63]":  "unused",
                      },
            0x1E0917: {    "devdesc": "Processor Parameter is not scommable",
                           "moduleid": "SECUREBOOT::MOD_CAN_XSCOM_PROC",
                           "reasoncode": "SECUREBOOT::RC_SECURE_BAD_TARGET",
                           "userdata1":  "HUID of Processor Target",
                           "userdata2":  "<unused>",
                      },
            0x286D17: {    "devdesc": "SBEIO RT Scom Support not available",
                           "moduleid": "SBEIO::SBEIO_RT_SCOM",
                           "reasoncode": "SBEIO::SBEIO_SCOM_SUPPORT_READ",
                           "userdata1":  "HUID of Target",
                           "userdata2":  "Unused",
                      },
            0x286E17: {    "devdesc": "SBEIO RT Scom Support not available",
                           "moduleid": "SBEIO::SBEIO_RT_SCOM",
                           "reasoncode": "SBEIO::SBEIO_SCOM_SUPPORT_WRITE",
                           "userdata1":  "HUID of Target",
                           "userdata2":  "Unused",
                      },
            0x2BB717: {    "devdesc": "TPM testcase error. See the return code for details.",
                           "moduleid": "MOD_TEST_CMP_PRIMARY_AND_BACKUP_TPM",
                           "reasoncode": "RC_BACKUP_TPM_TEST_FAIL",
                           "userdata1":  "return code",
                           "userdata2":  "0",
                      },
            0x471617: {    "devdesc": "Software problem, wanted 0 or 1 target, got multiple",
                           "moduleid": "MOD_PLDM_ENTITY_IDS",
                           "reasoncode": "RC_EXPECTED_UNIQUE_ENTITY",
                           "userdata1":  "The number of targets found",
                           "userdata2[0:31]":  "The class of target",
                           "userdata2[32:63]":  "The type of target",
                      },
            0x471717: {    "devdesc": "Software problem, cannot find the Target from FRU Record Set ID",
                           "moduleid": "MOD_PLDM_ENTITY_IDS",
                           "reasoncode": "RC_NO_TARGET_FROM_RSID",
                           "userdata1":  "The FRU Record Set ID that does not correspond to a Target",
                           "userdata2":  "The entity type of the corresponding Record Set",
                      },
            0x471817: {    "devdesc": "Software problem, cannot find Entity from FRU Record Set ID",
                           "moduleid": "MOD_PLDM_ENTITY_IDS",
                           "reasoncode": "RC_NO_ENTITY_FROM_RSID",
                           "userdata1":  "The Target HUID",
                           "userdata2":  "The FRU Record Set ID",
                      },
            0x471917: {    "devdesc": "Software problem, mismatching number of Targets and Entities",
                           "moduleid": "MOD_PLDM_ENTITY_IDS",
                           "reasoncode": "RC_EXPECTED_UNIQUE_TARGET",
                           "userdata1[0:31]":  "The number of targets found",
                           "userdata1[32:63]":  "The number of PLDM entities found",
                           "userdata2[0:31]":  "The target class",
                           "userdata2[32:63]":  "The target type",
                      },
            0x901117: {    "devdesc": "Exceeded limit of number of mainstore area array entries",
                           "moduleid": "MOD_ADD_MS_AREA_FRU",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current array entry count",
                           "userdata2":  "maximum array entry count",
                           "userdata3":  "ID number of mainstore area that wasn't added",
                           "userdata4":  "none",
                      },
            0xE2418: {    "devdesc": "EECACHE PNOR partition is empty or invalid",
                           "moduleid": "EEPROM_IS_EECACHE_EMPTY",
                           "reasoncode": "EEPROM_EECACHE_IS_EMPTY",
                           "userdata1":  "The pointer to the end of EECACHE",
                           "userdata2":  "The version of EECACHE",
                      },
            0x161F18: {    "devdesc": "BMC returned a lid of size larger than the size of lid's destination",
                           "moduleid": "Util::UTIL_LIDMGR_GET_LID_BMC",
                           "reasoncode": "Util::UTIL_LIDMGR_LID_TOO_BIG",
                           "userdata1":  "LID ID",
                           "userdata2[0:31]":  "Requested lid size",
                           "userdata2[32:63]":  "Lid size returned by BMC",
                      },
            0x1A1C18: {    "devdesc": "Error unmapping a virtual memory map",
                           "moduleid": "RUNTIME::MOD_UNMAP_VIRT_ADDR",
                           "reasoncode": "RUNTIME::RC_UNMAP_FAIL",
                           "userdata1":  "Virtual address we are trying to unmap",
                           "userdata2":  "0",
                      },
            0x1D5018: {    "devdesc": "The type EEPROM to read for the given target is not supported.",
                           "moduleid": "VPD::VPD_FETCH_DATA_EEPROM_TYPE",
                           "reasoncode": "VPD::VPD_UNSUPPORTED_EEPROM_TYPE",
                           "userdata1":  "Unsupported EEPROM type",
                           "userdata2":  "HUID of target to read the EEPROM data for",
                      },
            0x1E1118: {    "devdesc": "Device read did not return expected size",
                           "moduleid": "SECUREBOOT::MOD_READ_SBE_MEASUREMENT_REGISTER",
                           "reasoncode": "SECUREBOOT::RC_DEVICE_READ_ERR",
                           "userdata1":  "Actual size read",
                           "userdata2":  "Expected size read",
                      },
            0x286F18: {    "devdesc": "SPPE responded with an array of mismatches to Host's attribute sync request. See the FFDC field for mismatches.",
                           "moduleid": "SBEIO_PROCESS_ATTR_ARRAY",
                           "reasoncode": "SBEIO_ATTR_MISMATCH_DETECTED",
                           "userdata1":  "The HUID of the Odyssey chip",
                           "userdata2[0:31]":  "The size of the attribute error array",
                           "userdata2[32:63]":  "Whether the operation was an attribute push (1) or pull (0)",
                      },
            0x2BB118: {    "devdesc": "msg_sendrecv() failed",
                           "moduleid": "MOD_TPM_GETRANDOM",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msq_sendrecv()",
                           "userdata2":  "TPM HUID if it's not nullptr",
                      },
            0x351B18: {    "devdesc": "Failed to read ready status or NVDIMM not ready for host access. (userdata1 != 0xA5)",
                           "moduleid": "NVDIMM_CHECK_READY",
                           "reasoncode": "NVDIMM_NOT_READY",
                           "userdata1[0:31]":  "Ret value from ready register",
                           "userdata1[32:63]":  "Target Huid",
                           "userdata2":  "<UNUSED>",
                      },
            0x471818: {    "devdesc": "Unable to find the entity associated with this RSID",
                           "moduleid": "MOD_ADD_OCC_PDRS",
                           "reasoncode": "RC_NO_ENTITY_FROM_RSID",
                           "userdata1":  "record set id of occ's parent processor",
                           "userdata2":  "HUID of target",
                      },
            0x901218: {    "devdesc": "Attempted to add a RAM FRU for an invalid mainstore area",
                           "moduleid": "MOD_ADD_RAM_FRU",
                           "reasoncode": "RC_ERC_NO_PARENT",
                           "userdata1":  "main store area id",
                           "userdata2":  "current count of main store areas",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0xE2519: {    "devdesc": "Invalid EEPROM chip to access",
                           "moduleid": "EEPROM_PRESENCE",
                           "reasoncode": "EEPROM_PRIMARY_FAILURE",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Role that failed",
                      },
            0x100C19: {    "devdesc": "nullptr Target is supplied as an input",
                           "moduleid": "TOD_FUNCTIONAL_TARGET",
                           "reasoncode": "TOD_INVALID_TARGET",
                      },
            0x162019: {    "devdesc": "firmware_request interface not linked.",
                           "moduleid": "Util::UTIL_SPI_LOCK_REQUEST",
                           "reasoncode": "Util::UTIL_RT_INTERFACE_ERR",
                           "userdata1[0:31]":  "Target Processor HUID",
                           "userdata1[32:63]":  "Lock State",
                           "userdata2":  "<unused>",
                      },
            0x1A2119: {    "devdesc": "Found duplicate I2C link IDs in PCRD section of HDAT. System security cannot be guaranteed.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_DUPLICATE_I2C_LINK_IDS",
                           "userdata1":  "I2C Link ID",
                      },
            0x1A2219: {    "devdesc": "An I2C device in the PCRD does not have a match in the MRW. Physical presence detection will not be available.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_I2C_DEVICE_NOT_IN_MRW",
                           "userdata1":  "I2C Link ID",
                      },
            0x1A2419: {    "devdesc": "An I2C device in the PCRD has a duplicate match in the MRW. Physical presence detection will still be available.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_I2C_DEVICE_DUPLICATE_IN_MRW",
                           "userdata1":  "I2C Link ID",
                      },
            0x1A2519: {    "devdesc": "An I2C device in the MRW has no match in the PCRD.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_EXTRA_I2C_DEVICE_IN_MRW",
                           "userdata1":  "[0:7] I2C engine",
                           "userdata1":  "[8:15] I2C masterPort",
                           "userdata1":  "[16:23] I2C slave deviceType",
                           "userdata1":  "[24:31] I2C slave address",
                           "userdata1":  "[32:39] I2C slave port",
                           "userdata1":  "[40:47] I2C device purpose",
                           "userdata1":  "[48:63] Bus speed in KHz",
                           "userdata2":  "master chip HUID",
                      },
            0x1A2A19: {    "devdesc": "The TPM data hdat section doesn't have enough space",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_OUT_OF_SPACE",
                           "userdata1":  "Size of hdat data struct",
                           "userdata2":  "Max size of hdat data struct",
                      },
            0x1A2B19: {    "devdesc": "TPM data hdat struct format value doesn't match",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_ID_MISMATCH",
                           "userdata1":  "hdat struct format value",
                           "userdata2":  "Expected hdat struct format value",
                      },
            0x1A2C19: {    "devdesc": "TPM data hdat struct name eye catcher doesn't match",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_EYE_CATCH_MISMATCH",
                           "userdata1":  "hdat struct name eye catcher",
                           "userdata2":  "Expected hdat eye catch",
                      },
            0x1A2D19: {    "devdesc": "TPM does not have a processor",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_MISSING_PROC",
                           "userdata1":  "Number of processors",
                           "userdata2":  "0",
                      },
            0x1A2E19: {    "devdesc": "Bad PCRD section version",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_BAD_VERSION",
                           "userdata1":  "hdat version",
                           "userdata2":  "Expected support version",
                      },
            0x1A2F19: {    "devdesc": "HDAT PCRD reported more than the max number of i2c devices",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_BAD_NUM_I2C",
                           "userdata1":  "hdat array count",
                           "userdata2":  "max number of i2c devices",
                      },
            0x1A3A19: {    "devdesc": "Failed to convert virtual address to physical address",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_VIRT_TO_PHYS_ERR",
                           "userdata1":  "Requested virtual address to convert",
                      },
            0x1A3B19: {    "devdesc": "Failed to map physical memory to virtual memory",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_MAP_BLOCK_ERR",
                           "userdata1":  "Aligned physical address to map",
                           "userdata2":  "Aligned size or region to map",
                      },
            0x1A4F19: {    "devdesc": "An SPI device in the PCRD has an invalid engine and/or port.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_INVALID_SPI_DEVICE",
                           "userdata1":  "[0:7] SPI Controller Engine",
                           "userdata1":  "[8:15] SPI Controller Port",
                           "userdata1":  "[16:23] SPI Receiver Device Type",
                           "userdata1":  "[24:31] SPI Receiver Device Purpose",
                           "userdata1":  "[32:63] SPI Device Id",
                           "userdata1":  "[32:35] Byte 0: System Level Node Ordinal ID",
                           "userdata1":  "[35:39] Byte 1: Node Level Processor Sequence ID",
                           "userdata1":  "[39:47] Byte 2-3: Running number for each SPI device entry in this array",
                      },
            0x1A5019: {    "devdesc": "HDAT PCRD reported more than the max number of SPI devices",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_TPM_HDAT_BAD_NUM_SPI",
                           "userdata1":  "hdat array count",
                           "userdata2":  "max number of SPI devices",
                      },
            0x1A5119: {    "devdesc": "Found duplicate SPI Device IDs in PCRD section of HDAT. System security cannot be guaranteed.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_DUPLICATE_SPI_DEV_IDS",
                           "userdata1":  "SPI Device ID",
                           "userdata1":  "[0:3] Byte 0: System Level Node Ordinal ID",
                           "userdata1":  "[4:7] Byte 1: Node Level Processor Sequence ID",
                           "userdata1":  "[8:15] Byte 2-3: Running number for each SPI device entry in this array",
                      },
            0x1A5219: {    "devdesc": "A SPI device in the PCRD does not have a match in the MRW.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_SPI_DEVICE_NOT_IN_MRW",
                           "userdata1":  "[0:7] SPI Controller Engine",
                           "userdata1":  "[8:15] SPI Controller Port",
                           "userdata1":  "[16:23] SPI Receiver Device Type",
                           "userdata1":  "[24:31] SPI Receiver Device Purpose",
                           "userdata1":  "[32:63] SPI Device Id",
                           "userdata1":  "[32:35] Byte 0: System Level Node Ordinal ID",
                           "userdata1":  "[35:39] Byte 1: Node Level Processor Sequence ID",
                           "userdata1":  "[39:47] Byte 2-3: Running number for each SPI device entry in this array",
                      },
            0x1A5319: {    "devdesc": "An SPI device in the PCRD has a duplicate match in the MRW.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_SPI_DEVICE_DUPLICATE_IN_MRW",
                           "userdata1":  "[0:7] SPI Controller Engine",
                           "userdata1":  "[8:15] SPI Controller Port",
                           "userdata1":  "[16:23] SPI Receiver Device Type",
                           "userdata1":  "[24:31] SPI Receiver Device Purpose",
                           "userdata1":  "[32:63] SPI Device Id",
                           "userdata1":  "[32:35] Byte 0: System Level Node Ordinal ID",
                           "userdata1":  "[35:39] Byte 1: Node Level Processor Sequence ID",
                           "userdata1":  "[39:47] Byte 2-3: Running number for each SPI device entry in this array",
                      },
            0x1A5419: {    "devdesc": "An SPI device in the MRW has no match in the PCRD.",
                           "moduleid": "RUNTIME::MOD_POPULATE_TPMINFOBYNODE",
                           "reasoncode": "RUNTIME::RC_EXTRA_SPI_DEVICE_IN_MRW",
                           "userdata1":  "[0:7] SPI Controller Engine",
                           "userdata1":  "[8:15] SPI Controller Port",
                           "userdata1":  "[16:23] SPI Receiver Device Type",
                           "userdata1":  "[24:31] SPI Receiver Device Purpose",
                           "userdata1":  "[32:63] SPI Device Id",
                           "userdata1":  "[32:35] Byte 0: System Level Node Ordinal ID",
                           "userdata1":  "[35:39] Byte 1: Node Level Processor Sequence ID",
                           "userdata1":  "[39:47] Byte 2-3: Running number for each SPI device entry in this array",
                      },
            0x1E1B19: {    "devdesc": "Odyssey secureboot settings don't match between the Odyssey chip and the system.",
                           "moduleid": "MOD_VERIFY_ODY_SECURITY_SETTINGS",
                           "reasoncode": "RC_ODY_SECURE_SETTINGS_MISMATCH",
                           "userdata1":  "Odyssey Chip HUID",
                           "userdata2[0]":  "Ody Secureboot Reg: secureboot enabled",
                           "userdata2[1]":  "Ody Secureboot Reg: ECDSA verification enabled",
                           "userdata2[2]":  "Ody Secureboot Reg: Dilithium verification enabled",
                           "userdata2[3]":  "Ody Secureboot Reg: ECID verification enabled",
                           "userdata2[4]":  "Ody Secureboot Reg: HW Key hash verification enabled",
                           "userdata2[5]":  "Ody Secureboot Reg: secure mode enabled",
                           "userdata2[6]":  "Ody Secureboot Reg: File hash calculation enabled",
                           "userdata2[7]":  "System: secureboot enabled",
                           "userdata2[8]":  "ECDSA signature enabled (1)",
                           "userdata2[9]":  "Dilithium signature enabled (1)",
                           "userdata2[10]":  "ECID verification enabled (0)",
                           "userdata2[11]":  "HW Key hash verification enabled (1)",
                           "userdata2[12]":  "System: secureboot enabled",
                           "userdata2[13]":  "File hash calculation enabled (1)",
                           "userdata2[14]":  "Ody Secureboot Reg: Odyssey boot complete flag",
                      },
            0x281719: {    "devdesc": "Null target passed",
                           "moduleid": "SBEIO_FIFO_ODY_CHECKS",
                           "reasoncode": "SBEIO_FIFO_NULL_TARGET",
                           "userdata1[0:7]":  "SBE FIFO Command Class",
                           "userdata1[8:15]":  "SBE FIFO Command",
                           "userdata2":  "unused",
                      },
            0x281D19: {    "devdesc": "Odyssey target is expected",
                           "moduleid": "SBEIO_FIFO_ODY_CHECKS",
                           "reasoncode": "SBEIO_FIFO_NOT_ODYSSEY_OCMB",
                           "userdata1[0:31]":  "HUID of OCMB chip",
                           "userdata1[32:63]":  "ATTR_CHIP_ID of OCMB chip",
                           "userdata2[0:7]":  "SBE FIFO Command Class",
                           "userdata2[8:15]":  "SBE FIFO Command",
                      },
            0x2BB819: {    "devdesc": "Caller attempted to get a random number from a TPM using an invalid TPM target.",
                           "moduleid": "MOD_VALIDATE_TPM_HANDLE",
                           "reasoncode": "RC_INVALID_TPM_HANDLE",
                           "userdata1":  "TPM HUID if it's not nullptr",
                      },
            0x2BB919: {    "devdesc": "Call attempted to get a random number from a TPM that was not functional",
                           "moduleid": "MOD_VALIDATE_TPM_HANDLE",
                           "reasoncode": "RC_NON_FUNCTIONAL_TPM_HANDLE",
                           "userdata1":  "TPM HUID if it's not nullptr",
                      },
            0x351C19: {    "devdesc": "Unable to inform PHYP of NVDIMM protection",
                           "moduleid": "NOTIFY_NVDIMM_PROTECTION_CHG",
                           "reasoncode": "NVDIMM_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "HUID of processor target",
                           "userdata2[0:31]":  "Requested protection state",
                           "userdata2[32:63]":  "Current armed state",
                      },
            0x470419: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SEND_SET_STATE_EFFECTER_STATES_REQUEST",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x901119: {    "devdesc": "Failed trying to add another entry to a mainstore area address range array",
                           "moduleid": "MOD_ADD_ADDR_RANGE",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current number of array entries",
                           "userdata2":  "maximum number of array entries",
                           "userdata3":  "ID number of mainstore area",
                           "userdata4":  "none",
                      },
            0x90111a: {    "devdesc": "Failed trying to add another entry to a mainstore area RAM array",
                           "moduleid": "MOD_ADD_RAM",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current number of array entries",
                           "userdata2":  "maximum number of array entries",
                           "userdata3":  "ID number of mainstore area",
                           "userdata4":  "none",
                      },
            0x16211A: {    "devdesc": "Software problem, trying to update a lid the lidpnor code doesn't know about",
                           "moduleid": "Util::UTIL_UPDATE_DATA_LID_MAP",
                           "reasoncode": "Util::UTIL_NO_MAP_ENTRY",
                           "userdata1":  "PNOR section Id we tried to lookup",
                           "userdata2":  "Data lid value we tried to update with",
                      },
            0x17321A: {    "devdesc": "SBE cannot be reset during MPIPL",
                           "moduleid": "MOD_CALL_MSS_ATTR_UPDATE",
                           "reasoncode": "RC_SBE_UPDATE_IN_MPIPL",
                           "userdata1":  "ATTR_FORCE_SBE_UPDATE, bit mask of reasons See SBE_UPDATE_TYPE from attribute_types_hb.xml",
                           "userdata2":  "0",
                      },
            0x17521A: {    "devdesc": "Return from updateProcessorSbeSeeproms occurred",
                           "moduleid": "MOD_CALL_MSS_ATTR_UPDATE",
                           "reasoncode": "RC_SBE_UPDATE_UNEXPECTEDLY_FAILED",
                           "userdata1":  "ATTR_FORCE_SBE_UPDATE, bit mask of reasons See SBE_UPDATE_TYPE from attribute_types_hb.xml",
                           "userdata2":  "0",
                      },
            0x175A1A: {    "devdesc": "Scratch reg / attribute mismatch",
                           "moduleid": "MOD_CALL_MSS_ATTR_UPDATE",
                           "reasoncode": "RC_SCRATCH_REG_ATTR_MISMATCH",
                           "userdata1":  "Bitwise scratch register miscompare",
                           "userdata2":  "<unused>",
                      },
            0x1E1C1A: {    "devdesc": "Odyssey failed bootloader measurement hash verification",
                           "moduleid": "MOD_VERIFY_ODY_MEASUREMENT_REGS",
                           "reasoncode": "RC_ODY_BOOT_MEASUREMENT_FAIL",
                           "userdata1":  "Odyssey Chip HUID",
                           "userdata2":  "Unused",
                      },
            0x1E1D1A: {    "devdesc": "Odyssey failed runtime measurement hash verification",
                           "moduleid": "MOD_VERIFY_ODY_MEASUREMENT_REGS",
                           "reasoncode": "RC_ODY_RT_MEASUREMENT_FAIL",
                           "userdata1":  "Odyssey Chip HUID",
                           "userdata2":  "Unused",
                      },
            0x28711A: {    "devdesc": "An async ffdc request to the SBE returned an error. Depending on context this may not be an issue and is purely informational in nature.",
                           "moduleid": "SBEIO_FIFO_SBE_FFDC",
                           "reasoncode": "SBEIO_FIFO_SBE_ASYNC_FFDC_REQUEST",
                           "userdata1[0:31]":  "HUID of OCMB chip",
                           "userdata2":  "Unused",
                      },
            0x2BBC1A: {    "devdesc": "Incorrect response from TPM_CC_CreatePrimary command (see logs for TPM HUID)",
                           "moduleid": "MOD_TPM_CMD_CREATE_ATTEST",
                           "reasoncode": "RC_TPM_BAD_RESP",
                           "userdata1":  "TPM HUID",
                           "userdata2[0..31]":  "Expected response RC",
                           "userdata2[32..63]":  "Actual response RC",
                      },
            0x33411A: {    "devdesc": "Attribute overrides were rejected because system is in secure mode",
                           "moduleid": "MOD_FAPI2_MONITOR_FOR_FSP_MSGS",
                           "reasoncode": "RC_ATTR_OVERRIDE_DISALLOWED",
                      },
            0x351D1A: {    "devdesc": "Unable to update an unsupported NVDIMM type",
                           "moduleid": "NVDIMM_RUN_UPDATE",
                           "reasoncode": "NVDIMM_UNSUPPORTED_NVDIMM_TYPE",
                           "userdata1[0:31]":  "Unsupported Type",
                           "userdata1[32:63]":  "NVDIMM Target Huid",
                           "userdata2[0:31]":  "Supported nvdimm type",
                           "userdata2[32:63]":  "Other supported nvdimm type",
                      },
            0x47041A: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_BIOS_ATTR_FROM_HANDLE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x47051A: {    "devdesc": "Software problem, PLDM transaction failed",
                           "moduleid": "MOD_GET_BIOS_ATTR_FROM_HANDLE",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Attribute Handle",
                           "userdata2":  "Response Header Data",
                      },
            0x470D1A: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_BIOS_ATTR_FROM_HANDLE",
                           "reasoncode": "RC_BAD_TRANSFER_FLAG",
                           "userdata1":  "Actual Transfer Flag",
                           "userdata2":  "Expected Transfer Flag",
                      },
            0x47331A: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_BIOS_ATTR_FROM_HANDLE",
                           "reasoncode": "RC_BAD_NEXT_TRANSFER_HANDLE",
                           "userdata1":  "Actual Next Transfer Handle",
                           "userdata2":  "Expected Next Transfer Handle",
                      },
            0x90051b: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_MSVPD_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x16211B: {    "devdesc": "Software problem, trying to lookup a lid the lidpnor code doesn't know about",
                           "moduleid": "Util::UTL_GET_PNOR_SEC_LID_IDS",
                           "reasoncode": "Util::UTIL_NO_MAP_ENTRY",
                           "userdata1":  "PNOR section Id we tried to lookup",
                           "userdata2":  "Unused",
                      },
            0x1E1E1B: {    "devdesc": "Odyssey Minimum Secure Version is less than the Minimum Secure Version set by P10 SBE.",
                           "moduleid": "MOD_ODY_SECUREBOOT_VERIF",
                           "reasoncode": "RC_ODY_BAD_MSV",
                           "userdata1":  "Odyssey Chip HUID",
                           "userdata2[0:31]":  "Odyssey MSV",
                           "userdata2[32:63]":  "System MSV (set by P10 SBE)",
                      },
            0x1E1F1B: {    "devdesc": "Odyssey image version doesn't match what host expects.",
                           "moduleid": "MOD_ODY_SECUREBOOT_VERIF",
                           "reasoncode": "RC_ODY_BAD_IMAGE",
                           "userdata1":  "Odyssey Chip HUID",
                           "userdata2[0:31]":  "Host production mode",
                           "userdata2[32:63]":  "Odyssey production mode",
                      },
            0x28721B: {    "devdesc": "There is no recovery action on the SBE.",
                           "moduleid": "SBEIO_ODY_RECOVERY",
                           "reasoncode": "SBEIO_ODY_RECOVERY_NOT_AVAILABLE",
                           "userdata1":  "HUID of Odyssey OCMB",
                           "userdata2":  "Unused",
                      },
            0x287A1B: {    "devdesc": "All attempts to recover the Odyssey SBE have failed.",
                           "moduleid": "SBEIO_ODY_RECOVERY",
                           "reasoncode": "SBEIO_ODY_CANNOT_RECOVER",
                           "userdata1":  "HUID of Odyssey OCMB",
                           "userdata2[00:31]":  "EID of first hreset attempt failure",
                           "userdata2[32:63]":  "EID of second hreset attempt failure",
                      },
            0x2BB11B: {    "devdesc": "msg_sendrecv failed for createAttestationKeys",
                           "moduleid": "MOD_CREATE_ATT_KEYS",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2":  "TPM HUID",
                      },
            0x33281B: {    "devdesc": "Invalid or unsupported MemVpdData requested.",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_VPD_OCMB",
                           "reasoncode": "fapi2::RC_INVALID_TYPE",
                           "userdata1":  "vpd_type attempted",
                           "userdata2":  "HUID of OCMB target",
                      },
            0x33421B: {    "devdesc": "Invalid or unsupported MemVpdData requested.",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_VPD_OCMB",
                           "reasoncode": "fapi2::RC_UNKNOWN_OCMB_CHIP_TYPE",
                           "userdata1":  "Mem type of OCMB",
                           "userdata2":  "HUID of OCMB target",
                      },
            0x351E1B: {    "devdesc": "NV controller is busy so no update can run",
                           "moduleid": "UPDATE_IMAGE",
                           "reasoncode": "NVDIMM_OPERATION_IN_PROGRESS",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2":  "NVDIMM_CMD_STATUS0",
                      },
            0x351F1B: {    "devdesc": "Checksum failure when transferring region",
                           "moduleid": "UPDATE_IMAGE",
                           "reasoncode": "NVDIMM_CHECKSUM_ERROR",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Host checksum calculated",
                           "userdata2[16:31]":  "NV checksum returned",
                           "userdata2[32:47]":  "size of data for checksum",
                      },
            0x47041B: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_BIOS_TABLE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x470D1B: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_BIOS_TABLE",
                           "reasoncode": "RC_BAD_TRANSFER_FLAG",
                           "userdata1":  "Actual Transfer Flag",
                           "userdata2":  "Expected Transfer Flag",
                      },
            0x47331B: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_BIOS_TABLE",
                           "reasoncode": "RC_BAD_NEXT_TRANSFER_HANDLE",
                           "userdata1":  "Actual Next Transfer Handle",
                           "userdata2":  "Expected Next Transfer Handle",
                      },
            0x90141c: {    "devdesc": "Master proc target returned is Null",
                           "moduleid": "HDAT::MOD_GET_PATH_INFO",
                           "reasoncode": "HDAT::RC_MASTER_PROC_TARGET_NULL",
                      },
            0x100C1C: {    "devdesc": "Invalid target is supplied as input, SYSTEM target has no parent",
                           "moduleid": "TOD_UTIL_MOD_GET_PARENT",
                           "reasoncode": "TOD_INVALID_TARGET",
                           "userdata1":  "HUID of the input target",
                      },
            0x10171C: {    "devdesc": "Parent of input CLASS for supplied Target is not found",
                           "moduleid": "TOD_UTIL_MOD_GET_PARENT",
                           "reasoncode": "TOD_PARENT_NOT_FOUND",
                           "userdata1":  "HUID of supplied Target",
                           "userdata2[0:31]":  "Size of the list",
                           "userdata2[32:63]":  "Input CLASS",
                      },
            0x16221C: {    "devdesc": "Problem with XZ compression initialization",
                           "moduleid": "Util::UTIL_DECOMPRESS_LID",
                           "reasoncode": "Util::UTIL_DECOMPRESS_FAIL_INIT",
                           "userdata1":  "i_size Size of the input data to decompress",
                           "userdata2":  "io_size Size of the output buffer passed in",
                      },
            0x16231C: {    "devdesc": "Problem with XZ decompression",
                           "moduleid": "Util::UTIL_DECOMPRESS_LID",
                           "reasoncode": "Util::UTIL_DECOMPRESS_FAILED",
                           "userdata1":  "ret XZ decompression return code",
                           "userdata2":  "i_size Size of the input data to decompress",
                      },
            0x16241C: {    "devdesc": "Decompressed LID is unexpectedly empty",
                           "moduleid": "Util::UTIL_DECOMPRESS_LID",
                           "reasoncode": "Util::UTIL_DECOMPRESS_EMPTY",
                           "userdata1":  "i_size Size of the input data to decompress",
                           "userdata2":  "io_size Size of the output buffer passed in",
                      },
            0x28731C: {    "devdesc": "Null target passed",
                           "moduleid": "SBEIO_ERRLUD_SPPE_CODE_LEVELS",
                           "reasoncode": "SBEIO_CHIP_NULL_TARGET",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x2BB11C: {    "devdesc": "msg_sendrecv failed for readAKCertificate",
                           "moduleid": "MOD_READ_AK_CERT",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2":  "TPM HUID",
                      },
            0x333F1C: {    "devdesc": "platErrorOnSet> Set operation not valid",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_ERROR_ON_SET",
                           "reasoncode": "fapi2::RC_SET_ATTR_NOT_VALID",
                           "userdata1":  "Target HUID",
                           "userdata2":  "FAPI Attribute Id",
                      },
            0x351F1C: {    "devdesc": "Checksum failure when transferring region",
                           "moduleid": "UPDATE_IMAGE_DATA",
                           "reasoncode": "NVDIMM_CHECKSUM_ERROR",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Host checksum calculated",
                           "userdata2[16:31]":  "NV checksum returned",
                           "userdata2[32:47]":  "size of data for checksum",
                           "userdata2[48:63]":  "region",
                      },
            0x35201C: {    "devdesc": "Firmware image size is not large enough (needs to be at least region_size)",
                           "moduleid": "UPDATE_IMAGE_DATA",
                           "reasoncode": "NVDIMM_ZERO_TOTAL_REGIONS",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Firmware image size",
                           "userdata2[16:31]":  "region_size",
                      },
            0x470E1C: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_CURRENT_VALUE",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Actual type returned",
                           "userdata2":  "Expected type",
                      },
            0x47211C: {    "devdesc": "Software problem, PLDM transaction failed",
                           "moduleid": "MOD_GET_CURRENT_VALUE",
                           "reasoncode": "RC_UNSUPPORTED_ATTRIBUTE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x47221C: {    "devdesc": "Software problem, PLDM transaction failed",
                           "moduleid": "MOD_GET_CURRENT_VALUE",
                           "reasoncode": "RC_NO_ATTRIBUTE_MATCH",
                           "userdata1":  "String handle we found in string table",
                           "userdata2":  "Unused",
                      },
            0x161D1D: {    "devdesc": "Unsupported Component",
                           "moduleid": "Util::UTIL_MCL_MANAGE_SINGLE",
                           "reasoncode": "Util::UTIL_LIDMGR_INVAL_COMP",
                           "userdata1":  "Component ID (truncated to 8 bytes)",
                           "userdata2":  "Unused",
                      },
            0x16251D: {    "devdesc": "Unsupported Component",
                           "moduleid": "Util::UTIL_MCL_MANAGE_SINGLE",
                           "reasoncode": "Util::UTIL_MCL_MANAGE_NOT_SUPPORTED",
                           "userdata1":  "i_compId",
                           "userdata2":  "Unused",
                      },
            0x17351D: {    "devdesc": "P9N (Nimbus) DD1.x is not supported in this firmware driver.  Please update your module or use a different driver",
                           "moduleid": "ISTEP::MOD_SET_IPL_PARMS",
                           "reasoncode": "ISTEP::RC_P9N_DD1_NOT_SUPPORTED",
                           "userdata1":  "PVR of master proc",
                      },
            0x174D1D: {    "devdesc": "PNOR-IPMI not enabled, BMC firmware needs to be updated",
                           "moduleid": "ISTEP::MOD_SET_IPL_PARMS",
                           "reasoncode": "ISTEP::RC_PNOR_IPMI_NOT_ENABLED",
                           "userdata1":  "HIOMAP Mode",
                           "userdata2[0-31]":  "CONFIG_PNORDD_IS_BMCMBOX",
                           "userdata2[32:63]":  "CONFIG_PNORDD_IS_IPMI",
                      },
            0x2BBC1D: {    "devdesc": "Incorrect response from TPM_CC_NV_Read command (see logs for TPM HUID)",
                           "moduleid": "MOD_TPM_CMD_READ_AK_CERT",
                           "reasoncode": "RC_TPM_BAD_RESP",
                           "userdata1":  "TPM HUID",
                           "userdata2[0..31]":  "Expected response RC",
                           "userdata2[32..63]":  "Actual response RC",
                      },
            0x2BC31D: {    "devdesc": "TPM_RC_HANDLE response from TPM_CC_NV_Read indicates unprovisioned TPM (see logs for TPM HUID)",
                           "moduleid": "MOD_TPM_CMD_READ_AK_CERT",
                           "reasoncode": "RC_AK_CERT_NOT_AVAIL",
                           "userdata1":  "TPM HUID",
                           "userdata2[0..31]":  "TPM_RC_HANDLE response RC",
                           "userdata2[32..63]":  "Actual response RC",
                      },
            0x35211D: {    "devdesc": "Firmware Update Mode not updated",
                           "moduleid": "CHANGE_FW_UPDATE_MODE",
                           "reasoncode": "NVDIMM_UPDATE_MODE_UNCHANGED",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:7]":  "Mode setting",
                           "userdata2[8:15]":  "FIRMWARE_OPS_STATUS byte",
                      },
            0x90141d: {    "devdesc": "Master proc target returned is Null",
                           "moduleid": "HDAT::MOD_HDAT_SP_SUBSYS_CTOR",
                           "reasoncode": "HDAT::RC_MASTER_PROC_TARGET_NULL",
                      },
            0x90051e: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_HDAT_SP_SUBSYS_DTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x10191E: {    "devdesc": "Top level Target not found",
                           "moduleid": "TOD_IS_MPIPL",
                           "reasoncode": "TOD_TOP_LEVEL_TARGET_NOT_FOUND",
                      },
            0x16161E: {    "devdesc": "Error calling mm_block_map",
                           "moduleid": "Util::UTIL_MCL_MANAGE_PHYP",
                           "reasoncode": "Util::UTIL_MM_BLOCK_MAP_FAILED",
                           "userdata1":  "Physical address being mapped",
                           "userdata2":  "mapSize",
                      },
            0x16171E: {    "devdesc": "Error calling mm_block_unmap",
                           "moduleid": "Util::UTIL_MCL_MANAGE_PHYP",
                           "reasoncode": "Util::UTIL_MM_BLOCK_UNMAP_FAILED",
                           "userdata1":  "Address being removed",
                           "userdata2":  "rc from mm_block_unmap",
                      },
            0x28751E: {    "devdesc": "Odyssey flash check error(s) detected",
                           "moduleid": "SBEIO_ODY_CHECK_FLASH",
                           "reasoncode": "SBEIO_ODY_FLASH_CHECK_ERR",
                           "userdata1[0:31]":  "Odyssey HUID",
                           "userdata1[32:63]":  "Currently running side",
                           "userdata2[0:15]":  "Whether the failure was detected on side 0",
                           "userdata2[16:31]":  "Whether the failure was detected on side 1",
                           "userdata2[32:47]":  "Whether the failure was detected on golden side",
                      },
            0x2BBC1E: {    "devdesc": "Incorrect response from TPM_CC_Quote command (see logs for TPM HUID)",
                           "moduleid": "MOD_TPM_CMD_GEN_QUOTE",
                           "reasoncode": "RC_TPM_BAD_RESP",
                           "userdata1":  "TPM HUID",
                           "userdata2[0..31]":  "Expected response RC",
                           "userdata2[32..63]":  "Actual response RC",
                      },
            0x35221E: {    "devdesc": "Firmware Operation timed out",
                           "moduleid": "WAIT_FW_OPS_COMPLETE",
                           "reasoncode": "NVDIMM_FW_OPS_IN_PROGRESS_TIMEOUT",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Last NVDIMM_CMD_STATUS0 read",
                           "userdata2[16:31]":  "Timeout (seconds)",
                      },
            0x470E1E: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_DEBUG_CONSOLE_ENABLED",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x90021f: {    "devdesc": "Top level target not found",
                           "moduleid": "HDAT::MOD_PCRD_LOAD",
                           "reasoncode": "HDAT::RC_TOP_LVL_TGT_NOT_FOUND",
                      },
            0x900A1f: {    "devdesc": "could not find target",
                           "moduleid": "HDAT::MOD_PCRD_LOAD",
                           "reasoncode": "RC_TGT_ATTR_NOTFOUND",
                      },
            0x100C1F: {    "devdesc": "No/Multiple parent(s) found for processor osc target",
                           "moduleid": "TOD_RT_TOPOLOGY_RESET_BACKUP",
                           "reasoncode": "TOD_INVALID_TARGET",
                           "userdata1":  "The number of parents found osc target",
                           "userdata2":  "None",
                      },
            0x101A1F: {    "devdesc": "Host interfaces are not initialized",
                           "moduleid": "TOD_RT_TOPOLOGY_RESET_BACKUP",
                           "reasoncode": "TOD_RT_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "None",
                           "userdata2":  "None",
                      },
            0x28791F: {    "devdesc": "This error log (and those that are linked to this log) contains the Odyssey scratch data in its FFDC fields.",
                           "moduleid": "SBEIO_ODY_READ_SCRATCH_DATA",
                           "reasoncode": "SBEIO_ODY_SCRATCH_DATA",
                           "userdata1":  "The Odyssey chip HUID",
                           "userdata2":  "The remaining size of scratch data | total size of scratch data",
                      },
            0x2BB11F: {    "devdesc": "msg_sendrecv failed for generateQuote",
                           "moduleid": "MOD_GEN_QUOTE",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2":  "TPM HUID",
                      },
            0x35231F: {    "devdesc": "Data size too big to transfer in one command",
                           "moduleid": "BYTE_REGION_BLOCK_TRANSFER",
                           "reasoncode": "NVDIMM_DATA_SIZE_TOO_LARGE",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Data size trying to transfer",
                           "userdata2[16:31]":  "Maximum data size allowed",
                           "userdata2[32:47]":  "Calculated blocks_per_region",
                           "userdata2[48-63]":  "Maximum blocks_per_region allowed",
                      },
            0x35241F: {    "devdesc": "Data size too big to transfer",
                           "moduleid": "BYTE_REGION_BLOCK_TRANSFER",
                           "reasoncode": "NVDIMM_DATA_SIZE_INVALID",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Data size trying to transfer",
                           "userdata2[16:31]":  "Calculated maximum data size transfer",
                           "userdata2[32:47]":  "Blocks per region",
                           "userdata2[48-63]":  "Bytes transferred per block",
                      },
            0x47051F: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_LOOKUP_VALUE_IN_STRING_TABLE",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Stated Size",
                           "userdata2":  "Size found",
                      },
            0x47231F: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_LOOKUP_VALUE_IN_STRING_TABLE",
                           "reasoncode": "RC_OUT_OF_RANGE",
                           "userdata1":  "possible_value_index",
                           "userdata2":  "max possible value",
                      },
            0x47241F: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_LOOKUP_VALUE_IN_STRING_TABLE",
                           "reasoncode": "RC_NO_MATCH_IN_TABLE",
                           "userdata1":  "String handle we tried to lookup",
                           "userdata2":  "Unused",
                      },
            0x63F20: {    "devdesc": "PnorSfcDD::PnorSfcDD> Read zero for PNOR chipid, assuming SFC is bad or missing.",
                           "moduleid": "PNOR::MOD_PNORDD_SFC_CONSTRUCTOR",
                           "reasoncode": "PNOR::RC_ZERO_NOR_CHIPID",
                           "userdata1":  "Processor HUID",
                           "userdata2":  "<unused>",
                      },
            0x93120: {    "devdesc": "PROC or OCC expected",
                           "moduleid": "fapi::MOD_GET_OCC_CHIP_TARGET",
                           "reasoncode": "fapi::RC_TARGET_UNSUPPORTED",
                           "userdata1":  "Target Type",
                           "userdata2":  "Target HUID",
                      },
            0xA0120: {    "devdesc": "presenceDetect> Invalid data length (!= 1 bytes)",
                           "moduleid": "FSI::MOD_FSIPRES_PROCPRESENCEDETECT",
                           "reasoncode": "FSI::RC_INVALID_LENGTH",
                           "userdata1":  "Data Length",
                      },
            0xA0F20: {    "devdesc": "presenceDetect> FSI and MVPD do not agree",
                           "moduleid": "FSI::MOD_FSIPRES_PROCPRESENCEDETECT",
                           "reasoncode": "FSI::RC_FSI_MVPD_MISMATCH",
                           "userdata1":  "HUID of processor",
                           "userdata2[0:31]":  "FSI Presence",
                           "userdata2[32:63]":  "MVPD Presence",
                      },
            0x101A20: {    "devdesc": "Host interfaces are not initialized",
                           "moduleid": "TOD_RT_TOPOLOGY_DATA",
                           "reasoncode": "TOD_RT_NULL_FIRMWARE_REQUEST_PTR",
                      },
            0x173920: {    "devdesc": "Targets detected via I2C were rediscovered after an I2C reset.  Reboot to add to config",
                           "moduleid": "ISTEP::MOD_REDISCOVER_I2C_TARGETS",
                           "reasoncode": "ISTEP::RC_REDISCOVERED_TARGETS",
                           "userdata1[0:31]":  "HUID of 1st rediscovered target",
                           "userdata1[31:63]":  "HUID of 2nd rediscovered target, if applicable",
                           "userdata2[0:31]":  "Target Count Before Rediscover Attempt",
                           "userdata2[31:63]":  "Target Count After Rediscover Attempt",
                      },
            0x1A2720: {    "devdesc": "Unable to fill in HB data memory",
                           "moduleid": "RUNTIME::MOD_FILL_RSVMEM_HBDATA",
                           "reasoncode": "RUNTIME::RC_EXCEEDED_MEMORY",
                           "userdata1":  "Total size needed",
                           "userdata2":  "Size allowed",
                      },
            0x1A4420: {    "devdesc": "Unknown reserved memory label attempted",
                           "moduleid": "RUNTIME::MOD_FILL_RSVMEM_HBDATA",
                           "reasoncode": "RUNTIME::RC_UNKNOWN_LABEL",
                           "userdata1":  "Unknown Label",
                           "userdata2":  "<unused>",
                      },
            0x1D0320: {    "devdesc": "The record enumeration did not have a corresponding string value.",
                           "moduleid": "VPD::VPD_IPVPD_TRANSLATE_RECORD",
                           "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                           "userdata1":  "Record enumeration.",
                           "userdata2":  "<UNUSED>",
                      },
            0x1E2020: {    "devdesc": "Error found in Node Comm status/ctrl register",
                           "moduleid": "MOD_NCDD_CHECK_FOR_ERRORS",
                           "reasoncode": "RC_NCDD_HW_ERROR_FOUND",
                           "userdata1":  "Status Register Value",
                           "userdata2":  "Target HUID",
                      },
            0x260620: {    "devdesc": "Failed to read util to throttle results",
                           "moduleid": "HTMGT_MOD_MEM_THROTTLE_OT",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "ocmb HUID",
                           "userdata2":  "port HUID",
                      },
            0x260720: {    "devdesc": "Failed to save util to throttle results",
                           "moduleid": "HTMGT_MOD_MEM_THROTTLE_OT",
                           "reasoncode": "HTMGT_RC_SAVE_TO_ATTRIBUTE_FAIL",
                           "userdata1":  "ocmb HUID",
                      },
            0x2BBC20: {    "devdesc": "Incorrect response from TPM2_FlushContext command (see logs for TPM HUID)",
                           "moduleid": "MOD_TPM_CMD_FLUSH_CONTEXT",
                           "reasoncode": "RC_TPM_BAD_RESP",
                           "userdata1":  "TPM HUID",
                           "userdata2[0..31]":  "Expected response RC",
                           "userdata2[32..63]":  "Actual response RC",
                      },
            0x333420: {    "devdesc": "Bad SPD or unsupported DIMM",
                           "moduleid": "MOD_FAPI2_SPD_ACCESS",
                           "reasoncode": "RC_INVALID_SPD_DRAM_GEN",
                           "userdata1":  "DDR generation",
                           "userdata2":  "HUID of input target",
                      },
            0x352620: {    "devdesc": "Firmware Operation not successful",
                           "moduleid": "VALIDATE_FW_HEADER",
                           "reasoncode": "NVDIMM_FW_OPS_NOT_SUCCESSFUL",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2":  "Operation command being verified",
                      },
            0x470520: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_SYSTEM_ENUM_ATTR_LOOKUP",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "# String Handles Returned",
                           "userdata2":  "Unused",
                      },
            0x900120: {    "devdesc": "Input Target Pointer is NULL",
                           "moduleid": "HDAT::MOD_PCRD_SET_PROC_INF",
                           "reasoncode": "HDAT::RC_INVALID_OBJECT",
                           "userdata1":  "Index of proc target",
                           "userdata2":  "Target HUID",
                      },
            0x900620: {    "devdesc": "Input Target Pointer is NULL",
                           "moduleid": "HDAT::MOD_PCRD_SET_PROC_INF:",
                           "reasoncode": "HDAT::RC_EMPTY_TARGET_LIST",
                      },
            0x93221: {    "devdesc": "Improper data size, data is not 8 byte aligned.",
                           "moduleid": "fapi::MOD_ACCESS_OCB_INDIRECT_CHANNEL",
                           "reasoncode": "fapi::RC_INVALID_DATA_BUFFER_LENGTH",
                           "userdata1":  "Length of requested buffer size(in Bytes) to perform read operation.",
                           "userdata2":  "OCI address",
                      },
            0x101B21: {    "devdesc": "This TOD OSC is not able to provide good signals to the processor. This OSC will be called out. Associated TOD end points on the processor side will also be called out, look for other callout details on this error log.",
                           "moduleid": "TOD_OSC_CALLOUT",
                           "reasoncode": "TOD_BAD_OSC",
                           "userdata1":  "EMOD_CALLOUT_TOD_OSC",
                           "userdata2":  "HUID of the TOD OSC through which good signals are not received.",
                      },
            0x174021: {    "devdesc": "messages from other nodes have not returned in time",
                           "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                           "reasoncode": "ISTEP::RC_FREQ_ATTR_TIMER_EXPIRED,",
                           "userdata1":  "MAX_TIME_ALLOWED_MS",
                           "userdata2":  "Number of nodes that have not responded",
                      },
            0x174121: {    "devdesc": "Freq attribute DATA timer thread failed",
                           "moduleid": "ISTEP::MOD_FREQ_ATTR_DATA,",
                           "reasoncode": "ISTEP::RC_FREQ_ATTR_TIMER_THREAD_FAIL,",
                           "userdata1":  "l_tidretrc,",
                           "userdata2":  "l_childsts,",
                      },
            0x1A2821: {    "devdesc": "Unable to pin read/write attribute memory",
                           "moduleid": "RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL",
                           "reasoncode": "RUNTIME::RC_UNABLE_TO_PIN_ATTR_MEM",
                           "userdata1":  "Message return code from message handler",
                           "userdata2":  "Return code from msg_sendrecv function",
                      },
            0x1A2921: {    "devdesc": "Unable to unpin read/write attribute memory",
                           "moduleid": "RUNTIME::MOD_ATTR_RUNTIME_CHECK_PREP_FAIL",
                           "reasoncode": "RUNTIME::RC_UNABLE_TO_UNPIN_ATTR_MEM",
                           "userdata1":  "Message return code from message handler",
                           "userdata2":  "Return code from msg_sendrecv function",
                      },
            0x1D0421: {    "devdesc": "The keyword enumeration did not have a corresponding string value.",
                           "moduleid": "VPD::VPD_IPVPD_TRANSLATE_KEYWORD",
                           "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                           "userdata1":  "Keyword Enumeration",
                           "userdata2":  "<UNUSED>",
                      },
            0x1E2121: {    "devdesc": "Timed out waiting for command complete.",
                           "moduleid": "MOD_NCDD_WAIT_FOR_CMD_COMP",
                           "reasoncode": "RC_NCDD_CMD_COMP_TIMEOUT",
                           "userdata1":  "Status Register Value",
                           "userdata2[0:31]":  "Status/Control Register Address",
                           "userdata2[32:63]":  "Target HUID",
                      },
            0x260621: {    "devdesc": "Failed to read throttle procedure results",
                           "moduleid": "HTMGT_MOD_MEM_THROTTLE_REDUN",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "ocmb HUID",
                           "userdata2":  "port HUID",
                      },
            0x260721: {    "devdesc": "Failed to save throttle procedure results",
                           "moduleid": "HTMGT_MOD_MEM_THROTTLE_REDUN",
                           "reasoncode": "HTMGT_RC_SAVE_TO_ATTRIBUTE_FAIL",
                           "userdata1":  "ocmb HUID",
                      },
            0x2BB121: {    "devdesc": "msg_sendrecv failed for TPM2_FlushContext",
                           "moduleid": "MOD_FLUSH_CONTEXT",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2":  "TPM HUID",
                      },
            0x352621: {    "devdesc": "Firmware Operation not successful",
                           "moduleid": "COMMIT_FW_REGION",
                           "reasoncode": "NVDIMM_FW_OPS_NOT_SUCCESSFUL",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2":  "Operation command being verified",
                      },
            0x470421: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_WRITE_FILE_BY_TYPE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x470521: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_WRITE_FILE_BY_TYPE",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Actual Length",
                           "userdata2":  "Expected Length",
                      },
            0x900521: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_PCRD_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0xA0B22: {    "devdesc": "FsiDD::genFullFsiAddr> Master Type is not supported",
                           "moduleid": "FSI::MOD_RTFSI_GENFULLFSIADDR",
                           "reasoncode": "FSI::RC_FSI_NOT_SUPPORTED",
                           "userdata1":  "Target of FSI Operation",
                           "userdata2[32:39]":  "Physical Node of FSI Master processor",
                           "userdata2[40:47]":  "Physical Position of FSI Master processor",
                           "userdata2[48:55]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER)",
                           "userdata2[56:63]":  "Slave link/port number",
                      },
            0xA0C22: {    "devdesc": "FsiDD::genFullFsiAddr> Cannot chain 2 masters",
                           "moduleid": "FSI::MOD_RTFSI_GENFULLFSIADDR",
                           "reasoncode": "FSI::RC_INVALID_FSI_PATH_1",
                           "userdata1[0:31]":  "Target of FSI Operation",
                           "userdata1[32:63]":  "Target's FSI Master Chip",
                           "userdata2[0:7]":  "Physical Node of FSI Master processor [target's master]",
                           "userdata2[8:15]":  "Physical Position of FSI Master processor [target's master]",
                           "userdata2[16:23]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER) [target's master]",
                           "userdata2[24:31]":  "Slave link/port number  [target's master]",
                           "userdata2[32:39]":  "Physical Node of FSI Master processor [master's master]",
                           "userdata2[40:47]":  "Physical Position of FSI Master processor [master's master]",
                           "userdata2[48:55]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER) [master's master]",
                           "userdata2[56:63]":  "Slave link/port number  [master's master]",
                      },
            0xA0D22: {    "devdesc": "FsiDD::genFullFsiAddr> Invalid master type for the target's master",
                           "moduleid": "FSI::MOD_RTFSI_GENFULLFSIADDR",
                           "reasoncode": "FSI::RC_INVALID_FSI_PATH_2",
                           "userdata1[0:31]":  "Target of FSI Operation",
                           "userdata1[32:63]":  "Target's FSI Master Chip",
                           "userdata2[0:7]":  "Physical Node of FSI Master processor [target's master]",
                           "userdata2[8:15]":  "Physical Position of FSI Master processor [target's master]",
                           "userdata2[16:23]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER) [target's master]",
                           "userdata2[24:31]":  "Slave link/port number  [target's master]",
                           "userdata2[32:39]":  "Physical Node of FSI Master processor [master's master]",
                           "userdata2[40:47]":  "Physical Position of FSI Master processor [master's master]",
                           "userdata2[48:55]":  "FSI Master type (0=MFSI,1=CMFSI,2=NO_MASTER) [master's master]",
                           "userdata2[56:63]":  "Slave link/port number  [master's master]",
                      },
            0x174A22: {    "devdesc": "p10_fabric_iovalid HWP returned errors on odd and even links. Creating an error to link all the individual link RCs together",
                           "moduleid": "MOD_SMP_WRAP_PROC_IOVALID",
                           "reasoncode": "RC_LINK_TRAIN_ERRORS_FROM_HWP",
                           "userdata0":  "PROC HUID",
                           "userdata1":  "Number of RCs from HWP",
                      },
            0x1A3E22: {    "devdesc": "messages from other nodes have not returned in time",
                           "moduleid": "RUNTIME::MOD_SEND_SBE_SYSCONFIG,",
                           "reasoncode": "RUNTIME::RC_SEND_SBE_TIMER_EXPIRED,",
                           "userdata1":  "Message Type IPC_QUERY_CHIPINFO or IPC_SET_SBE_CHIPINFO",
                           "userdata2":  "Number of nodes that have not responded",
                      },
            0x1A3F22: {    "devdesc": "sendSBESystemConfig timer thread failed",
                           "moduleid": "RUNTIME::MOD_SEND_SBE_SYSCONFIG,",
                           "reasoncode": "RUNTIME::RC_HOST_TIMER_THREAD_FAIL,,",
                           "userdata1":  "l_tidretrc,",
                           "userdata2":  "l_childsts,",
                      },
            0x1D3122: {    "devdesc": "Unable to resolve the VPD source (PNOR or SEEPROM)",
                           "moduleid": "VPD::VPD_IPVPD_FIND_RECORD_OFFSET",
                           "reasoncode": "VPD::VPD_READ_SOURCE_UNRESOLVED",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Requested VPD Source Location",
                           "userdata2[0:31]":  "VPD write PNOR flag",
                           "userdata2[32:63]":  "VPD write HW flag",
                      },
            0x1E2222: {    "devdesc": "No Attention was found after sending data in Xbus Node Comm Test",
                           "moduleid": "MOD_NC_XBUS_TEST",
                           "reasoncode": "RC_NC_DATA_MISCOMPARE",
                           "userdata1":  "Data Read Back",
                           "userdata2[0:15]":  "LinkId data was read from",
                           "userdata2[16:31]":  "MboxId data was read from",
                           "userdata2[32:63]":  "Target HUID data was read from",
                      },
            0x1E2322: {    "devdesc": "No Attention was found after sending data in XBUS Node Comm Test",
                           "moduleid": "MOD_NC_XBUS_TEST",
                           "reasoncode": "RC_NC_NO_ATTN_FOUND",
                           "userdata1":  "Data Sent",
                           "userdata2[0:15]":  "LinkId data was sent from",
                           "userdata2[16:31]":  "MboxId data was sent from",
                           "userdata2[32:63]":  "Target HUID data was sent from",
                      },
            0x260622: {    "devdesc": "Failed to set utilization for throttle procedures",
                           "moduleid": "HTMGT_MOD_MEM_UTIL_TO_THROTTLE",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "ocmb HUID",
                           "userdata2":  "port HUID",
                      },
            0x2BB122: {    "devdesc": "msg_sendrecv failed for pcrRead",
                           "moduleid": "MOD_PCR_READ",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2":  "TPM HUID",
                      },
            0x334322: {    "devdesc": "Invalid read buffer size, needs to be divisible by transaction size",
                           "moduleid": "fapi2::MOD_FAPI2_EXPLR_IB_I2C_READ",
                           "reasoncode": "fapi2::RC_INVALID_BUFFER_SIZE",
                           "userdata1[0:31]":  "Buffer size",
                           "userdata1[32:63]":  "Transaction size",
                           "userdata2[0:31]":  "HUID of input target",
                           "userdata2[32:63]":  "i2c_address",
                      },
            0x352622: {    "devdesc": "Firmware Operation not successful",
                           "moduleid": "CLEAR_FW_DATA_BLOCK",
                           "reasoncode": "NVDIMM_FW_OPS_NOT_SUCCESSFUL",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2":  "Operation command being verified",
                      },
            0x472622: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_MFG_FLAGS",
                           "reasoncode": "RC_UNSUPPORTED_STRING_TYPE",
                           "userdata1":  "Expected String Type",
                           "userdata2":  "Returned String Type",
                      },
            0x472722: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_MFG_FLAGS",
                           "reasoncode": "RC_UNEXPECTED_STRING_SIZE",
                           "userdata1":  "Expected string size",
                           "userdata2":  "Returned string size",
                      },
            0x901522: {    "devdesc": "PVPD read fail",
                           "moduleid": "HDAT::MOD_UTIL_PVPD_READ_FUNC",
                           "reasoncode": "HDAT::RC_PVPD_READ_FAIL",
                           "userdata1":  "pvpd record",
                           "userdata2":  "pvpd keyword",
                      },
            0x901622: {    "devdesc": "PVPD read fail",
                           "moduleid": "HDAT::MOD_UTIL_PVPD_READ_FUNC",
                           "reasoncode": "HDAT::RC_PVPD_FAIL",
                           "userdata1":  "pvpd record",
                           "userdata2":  "pvpd keyword",
                      },
            0x1A3223: {    "devdesc": "Error with Firmware Notify request",
                           "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                           "reasoncode": "RC_FW_NOTIFY_RT_INVALID_MSG",
                           "userdata1[0:31]":  "Firmware Request type",
                           "userdata1[32:63]":  "Sequence number (FSP msg)",
                           "userdata2[0:31]":  "MBOX message type (FSP msg)",
                           "userdata2[32:63]":  "Message Type (FSP msg)",
                      },
            0x1A3423: {    "devdesc": "g_hostInterfaces->firmware_request not supported",
                           "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                           "reasoncode": "RC_FW_REQUEST_RT_NULL_PTR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "HWSV error log id (plid)",
                      },
            0x1A3523: {    "devdesc": "Invalid Target HUID in SBE Retry Data",
                           "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                           "reasoncode": "RC_SBE_RT_INVALID_HUID",
                           "userdata1":  "HUID of target",
                           "userdata2":  "HWSV error log id (plid)",
                      },
            0x1A3623: {    "devdesc": "SBE did not recover after hreset attempt",
                           "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                           "reasoncode": "RC_SBE_RT_RECOVERY_ERR",
                           "userdata1[00:31]":  "Target HUID",
                           "userdata1[32:63]":  "HWSV error log id (plid)",
                           "userdata2[00:31]":  "SBE Message Register",
                           "userdata2[32:63]":  "Unused",
                      },
            0x1A4E23: {    "devdesc": "Error during MCTP message handling during hbrt",
                           "moduleid": "MOD_RT_FIRMWARE_NOTIFY",
                           "reasoncode": "RC_MCTP_AVAILABLE_ERR",
                           "userdata1":  "return code from MCTP::get_next_packet",
                           "userdata2":  "unused",
                      },
            0x1D0423: {    "devdesc": "Keyword was not found in Record starting at given offset.",
                           "moduleid": "VPD::VPD_IPVPD_FIND_KEYWORD_ADDR",
                           "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                           "userdata1[0:31]":  "Start of Record Offset",
                           "userdata1[32:63]":  "Keyword Index",
                           "userdata2[0:31]":  "Requested Record",
                           "userdata2[32:63]":  "Requested Keyword",
                      },
            0x1D0523: {    "devdesc": "Record name does not match value expected for offset read.",
                           "moduleid": "VPD::VPD_IPVPD_FIND_KEYWORD_ADDR",
                           "reasoncode": "VPD::VPD_RECORD_MISMATCH",
                           "userdata1[00:31]":  "Current offset into VPD",
                           "userdata1[32:63]":  "Start of Record offset",
                           "userdata2[00:31]":  "Expected record name",
                           "userdata2[32:63]":  "Found record name",
                      },
            0x1E2423: {    "devdesc": "Too many attentions were found in the Node Comm FIR Register",
                           "moduleid": "MOD_NC_MAP_ATTN",
                           "reasoncode": "RC_NC_TOO_MANY_ATTNS_FOUND",
                           "userdata1":  "Raw FIR Data",
                           "userdata2[0:31]":  "Number of Attentions found",
                           "userdata2[32:63]":  "Target HUID FIR was read from",
                      },
            0x260623: {    "devdesc": "Failed to set target power for throttle procedure",
                           "moduleid": "HTMGT_MOD_MEM_BULK_PWR_THROTTLE",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "ocmb HUID",
                           "userdata2":  "port HUID",
                      },
            0x2BB123: {    "devdesc": "msg_sendrecv failed for expandTpmLog",
                           "moduleid": "MOD_EXPAND_TPM_LOG",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2":  "TPM HUID",
                      },
            0x334323: {    "devdesc": "Invalid write buffer size, needs to be divisible by transaction size",
                           "moduleid": "fapi2::MOD_FAPI2_EXPLR_IB_I2C_WRITE",
                           "reasoncode": "fapi2::RC_INVALID_BUFFER_SIZE",
                           "userdata1[0:31]":  "Buffer size",
                           "userdata1[32:63]":  "Transaction size",
                           "userdata2[0:31]":  "HUID of input target",
                           "userdata2[32:63]":  "i2c_address",
                      },
            0x352623: {    "devdesc": "Firmware Operation not successful",
                           "moduleid": "VALIDATE_FW_IMAGE",
                           "reasoncode": "NVDIMM_FW_OPS_NOT_SUCCESSFUL",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2":  "Operation command being verified",
                      },
            0x470423: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_TID",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x901823: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_PROCESS_FRU",
                           "reasoncode": "HDAT::RC_DEV_UNMAP_FAIL",
                      },
            0x174C24: {    "devdesc": "The HX keyword data found in the vpd is invalid. See Userdata for specific reason.",
                           "moduleid": "MOD_GET_LANEMASK_FROM_HX_KEYWORD",
                           "reasoncode": "RC_INVALID_HX_KEYWORD_DATA",
                           "userdata1[0:31]":  "Return code value from parseHxKeyword",
                           "userdata1[32:63]":  "PEC target HUID",
                           "userdata2":  "HX keyword data",
                      },
            0x1A3424: {    "devdesc": "Hypervisor firmware request interface not linked",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_FW_REQUEST_RT_NULL_PTR",
                           "userdata1":  "Number of Attributes to serialize and send",
                      },
            0x1A3724: {    "devdesc": "The Firmware Request call failed",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_FW_REQUEST_HWSV_ERR",
                           "userdata1[0:31]":  "HWSV error log id (PLID)",
                           "userdata1[32:63]":  "Sequence number",
                           "userdata2[0:31]":  "MBOX message type",
                           "userdata2[32:63]":  "Message Type",
                      },
            0x1A3824: {    "devdesc": "The Firmware Request call failed",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_FW_REQUEST_RESET_RELOAD_ERR",
                           "userdata1[0:31]":  "Hypervisor return code",
                           "userdata1[32:63]":  "Firmware Request type (HCODE Update, Initiate gard) ||                                  sequence number (FSP MSG) ||                                  i2cMaster & lock operation",
                           "userdata2[0:31]":  "SCOM address (HCODE Update) ||                                  MBOX message type (FSP MSG) ||                                  chipID ||                                  error type + resource type (Initiate gard)",
                           "userdata2[32:63]":  "SCOM data (HCODE Update) ||                                  Message Type (FSP MSG) ||                                  SBE state ||                                  NVDIMM protection ||                                  resource ID (Initiate gard)",
                      },
            0x1A3924: {    "devdesc": "The Firmware Request call failed",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_FW_REQUEST_ERR",
                           "userdata1[0:31]":  "Hypervisor return code",
                           "userdata1[32:63]":  "Firmware Request type (HCODE Update) ||                                  sequence number (FSP MSG) ||                                  i2cMaster & lock operation",
                           "userdata2[0:31]":  "SCOM address (HCODE Update) ||                                  MBOX message type (FSP MSG) ||                                  chipId",
                           "userdata2[32:63]":  "SCOM data (HCODE Update) ||                                  Message Type (FSP MSG)  ||                                  SBE state ||                                  NVDIMM protection state",
                      },
            0x1A5A24: {    "devdesc": "Unable to find I2C info necessary for lock/unlock() request",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_FAPI_I2C_CONTROL_INFO_MISSING",
                           "userdata1":  "HUID of target",
                           "userdata2":  "nothing",
                      },
            0x1A5B24: {    "devdesc": "Unable to find chipId for lock/unlock() request",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_TARGET_CHIP_NOT_FOUND",
                           "userdata1":  "HUID of target",
                           "userdata2":  "Nothing",
                      },
            0x1A5C24: {    "devdesc": "HBRT problem with hostInterfaces",
                           "moduleid": "MOD_RT_FIRMWARE_REQUEST",
                           "reasoncode": "RC_RT_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "I2C Lock message type",
                      },
            0x1D0624: {    "devdesc": "Buffer size was not greater than or equal to expected buffer size.",
                           "moduleid": "VPD::VPD_IPVPD_CHECK_BUFFER_SIZE",
                           "reasoncode": "VPD::VPD_INSUFFICIENT_BUFFER_SIZE",
                           "userdata1":  "Buffer Size",
                           "userdata2":  "Expected Buffer Size",
                      },
            0x1E2524: {    "devdesc": "Invalid Input Args for Node Comm DD call",
                           "moduleid": "MOD_NCDD_PERFORM_OP",
                           "reasoncode": "RC_NCDD_INVALID_ARGS",
                           "userdata1[0:15]":  "LinkId Value",
                           "userdata1[16:31]":  "MAX possile LinkId Value",
                           "userdata1[32:47]":  "MailboxId Value",
                           "userdata1[48:63]":  "MAX possible MailboxId Value",
                           "userdata2":  "Input Data Pointer",
                      },
            0x1E3024: {    "devdesc": "NodeComm DD invalid operation type",
                           "moduleid": "MOD_NCDD_PERFORM_OP",
                           "reasoncode": "RC_NCDD_INVALID_OP_TYPE",
                           "userdata1":  "Operation type",
                           "userdata2":  "Input Target HUID",
                      },
            0x260624: {    "devdesc": "Invalid APSS config data was found",
                           "moduleid": "HTMGT_MOD_APSS_DATA",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "None",
                      },
            0x2BBD24: {    "devdesc": "Could not fetch the TPM log manager",
                           "moduleid": "MOD_TPM_CMD_EXPAND_TPM_LOG",
                           "reasoncode": "RC_NO_TPM_LOG_MGR",
                           "userdata1":  "TPM HUID",
                      },
            0x334424: {    "devdesc": "MRW WOF selection index value not included in SEEPROM WOF image entries",
                           "moduleid": "fapi2::MOD_FAPI2_GET_DEFAULT_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_MRW_IDX_NOT_INCLUDED",
                           "userdata1":  "MRW WOF selection index",
                           "userdata2":  "Entry count in SEEPROM WOF image",
                      },
            0x334524: {    "devdesc": "WOF table header entry to be fetched goes beyond WOF image in SEEPROM",
                           "moduleid": "fapi2::MOD_FAPI2_GET_DEFAULT_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_HEADER_ENTRY_BEYOND_IMG",
                           "userdata1[00:31]":  "Offset of table header entry in WOF image",
                           "userdata1[32:63]":  "Size of table header entry",
                           "userdata2[00:31]":  "Selection index ATTR_WOF_INDEX_SELECT",
                           "userdata2[32:63]":  "Size of WOF image",
                      },
            0x352524: {    "devdesc": "Firmware Operation timed out waiting for data block transfer confirmation",
                           "moduleid": "WAIT_FW_OPS_BLOCK_RECEIVED",
                           "reasoncode": "NVDIMM_BLOCK_NOT_RECEIVED",
                           "userdata1":  "NVDIMM Target Huid",
                           "userdata2[0:15]":  "Last FIRMWARE_OPS_STATUS read",
                           "userdata2[16:31]":  "Timeout (msecs)",
                      },
            0x471824: {    "devdesc": "Unable to find the entity associated with this RSID",
                           "moduleid": "MOD_ADD_INVENTORY_PDRS",
                           "reasoncode": "RC_NO_ENTITY_FROM_RSID",
                           "userdata1":  "record set ID of target",
                           "userdata2":  "HUID of target",
                      },
            0x901724: {    "devdesc": "process fru funciton failed",
                           "moduleid": "HDAT::MOD_BUILD_SPECIFIED_VPD",
                           "reasoncode": "HDAT::RC_PROCESS_FRU_FAIL",
                           "userdata1":  "Spira data area",
                           "userdata2":  "Hdat fru type",
                      },
            0x1A3C25: {    "devdesc": "Attribute failed to update on HBRT side",
                           "moduleid": "MOD_RT_ATTR_SYNC_REQUEST",
                           "reasoncode": "RC_ATTR_UPDATE_FAILED",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Attribute ID",
                           "userdata2[0:31]":  "Data Size",
                           "userdata2[32:63]":  "Up to 4 bytes of attribute data",
                      },
            0x1D0325: {    "devdesc": "The record string did not have a corresponding enumeration value.",
                           "moduleid": "VPD::VPD_IPVPD_RECORD_STRING_TO_ENUM",
                           "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                           "userdata1":  "Record string.",
                           "userdata2":  "<UNUSED>",
                      },
            0x1E2625: {    "devdesc": "Sent bit not set in Node Comm status/ctrl register",
                           "moduleid": "MOD_NCDD_WRITE",
                           "reasoncode": "RC_NCDD_DATA_NOT_SENT",
                           "userdata1":  "Status Register Value",
                           "userdata2":  "Target HUID",
                      },
            0x260625: {    "devdesc": "Failed to read throttle procedure results",
                           "moduleid": "HTMGT_MOD_MEM_THROTTLE_OVERSUB",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "ocmb HUID",
                           "userdata2":  "port HUID",
                      },
            0x260725: {    "devdesc": "Failed to save throttle procedure results",
                           "moduleid": "HTMGT_MOD_MEM_THROTTLE_OVERSUB",
                           "reasoncode": "HTMGT_RC_SAVE_TO_ATTRIBUTE_FAIL",
                           "userdata1":  "ocmb HUID",
                      },
            0x334625: {    "devdesc": "WOF data has uncorrectable ECC",
                           "moduleid": "fapi2::MOD_FAPI2_GET_SEEPROM_ECC_LESS_WOF_DATA",
                           "reasoncode": "fapi2::RC_WOF_READ_UNCORRECTABLE_ECC",
                           "userdata1":  "Offset used to read WOF+ECC data from SEEPROM",
                           "userdata2":  "Buffer length used to read WOF+ECC data from SEEPROM",
                      },
            0x352725: {    "devdesc": "Unable to update an NVDIMM at this code level",
                           "moduleid": "NVDIMM_IS_UPDATE_NEEDED",
                           "reasoncode": "NVDIMM_UPDATE_NOT_SUPPORTED",
                           "userdata1[0:31]":  "NVDIMM version level",
                           "userdata1[32:63]":  "NVDIMM Target Huid",
                           "userdata2":  "NVDIMM type (manufacturer and product)",
                      },
            0x471B25: {    "devdesc": "Software problem, invalid effecter state from BMC",
                           "moduleid": "MOD_HANDLE_SET_OCC_STATE",
                           "reasoncode": "RC_INVALID_EFFECTER_STATE",
                           "userdata1":  "HUID of the PROC with the OCC that was being reset",
                           "userdata2[0:15]":  "Set request field of first effecter",
                           "userdata2[16:31]":  "Effecter state of first effecter",
                           "userdata2[32:63]":  "Effecter count",
                      },
            0x900525: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_HDAT_SERVICEDATA_CTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x174F26: {    "devdesc": "The UCD content LID was not found within the UCD container",
                           "moduleid": "ISTEP::MOD_CALL_UPDATE_UCD_FLASH",
                           "reasoncode": "ISTEP::RC_UCD_IMG_NOT_IN_CONTAINER",
                           "userdata1":  "UCD LID ID",
                      },
            0x1A3D26: {    "devdesc": "Hostboot attempted to reserve memory past allowed range. Bottom limit = Hostboot HRMOR + 64M, top limit = 256M - 4K.",
                           "moduleid": "RUNTIME::MOD_CHECK_HB_RES_MEM_LIMIT",
                           "reasoncode": "RUNTIME::RC_HB_RES_MEM_EXCEEDED",
                           "userdata1":  "Starting address",
                           "userdata2":  "Size of the section",
                      },
            0x1D0426: {    "devdesc": "The keyword string did not have a corresponding enumeration value.",
                           "moduleid": "VPD::VPD_IPVPD_KEYWORD_STRING_TO_ENUM",
                           "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                           "userdata1":  "Keyword string.",
                           "userdata2":  "<UNUSED>",
                      },
            0x1E2926: {    "devdesc": "Primary Proc's ATTR_PHYS_PATH is invalid as it doesn't have either a NODE or PROC elemenent",
                           "moduleid": "MOD_NCEX_MAIN",
                           "reasoncode": "RC_NCEX_INVALID_PHYS_PATH",
                           "userdata1":  "Primary Proc Target HUID",
                           "userdata2":  "<Unused>",
                      },
            0x1E2A26: {    "devdesc": "When processing the IOHS Peer paths, the wrong count of valid paths was found",
                           "moduleid": "MOD_NCEX_MAIN",
                           "reasoncode": "RC_NCEX_INVALID_INSTANCE_COUNT",
                           "userdata1":  "Primary Proc Target HUID",
                           "userdata2[0:31]":  "Number of Valid IOHS Instances",
                           "userdata2[32:63]":  "Total Number Of Nodes",
                      },
            0x2BBA26: {    "devdesc": "Input Processor Target cannot use XSCOMs yet so the TPM is unreachable",
                           "moduleid": "TRUSTEDBOOT::MOD_TPM_CHECK_TDP_BIT",
                           "reasoncode": "TRUSTEDBOOT::RC_UNREACHABLE_TPM",
                           "userdata1":  "Processor Target Driving SPI To The TPM",
                           "userdata2":  "TPM Target",
                      },
            0x2BC026: {    "devdesc": "TPM Deconfig Protect bit was set in TPM's SPI Driver Processor's Security Switch Register",
                           "moduleid": "TRUSTEDBOOT::MOD_TPM_CHECK_TDP_BIT",
                           "reasoncode": "TRUSTEDBOOT::RC_TPM_TDP_BIT_IS_SET",
                           "userdata1[0:31]":  "Processor Target Driving SPI To The TPM",
                           "userdata1[32:63]":  "TPM Target",
                           "userdata2":  "Security Switch Register Value",
                      },
            0x332B26: {    "devdesc": "WOF image header magic value mismatch",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_IMAGE_MAGIC_MISMATCH",
                           "userdata1[00:31]":  "Image header magic value",
                           "userdata1[32:63]":  "Expected magic value",
                           "userdata2[00:31]":  "Proc whose WOF data is being overridden",
                           "userdata2[32:63]":  "0-based index of Override WOF Image that match override search criteria",
                      },
            0x332C26: {    "devdesc": "WOF tables header magic value mismatch",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_TABLES_MAGIC_MISMATCH",
                           "userdata1[00:31]":  "Override WOF table header magic value",
                           "userdata1[32:63]":  "Expected magic value",
                      },
            0x332E26: {    "devdesc": "Image header version not supported",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_IMAGE_VERSION_MISMATCH",
                           "userdata1[00:31]":  "Image header version",
                           "userdata1[32:63]":  "Supported header version",
                           "userdata2[00:31]":  "Proc whose WOF data is being overridden",
                           "userdata2[32:63]":  "0-based index of Override WOF Image that match override search criteria",
                      },
            0x332F26: {    "devdesc": "WOF tables header version not supported",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_TABLES_VERSION_MISMATCH",
                           "userdata1[00:31]":  "Override WOF tables header version",
                           "userdata1[32:63]":  "Supported header version",
                      },
            0x333026: {    "devdesc": "Error calling mm_alloc_block for WOFDATA",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_MM_ALLOC_BLOCK_FAILED",
                           "userdata1":  "Address being allocated",
                           "userdata2[00:31]":  "Size of block allocation",
                           "userdata2[32:63]":  "rc from mm_alloc_block",
                      },
            0x333126: {    "devdesc": "Error calling mm_set_permission for WOFDATA",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_MM_SET_PERMISSION_FAILED",
                           "userdata1":  "Address being changed",
                           "userdata2[00:31]":  "Size of change",
                           "userdata2[32:63]":  "rc from mm_set_permission",
                      },
            0x333226: {    "devdesc": "Error calling mm_remove_pages for WOFDATA",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_MM_REMOVE_PAGES_FAILED",
                           "userdata1":  "Address being removed",
                           "userdata2[00:31]":  "Size of removal",
                           "userdata2[32:63]":  "rc from mm_remove_pages",
                      },
            0x333326: {    "devdesc": "Error calling mm_set_permission for WOFDATA",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_MM_SET_PERMISSION2_FAILED",
                           "userdata1":  "Address being changed",
                           "userdata2[00:31]":  "Size of change",
                           "userdata2[32:63]":  "rc from mm_set_permission",
                      },
            0x334726: {    "devdesc": "WOF Override image magic value mismatch",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_OVERRIDE_MAGIC_MISMATCH",
                           "userdata1[00:31]":  "WOF Override image magic value",
                           "userdata1[32:63]":  "Expected magic value",
                           "userdata2[00:31]":  "Proc whose WOF data is being overridden",
                           "userdata2[32:63]":  "WOFDATA LID number that was used",
                      },
            0x334826: {    "devdesc": "WOF Override image version not supported",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_OVERRIDE_VERSION_MISMATCH",
                           "userdata1[00:31]":  "WOF Override image header version",
                           "userdata1[32:63]":  "Supported version number",
                           "userdata2[00:31]":  "Proc whose WOF data is being overridden",
                           "userdata2[32:63]":  "WOFDATA LID number that was used",
                      },
            0x334926: {    "devdesc": "No override WOF table found",
                           "moduleid": "fapi2::MOD_FAPI2_GET_OVERRIDE_WOF_TABLE",
                           "reasoncode": "fapi2::RC_WOF_OVERRIDE_TABLE_NOT_FOUND",
                           "userdata1[00:31]":  "Number of WOF override sets checked",
                           "userdata1[32:63]":  "Core count",
                           "userdata2[00:31]":  "Nominal power in watts",
                           "userdata2[32:63]":  "WofBase frequency in Mhz",
                      },
            0x470E26: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_LMB_SIZE",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x900526: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_HDAT_NODEDATA_DTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x175027: {    "devdesc": "Could not unmap unsecure HOMER's virtual address",
                           "moduleid": "ISTEP::MOD_LOAD_HCODE",
                           "reasoncode": "ISTEP::RC_MM_UNMAP_FAILED",
                           "userdata1":  "Unsecure HOMER addr",
                           "userdata2":  "RC from HBPM_UNMAP",
                      },
            0x1A4027: {    "devdesc": "Copy of trace buffer from previous HBRT run",
                           "moduleid": "RUNTIME::MOD_INIT_RT_RES_MEM_TRACE_BUF",
                           "reasoncode": "RUNTIME::RC_RT_RES_TRACE_BUF_DUMPED",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x260627: {    "devdesc": "DIMM Power calculation array sizes mismatch",
                           "moduleid": "HTMGT_MOD_UPDATE_DIMM_POWER_UTIL",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "size of DIMM_POWER_UTIL",
                           "userdata2":  "size of DIMM_POWER",
                      },
            0x260727: {    "devdesc": "Software problem, Failed to DIMM power utilization points",
                           "moduleid": "HTMGT_MOD_UPDATE_DIMM_POWER_UTIL",
                           "reasoncode": "HTMGT_RC_SAVE_TO_ATTRIBUTE_FAIL",
                           "userdata1":  "num points",
                           "userdata2":  "minimum utilization point",
                      },
            0x2BB227: {    "devdesc": "msg_send() failed",
                           "moduleid": "MOD_SYNCHRONIZE_TPM_LOG",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "rc from msq_send()",
                      },
            0x471A27: {    "devdesc": "Software problem, could not find SW Termination PDR.",
                           "moduleid": "MOD_FIND_TERMINATION_STATUS_ID",
                           "reasoncode": "RC_INVALID_EFFECTER_ID",
                           "userdata1":  "The total number of PDRs that PDR Manager is aware of.",
                           "userdata2[0:31]":  "PLDM_STATE_EFFECTER_PDR enum value",
                           "userdata2[32:63]":  "State set being searched for",
                      },
            0x901927: {    "devdesc": "could not create the data area from spiras",
                           "moduleid": "HDAT::MOD_SPIRAS_CREATE_DATA_AREA",
                           "reasoncode": "HDAT::RC_DATA_AREA_FAIL",
                      },
            0x90728: {    "devdesc": "NULL target pointer given to platGetScom",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_GET_SCOM",
                           "reasoncode": "fapi2::RC_INVALID_TARG_TARGET",
                           "userdata1":  "SCOM address being read",
                      },
            0x1A4228: {    "devdesc": "SP ATTN Areas attempting to allocate past valid memory range.",
                           "moduleid": "RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS",
                           "reasoncode": "RUNTIME::RC_SP_ATTN_AREA_OVERFLOW",
                           "userdata1":  "SP ATTN Area total size",
                           "userdata2":  "SP ATTN Area start address",
                      },
            0x1A4328: {    "devdesc": "SP ATTN Area 1 size exceeds the maximum.",
                           "moduleid": "RUNTIME::MOD_OPEN_UNTRUSTED_SP_AREAS",
                           "reasoncode": "RUNTIME::RC_SP_ATTN_AREA1_SIZE_OVERFLOW",
                           "userdata1":  "SP ATTN Area 1 size proposed by hostboot",
                           "userdata2":  "SP ATTN Area 1 size reported in HDAT",
                      },
            0x2BB128: {    "devdesc": "msg_sendrecv failed for logSbeMeasurementRegs",
                           "moduleid": "MOD_LOG_SBE_MEASUREMENT_REGS",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "rc from msg_sendrecv",
                           "userdata2[0:31]":  "TPM HUID",
                           "userdata2[32:63]":  "Processor HUID",
                      },
            0x470E28: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_POWER_LIMIT",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x900528: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_SPIRAS_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x90729: {    "devdesc": "NULL target pointer given to platPutScom",
                           "moduleid": "fapi2::MOD_FAPI2_PLAT_PUT_SCOM",
                           "reasoncode": "fapi2::RC_INVALID_TARG_TARGET",
                           "userdata1":  "SCOM address being written",
                      },
            0x1A4529: {    "devdesc": "Unable to allocate firmware request messages",
                           "moduleid": "MOD_SEND_ATTRIBUTES_TO_FSP",
                           "reasoncode": "RC_NULL_FIRMWARE_MSG_PTR",
                           "userdata1":  "Number of Attributes to serialize and send",
                      },
            0x1A4629: {    "devdesc": "Serialization of an Attribute Failed",
                           "moduleid": "MOD_SEND_ATTRIBUTES_TO_FSP",
                           "reasoncode": "RC_SERIALIZE_ATTRIBUTE_FAILED",
                           "userdata1":  "Number of Attributes to serialize and send",
                      },
            0x1A4729: {    "devdesc": "Serialization data of Attribute to large for given buffer",
                           "moduleid": "MOD_SEND_ATTRIBUTES_TO_FSP",
                           "reasoncode": "RC_NO_SPACE_FOR_ATTRIBUTE_SERIALIZATION",
                           "userdata1":  "Number of Attributes to serialize and send",
                      },
            0x1E3429: {    "devdesc": "Functional Primary TPM was not found",
                           "moduleid": "MOD_NCEX_GET_RANDOM",
                           "reasoncode": "RC_NCEX_NO_FUNCTIONAL_PRIMARY_TPM",
                           "userdata1":  "TPM Target HUID",
                           "userdata2[0:31]":  "TPM Target HWAS State Present",
                           "userdata2[31:63]":  "TPM Target HWAS State Functional",
                      },
            0x2BC129: {    "devdesc": "Could not translate virtual address to physical address. Likely a firmware bug.",
                           "moduleid": "TRUSTEDBOOT::MOD_EXTEND_MEAS_OTHER_NODES",
                           "reasoncode": "TRUSTEDBOOT::RC_VIRT_TO_PHYS_FAIL",
                           "userdata1":  "Virtual address to map",
                      },
            0x2BC229: {    "devdesc": "MBOX queue registered with MBOX::HB_IPC_EXTEND_PCR_MSGQ handle was different than expected when unregistering the handle.  Likely a firmware bug.",
                           "moduleid": "TRUSTEDBOOT::MOD_EXTEND_MEAS_OTHER_NODES",
                           "reasoncode": "TRUSTEDBOOT::RC_MBOX_QUEUE_MISMATCH",
                           "userdata1":  "Queue that was registered",
                           "userdata2":  "Queue that was unregistered",
                      },
            0x900529: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_HDAT_SPIRAH_DTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                           "userdata1":  "Spirah address hi",
                           "userdata2":  "Spirah address lo",
                      },
            0x1E272A: {    "devdesc": "Mismatch between expected and actual Link Mbox Ids a secure message was received on",
                           "moduleid": "MOD_NC_RECV",
                           "reasoncode": "RC_NCEX_MISMATCH_RECV_LINKS",
                           "userdata1":  "Target HUID",
                           "userdata2[0:15]":  "Expected Link Id to receive message on",
                           "userdata2[16:31]":  "Expected Mailbox Id to receive message on",
                           "userdata2[32:47]":  "Actual Link Id message was received on",
                           "userdata2[48:63]":  "Actual Mailbox Id message was receiveed on",
                      },
            0x1E2B2A: {    "devdesc": "Timed out waiting to receive message from another node",
                           "moduleid": "MOD_NC_RECV",
                           "reasoncode": "RC_NC_WAITING_TIMEOUT",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Time Polled in ns",
                           "userdata2[0:31]":  "Defined MAX Poll Time in ns",
                           "userdata2[32:63]":  "Time Interval Between Polls in ns",
                      },
            0x472C2A: {    "devdesc": "BMC sent an unexpected message global enable value in the SetEventReceiverRequest command",
                           "moduleid": "MOD_HANDLE_SET_EVENT_RECEIVER",
                           "reasoncode": "RC_BAD_GLOBAL_ENABLE",
                           "userdata1":  "Expected value of message global enable",
                           "userdata2":  "Actual value of message global enable",
                      },
            0x472D2A: {    "devdesc": "BMC requested a watchdog timeout value that's too small",
                           "moduleid": "MOD_HANDLE_SET_EVENT_RECEIVER",
                           "reasoncode": "RC_BAD_WATCHDOG_VALUE",
                           "userdata1":  "Minimum value of the watchdog supported by HB",
                           "userdata2":  "Watchdog timeout value sent by BMC",
                      },
            0x901a2a: {    "devdesc": "Null passed for spirah ms addr",
                           "moduleid": "HDAT::MOD_HDAT_GET_SPIRAH",
                           "reasoncode": "HDAT::RC_NULL_PTR_PASSED",
                      },
            0x1E2C2B: {    "devdesc": "The system policy is set to not allow boot without a functioning TPM, but the system's primary node indicated that its TPM is compromised. This secondary node must terminate the boot process.",
                           "moduleid": "MOD_NC_GEN_QUOTE_RESPONSE",
                           "reasoncode": "RC_NC_BAD_REQUESTER_TPM",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x1E2D2B: {    "devdesc": "Could not fetch primary TPM's Log",
                           "moduleid": "MOD_NC_GEN_QUOTE_RESPONSE",
                           "reasoncode": "RC_NC_NO_PRIMARY_TPM_LOG",
                           "userdata1":  "Primary TPM HUID",
                      },
            0x1E2E2B: {    "devdesc": "Requesting node sent an unrecognized eye catcher",
                           "moduleid": "MOD_NC_GEN_QUOTE_RESPONSE",
                           "reasoncode": "RC_NC_BAD_REQUESTER_EYE_CATCH",
                           "userdata1":  "Eye catcher received from requesting node",
                      },
            0x47042B: {    "devdesc": "BMC responded with a bad return code to the heartbeat timer elapsed event.",
                           "moduleid": "MOD_RESET_WATCHDOG_TIMER",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Completion code",
                      },
            0x90052b: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_NACA_GET_MEM",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x901b2b: {    "devdesc": "map a mapped region failed",
                           "moduleid": "HDAT::MOD_NACA_GET_MEM",
                           "reasoncode": "HDAT::RC_INVALID_NACA",
                      },
            0x1A1A2C: {    "devdesc": "Targeting target's type not supported by runtime code",
                           "moduleid": "RUNTIME::MOD_CONFIGURE_HBRT_HYP_IDS",
                           "reasoncode": "RUNTIME::RT_TARGET_TYPE_NOT_SUPPORTED",
                           "userdata1":  "Target's HUID",
                           "userdata2":  "Target's targeting type",
                      },
            0x47252C: {    "devdesc": "Cannot locate graceful shutdown PDRs.",
                           "moduleid": "MOD_PLDM_SHUTDOWN",
                           "reasoncode": "RC_NOT_READY",
                           "userdata1":  "The graceful shutdown sensor ID",
                           "userdata2":  "The BMC chassis poweroff effecter ID",
                      },
            0x90052c: {    "devdesc": "Unmap a mapped region failed",
                           "moduleid": "HDAT::MOD_HBRT_LOAD_DATA",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                      },
            0x900A2c: {    "devdesc": "The target attribute not found",
                           "moduleid": "HDAT::MOD_HBRT_LOAD_DATA",
                           "reasoncode": "HDAT::RC_TGT_ATTR_NOTFOUND",
                      },
            0x9242D: {    "devdesc": "mm_block_unmap returned incorrectly with 0",
                           "moduleid": "fapi::MOD_START_XZ_PAYLOAD",
                           "reasoncode": "fapi::RC_MM_UNMAP_ERR",
                      },
            0x93E2D: {    "devdesc": "xz-embedded has returned an error. the return code can be found in xz.h",
                           "moduleid": "fapi::MOD_START_XZ_PAYLOAD",
                           "reasoncode": "fapi::RC_INVALID_RETURN_XZ_CODE",
                           "userdata1":  "Return code from xz-embedded",
                           "userdata2[0:31]":  "Original Payload Size",
                           "userdata2[32:63]":  "Uncompressed Payload Size",
                      },
            0x1E2F2D: {    "devdesc": "One of the secondary nodes indicated that there was an issue with its TPM or quote generation process",
                           "moduleid": "MOD_NC_PROCESS_QUOTE",
                           "reasoncode": "RC_NC_BAD_QUOTE",
                           "userdata1":  "Node where the quote came from",
                      },
            0x47252D: {    "devdesc": "Software problem, graceful shutdown requested by BMC at runtime",
                           "moduleid": "MOD_HANDLE_GRACEFUL_SHUTDOWN_REQUEST",
                           "reasoncode": "RC_NOT_READY",
                      },
            0x901c2d: {    "devdesc": "Device read failed",
                           "moduleid": "HDAT::MOD_UTIL_FULL_MVPD_READ_FUNC",
                           "reasoncode": "HDAT::RC_DEV_READ_VPD_FAIL",
                      },
            0x1A4D2E: {    "devdesc": "Could not map OCC reset reason from PHYP to HTMGT",
                           "moduleid": "RUNTIME::MOD_PM_RT_RESET_W_REASON",
                           "reasoncode": "RUNTIME::RC_COULD_NOT_MAP_RESET_REASON",
                           "userdata1":  "Input OCC reason code",
                           "userdata2":  "Chip ID of the input chip",
                      },
            0x1E312E: {    "devdesc": "Invalid Input Args for Node Comm Transfer Send",
                           "moduleid": "MOD_NCT_SEND",
                           "reasoncode": "RC_NCT_TYPE_SIZE_MISMATCH",
                           "userdata1[0:31]":  "Input TARGET HUID",
                           "userdata1[32:63]":  "Input Data Size",
                           "userdata2[0:31]":  "Input Transfer Type",
                           "userdata2[32:63]":  "Expected Size For Input Transfer Type",
                      },
            0x1E322E: {    "devdesc": "Invalid data from ACK for Node Comm Transfer Send",
                           "moduleid": "MOD_NCT_SEND",
                           "reasoncode": "RC_NCT_ACK_MISMATCH",
                           "userdata1[0:15]":  "Actual Node Sending the ACK",
                           "userdata1[16:31]":  "Expected Node Sending the ACK",
                           "userdata1[32:47]":  "Actual Node Receiving the ACK",
                           "userdata1[48:63]":  "Expected Node Receiving the ACK",
                           "userdata2[0:15]":  "Actual Message Type from the ACK",
                           "userdata2[16:31]":  "Expected Message Type from the ACK",
                           "userdata2[32:47]":  "Actual Sequence Number from the ACK",
                           "userdata2[48:63]":  "Expected Sequence Number from the ACK",
                      },
            0x470E2E: {    "devdesc": "BMC returned an unknown enum for secure version lockin enabled",
                           "moduleid": "MOD_GET_SEC_VER_LOCKIN_ENABLED",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                      },
            0x92A2F: {    "devdesc": "messages from other nodes have not returned in time",
                           "moduleid": "fapi::MOD_VERIFY_IPC_CONNECTION",
                           "reasoncode": "fapi::RC_HOST_TIMER_EXPIRED",
                           "userdata1":  "MAX_TIME_ALLOWED_MS",
                           "userdata2":  "Number of nodes that have not responded",
                      },
            0x92B2F: {    "devdesc": "host coalesce host timer thread failed",
                           "moduleid": "fapi::MOD_VERIFY_IPC_CONNECTION",
                           "reasoncode": "fapi::RC_HOST_TIMER_THREAD_FAIL",
                           "userdata1":  "l_tidRetRc",
                           "userdata2":  "l_childSts",
                      },
            0x17072F: {    "devdesc": "mm_block_unmap failed and returned nullptr",
                           "moduleid": "MOD_VERIFY_AND_MOVE_PAYLOAD",
                           "reasoncode": "ISTEP::RC_MM_UNMAP_ERR",
                           "userdata1":  "Map Fail Location",
                           "userdata2":  "Return code from mm_block_unmap",
                      },
            0x170A2F: {    "devdesc": "mm_block_map failed and returned nullptr",
                           "moduleid": "MOD_VERIFY_AND_MOVE_PAYLOAD",
                           "reasoncode": "ISTEP::RC_MM_MAP_ERR",
                           "userdata1":  "Map Fail Location",
                           "userdata2":  "<UNUSED>",
                      },
            0x173A2F: {    "devdesc": "PAYLOAD allocated more HDAT space than temporary space that Hostboot uses",
                           "moduleid": "MOD_VERIFY_AND_MOVE_PAYLOAD",
                           "reasoncode": "ISTEP::RC_HDAT_SIZE_CHECK_FAILED",
                           "userdata1":  "Allocated HDAT size from PAYLOAD",
                           "userdata2":  "Temporary HDAT size",
                      },
            0x1E312F: {    "devdesc": "Unexpected Size of Data Received based on Input Transfer Type",
                           "moduleid": "MOD_NCT_RECEIVE",
                           "reasoncode": "RC_NCT_TYPE_SIZE_MISMATCH",
                           "userdata1[0:31]":  "Input TARGET HUID",
                           "userdata1[32:63]":  "Output Data Size",
                           "userdata2[0:31]":  "Input Transfer Type",
                           "userdata2[32:63]":  "Expected Size For Input Transfer Type",
                      },
            0x1E332F: {    "devdesc": "Invalid data from Initiation Message",
                           "moduleid": "MOD_NCT_RECEIVE",
                           "reasoncode": "RC_NCT_INITIATION_MISMATCH",
                           "userdata1[0:15]":  "Actual Node Sending the Initiation Message",
                           "userdata1[16:31]":  "Expected Node Sending the Initiation Message",
                           "userdata1[32:47]":  "Actual Node Receiving the Initiation Message",
                           "userdata1[48:63]":  "Expected Node Receiving the Initiaion Message",
                           "userdata2[0:15]":  "Actual Message Type from Initiation Message",
                           "userdata2[16:31]":  "Expected Message Type from Initiation Message",
                           "userdata2[32:47]":  "Actual Sequence Number from Initiation Message",
                           "userdata2[48:63]":  "Expected Sequence Number from Initiation Msg",
                      },
            0x47042F: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SET_BIOS_ATTR_BY_HANDLE",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x47332F: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SET_BIOS_ATTR_BY_HANDLE",
                           "reasoncode": "RC_BAD_NEXT_TRANSFER_HANDLE",
                           "userdata1":  "Actual Next Transfer Handle",
                           "userdata2":  "Expected Next Transfer Handle",
                      },
            0x90152f: {    "devdesc": "PVPD read fail",
                           "moduleid": "HDAT::MOD_UTIL_PVPD_FULL_READ_FUNC",
                           "reasoncode": "HDAT::RC_PVPD_READ_FAIL",
                           "userdata1":  "pvpd record",
                      },
            0x90162f: {    "devdesc": "PVPD read fail",
                           "moduleid": "HDAT::MOD_UTIL_PVPD_FULL_READ_FUNC",
                           "reasoncode": "HDAT::RC_PVPD_FAIL",
                           "userdata1":  "pvpd record",
                      },
            0x1A4A30: {    "devdesc": "Unknown/invalid error type",
                           "moduleid": "MOD_LOG_GARD_EVENT",
                           "reasoncode": "RC_LOG_GARD_EVENT_UNKNOWN_ERROR_TYPE",
                           "userdata1[0:31]":  "GARD error type",
                           "userdata1[32:63]":  "Processor ID",
                           "userdata2[0:31]":  "Sub unit mask",
                           "userdata2[32:63]":  "Recovery level",
                      },
            0x1A4B30: {    "devdesc": "Gard event from Opal/Phyp",
                           "moduleid": "MOD_LOG_GARD_EVENT",
                           "reasoncode": "RC_LOG_GARD_EVENT",
                           "userdata1[0:31]":  "GARD error type",
                           "userdata1[32:63]":  "Processor ID",
                           "userdata2[0:31]":  "Sub unit mask",
                           "userdata2[32:63]":  "Recovery level",
                      },
            0x1D0330: {    "devdesc": "The requested record was not found in the VPD VTOC.",
                           "moduleid": "VPD::VPD_IPVPD_FIND_RECORD_OFFSET_SEEPROM",
                           "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                           "userdata1[0:31]":  "Requested Record",
                           "userdata1[32:63]":  "Requested Keyword",
                           "userdata2":  "Target HUID",
                      },
            0x1E2F30: {    "devdesc": "Peer node indicated that it encountered an issue during secure node comm.",
                           "moduleid": "MOD_NCT_REQUEST_QUOTE",
                           "reasoncode": "RC_NC_BAD_QUOTE",
                           "userdata1":  "Peer node ID",
                      },
            0x470E30: {    "devdesc": "Unable to find a valid bootside",
                           "moduleid": "MOD_GET_BIOS_SIDE",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "pldm_bootside  value",
                           "userdata2":  "unused",
                      },
            0x900D30: {    "devdesc": "Device read failed",
                           "moduleid": "HDAT::MOD_UTIL_MVPD",
                           "reasoncode": "HDAT::RC_DEV_READ_FAIL",
                      },
            0x175431: {    "devdesc": "Could not map HOMER Physical address to virt",
                           "moduleid": "ISTEP::MOD_START_PM_COMPLEX",
                           "reasoncode": "ISTEP::RC_INVALID_HOMER_VADDR",
                           "userdata1":  "HUID",
                           "userdata2":  "HOMER Phys Addr",
                      },
            0x1A5631: {    "devdesc": "Host callback interface not linked",
                           "moduleid": "MOD_CREATE_PMIC_HEALTH_CHECK_CALLBACK",
                           "reasoncode": "RC_HOST_CALLBACK_INTERFACE_ERR",
                           "userdata1":  "First call to create callback function",
                           "userdata2":  "<unused>",
                      },
            0x1A5731: {    "devdesc": "Host Callback failed.",
                           "moduleid": "MOD_CREATE_PMIC_HEALTH_CHECK_CALLBACK",
                           "reasoncode": "RC_HOST_CALLBACK_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2[0:31]":  "Callback timer value",
                           "userdata2[32:63]":  "Callback message size",
                      },
            0x1D3031: {    "devdesc": "The retrieved VPD Header Record (VHDR) is incomplete.",
                           "moduleid": "VPD::VPD_IPVPD_FETCH_DATA",
                           "reasoncode": "VPD::VPD_RECORD_INVALID_VHDR",
                           "userdata1[00:31]":  "Target to find record in",
                           "userdata1[32:63]":  "Input arg: Record ID",
                           "userdata2[00:31]":  "<unused>",
                           "userdata2[32:63]":  "Input arg: EEEPROM SOURCE",
                      },
            0x470E31: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_MIRROR_MEMORY",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x1A5832: {    "devdesc": "ATTR_DEALLOCATED not found on target",
                           "moduleid": "MOD_DEALLOCATE_RESOURCE",
                           "reasoncode": "RC_UNSUPPORTED_TARGET",
                           "userdata1[0:31]":  "huid of target",
                           "userdata1[32:63]":  "resourceType",
                           "userdata2":  "resourceId",
                      },
            0x1A5932: {    "devdesc": "Unsupported deallocated resource type",
                           "moduleid": "MOD_DEALLOCATE_RESOURCE",
                           "reasoncode": "RC_UNSUPPORTED_RESOURCE_TYPE",
                           "userdata1":  "Resource Type",
                           "userdata2":  "Resource ID",
                      },
            0x1D4732: {    "devdesc": "No MVPD write support in HBRT",
                           "moduleid": "VPD::VPD_IPVPD_WRITE_KEYWORD",
                           "reasoncode": "VPD::VPD_WRITE_MVPD_UNSUPPORTED_HBRT",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "<unused>",
                           "userdata2[0:31]":  "VPD Record (ASCII)",
                           "userdata2[32:63]":  "VPD Keyword (ASCII)",
                      },
            0x472632: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_LID_IDS",
                           "reasoncode": "RC_UNSUPPORTED_STRING_TYPE",
                           "userdata1":  "Expected String Type",
                           "userdata2":  "Returned String Type",
                      },
            0x900532: {    "devdesc": "Creation of mapped region failed",
                           "moduleid": "HDAT::MOD_TPMDATA_CONSTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                           "userdata1[00:31]":  "Address attempted to map upper",
                           "userdata1[32:63]":  "Address attempted to map lower",
                           "userdata2[00:31]":  "Size of mapped region upper",
                           "userdata2[32:63]":  "Size of mapped region lower",
                      },
            0x175733: {    "devdesc": "Mapping of HOMER region to virtual space failed",
                           "moduleid": "ISTEP::MOD_SCOPED_HOMER_MAPPER_MAP",
                           "reasoncode": "ISTEP::RC_COULD_NOT_MAP_HOMER",
                           "userdata1":  "The physical address of HOMER region",
                           "userdata2":  "The HUID of the proc",
                      },
            0x1A5533: {    "devdesc": "Expected to get only one NX unit for the given PROC but didn't. See userdata for amount found.",
                           "moduleid": "MOD_CONVERT_TO_HB_TARGET",
                           "reasoncode": "RC_INVALID_NX_QUANTITY",
                           "userdata1[0:31]":  "Number of NX units found, expected 1",
                           "userdata1[32:63]":  "Processor ID",
                      },
            0x470E33: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_KEY_CLEAR_REQUEST",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x900533: {    "devdesc": "Unmap of a mapped region failed",
                           "moduleid": "HDAT::MOD_TPMDATA_DESTRUCTOR",
                           "reasoncode": "HDAT::RC_DEV_MAP_FAIL",
                           "userdata1[00:31]":  "Address attempted to unmap upper",
                           "userdata1[32:63]":  "Address attempted to unmap lower",
                      },
            0x175834: {    "devdesc": "Failed to unmap HOMER from the virtual space",
                           "moduleid": "ISTEP::MOD_SCOPED_HOMER_MAPPER_UNMAP",
                           "reasoncode": "ISTEP::RC_COULD_NOT_UNMAP_HOMER",
                           "userdata1":  "The HUID of the proc",
                      },
            0x1A5634: {    "devdesc": "Host callback interface not linked",
                           "moduleid": "MOD_CREATE_PMC_LOAD_START_CALLBACK",
                           "reasoncode": "RC_HOST_CALLBACK_INTERFACE_ERR",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x1A5734: {    "devdesc": "Host Callback failed",
                           "moduleid": "MOD_CREATE_PMC_LOAD_START_CALLBACK",
                           "reasoncode": "RC_HOST_CALLBACK_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2[0:31]":  "Callback timer in milliseconds",
                           "userdata2[32:63]":  "Callback message size",
                      },
            0x470E34: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_TPM_REQUIRED_POLICY",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x901e34: {    "devdesc": "Invalid OBUS brick ID",
                           "moduleid": "HDAT::MOD_UTIL_SMP_LINK_INFO",
                           "reasoncode": "HDAT::RC_INVALID_OBUS_BRICKID",
                      },
            0x901f34: {    "devdesc": "Invalid OBUS Freq Bucket",
                           "moduleid": "HDAT::MOD_UTIL_SMP_LINK_INFO",
                           "reasoncode": "HDAT::RC_INVALID_OBUS_FREQ_BUCKET",
                      },
            0x175535: {    "devdesc": "get_pm_complex_addresses interface is not provided",
                           "moduleid": "ISTEP::MOD_GET_RUNTIME_PM_ADDRESSES",
                           "reasoncode": "ISTEP::RC_PM_COMPLEX_ADDRESSES_NOT_FOUND",
                           "userdata1":  "The HUID of the proc",
                      },
            0x175635: {    "devdesc": "The get_pm_complex_addresses returned an error rc",
                           "moduleid": "ISTEP::MOD_GET_RUNTIME_PM_ADDRESSES",
                           "reasoncode": "ISTEP::RC_BAD_INTERFACE_RETURN_CODE",
                           "userdata1":  "The return code of the PHYP interface",
                           "userdata2":  "The HUID of the proc",
                      },
            0x175935: {    "devdesc": "HOMER and/or OCC Common physical address is zero",
                           "moduleid": "ISTEP::MOD_GET_RUNTIME_PM_ADDRESSES",
                           "reasoncode": "ISTEP::RC_INVALID_PM_ADDRESS",
                           "userdata1":  "Provided HOMER Physical address",
                           "userdata2":  "Provided OCC Common Physical Address",
                      },
            0x1A5D35: {    "devdesc": "Host callback interface not linked",
                           "moduleid": "MOD_CREATE_PMIC_HEALTH_CHECK_DDR5_CALLBACK",
                           "reasoncode": "RC_HOST_CALLBACK_INTERFACE_DDR5_ERR",
                           "userdata1":  "First call to create callback function",
                           "userdata2":  "<unused>",
                      },
            0x1A5E35: {    "devdesc": "Host Callback failed.",
                           "moduleid": "MOD_CREATE_PMIC_HEALTH_CHECK_DDR5_CALLBACK",
                           "reasoncode": "RC_HOST_CALLBACK_DDR5_ERR",
                           "userdata1":  "Hypervisor return code",
                           "userdata2[0:31]":  "Callback timer value",
                           "userdata2[32:63]":  "Callback message size",
                      },
            0x1D4235: {    "devdesc": "API vpdecc_create_ecc returned unknown error",
                           "moduleid": "VPD::VPD_IPVPD_ECC_DATA_UPDATE",
                           "reasoncode": "VPD::VPD_ECC_DATA_UNKNOWN_FAILURE",
                           "userdata1[00:31]":  "HUID of target",
                           "userdata1[32:47]":  "Record to create ECC data for",
                           "userdata1[48:63]":  "Error code returned from call to vpdecc_create_ecc",
                           "userdata2[00:15]":  "Record data offset",
                           "userdata2[16:31]":  "Record data length",
                           "userdata2[32:47]":  "ECC data offset",
                           "userdata2[48:63]":  "ECC data length",
                      },
            0x1D4335: {    "devdesc": "Buffer to store ECC data is not large enough",
                           "moduleid": "VPD::VPD_IPVPD_ECC_DATA_UPDATE",
                           "reasoncode": "VPD::VPD_ECC_DATA_ECC_SIZE_ISSUE",
                           "userdata1[00:31]":  "HUID of target",
                           "userdata1[32:47]":  "Record to create ECC data for",
                           "userdata1[48:63]":  "Error code returned from call to vpdecc_create_ecc",
                           "userdata2[00:15]":  "Record data offset",
                           "userdata2[16:31]":  "Record data length",
                           "userdata2[32:47]":  "ECC data offset",
                           "userdata2[48:63]":  "ECC data length",
                      },
            0x472F35: {    "devdesc": "BIOS attr does not have a matching possible value for the given enum string.",
                           "moduleid": "MOD_SET_BIOS_ATTR_ENUM_VALUE",
                           "reasoncode": "RC_NO_MATCHING_VALUE",
                           "userdata1":  "Ascii representation of the bios attr to set",
                           "userdata2":  "Ascii representation of the unmatched enum value string",
                      },
            0x901135: {    "devdesc": "Failed trying to add another entry to a mainstore area MMIO address range array",
                           "moduleid": "MOD_ADD_MMIO_ADDR_RANGE",
                           "reasoncode": "RC_ERC_MAX_EXCEEDED",
                           "userdata1":  "current no of mmio array entries",
                           "userdata2":  "maximum no of mmio array entries",
                           "userdata3":  "ID number of mainstore area",
                           "userdata4":  "none",
                      },
            0x175E36: {    "devdesc": "Memory encryption key setup failed",
                           "moduleid": "MOD_ENABLE_MEMORY_ENCRYPTION",
                           "reasoncode": "RC_MEMCRYPT_KEY_SETUP_FAILED",
                      },
            0x175F36: {    "devdesc": "Memory encryption lock failed",
                           "moduleid": "MOD_ENABLE_MEMORY_ENCRYPTION",
                           "reasoncode": "RC_MEMCRYPT_LOCK_FAILED",
                      },
            0x176036: {    "devdesc": "RNG for memory encryption keygen failed",
                           "moduleid": "MOD_ENABLE_MEMORY_ENCRYPTION",
                           "reasoncode": "RC_RNG_FAILED",
                      },
            0x176136: {    "devdesc": "Memory encryption was enabled for the listed MCCs",
                           "moduleid": "MOD_ENABLE_MEMORY_ENCRYPTION",
                           "reasoncode": "RC_MEMORY_ENCRYPTION_ENABLED",
                           "userdata1":  "Was memory encryption successfully enabled? (1 = yes, 0 = no)",
                      },
            0x1D4236: {    "devdesc": "API vpdecc_check_data returned an unknown error",
                           "moduleid": "VPD::VPD_IPVPD_ECC_DATA_CHECK",
                           "reasoncode": "VPD::VPD_ECC_DATA_UNKNOWN_FAILURE",
                           "userdata1[00:31]":  "HUID of target",
                           "userdata1[32:63]":  "Record to validate ECC data for (ASCII)",
                           "userdata2[00:15]":  "Record data offset",
                           "userdata2[16:31]":  "Record data length",
                           "userdata2[32:47]":  "ECC data offset",
                           "userdata2[48:63]":  "ECC data length",
                      },
            0x1D4336: {    "devdesc": "There is an issue with the ECC data size",
                           "moduleid": "VPD::VPD_IPVPD_ECC_DATA_CHECK",
                           "reasoncode": "VPD::VPD_ECC_DATA_ECC_SIZE_ISSUE",
                           "userdata1[00:31]":  "HUID of target",
                           "userdata1[32:63]":  "Record to validate ECC data for (ASCII)",
                           "userdata2[00:15]":  "Record data offset",
                           "userdata2[16:31]":  "Record data length",
                           "userdata2[32:47]":  "ECC data offset",
                           "userdata2[48:63]":  "ECC data length",
                      },
            0x1D4436: {    "devdesc": "Encountered an uncorrectable error with the VPD check",
                           "moduleid": "VPD::VPD_IPVPD_ECC_DATA_CHECK",
                           "reasoncode": "VPD::VPD_ECC_DATA_UNCORRECTABLE_DATA",
                           "userdata1[00:31]":  "HUID of target",
                           "userdata1[32:63]":  "Record to validate ECC data for (ASCII)",
                           "userdata2[00:15]":  "Record data offset",
                           "userdata2[16:31]":  "Record data length",
                           "userdata2[32:47]":  "ECC data offset",
                           "userdata2[48:63]":  "ECC data length",
                      },
            0x1D4536: {    "devdesc": "Encountered a correctable error with the VPD check",
                           "moduleid": "VPD::VPD_IPVPD_ECC_DATA_CHECK",
                           "reasoncode": "VPD::VPD_ECC_DATA_CORRECTABLE_DATA",
                           "userdata1[00:31]":  "HUID of target",
                           "userdata1[32:63]":  "Record to validate ECC data for (ASCII)",
                           "userdata2[00:15]":  "Record data offset",
                           "userdata2[16:31]":  "Record data length",
                           "userdata2[32:47]":  "ECC data offset",
                           "userdata2[48:63]":  "ECC data length",
                      },
            0x470436: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SEND_SET_NUMERIC_EFFECTER_VALUE_REQUEST",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x902236: {    "devdesc": "Failed trying to convert the raw spd data for ocmb chip to IPZ format",
                           "moduleid": "MOD_ADD_MS_AREA_IPZ_VPD",
                           "reasoncode": "RC_OCMB_IPZ_CONVERT_FAIL",
                           "userdata1":  "resource id of ocmb chip",
                           "userdata2":  "unused",
                           "userdata3":  "total ipz keyword size of ocmb chip",
                           "userdata4":  "ID number of mainstore area",
                      },
            0x176337: {    "devdesc": "SBE or HBBL put FFDC data into Scratch Register 11",
                           "moduleid": "MOD_SECUREBOOT_LOCKDOWN",
                           "reasoncode": "RC_SBE_REPORTED_FFDC",
                           "userdata1":  "HUID of Processor Target target",
                           "userdata2[0:31]":  "Scratch Register Data",
                           "userdata2[32:63]":  "Scratch Register Mask",
                      },
            0x1D1237: {    "devdesc": "Buffer size returned is insufficient to contain the VTOC meta data.",
                           "moduleid": "VPD::VPD_IPVPD_GET_VTOC_RECORD_META_DATA",
                           "reasoncode": "VPD::VPD_SIZE_MISMATCH",
                           "userdata1[0:31]":  "Returned buffer size",
                           "userdata1[32:63]":  "Expected buffer size",
                           "userdata2":  "Target HUID",
                      },
            0x1D4637: {    "devdesc": "Incorrect record returned, expected the VTOC record",
                           "moduleid": "VPD::VPD_IPVPD_GET_VTOC_RECORD_META_DATA",
                           "reasoncode": "VPD::VPD_INCORRECT_RECORD_RETURNED",
                           "userdata1[0:31]":  "Returned record name",
                           "userdata1[32:63]":  "Expected record name",
                           "userdata2":  "Target HUID",
                      },
            0x473037: {    "devdesc": "Missing SBE dump effecter ID",
                           "moduleid": "MOD_SBE_DUMP",
                           "reasoncode": "RC_EFFECTER_NOT_FOUND",
                           "userdata1":  "Dump target HUID",
                           "userdata2[0:31]":  "BMC's SBE start-dump effecter ID",
                           "userdata2[32:63]":  "Host's SBE dump-complete effecter ID",
                      },
            0x473237: {    "devdesc": "BMC failed to respond to dump request.",
                           "moduleid": "MOD_SBE_DUMP",
                           "reasoncode": "RC_SBE_DUMP_TIMED_OUT",
                           "userdata1":  "Dump target HUID",
                           "userdata2[0:31]":  "BMC's SBE start-dump effecter ID",
                           "userdata2[32:63]":  "Host's SBE dump-complete effecter ID",
                      },
            0x474437: {    "devdesc": "Missing target to dump",
                           "moduleid": "MOD_SBE_DUMP",
                           "reasoncode": "RC_DUMP_TARGET_NOT_FOUND",
                           "userdata1":  "Input target HUID",
                      },
            0x474537: {    "devdesc": "SBE dump request failed.",
                           "moduleid": "MOD_SBE_DUMP",
                           "reasoncode": "RC_SBE_DUMP_FAILED",
                           "userdata1":  "Dump target HUID",
                           "userdata2[0:31]":  "BMC's SBE start-dump effecter ID",
                           "userdata2[32:63]":  "Host's SBE dump-complete effecter ID",
                      },
            0x902337: {    "devdesc": "Failed trying to convert the raw spd data for dimm to IPZ format",
                           "moduleid": "MOD_ADD_RAM_AREA_IPZ_VPD",
                           "reasoncode": "RC_DIMM_IPZ_CONVERT_FAIL",
                           "userdata1":  "resource id of dimm",
                           "userdata2":  "unused",
                           "userdata3":  "total ipz keyword size for dimm",
                           "userdata4":  "slca index",
                      },
            0x176438: {    "devdesc": "Failed to boot a secondary SBE",
                           "moduleid": "MOD_RECOVER_SBE",
                           "reasoncode": "RC_FAILED_SBE_HRESET",
                           "userdata1":  "HUID of proc that failed to boot its SBE",
                           "userdata2":  "Unused",
                      },
            0x1D0338: {    "devdesc": "VPD record was not found.",
                           "moduleid": "VPD::VPD_IPVPD_GET_RECORD_META_DATA",
                           "reasoncode": "VPD::VPD_RECORD_NOT_FOUND",
                           "userdata1[00:31]":  "Target to find record in",
                           "userdata1[32:63]":  "Input arg: Record ID",
                           "userdata2[00:31]":  "<unused>",
                           "userdata2[32:63]":  "Input arg: EEEPROM SOURCE",
                      },
            0x470E38: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_USB_ENABLEMENT",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x902438: {    "devdesc": "Unable to determine the DIMM type from raw spd data",
                           "moduleid": "MOD_SPD_RAW_CONVERT_TO_IPZ_TYPE",
                           "reasoncode": "RC_INVALID_DIMM_TYPE",
                           "userdata1":  "resource id of fru",
                           "userdata2":  "total raw spd keyword size",
                           "userdata3":  "dimm type",
                           "userdata4":  "none",
                      },
            0x176539: {    "devdesc": "Unable to confirm PCR6 match between primary and secondary SBE",
                           "moduleid": "MOD_RETRIEVE_EXTEND_SECONDARY_MEASUREMENTS",
                           "reasoncode": "RC_PCR6_MISMATCH_DETECTED",
                           "userdata1":  "Huid of secondary processor",
                           "userdata2":  "Mismatch found (bitwise 0x02 = PCR6 0, 0x01 = PCR6 4-7)",
                      },
            0x1D3039: {    "devdesc": "VPD VHDR record data does not match what is expected",
                           "moduleid": "VPD::VPD_IPVPD_VERIFY_VHDR_RECORD_IS_VALID",
                           "reasoncode": "VPD::VPD_RECORD_INVALID_VHDR",
                           "userdata1[00:31]":  "Huid of target",
                           "userdata1[32:47]":  "Expected record length",
                           "userdata1[48:63]":  "Actual record length",
                           "userdata2[00:31]":  "Expected record name",
                           "userdata2[32:63]":  "Actual record name",
                      },
            0x472339: {    "devdesc": "Value we are trying to set BIOS attr with is out of acceptable range of values.",
                           "moduleid": "MOD_SET_BIOS_ATTR_INTEGER_VALUE",
                           "reasoncode": "RC_OUT_OF_RANGE",
                           "userdata1":  "Ascii representation of the bios attr to set",
                           "userdata2":  "Value hb is attempting to set the attr with",
                      },
            0x902539: {    "devdesc": "Unable to determine the DIMM module from raw spd data",
                           "moduleid": "MOD_SPD_RAW_CONVERT_TO_IPZ_MODULE",
                           "reasoncode": "RC_INVALID_DIMM_MODULE",
                           "userdata1":  "resource id of fru",
                           "userdata2":  "total raw spd keyword size",
                           "userdata3":  "dimm type",
                           "userdata4":  "none",
                      },
            0x17663A: {    "devdesc": "SBE security compromise detected in 10.1 and not resolved",
                           "moduleid": "MOD_CALL_HOST_SECUREBOOT_LOCKDOWN",
                           "reasoncode": "RC_SBE_COMPROMISED",
                           "userdata1":  "Huid of processor with compromised SBE",
                           "userdata2":  "EID with more details of why compromised",
                      },
            0x47253A: {    "devdesc": "Software problem, SBE HRESET request sent by BMC at IPL time",
                           "moduleid": "MOD_HANDLE_SBE_HRESET_REQUEST",
                           "reasoncode": "RC_NOT_READY",
                           "userdata1":  "HUID of processor",
                           "userdata2":  "ID of PLDM effecter",
                      },
            0x1D4E3a: {    "devdesc": "VPD record data does not match what is in the record meta data",
                           "moduleid": "VPD::VPD_IPVPD_VERIFY_RECORD_IS_VALID",
                           "reasoncode": "VPD::VPD_RECORD_INVALID",
                           "userdata1[00:31]":  "Huid of target",
                           "userdata1[32:47]":  "Record length from record meta data",
                           "userdata1[48:63]":  "Record length + 4 from record itself",
                           "userdata2[00:31]":  "Record name from record meta data",
                           "userdata2[32:63]":  "Record name from record itself",
                      },
            0x90263a: {    "devdesc": "Unable to process the spd ipz template file",
                           "moduleid": "MOD_SPD_TO_IPZ_CONVERT_TEMPLATE",
                           "reasoncode": "RC_SPD_IPZ_TEMPLATE_PROCESS_FAIL",
                           "userdata1":  "resource id of fru",
                           "userdata2":  "total raw spd keyword size",
                           "userdata3":  "spd template size from file.read()",
                           "userdata4":  "spd ipz template data from file.size()",
                      },
            0x90273b: {    "devdesc": "Unable to determine the system type in slot map table area data",
                           "moduleid": "MOD_IOHUB_SYSTEM_TYPE",
                           "reasoncode": "RC_INVALID_SYSTEM_TYPE_SMAREA",
                           "userdata1":  "io hub number",
                           "userdata2":  "dcm number",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0x90283b: {    "devdesc": "Unable to determine the system type in slot map entry info data",
                           "moduleid": "MOD_IOHUB_SYSTEM_TYPE",
                           "reasoncode": "RC_INVALID_SYSTEM_TYPE_SMINFO",
                           "userdata1":  "io hub number",
                           "userdata2":  "dcm number",
                           "userdata3":  "none",
                           "userdata4":  "none",
                      },
            0x17673B: {    "devdesc": "Failed to halt a secondary SBE",
                           "moduleid": "MOD_WAIT_FOR_SBE_ATTN",
                           "reasoncode": "RC_WAIT_ATTN_TIMEOUT",
                           "userdata1[0:31]":  "HUID of proc without SBE attn",
                           "userdata1[32:63]":  "Last response status (bit 30 = SBE Attn bit)",
                           "userdata2":  "Max wait time in ns",
                      },
            0x47253B: {    "devdesc": "Software problem, SBE dump complete notification sent by BMC at runtime",
                           "moduleid": "MOD_HANDLE_SBE_HRESET_REQUEST_RT",
                           "reasoncode": "RC_NOT_READY",
                           "userdata1":  "HUID of processor",
                           "userdata2":  "ID of PLDM effecter",
                      },
            0x17683C: {    "devdesc": "Security Access mismatch",
                           "moduleid": "MOD_CHECK_FOR_SECURITY_ACCESS_MISMATCH",
                           "reasoncode": "RC_SAB_MISMATCH_DETECTED",
                           "userdata1":  "Huid of secondary processor",
                           "userdata2[0:31]":  "Primary processor SAB",
                           "userdata2[32:63]":  "Secondary processor SAB",
                      },
            0x176C3D: {    "devdesc": "FSP must have woken up halted secondary SBE",
                           "moduleid": "ISTEP::MOD_MONITOR_SBE_HALT",
                           "reasoncode": "ISTEP::RC_UNHALTED_SBE",
                           "userdata1":  "SBE processor",
                           "userdata2":  "FSI2PIB.STATUS register",
                      },
            0x470E3D: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_INHIBIT_BMC_RESET_VALUE",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x471A3E: {    "devdesc": "Software problem, could not find reboot count effecter PDR.",
                           "moduleid": "MOD_RESET_REBOOT_COUNT",
                           "reasoncode": "RC_INVALID_EFFECTER_ID",
                           "userdata1":  "The total number of PDRs that PDR Manager is aware of.",
                      },
            0x17623F: {    "devdesc": "Software problem, bad data from BMC",
                           "moduleid": "ISTEP::MOD_BIOS_ATTR_PARSERS",
                           "reasoncode": "ISTEP::RC_INVALID_PAYLOAD_KIND",
                           "userdata1":  "Payload Kind that BMC returned",
                           "userdata2":  "unused",
                      },
            0x176B3F: {    "devdesc": "Software problem, bad data from BMC",
                           "moduleid": "ISTEP::MOD_BIOS_ATTR_PARSERS",
                           "reasoncode": "ISTEP::RC_INVALID_BOOTSIDE",
                           "userdata1":  "Bootside that BMC returned",
                           "userdata2":  "unused",
                      },
            0x17703F: {    "devdesc": "Software problem, user requested frequency is outside the boundary. Requested frequency is from BMC.",
                           "moduleid": "ISTEP::MOD_BIOS_ATTR_PARSERS",
                           "reasoncode": "ISTEP::RC_REQUESTED_FREQ_OUTSIDE_BOUNDARY",
                           "userdata1":  "Requested cap frequency in MHz (hb_cap_freq_mhz_request)",
                           "userdata2[0:31]":  "Minimum frequency in MHz (hb_cap_freq_mhz_min)",
                           "userdata2[32:63]":  "Maximum frequency in MHz (hb_cap_freq_mhz_max)",
                      },
            0x47043F: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_PDR",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x470D3F: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_PDR",
                           "reasoncode": "RC_BAD_TRANSFER_FLAG",
                           "userdata1":  "Actual Transfer Flag",
                           "userdata2":  "Expected Transfer Flag",
                      },
            0x47333F: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_GET_PDR",
                           "reasoncode": "RC_BAD_NEXT_TRANSFER_HANDLE",
                           "userdata1":  "Actual Next Transfer Handle",
                           "userdata2":  "Expected Next Transfer Handle",
                      },
            0x176D40: {    "devdesc": "Software problem, bad data from BMC",
                           "moduleid": "ISTEP::MOD_BIOS_ATTR_SETTERS",
                           "reasoncode": "ISTEP::RC_INVALID_HUGE_PAGE_SIZE",
                           "userdata1":  "Value of ATTR_HUGE_PAGE_SIZE",
                           "userdata2":  "unused",
                      },
            0x1E4140: {    "devdesc": "Master processor target did not have ATTR_GPIO_INFO_PHYS_PRES associated with it",
                           "moduleid": "MOD_DETECT_PHYS_PRES",
                           "reasoncode": "RC_PHYS_PRES_ATTR_NOT_FOUND",
                           "userdata1":  "HUID of Master Processor Target",
                           "userdata2":  "ATTR_GPIO_INFO_PHYS_PRES hash value",
                      },
            0x1E4240: {    "devdesc": "Attempt to close physical presence window did not close the window",
                           "moduleid": "MOD_DETECT_PHYS_PRES",
                           "reasoncode": "RC_PHYS_PRES_WINDOW_NOT_CLOSED",
                           "userdata1":  "HUID of Master Processor Target",
                           "userdata2[0:31]":  "LED Data from PCA9551",
                           "userdata2[32:63]":  "LED Windoow Open LED (aka PIN)",
                      },
            0x1E4440: {    "devdesc": "Physical Presence was Asserted",
                           "moduleid": "MOD_DETECT_PHYS_PRES",
                           "reasoncode": "RC_PHYS_PRES_ASSERTED",
                           "userdata1[0:31]":  "Value of Attribute Requesting an Open Window",
                           "userdata1[32:63]":  "Value of Attribute to Fake Physical Presence Assertion",
                           "userdata2[0:31]":  "Logic of 'is_window_open'",
                           "userdata2[32:63]":  "Logic of 'is_phys_pres_asserted'",
                      },
            0x260740: {    "devdesc": "Software problem, Failed to write bulk power limit attributes",
                           "moduleid": "HTMGT_MOD_MRW_POWER_LIMIT",
                           "reasoncode": "HTMGT_RC_SAVE_TO_ATTRIBUTE_FAIL",
                           "userdata1[00:31]":  "N Bulk power limit",
                           "userdata1[32:63]":  "N+1 Bulk power limit",
                           "userdata2[00:31]":  "Min power cap",
                           "userdata2[32:63]":  "Reserved",
                      },
            0x470440: {    "devdesc": "Bad completion code received for get date/time PLDM operation",
                           "moduleid": "MOD_GET_DATE_TIME",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Completion code",
                      },
            0x176E41: {    "devdesc": "BMC returned less PDRs than previous BMC + HB PDRs",
                           "moduleid": "ISTEP::MOD_FINISH_PDR_EXCHANGE",
                           "reasoncode": "ISTEP::RC_TOO_SMALL_BMC_PDR_COUNT",
                           "userdata1":  "Current BMC PDR count (should includes HB PDRs)",
                           "userdata2[0:31]":  "BMC PDR count before HB pdr exchange",
                           "userdata2[32:63]":  "Hostboot PDR count sent to BMC",
                      },
            0x1E4141: {    "devdesc": "Primary processor target did not have the ATTR_GPIO_INFO_PHYS_PRES attribute associated with it",
                           "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                           "reasoncode": "RC_PHYS_PRES_ATTR_NOT_FOUND",
                           "userdata1":  "HUID of primary processor target",
                           "userdata2":  "ATTR_GPIO_INFO_PHYS_PRES attribute hash value",
                      },
            0x1E4341: {    "devdesc": "Attempt to open physical presence window did not close the window",
                           "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                           "reasoncode": "RC_PHYS_PRES_WINDOW_NOT_OPENED",
                           "userdata1":  "HUID of Master Processor Target",
                           "userdata2[0:31]":  "LED Data from PCA9551",
                           "userdata2[32:63]":  "LED Windoow Open LED (aka PIN)",
                      },
            0x1E4541: {    "devdesc": "Re-IPLing to open a Physical Presence Window",
                           "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                           "reasoncode": "RC_PHYS_PRES_REIPL",
                           "userdata1[0:31]":  "Value of Attribute Requesting an Open Window",
                           "userdata1[32:63]":  "Value of Key Clear Requests",
                           "userdata2[0:31]":  "Value of Attribute Physical Presence Asserted",
                           "userdata2[32:63]":  "Value of Attribute Physical Presence re-IPL",
                      },
            0x1E4741: {    "devdesc": "Found special case of KEY_CLEAR_REQUEST_MFG; No Re-IPL is necessary",
                           "moduleid": "MOD_HANDLE_PHYS_PRES_WINDOW",
                           "reasoncode": "RC_KEY_CLEAR_REQUEST_MFG",
                           "userdata1[0:31]":  "Value of Attribute Requesting an Open Window",
                           "userdata1[32:63]":  "Value of Key Clear Requests",
                           "userdata2[0:31]":  "Value of Attribute Physical Presence Asserted",
                           "userdata2[32:63]":  "Value of Attribute Physical Presence re-IPL",
                      },
            0x260741: {    "devdesc": "Software problem, Failed to write bulk power limit attributes",
                           "moduleid": "HTMGT_MOD_PS_CONFIG_POWER_LIMIT",
                           "reasoncode": "HTMGT_RC_SAVE_TO_ATTRIBUTE_FAIL",
                           "userdata1":  "PS Config Searching for match.",
                           "userdata2":  "index trying to write.",
                      },
            0x264F41: {    "devdesc": "Power Limits failed to find power config in MRW table.",
                           "moduleid": "HTMGT_MOD_PS_CONFIG_POWER_LIMIT",
                           "reasoncode": "HTMGT_RC_MISSING_DATA",
                           "userdata1":  "Power Limits failed to find power config in MRW table.",
                           "userdata2":  "0",
                      },
            0x470741: {    "devdesc": "Software problem, failed msg_sendrecv",
                           "moduleid": "MOD_PLDM_SEND_REQ_RETRY",
                           "reasoncode": "RC_SENDRECV_FAIL",
                           "userdata1":  "Return code returned by msg_sendrecv",
                           "userdata2":  "Header of pldm request",
                      },
            0x473941: {    "devdesc": "Software problem, no PLDM response after multiple retries",
                           "moduleid": "MOD_PLDM_SEND_REQ_RETRY",
                           "reasoncode": "RC_TIMEOUT",
                           "userdata1":  "Header of pldm request",
                           "userdata2":  "Total invalid responses encountered",
                      },
            0x177142: {    "devdesc": "Cannot mix explorer and odyssey ocmbs",
                           "moduleid": "MOD_MSS_ATTR_CLEANUP",
                           "reasoncode": "RC_OCMB_MIXING_RULES_ERROR",
                           "userdata1":  "number of explorer ocmbs",
                           "userdata2":  "number of odyssey ocmbs",
                      },
            0x473B42: {    "devdesc": "Unable to find target in ATTR_PLDM_STATE_QUERY_RECORDS",
                           "moduleid": "MOD_GET_STATE_SENSOR_ID",
                           "reasoncode": "RC_NO_SENSOR",
                           "userdata1":  "target huid",
                           "userdata2":  "total records",
                      },
            0x61543: {    "devdesc": "SfcIBM::pollOpComplete> Error or timeout from SFC Status Register",
                           "moduleid": "PNOR::MOD_SFCIBM_POLLOPCOMPLETE",
                           "reasoncode": "PNOR::RC_SFC_TIMEOUT",
                           "userdata1[0:31]":  "NOR Flash Chip ID",
                           "userdata1[32:63]":  "Total poll time (ns)",
                           "userdata2[0:31]":  "SFC Status Register",
                      },
            0x470E43: {    "devdesc": "Unsupported entity type for connector type.  Possible BMC normalization failure.",
                           "moduleid": "MOD_UPDATE_CONNECTOR_INFO_ATTR",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "The child Target HUID",
                           "userdata2":  "Entity type",
                      },
            0x471343: {    "devdesc": "Only one association record should be found.",
                           "moduleid": "MOD_UPDATE_CONNECTOR_INFO_ATTR",
                           "reasoncode": "RC_INVALID_RECORD_COUNT",
                           "userdata1":  "The child Target HUID",
                           "userdata2[0:31]":  "container_id searched",
                           "userdata2[32:63]":  "Number of association records found matching container_id",
                      },
            0x473C43: {    "devdesc": "Connection entity instance number not in sync with child value",
                           "moduleid": "MOD_UPDATE_CONNECTOR_INFO_ATTR",
                           "reasoncode": "RC_MISMATCHED_ENTITY_INSTANCE",
                           "userdata1":  "The child Target HUID",
                           "userdata2[0:31]":  "Parent connector entity instance number",
                           "userdata2[32:63]":  "Expected child entity instance number",
                      },
            0x473544: {    "devdesc": "Since HB failed to init PLDM error logs will not make it to BMC. Shutting down and forcing BMC to dump HB",
                           "moduleid": "MOD_BASE_INIT",
                           "reasoncode": "RC_BASE_INIT_FAIL",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x60245: {    "devdesc": "PnorDD::eraseFlash> Address not on erase boundary",
                           "moduleid": "PNOR::MOD_SFCIBM_ERASEFLASH",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1":  "Flash address being erased",
                           "userdata2":  "Nearest Erase Boundary",
                      },
            0x470E45: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_LATERAL_CAST_OUT_MODE",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x61046: {    "devdesc": "SfcIBM::checkForErrors> Error(s) found in SFC and/or LPC Slave Status Registers",
                           "moduleid": "PNOR::MOD_SFCIBM_CHECKFORERRORS",
                           "reasoncode": "PNOR::RC_ERROR_IN_STATUS_REG",
                           "userdata1[0:31]":  "SFC Status Register",
                           "userdata1[32:63]":  "LPC Slave Status Register",
                           "userdata2":  "Reset Level",
                      },
            0x473E46: {    "devdesc": "Unable to set PLDM shutdown effecter for graceful shutdown.",
                           "moduleid": "MOD_WAIT_HOST_INITIATED_SHUTDOWN",
                           "reasoncode": "RC_REQ_FAILED_SHUTDOWN",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x60747: {    "devdesc": "SfcIBM::hwReset> Unsupported Reset Level requested",
                           "moduleid": "PNOR::MOD_SFCIBM_HWRESET",
                           "reasoncode": "PNOR::RC_UNSUPPORTED_OPERATION",
                           "userdata1":  "Unsupported Reset Level Parameter",
                           "userdata2":  "<unused>",
                      },
            0x473E47: {    "devdesc": "Unable to send PLDM graceful shutdown notification event.",
                           "moduleid": "MOD_WAIT_BMC_INITIATED_SHUTDOWN",
                           "reasoncode": "RC_REQ_FAILED_SHUTDOWN",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x473D48: {    "devdesc": "Received a getPLDMVersion request which indicates PLDM daemon restarted/reloaded",
                           "moduleid": "MOD_GET_PLDM_VERSION_REQ",
                           "reasoncode": "RC_RESET_DETECTED_SHUTDOWN",
                           "userdata1":  "unused",
                           "userdata2":  "unused",
                      },
            0x470549: {    "devdesc": "PLDM Response from BMC is too small.",
                           "moduleid": "MOD_MAKE_PLDM_REQUEST_RUNTIME",
                           "reasoncode": "RC_INVALID_LENGTH",
                           "userdata1":  "Actual Response Length",
                           "userdata2":  "Header of original pldm request",
                      },
            0x470849: {    "devdesc": "Software problem, failed to decode PLDM message",
                           "moduleid": "MOD_MAKE_PLDM_REQUEST_RUNTIME",
                           "reasoncode": "RC_SEND_FAIL",
                           "userdata1":  "Return code returned by MCTP::send_message",
                           "userdata2":  "Header of pldm request",
                      },
            0x471F49: {    "devdesc": "Software problem, failed to get next PLDM message",
                           "moduleid": "MOD_MAKE_PLDM_REQUEST_RUNTIME",
                           "reasoncode": "RC_RECV_FAIL",
                           "userdata1":  "Return code returned by MCTP::get_next_packet",
                           "userdata2":  "Header of pldm request",
                      },
            0x47284A: {    "devdesc": "Could not find Terminus Locator PDR in the PDR repo",
                           "moduleid": "MOD_CHECK_FOR_HB_TERMINUS_LOCATOR",
                           "reasoncode": "RC_TERM_LOCATOR_NOT_FOUND",
                           "userdata1":  "Count of BMC/HB PDRs",
                           "userdata2":  "Count of HB PDRs",
                      },
            0x470E4B: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "MOD_GET_PROC_FAVOR_AGGRESSIVE_PREFETCH",
                           "reasoncode": "RC_UNSUPPORTED_TYPE",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x47264C: {    "devdesc": "Software problem, Invalid power supply model found",
                           "moduleid": "MOD_GET_POWER_SUPPLY_CONFIG",
                           "reasoncode": "RC_UNSUPPORTED_STRING_TYPE",
                           "userdata1":  "Expected String Type",
                           "userdata2":  "Returned String Type",
                      },
            0x47424C: {    "devdesc": "Software problem, PS input Voltage Data from BMC not found.",
                           "moduleid": "MOD_GET_POWER_SUPPLY_CONFIG",
                           "reasoncode": "RC_PS_INPUT_VOLTAGE_NOT_FOUND",
                           "userdata1":  "Unused",
                           "userdata2":  "Unused",
                      },
            0x47434D: {    "devdesc": "Possible issue with retrieving PLDM file",
                           "moduleid": "MOD_APPEND_KEYWORDS",
                           "reasoncode": "RC_FILE_IO_PROBLEM",
                           "userdata1":  "i_record_name",
                           "userdata2":  "special_keyword",
                      },
            0x47044E: {    "devdesc": "Software problem, bad PLDM response from BMC",
                           "moduleid": "MOD_SEND_GET_NUMERIC_EFFECTER_VALUE_REQUEST",
                           "reasoncode": "RC_BAD_COMPLETION_CODE",
                           "userdata1":  "Actual Completion Code",
                           "userdata2":  "Expected Completion Code",
                      },
            0x1D3650: {    "devdesc": "presenceDetect> Invalid data length (!= 1 bytes)",
                           "moduleid": "VPD::VPD_PVPD_PRESENCEDETECT",
                           "reasoncode": "VPD::VPD_INVALID_LENGTH",
                           "userdata1":  "Data Length",
                      },
            0x60261: {    "devdesc": "SfcFake::readFlash> Requested access exceeded the bounds of the allocated PNOR space",
                           "moduleid": "PNOR::MOD_SFCFAKE_READFLASH",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1[0:31]":  "PNOR Address",
                           "userdata1[32:63]":  "Bytes to read",
                           "userdata2[0:31]":  "<unused>",
                           "userdata2[32:63]":  "Size of allocated PNOR space",
                      },
            0x1D0761: {    "devdesc": "Invalid Basic Memory Type",
                           "moduleid": "VPD::VPD_SPD_GET_KEYWORD_VALUE",
                           "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                           "userdata1":  "Basic Memory Type (Byte 2)",
                           "userdata2":  "Keyword Requested",
                      },
            0x60262: {    "devdesc": "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space",
                           "moduleid": "PNOR::MOD_SFCFAKE_WRITEFLASH",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1[0:31]":  "PNOR Address",
                           "userdata1[32:63]":  "Bytes to write",
                           "userdata2[0:31]":  "<unused>",
                           "userdata2[32:63]":  "Size of allocated PNOR space",
                      },
            0x1D1462: {    "devdesc": "The table entry associated with keyword was NULL.",
                           "moduleid": "VPD::VPD_SPD_GET_VALUE",
                           "reasoncode": "VPD::VPD_NULL_ENTRY",
                           "userdata1":  "SPD Keyword",
                           "userdata2[0:31]":  "Buffer Size",
                           "userdata2[32:63]":  "Memory Type",
                      },
            0x60263: {    "devdesc": "SfcFake::writeFlash> Requested access exceeded the bounds of the allocated PNOR space",
                           "moduleid": "PNOR::MOD_SFCFAKE_ERASEFLASH",
                           "reasoncode": "PNOR::RC_INVALID_ADDRESS",
                           "userdata1[0:31]":  "PNOR Address",
                           "userdata1[32:63]":  "<unused>",
                           "userdata2[0:31]":  "Bytes in erase block",
                           "userdata2[32:63]":  "Size of allocated PNOR space",
                      },
            0x1D0663: {    "devdesc": "Buffer Size provided was not big enough for the keyword requested.",
                           "moduleid": "VPD::VPD_SPD_CHECK_SIZE",
                           "reasoncode": "VPD::VPD_INSUFFICIENT_BUFFER_SIZE",
                           "userdata1":  "Keyword",
                           "userdata2[0:31]":  "Needed Buffer Size",
                           "userdata2[32:63]":  "Expected Buffer Size",
                      },
            0x60764: {    "devdesc": "SfcFake::sendSpiCmd> Function is not supported",
                           "moduleid": "PNOR::MOD_SFCFAKE_SENDSPICMD",
                           "reasoncode": "PNOR::RC_UNSUPPORTED_OPERATION",
                           "userdata1[0:31]":  "Op Code",
                           "userdata1[32:63]":  "Address",
                           "userdata2":  "<unused>",
                      },
            0x1D0765: {    "devdesc": "Invalid Basic Memory Type",
                           "moduleid": "VPD::VPD_SPD_WRITE_KEYWORD_VALUE",
                           "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                           "userdata1":  "Basic Memory Type (Byte 2)",
                           "userdata2":  "Keyword Requested",
                      },
            0x1D0766: {    "devdesc": "Invalid DDR Revision",
                           "moduleid": "VPD::VPD_SPD_SPECIAL_CASES",
                           "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                           "userdata1":  "SPD Keyword",
                           "userdata2[00:31]":  "Target HUID",
                           "userdata2[32:63]":  "DIMM DDR Revision",
                      },
            0x1D0967: {    "devdesc": "Keyword is not a special case keyword.",
                           "moduleid": "VPD::VPD_SPD_DDR3_SPECIAL_CASES",
                           "reasoncode": "VPD::VPD_INVALID_SPD_KEYWORD",
                           "userdata1":  "SPD Keyword",
                           "userdata2":  "UNUSED",
                      },
            0x1D0968: {    "devdesc": "Keyword is not a special case keyword.",
                           "moduleid": "VPD::VPD_SPD_DDR4_SPECIAL_CASES",
                           "reasoncode": "VPD::VPD_INVALID_SPD_KEYWORD",
                           "userdata1":  "SPD Keyword",
                           "userdata2":  "UNUSED",
                      },
            0x1D0669: {    "devdesc": "Buffer for checking Presence Detect was not the correct size.",
                           "moduleid": "VPD::VPD_SPD_PRESENCE_DETECT",
                           "reasoncode": "VPD::VPD_INSUFFICIENT_BUFFER_SIZE",
                           "userdata1":  "Buffer Length",
                           "userdata2":  "<UNUSED>",
                      },
            0x1D5169: {    "devdesc": "Primary eeprom has invalid data, running on backup eeprom",
                           "moduleid": "VPD::VPD_SPD_PRESENCE_DETECT",
                           "reasoncode": "VPD::VPD_SPD_INVALID_PRIMARY_VPD",
                           "userdata1":  "target huid",
                           "userdata2":  "invalid memory type",
                      },
            0x1D5369: {    "devdesc": "Unsupported FRU part number",
                           "moduleid": "VPD::VPD_SPD_PRESENCE_DETECT",
                           "reasoncode": "VPD::VPD_ISDIMM_UNSUPPORTED_PN_FOR_FN",
                           "userdata1[00:31]":  "TCK_MIN",
                           "userdata1[32:63]":  "target huid",
                           "userdata2":  "partNumber",
                      },
            0x1D5469: {    "devdesc": "Unsupported FRU part number",
                           "moduleid": "VPD::VPD_SPD_PRESENCE_DETECT",
                           "reasoncode": "VPD::VPD_ISDIMM_UNSUPPORTED_PN_FOR_CCIN",
                           "userdata1":  "target huid",
                           "userdata2":  "partNumber",
                      },
            0x1D5769: {    "devdesc": "Unsupported FRU number",
                           "moduleid": "VPD::VPD_SPD_PRESENCE_DETECT",
                           "reasoncode": "VPD::VPD_ISDIMM_UNSUPPORTED_FN_FOR_CCIN",
                           "userdata1":  "target huid",
                           "userdata2":  "fruNumber (ASCII)",
                      },
            0x1D116A: {    "devdesc": "Unsupported Module Type.",
                           "moduleid": "VPD::VPD_SPD_CHECK_MODULE_SPECIFIC_KEYWORD",
                           "reasoncode": "VPD::VPD_MOD_SPECIFIC_UNSUPPORTED",
                           "userdata1[00:15]":  "Memory Module Type",
                           "userdata1[16:31]":  "Memory Type (byte 2)",
                           "userdata1[32:47]":  "SPD Keyword",
                           "userdata1[48:63]":  "Module Specific Flag",
                           "userdata2":  "Target HUID",
                      },
            0x1D0B6B: {    "devdesc": "The SPD Keyword is not writable.",
                           "moduleid": "VPD::VPD_SPD_WRITE_VALUE",
                           "reasoncode": "VPD::VPD_KEYWORD_NOT_WRITABLE",
                           "userdata1":  "SPD Keyword",
                           "userdata2[0:31]":  "Buffer Length",
                           "userdata2[32:63]":  "Memory Type",
                      },
            0x1D146B: {    "devdesc": "The table entry associated with keyword was NULL.",
                           "moduleid": "VPD::VPD_SPD_WRITE_VALUE",
                           "reasoncode": "VPD::VPD_NULL_ENTRY",
                           "userdata1":  "SPD Keyword",
                           "userdata2[0:31]":  "Buffer Length",
                           "userdata2[32:63]":  "Memory Type",
                      },
            0x1D156B: {    "devdesc": "Writes to non-byte SPD keywords are unsupported.",
                           "moduleid": "VPD::VPD_SPD_WRITE_VALUE",
                           "reasoncode": "VPD::VPD_UNSUPPORTED_WRITE",
                           "userdata1":  "SPD Keyword",
                           "userdata2[0:15]":  "Keyword Length (in bytes)",
                           "userdata2[16:31]":  "Keyword Bitmask",
                           "userdata2[32:63]":  "Memory Type",
                      },
            0x1D046C: {    "devdesc": "Invalid SPD Keyword",
                           "moduleid": "VPD::VPD_SPD_GET_KEYWORD_ENTRY",
                           "reasoncode": "VPD::VPD_KEYWORD_NOT_FOUND",
                           "userdata1[00:31]":  "Module type",
                           "userdata1[32:63]":  "SPD Keyword",
                           "userdata2[00:31]":  "Mem type",
                           "userdata2[32:63]":  "target HUID reading the SPD for",
                      },
            0x1D076C: {    "devdesc": "Invalid DDR Revision",
                           "moduleid": "VPD::VPD_SPD_GET_KEYWORD_ENTRY",
                           "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                           "userdata1[00:31]":  "Module type",
                           "userdata1[32:63]":  "SPD Keyword",
                           "userdata2[00:31]":  "Target HUID",
                           "userdata2[32:63]":  "DDR Revision",
                      },
            0x1D116E: {    "devdesc": "Unrecognized Module Type.",
                           "moduleid": "VPD::VPD_SPD_GET_MOD_TYPE",
                           "reasoncode": "VPD::VPD_MOD_SPECIFIC_UNSUPPORTED",
                           "userdata1[00:31]":  "Module Type (byte 3[3:0])",
                           "userdata1[32:63]":  "Memory Type (byte 2)",
                           "userdata2":  "Target HUID",
                      },
            0x1D316F: {    "devdesc": "Unable to resolve the VPD source (PNOR or SEEPROM)",
                           "moduleid": "VPD::VPD_SPD_FETCH_DATA",
                           "reasoncode": "VPD::VPD_READ_SOURCE_UNRESOLVED",
                           "userdata1[0:31]":  "Target HUID",
                           "userdata1[32:63]":  "Requested VPD Source Location",
                           "userdata2[0:31]":  "SPD read PNOR flag",
                           "userdata2[32:63]":  "SPD read HW flag",
                      },
            0x1D0770: {    "devdesc": "Invalid DDR Revision",
                           "moduleid": "VPD::VPD_SPD_SET_DIMM_SIZE",
                           "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                           "userdata1":  "HUID to DIMM target",
                           "userdata2":  "The DDR Revision",
                      },
            0x1D5271: {    "devdesc": "An unexpected value for a DDIMM's height likely means that this func needs to account for a new valid value, and should be updated. However there is a small chance that the SPD byte holding the height value is corrupted. In the case that this target does have a redundant eeprom, we will leave the attr value as POSSIBLE so that writes will still be attempted to the backup",
                           "moduleid": "VPD::VPD_SPD_EEPROM_REDUNDANCY",
                           "reasoncode": "VPD::VPD_SPD_UNEXPECTED_DDIMM_HEIGHT",
                           "userdata1":  "HUID of DIMM target",
                           "userdata2":  "Unexpected DDIMM Module Height",
                      },
            0x260C76: {    "devdesc": "Invalid OCC present data in POLL response",
                           "moduleid": "HTMGT_MOD_OCC_POLL",
                           "reasoncode": "HTMGT_RC_DUPLICATE_CHIP_ID",
                           "userdata1[0:15]":  "OCC instance",
                           "userdata1[16:31]":  "response OCC present",
                           "userdata2[0:15]":  "duplicate OCC instance",
                           "userdata2[16:31]":  "response status byte",
                      },
            0x261C76: {    "devdesc": "Invalid POLL response length",
                           "moduleid": "HTMGT_MOD_OCC_POLL",
                           "reasoncode": "HTMGT_RC_INVALID_LENGTH",
                           "userdata1":  "OCC instance",
                      },
            0x262276: {    "devdesc": "Invalid role is POLL response",
                           "moduleid": "HTMGT_MOD_OCC_POLL",
                           "reasoncode": "HTMGT_RC_INVALID_ROLE",
                           "userdata1[0:15]":  "OCC instance",
                           "userdata[16:31]":  "response state",
                           "userdata2[0:15]":  "expected role",
                           "userdata2[16:31]":  "response status byte",
                      },
            0x61480: {    "devdesc": "SfcAST2X00::enableWriteMode> Unable to enable write mode on the PNOR flash",
                           "moduleid": "PNOR::MOD_SFCAST2X00_ENABLEWRITEMODE",
                           "reasoncode": "PNOR::RC_CANNOT_ENABLE_WRITES",
                           "userdata1[24:31]":  "Output from RDSR",
                           "userdata1[32:63]":  "NOR chip id",
                           "userdata2":  "<unused>",
                      },
            0xB8080: {    "devdesc": "The caller passed an invalid node target to find the master proc handle.",
                           "moduleid": "TARG_MOD_QUERY_MASTER_PROC_CHIP",
                           "reasoncode": "TARG_RC_INVALID_NODE",
                           "userData1":  "HUID of Target Passed",
                      },
            0xB8180: {    "devdesc": "The caller passed an invalid node target to find the master proc handle",
                           "moduleid": "TARG_MOD_QUERY_MASTER_PROC_CHIP",
                           "reasoncode": "TARG_RC_TARGET_NOT_FOUND",
                           "userData1":  "HUID of Target Passed",
                      },
            0xB8081: {    "devdesc": "The caller passed an invalid node target.",
                           "moduleid": "TARG_MOD_SET_MASTER_NODE",
                           "reasoncode": "TARG_RC_INVALID_NODE",
                           "userData1":  "HUID of Target Passed",
                      },
            0xC8181: {    "devdesc": "Attempt to create a GARD Record for a target that is not DECONFIG_GARDABLE",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_TARGET_NOT_GARDABLE",
                           "userdata1":  "HUID of input target // GARD errlog EID",
                           "userdata2":  "ATTR_DECONFIG_GARDABLE // ATTR_HWAS_STATE.present",
                      },
            0xC8281: {    "devdesc": "Attempt to create a GARD Record and the GARD Repository is full",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_GARD_REPOSITORY_FULL",
                           "userdata1[00:31]":  "HUID of input target",
                           "userdata1[32:63]":  "GARD errlog EID",
                           "userdata2[00:31]":  "iv_nextGardRecordId",
                           "userdata2[32:63]":  "iv_maxGardRecords",
                      },
            0xC8681: {    "devdesc": "Post de-configuration of target failed",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_RT_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "none",
                      },
            0xC8781: {    "devdesc": "Post de-configuration of target failed",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_RT_NULL_FIRMWARE_MSG_PTR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "none",
                      },
            0xC8981: {    "devdesc": "Problem clearing and reset of version",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_BAD_CLEAR_ALL_RESET_VERSION",
                           "userdata1":  "none",
                           "userdata2":  "none",
                      },
            0xC8A81: {    "devdesc": "No PART NUMBER attribute found on the requested FRU target",
                           "moduleid": "MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "RC_NO_FRU_PART_NUM",
                           "userdata1":  "HUID of original input target // GARD errlog EID",
                           "userdata2":  "HUID of FRU target",
                      },
            0xC8B81: {    "devdesc": "No SERIAL NUMBER attribute found on the requested FRU target",
                           "moduleid": "MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "RC_NO_FRU_SERIAL_NUM",
                           "userdata1":  "HUID of original input target // GARD errlog EID",
                           "userdata2":  "HUID of FRU target",
                      },
            0xC8C81: {    "devdesc": "No FRU parent target found for PN or SN",
                           "moduleid": "MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "RC_NO_FRU_TARGET",
                           "userdata1":  "HUID of original input target // GARD errlog EID",
                      },
            0xC8D81: {    "devdesc": "Not the CURRENT GARD VERSION LAYOUT, NEED INVESTIGATION",
                           "moduleid": "MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "RC_NOT_CURRENT_GARD_VERSION",
                           "userdata1":  "GARD errlog EID",
                      },
            0xC8E81: {    "devdesc": "Cleaning old gard records",
                           "moduleid": "MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "RC_CLEAN_GARD_RECORDS",
                           "userdata1":  "iv_version read from BINARY",
                           "userdata2":  "current iv_version expected",
                      },
            0xC9181: {    "devdesc": "Problem flushing GUARD data to PNOR",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_PNOR_ACCESS_FAILED",
                           "userdata1[0:31]":  "Return code from mm_remove_pages",
                           "userdata2[32:63]":  "Number of bytes to flush",
                           "userdata2":  "PNOR address to flush",
                      },
            0xC9281: {    "devdesc": "Detected corruption in the GUARD partition during HBRT start.  No guard records will be created.",
                           "moduleid": "HWAS::MOD_PLAT_DECONFIG_GARD",
                           "reasoncode": "HWAS::RC_RT_POSSIBLE_PNOR_CORRUPTION",
                           "userdata1":  "The flags byte of the GUARD PNOR partition header",
                           "userdata2":  "none",
                      },
            0xB0282: {    "devdesc": "The eyecatch value observed in memory does not match the expected value of PNOR_TARG_EYE_CATCHER and therefore the contents of the Attribute sections are unable to be parsed.",
                           "moduleid": "TARG_MOD_ATTRRP_RT",
                           "reasoncode": "TARG_RC_BAD_EYECATCH",
                           "userdata1":  "Observed Header Eyecatch Value",
                           "userdata2":  "Memory address referenced.",
                      },
            0xB8A82: {    "devdesc": "Expected node is not present in ATTR_HB_EXISTING_IMAGE",
                           "moduleid": "TARG_MOD_ATTRRP_RT",
                           "reasoncode": "TARG_RT_NODE_NOT_IN_IMAGE",
                           "userdata1[00:31]":  "Node",
                           "userdata1[32:64]":  "HB Existing Image",
                           "userdata2":  "Memory address referenced.",
                      },
            0xC8382: {    "devdesc": "platReadIDEC> Invalid chipid from hardware (all FFs)",
                           "moduleid": "HWAS::MOD_PLAT_READIDEC",
                           "reasoncode": "HWAS::RC_BAD_CHIPID",
                           "userdata1":  "Target HUID",
                           "userdata2":  "<unused>",
                      },
            0x1D1b82: {    "devdesc": "Reserved size in memory insufficient for runtime VPD",
                           "moduleid": "VPD::VPD_BLD_RT_IMAGE",
                           "reasoncode": "VPD::VPD_INSUFFICIENT_SPACE_FOR_IMAGE",
                           "userdata1":  "Size provided",
                           "userdata2":  "vpd_type | Size required",
                      },
            0x61583: {    "devdesc": "SfcAST2X00::pollOpComplete> Timeout during write or erase operation",
                           "moduleid": "PNOR::MOD_SFCAST2X00_POLLOPCOMPLETE",
                           "reasoncode": "PNOR::RC_SFC_TIMEOUT",
                           "userdata1[0:31]":  "NOR Flash Chip ID",
                           "userdata1[32:63]":  "Total poll time (ns)",
                           "userdata2[56:63]":  "Output of RDSR command",
                      },
            0xB8283: {    "devdesc": "Size of override data exceeds available buffer space",
                           "moduleid": "TARG_MOD_SAVE_OVERRIDE_TANK",
                           "reasoncode": "TARG_SPACE_OVERRUN",
                           "userdata1[00:31]":  "Maximum Available size",
                           "userdata1[32:63]":  "Required size",
                           "userdata2[00:31]":  "Chunk Size",
                           "userdata2[32:63]":  "Previous Size",
                      },
            0xC8483: {    "devdesc": "platReadLx> Invalid Lx keyword",
                           "moduleid": "HWAS::MOD_PLAT_READLX",
                           "reasoncode": "HWAS::RC_BAD_LX",
                           "userdata1":  "Target MCA HUID",
                           "userdata2":  "Value of x for Lx keyword",
                      },
            0xC8583: {    "devdesc": "platReadLx> Bad MCA target",
                           "moduleid": "HWAS::MOD_PLAT_READLX",
                           "reasoncode": "HWAS::RC_BAD_MCA",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x1D3783: {    "devdesc": "MBOX send not supported in HBRT",
                           "moduleid": "VPD_SEND_MBOX_WRITE_MESSAGE",
                           "reasoncode": "VPD_RT_NULL_FIRMWARE_REQUEST_PTR",
                           "userdata1":  "HUID of target",
                           "userdata2":  "VPD message type",
                      },
            0x1D3d83: {    "devdesc": "Could not determine which node the target is in",
                           "moduleid": "VPD_SEND_MBOX_WRITE_MESSAGE",
                           "reasoncode": "VPD_FAILED_TO_RESOLVE_NODE_TARGET",
                           "userdata1":  "HUID of target to update VPD for",
                           "userdata2":  "VPD message type",
                      },
            0xB8284: {    "devdesc": "Size of attribute data exceeds available buffer space",
                           "moduleid": "TARG_MOD_SAVE_ATTR_TANK",
                           "reasoncode": "TARG_SPACE_OVERRUN",
                           "userdata1":  "Maximum Available size",
                           "userdata2":  "Required size",
                      },
            0xC8884: {    "devdesc": "Hostboot running on proc with only NVDIMMs",
                           "moduleid": "HWAS::MOD_CHECK_HB_NVDIMM",
                           "reasoncode": "HWAS::RC_HB_PROC_ONLY_NVDIMM",
                           "userdata1":  "Hostboot Proc Target HUID",
                           "userdata2":  "Hostboot Memory Group",
                      },
            0xB8885: {    "devdesc": "There is a mismatch with the sizes of the lid and/or reserved memory section",
                           "moduleid": "TARGETING::TARG_RT_HBRT_UPDATE_PREP",
                           "reasoncode": "TARGETING::TARG_RT_BAD_ATTR_SIZES",
                           "userdata1[00:31]":  "Lid size",
                           "userdata1[32:63]":  "Attribute size in lid",
                           "userdata2[00:31]":  "Reserved mem size",
                           "userdata2[32:63]":  "unused",
                      },
            0xC8F85: {    "devdesc": "Hostboot detected a part that the service processor did not.",
                           "moduleid": "MOD_CROSSCHECK_SP_PRESENCE",
                           "reasoncode": "RC_PRESENCE_MISMATCH_SP",
                           "userdata1":  "HUID of missing target",
                      },
            0xC9085: {    "devdesc": "Hostboot did not detect a part that the service processor found.",
                           "moduleid": "MOD_CROSSCHECK_SP_PRESENCE",
                           "reasoncode": "RC_PRESENCE_MISMATCH_HB",
                           "userdata1":  "HUID of missing target",
                      },
            0xB8386: {    "devdesc": "Bad eyecatcher in the new lid data",
                           "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                           "reasoncode": "TARGETING::TARG_RT_BAD_EYECATCHER_LID",
                           "userdata1":  "Eyecatcher from LID",
                           "userdata2":  "Expected eyecatcher",
                      },
            0xB8486: {    "devdesc": "Bad eyecatcher in the existing attribute data",
                           "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                           "reasoncode": "TARGETING::TARG_RT_BAD_EYECATCHER_MEM",
                           "userdata1":  "Eyecatcher from existing memory",
                           "userdata2":  "Expected eyecatcher",
                      },
            0xB8586: {    "devdesc": "Section number mismatch between new and old data",
                           "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                           "reasoncode": "TARGETING::TARG_RT_SECTION_NUM_MISMATCH",
                           "userdata1":  "Number of sections in lid",
                           "userdata2":  "Number of sections in existing mem",
                      },
            0xB8686: {    "devdesc": "Section number mismatch between new and old data",
                           "moduleid": "TARGETING::TARG_RT_VALIDATEDATA",
                           "reasoncode": "TARGETING::TARG_RT_SECTION_MISMATCH",
                           "userdata1":  "Section number",
                           "userdata2[00:31]":  "Section type in the lid",
                           "userdata2[32:63]":  "Section type in the memory",
                      },
            0xC9386: {    "devdesc": "CRCs mismatch between EEPROMs",
                           "moduleid": "HWAS::MOD_PLAT_CHECK_OCMB_CRC",
                           "reasoncode": "HWAS::RC_CRC_MISMATCH_FOUND",
                           "userdata1":  "Hostboot OCMB Target HUID",
                           "userdata2":  "First mismatch (start, primary CRC, backup CRC, total primary sections, total backup sections)",
                      },
            0xB8787: {    "devdesc": "Could not find attribute data in lid",
                           "moduleid": "TARGETING::TARG_RT_SAVERESTOREATTRS",
                           "reasoncode": "TARGETING::TARG_RT_MISSING_ATTR",
                           "userdata1":  "Attribute Id",
                           "userdata2":  "HUID of target",
                      },
            0x1D4987: {    "devdesc": "Skipping VPD override because of secureboot enablement",
                           "moduleid": "VPD_RT_OVERRIDE",
                           "reasoncode": "VPD_OVERRIDE_NOT_ALLOWED",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0x1D4A87: {    "devdesc": "the incoming request is too small",
                           "moduleid": "VPD_RT_OVERRIDE",
                           "reasoncode": "VPD_SHORT_REQUEST",
                           "userdata1[0:31]":  "size of the incoming request",
                           "userdata1[32:63]":  "minimum request size",
                           "userdata2":  "huid of the target",
                      },
            0x1D4D87: {    "devdesc": "invalid data section/write method enum was passed",
                           "moduleid": "VPD_RT_OVERRIDE",
                           "reasoncode": "VPD_INVALID_METHOD_OR_DATA_SECTION",
                           "userdata1":  "the invalid value for the method and data section to write to",
                           "userdata2":  "unused",
                      },
            0xB8988: {    "devdesc": "For some reason attr IDs in hbMutexAttrIds list are not matching the attribute IDs that target service is seeing. This is causing incorrect matching. Make sure mutexattribute.H in genfiles has good values",
                           "moduleid": "TARG_SVC_RESET_MUTEX",
                           "reasoncode": "TARG_SVC_MISSING_ATTR",
                           "userdata1":  "Attribute Id we attempted to read",
                           "userdata2":  "Huid of target we attempted to read",
                      },
            0x1D4B88: {    "devdesc": "writing to non PROC targets is not supported",
                           "moduleid": "VPD_RT_OVERRIDE_MVPD_REC_KEY",
                           "reasoncode": "VPD_TARGET_NOT_TYPE_PROC",
                           "userdata1":  "HUID of the target",
                           "userdata2":  "ATTR_TYPE of the target",
                      },
            0xB8089: {    "devdesc": "Invalid Node ID was returned for the passed target",
                           "moduleid": "TARG_MOD_ATTRRP_TO_COMMON_ADDR",
                           "reasoncode": "TARG_RC_INVALID_NODE",
                           "userdata1":  "Target's HUID",
                           "userdata2":  "Node ID",
                      },
            0x1D4B89: {    "devdesc": "writing to the MVPD of a non-PROC target is not supported",
                           "moduleid": "VPD_RT_OVERRIDE_MVPD_OFFSET",
                           "reasoncode": "VPD_TARGET_NOT_TYPE_PROC",
                           "userdata1":  "HUID of the target",
                           "userdata2":  "unused",
                      },
            0x1D4C89: {    "devdesc": "Number of bytes to write != data size bytes",
                           "moduleid": "VPD_RT_OVERRIDE_MVPD_OFFSET",
                           "reasoncode": "VPD_BYTES_TO_WRITE_MISMATCH",
                           "userdata1":  "number of bytes to write specified by caller",
                           "userdata2":  "size in bytes of the data to write",
                      },
            0xB8B8A: {    "devdesc": "Error: Failed to translate common association address to platform address",
                           "moduleid": "TARG_MOD_CLR_ASSOCS_FROM_SYS_OR_NODE_TARGET",
                           "reasoncode": "TARG_RC_FAILED_TO_XLATE_ADDR",
                           "userdata1":  "Address prior to translation",
                           "userdata2":  "Target's HUID",
                           "userdata3":  "Target's address",
                      },
            0xB8B8B: {    "devdesc": "Error: Failed to translate common association address to platform address",
                           "moduleid": "TARG_MOD_ADD_ASSOC_TO_SYS_OR_NODE_TARGET",
                           "reasoncode": "TARG_RC_FAILED_TO_XLATE_ADDR",
                           "userdata1":  "Address prior to translation",
                           "userdata2":  "Target's HUID",
                           "userdata3":  "Target's address",
                      },
            0xB8C8B: {    "devdesc": "Error: No free association entry to set",
                           "moduleid": "TARG_MOD_ADD_ASSOC_TO_SYS_OR_NODE_TARGET",
                           "reasoncode": "TARG_RC_EXCEEDED_ENTRY_LIMIT",
                           "userdata1":  "Index into association array",
                           "userdata2":  "Maximum association entries",
                           "userdata3":  "Association type",
                           "userdata4":  "HUID of target to modify",
                      },
            0x26338B: {    "devdesc": "Unsupported ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE type",
                           "moduleid": "HTMGT_MOD_OCMB_INIT",
                           "reasoncode": "HTMGT_RC_INVALID_MEM_SENSOR",
                           "userdata1":  "USAGE type",
                           "userdata2":  "OCMB HUID",
                      },
            0x26548B: {    "devdesc": "Failed to find OMI target for OCMB",
                           "moduleid": "HTMGT_MOD_OCMB_INIT",
                           "reasoncode": "HTMGT_RC_TARGET_NOT_FOUND",
                           "userdata1":  "OCC Instance",
                           "userdata2":  "OCMB HUID",
                      },
            0xB818C: {    "devdesc": "Error: Failed to find master system target",
                           "moduleid": "TARG_MOD_RECONNECT_SYS_AND_NODE_TARGETS",
                           "reasoncode": "TARG_RC_TARGET_NOT_FOUND",
                      },
            0x26338C: {    "devdesc": "Unsupported MEM_EFF_THERM_SENSOR type",
                           "moduleid": "HTMGT_MOD_CONVERT_TEMP_TYPE",
                           "reasoncode": "HTMGT_RC_INVALID_MEM_SENSOR",
                           "userdata1":  "USAGE type",
                           "userdata2":  "0",
                      },
            0xB8E8D: {    "devdesc": "Could not find attribute to override",
                           "moduleid": "TARG_MOD_ATTR_ENUM_DATA_FROM_MAP",
                           "reasoncode": "TARG_RC_ATTR_NOT_FOUND",
                           "userdata1":  "Target ascii string",
                           "userdata2":  "Target ascii string continued",
                      },
            0x26068D: {    "devdesc": "Failed to read MEM_EFF_THERM_SENSOR_DIFF_USAGE",
                           "moduleid": "HTMGT_MOD_ADD_OBMC_INTERNAL_DTS",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "OCMB number",
                           "userdata2":  "chip ID",
                      },
            0x26338D: {    "devdesc": "Unsupported ATTR_MEM_EFF_THERM_SENSOR_DIFF_USAGE type",
                           "moduleid": "HTMGT_MOD_ADD_OBMC_INTERNAL_DTS",
                           "reasoncode": "HTMGT_RC_INVALID_MEM_SENSOR",
                           "userdata1":  "USAGE type",
                           "userdata2":  "OCMB HUID",
                      },
            0xB8F8E: {    "devdesc": "Missing attribute value",
                           "moduleid": "TARG_MOD_ATTR_LINE_TO_FIELDS",
                           "reasoncode": "TARG_RC_ATTR_VALUE_MISSING",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0xB908E: {    "devdesc": "Override exceeds max dimensions",
                           "moduleid": "TARG_MOD_ATTR_LINE_TO_FIELDS",
                           "reasoncode": "TARG_RC_ATTR_MAX_DIMENSIONS",
                           "userdata1":  "ATTR_MAX_DIMS",
                           "userdata2":  "Attribute dimensions",
                      },
            0x26068E: {    "devdesc": "Failed to read memory thermal sensor usage type",
                           "moduleid": "HTMGT_MOD_ADD_OBMC_DTS",
                           "reasoncode": "HTMGT_RC_ATTRIBUTE_ERROR",
                           "userdata1":  "DTS count",
                           "userdata2":  "Memory type",
                      },
            0xB918F: {    "devdesc": "Could not find attribute override target",
                           "moduleid": "TARG_MOD_ATTR_TARGET_LINE_TO_DATA",
                           "reasoncode": "TARG_RC_ATTR_TARGET_NOT_FOUND",
                           "userdata1":  "Target ascii string",
                           "userdata2":  "Target ascii string continued",
                      },
            0xB978F: {    "devdesc": "No attribute override target output generated",
                           "moduleid": "TARG_MOD_ATTR_TARGET_LINE_TO_DATA",
                           "reasoncode": "TARG_RC_NO_OUTPUT_GENERATED",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0xB9290: {    "devdesc": "Could not find attribute data",
                           "moduleid": "TARG_MOD_ATTR_GET_DATA_FROM_MAP",
                           "reasoncode": "TARG_RC_ATTR_DATA_NOT_FOUND",
                           "userdata1":  "Attribute name as ascii string",
                           "userdata2":  "Attribute name as ascii string continued",
                      },
            0x1D1490: {    "devdesc": "SPD is not valid for this part",
                           "moduleid": "VPD::VPD_OCMB_GET_SPD",
                           "reasoncode": "VPD::VPD_NULL_ENTRY",
                           "userdata1[00:31]":  "Buffer Size",
                           "userdata1[32:63]":  "Memory Type",
                           "userdata2[00:31]":  "SPD Keyword",
                           "userdata2[32:63]":  "Target HUID",
                      },
            0x260190: {    "devdesc": "OCC is not valid",
                           "moduleid": "HTMGT_MOD_SEND_OCC_CMD",
                           "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                           "userdata1":  "OCC command type",
                      },
            0x260E90: {    "devdesc": "Unable to send cmd to OCC exception",
                           "moduleid": "HTMGT_MOD_SEND_OCC_CMD",
                           "reasoncode": "HTMGT_RC_OCC_EXCEPTION",
                           "userdata1":  "OCC command",
                           "userdata2":  "comm established",
                           "userdata3":  "OCC state",
                           "userdata4":  "exception",
                      },
            0x262490: {    "devdesc": "OCC comm not established or command is not supported",
                           "moduleid": "HTMGT_MOD_SEND_OCC_CMD",
                           "reasoncode": "HTMGT_RC_OCC_UNAVAILABLE",
                           "userdata1":  "OCC command",
                           "userdata2":  "comm established",
                           "userdata3":  "OCC state",
                           "userdata4":  "1",
                      },
            0xB9291: {    "devdesc": "No override data",
                           "moduleid": "TARG_MOD_ATTR_TEXT_OVERRIDE",
                           "reasoncode": "TARG_RC_ATTR_DATA_NOT_FOUND",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0xB9391: {    "devdesc": "Override target validation failed",
                           "moduleid": "TARG_MOD_ATTR_TEXT_OVERRIDE",
                           "reasoncode": "TARG_RC_ATTR_TARGET_VALIDATION",
                           "userdata1":  "<unused>",
                           "userdata2":  "<unused>",
                      },
            0xB9491: {    "devdesc": "Override line exceeds max line length",
                           "moduleid": "TARG_MOD_ATTR_TEXT_OVERRIDE",
                           "reasoncode": "TARG_RC_MAX_OVD_LINE_LENGTH",
                           "userdata1":  "Current line size",
                           "userdata2":  "Max override line size",
                      },
            0xB9591: {    "devdesc": "Attribute name exceeds max name length",
                           "moduleid": "TARG_MOD_ATTR_TEXT_OVERRIDE",
                           "reasoncode": "TARG_RC_MAX_ATTR_NAME_LENGTH",
                           "userdata1":  "Current attribute name length",
                           "userdata2":  "Max attribute name length",
                      },
            0xB9691: {    "devdesc": "Override value exceeds max value length",
                           "moduleid": "TARG_MOD_ATTR_TEXT_OVERRIDE",
                           "reasoncode": "TARG_RC_MAX_ATTR_VAL_LENGTH",
                           "userdata1":  "Current attribute value length",
                           "userdata2":  "Max attribute value length",
                      },
            0x1D0791: {    "devdesc": "Invalid Basic Memory Type",
                           "moduleid": "VPD::VPD_OCMB_SPD_PERFORM_OP",
                           "reasoncode": "VPD::VPD_INVALID_BASIC_MEMORY_TYPE",
                           "userdata1[00:31]":  "Basic Memory Type (Byte 2)",
                           "userdata1[32:63]":  "Target HUID",
                           "userdata2":  "Keyword Requested",
                      },
            0x263591: {    "devdesc": "Timeout waiting for OCC response",
                           "moduleid": "HTMGT_MOD_WRITE_OCC_CMD",
                           "reasoncode": "HTMGT_RC_TIMEOUT",
                           "userdata1[0:15]":  "command",
                           "userdata1[16:31]":  "read timeout",
                           "userdata2[0:15]":  "response sequence number",
                           "userdata2[16:31]":  "response status",
                      },
            0x1D4192: {    "devdesc": "An unsupported eeprom content type was supplied.",
                           "moduleid": "VPD::VPD_READ_FROM_EEPROM_SOURCE",
                           "reasoncode": "VPD::VPD_INVALID_EEPROM_CONTENT_TYPE",
                           "userdata1":  "Eeprom Content Type Given",
                           "userdata2":  "Target HUID",
                      },
            0x261992: {    "devdesc": "OCC response had checksum failure",
                           "moduleid": "HTMGT_MOD_CHECK_OCC_RSP",
                           "reasoncode": "HTMGT_RC_CHECKSUM_FAIL",
                           "userdata1":  "OCC command type",
                           "userdata2":  "sequence number",
                           "userdata3":  "checksum",
                           "userdata4":  "calculated checksum",
                      },
            0x261B92: {    "devdesc": "Invalid length in OCC response",
                           "moduleid": "HTMGT_MOD_CHECK_OCC_RSP",
                           "reasoncode": "HTMGT_RC_OCC_CMD_FAIL",
                           "userdata1[0:15]":  "OCC command type",
                           "userdata1[16:31]":  "response data length",
                      },
            0x1D4193: {    "devdesc": "An unsupported eeprom content type was supplied.",
                           "moduleid": "VPD::VPD_GET_MEMTYPE",
                           "reasoncode": "VPD::VPD_INVALID_EEPROM_CONTENT_TYPE",
                           "userdata1":  "Eeprom Content Type Given",
                           "userdata2":  "Target HUID",
                      },
            0x1D4894: {    "devdesc": "CRC Miscompare in the SPD",
                           "moduleid": "VPD::VPD_OCMB_CHECK_CRC",
                           "reasoncode": "VPD::VPD_DDIMM_SPD_CRC_MISCOMPARE",
                           "userdata1[00:31]":  "Associated Target",
                           "userdata1[32:47]":  "First failing range",
                           "userdata1[48:63]":  "Second failing range",
                           "userdata2[00:47]":  "3rd,4th,5th failing range",
                           "userdata2[48:55]":  "EEPROM_ROLE that failed: 0=VPD_PRIMARY, 1=VPD_BACKUP, 6=VPD_AUTO",
                           "userdata2[56:63]":  "EEPROM_SOURCE that failed: 1=CACHE, 2=HW",
                      },
            0x261894: {    "devdesc": "Invalid response length received",
                           "moduleid": "HTMGT_MOD_PARSE_OCC_RSP",
                           "reasoncode": "HTMGT_RC_SEND_FAIL",
                           "userdata1[0:15]":  "response length",
                           "userdata1[16:31]":  "response buffer[0-3]",
                           "userdata2[0:15]":  "response buffer[4-7]",
                      },
            0x60BA0: {    "devdesc": "micronFlagStatus> Error or timeout from Micron Flag Status Register",
                           "moduleid": "PNOR::MOD_NORMICRON_MICRONFLAGSTATUS",
                           "reasoncode": "PNOR::RC_MICRON_INCOMPLETE",
                           "userdata1[0:31]":  "Micron Flag status register",
                           "userdata2":  "NOR Flash Chip ID",
                      },
            0x61BB0: {    "devdesc": "invalid section passed to getSectionInfo  or section prohibited by secureboot",
                           "moduleid": "PNOR::MOD_RTPNOR_GETSECTIONINFO",
                           "reasoncode": "PNOR::RC_RTPNOR_INVALID_SECTION",
                           "userdata1":  "PNOR::SectionId",
                           "userdata2[0:15]":  "Inhibited by secureboot",
                           "userdata2[16:31]":  "Indication of a secure section",
                           "userdata2[32:47]":  "Indication of a pre-verified section",
                           "userdata2[48:63]":  "0",
                      },
            0x61DB0: {    "devdesc": "section size is zero",
                           "moduleid": "PNOR::MOD_RTPNOR_GETSECTIONINFO",
                           "reasoncode": "PNOR::RC_SECTION_SIZE_IS_ZERO",
                           "userdata1":  "PNOR::SectionId",
                      },
            0x603B1: {    "devdesc": "invalid section passed to flush",
                           "moduleid": "PNOR::MOD_RTPNOR_FLUSH",
                           "reasoncode": "PNOR::RC_INVALID_SECTION",
                           "userdata1":  "PNOR::SectionId",
                      },
            0x61DB1: {    "devdesc": "section size is zero",
                           "moduleid": "PNOR::MOD_RTPNOR_FLUSH",
                           "reasoncode": "PNOR::RC_SECTION_SIZE_IS_ZERO",
                           "userdata1":  "PNOR::SectionId",
                      },
            0x616B2: {    "devdesc": "g_hostInterfaces->pnor_read failed",
                           "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                           "reasoncode": "PNOR::RC_PNOR_READ_FAILED",
                           "userdata1[00:31]":  "rc returned from pnor_read",
                           "userdata1[32:63]":  "section ID",
                           "userdata2[00:31]":  "offset within the section",
                           "userdata2[32:63]":  "size of data read in bytes",
                      },
            0x617B2: {    "devdesc": "error writing corrected data back to PNOR",
                           "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                           "reasoncode": "PNOR::RC_PNOR_WRITE_FAILED",
                           "userdata1":  "rc returned from pnor_write",
                           "userdata2":  "Expected size of write",
                      },
            0x61CB2: {    "devdesc": "UNCORRECTABLE ECC found when removing ECC from data retrieved from PNOR",
                           "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                           "reasoncode": "PNOR::RC_UNCORRECTABLE_ECC",
                      },
            0x61FB2: {    "devdesc": "g_hostInterfaces->pnor_read not supported",
                           "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                           "reasoncode": "PNOR::RC_PNOR_READ_NOT_SUPPORTED",
                      },
            0x62AB2: {    "devdesc": "Amount of data read from pnor does not match expected size",
                           "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE",
                           "reasoncode": "PNOR::RC_WRONG_SIZE_FROM_READ",
                           "userdata1[00:31]":  "section ID",
                           "userdata1[32:63]":  "requested size of read",
                           "userdata2[00:31]":  "requested start offset into flash",
                           "userdata2[32:63]":  "actual amount read",
                      },
            0x617B3: {    "devdesc": "g_hostInterfaces->pnor_write failed",
                           "moduleid": "PNOR::MOD_RTPNOR_WRITETODEVICE",
                           "reasoncode": "PNOR::RC_PNOR_WRITE_FAILED",
                           "userdata1[00:31]":  "rc returned from pnor_write",
                           "userdata1[32:63]":  "section ID",
                           "userdata2[00:31]":  "offset within the section",
                           "userdata2[32:63]":  "size of data written in bytes",
                      },
            0x620B3: {    "devdesc": "g_hostInterfaces->pnor_write not supported",
                           "moduleid": "PNOR::MOD_RTPNOR_WRITETODEVICE",
                           "reasoncode": "PNOR::RC_PNOR_WRITE_NOT_SUPPORTED",
                      },
            0x627B4: {    "devdesc": "getSideInfo> Side not supported",
                           "moduleid": "PNOR::MOD_RTPNOR_GETSIDEINFO",
                           "reasoncode": "PNOR::RC_INVALID_PNOR_SIDE",
                           "userdata1":  "Requested SIDE",
                           "userdata2":  "0",
                      },
            0x62AB5: {    "devdesc": "getLidFileFromOffset PLDM call failed",
                           "moduleid": "PNOR::MOD_RTPNOR_READFROMDEVICE_PLDM",
                           "reasoncode": "PNOR::RC_WRONG_SIZE_FROM_READ",
                           "userdata1[00:31]":  "section ID",
                           "userdata1[32:63]":  "offset within the section",
                           "userdata2[00:31]":  "size we tried to read in bytes",
                           "userdata2[32:63]":  "actual size of data read in bytes",
                      },
            0x640B6: {    "devdesc": "writeLidFileFromOffset PLDM call failed",
                           "moduleid": "PNOR::MOD_RTPNOR_WRITETODEVICE_PLDM",
                           "reasoncode": "PNOR::RC_WRONG_SIZE_FROM_WRITE",
                           "userdata1[00:31]":  "section ID",
                           "userdata1[32:63]":  "offset within the section",
                           "userdata2[00:31]":  "size we tried to write in bytes",
                           "userdata2[32:63]":  "actual size of data write in bytes",
                      },
            0x63ED0: {    "devdesc": "Secureboot page verify failure",
                           "moduleid": "MOD_SPNORRP_VERIFY_PAGE",
                           "reasoncode": "RC_VERIFY_PAGE_FAILED",
                           "userdata1":  "Kernel RC",
                           "userdata2":  "Virtual address accessed",
                      },
            0x604D2: {    "devdesc": "SPnorRP::initDaemon> Error from mm_alloc_block",
                           "moduleid": "PNOR::MOD_SPNORRP_ALLOCATE_BLOCK",
                           "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_alloc_block",
                      },
            0x601D3: {    "devdesc": "PnorRP::waitForMessage> Unrecognized message type",
                           "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_INVALID_MESSAGE_TYPE",
                           "userdata1":  "Message type",
                           "userdata2":  "Requested Virtual Address",
                      },
            0x635D3: {    "devdesc": "Not a loaded section",
                           "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_NOT_A_LOADED_SECTION",
                           "userdata1":  "Section attempted to unload",
                      },
            0x636D3: {    "devdesc": "Not a supported section",
                           "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_NOT_A_SUPPORTED_SECTION",
                           "userdata1":  "Section attempted to unload",
                      },
            0x637D3: {    "devdesc": "Secure unload of sections that critical to hostboot operation are not allowed.",
                           "moduleid": "PNOR::MOD_SPNORRP_WAITFORMESSAGE",
                           "reasoncode": "PNOR::RC_SECURE_UNLOAD_DISALLOWED",
                           "userdata1":  "Section Id",
                      },
            0x634D4: {    "devdesc": "Cannot verify unsigned PNOR section",
                           "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                           "reasoncode": "PNOR::RC_UNSIGNED_PNOR_SECTION",
                           "userdata1":  "PNOR section requested to verify",
                           "userdata2":  "0",
                      },
            0x638D4: {    "devdesc": "Total Container Size smaller than Protected Payload and Header size",
                           "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                           "reasoncode": "PNOR::RC_SECURE_TOTAL_SIZE_INVAL",
                           "userdata1":  "PNOR section",
                           "userdata2":  "Protected Payload Size plus Header Size",
                      },
            0x639D4: {    "devdesc": "Virtual address of PNOR section is not in Secure Space",
                           "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                           "reasoncode": "PNOR::RC_SECURE_VADDR_MISMATCH",
                           "userdata1":  "PNOR section",
                           "userdata2":  "PNOR section virtual address",
                      },
            0x63AD4: {    "devdesc": "PNOR section size smaller than total container size",
                           "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                           "reasoncode": "PNOR::RC_SECURE_SIZE_MISMATCH",
                           "userdata1":  "PNOR section",
                           "userdata2":  "Total Container Size",
                      },
            0x63BD4: {    "devdesc": "Protected Payload Size not Page aligned",
                           "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                           "reasoncode": "PNOR::RC_NOT_PAGE_ALIGNED",
                           "userdata1":  "PNOR section",
                           "userdata2":  "Protected Payload Size",
                      },
            0x63CD4: {    "devdesc": "Verified Protected Payload size does not match what was parsed by PnorRp",
                           "moduleid": "PNOR::MOD_SPNORRP_VERIFYSECTIONS",
                           "reasoncode": "PNOR::RC_SECURE_PRO_SIZE_MISMATCH",
                           "userdata1":  "PNOR section",
                           "userdata2":  "Protected Payload Size",
                      },
            0x604D5: {    "devdesc": "Could not set permissions of the given PNOR section",
                           "moduleid": "PNOR::MOD_SPNORRP_SET_PERMISSION",
                           "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_set_permission",
                      },
            0x604D6: {    "devdesc": "Secure Boot: Failed to securely load or unload signed boot firmware.",
                           "moduleid": "MOD_PNORRP_LOADUNLOADSECURESECTION",
                           "reasoncode": "RC_EXTERNAL_ERROR",
                           "userdata1":  "returncode from msg_sendrecv() or msg->data[1]",
                           "userdata2[0:31]":  "SPNOR message type [LOAD | UNLOAD]",
                           "userdata2[32:63]":  "Section ID",
                      },
            0x62FD7: {    "devdesc": "Hostboot Base and Extend code do not match versions.",
                           "moduleid": "MOD_SPNORRP_BASE_EXT_VER_CHK",
                           "reasoncode": "RC_BASE_EXT_MISMATCH",
                           "userdata1":  "First 8 bytes of hash of measured SW signatures",
                           "userdata2":  "First 8 bytes of hash of stored SW signatures in hash page table",
                      },
            0x630D8: {    "devdesc": "Key transition flag not set in outer SBKT container containing new hw keys",
                           "moduleid": "MOD_SPNORRP_KEY_TRAN_CHK",
                           "reasoncode": "RC_KEY_TRAN_FLAG_UNSET",
                           "userdata1":  "0",
                           "userdata2":  "0",
                      },
            0x604D9: {    "devdesc": "mm_remove_pages failed",
                           "moduleid": "PNOR::MOD_SPNORRP_REMOVE_PAGES",
                           "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                           "userdata1":  "virtual address",
                           "userdata2[00:31]":  "rc from mm_remove_pages",
                           "userdata2[32:63]":  "The size of memory attempted to remove",
                      },
            0x608E0: {    "devdesc": "astMbox::doMessage> LPC Error communicating                            with the mailbox",
                           "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                           "reasoncode": "PNOR::RC_LPC_ERROR",
                      },
            0x615E0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                           "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                           "reasoncode": "PNOR::RC_SFC_TIMEOUT",
                           "userdata1[48:55]":  "mbox status 1 reg",
                           "userdata1[56:63]":  "mbox flag reg",
                      },
            0x632E0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                           "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                           "reasoncode": "PNOR::RC_HIOMAP_BAD_SEQUENCE",
                           "userdata1[48:55]":  "mbox status 1 reg",
                           "userdata1[56:63]":  "mbox flag reg",
                           "userdata2[32:39]":  "original command code",
                           "userdata2[40:47]":  "response command code",
                           "userdata2[48:55]":  "sequence wanted",
                           "userdata2[56:63]":  "sequence obtained",
                      },
            0x633E0: {    "devdesc": "astMbox::doMessage> Timeout waiting for message response",
                           "moduleid": "PNOR::MOD_ASTMBOXDD_DO_MESSAGE",
                           "reasoncode": "PNOR::RC_HIOMAP_ERROR_STATUS",
                           "userdata1[48:55]":  "mbox status 1 reg",
                           "userdata1[56:63]":  "mbox flag reg",
                           "userdata2[32:39]":  "original command code",
                           "userdata2[40:47]":  "response command code",
                           "userdata2[48:55]":  "sequence number",
                           "userdata2[56:63]":  "status code",
                      },
            0x2601E0: {    "devdesc": "OCC reported exception",
                           "moduleid": "HTMGT_MOD_HANLDE_OCC_EXCEPTION",
                           "reasoncode": "HTMGT_RC_INTERNAL_ERROR",
                           "userdata1[0:31]":  "rsp status",
                           "userdata1[32:63]":  "exception data length",
                           "userdata2[0:31]":  "OCC instance",
                           "userdata2[32:63]":  "exception data",
                      },
            0x2616E1: {    "devdesc": "Operation not allowed, system is in safe mode",
                           "moduleid": "HTMGT_MOD_ENABLE_OCC_ACTUATION",
                           "reasoncode": "HTMGT_RC_OCC_CRIT_FAILURE",
                           "userdata1[0:31]":  "OCC activate [1==true][0==false]",
                           "userdata1[32:63]":  "return code triggering safe mode",
                           "userdata2[0:31]":  "safeMode flag",
                           "userdata2[32:63]":  "OCC instance",
                      },
            0x604F1: {    "devdesc": "PnorRP::setupPnorVMM> Error from mm_alloc_block",
                           "moduleid": "PNOR::MOD_PNORRP_SETUP_PNOR_VMM",
                           "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                           "userdata1":  "Requested Address",
                           "userdata2":  "rc from mm_alloc_block",
                      },
            0x604F2: {    "devdesc": "PnorRP::setupPnorVMM> Error from mm_alloc_block or mm_set_permission",
                           "moduleid": "PNOR::MOD_PNORRP_SETUP_PNOR_VMM_PLDM",
                           "reasoncode": "PNOR::RC_EXTERNAL_ERROR",
                           "userdata1":  "Requested Address",
                           "userdata2[0:31]":  "rc from mm_alloc_block or mm_set_permission",
                           "userdata2[32:63]":  "1 if rc if from mm_alloc_block, 0 if from mm_alloc_block",
                      },
            0x603F3: {    "devdesc": "PnorRP::populateTOC> Could not find section id in PLDM file table",
                           "moduleid": "PNOR::MOD_POPULATE_TOC",
                           "reasoncode": "PNOR::RC_INVALID_SECTION",
                           "userdata1[00:31]":  "Section ID we are looking up",
                           "userdata1[32:63]":  "Lid number we are looking up",
                           "userdata2":  "Section name (ASCII)",
                      },
            0x61AF3: {    "devdesc": "File size reported by BMC is larger than our max supported.",
                           "moduleid": "PNOR::MOD_POPULATE_TOC",
                           "reasoncode": "PNOR::RC_SECTION_SIZE_IS_BIG",
                           "userdata1":  "Section",
                           "userdata2":  "Section Size",
                      },
            0x603F4: {    "devdesc": "PLDM_PNOR::sectionIdToLidId> looking up a pnor section's lid mapping that does not exist",
                           "moduleid": "PNOR::MOD_PNOR_PLDM_SEC_TO_LID",
                           "reasoncode": "PNOR::RC_INVALID_SECTION",
                           "userdata1":  "Section ID we are looking up",
                           "userdata2":  "unused",
                      },
            0x642F5: {    "devdesc": "Software problem, incorrect data from BMC",
                           "moduleid": "PNOR::MOD_CHECK_PNOR_LID_MAPPING",
                           "reasoncode": "PNOR::RC_INVALID_LID_ID",
                           "userdata1":  "Lid Id Found",
                           "userdata2":  "Section Id Found",
                      },
          }
