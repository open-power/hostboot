<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types.xml $        -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2012,2024                        -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->
<attributes>
  <attribute>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <id>AFFINITY_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <description>Set to non-zero to enable EEPROM writes to Hardware</description>
    <id>ALLOW_EEPROM_WRITES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <description>
        System attribute.
        If all MCS chiplets are in an interleaving group (1=true, 0=false).
        - If true the SMP fabric is setup in normal mode and multiple MCSs
          are grouped (disallowing systems with memory only under 1 MCS
          (i.e. systems with a single C-DIMM))
        - If false the SMP fabric is setup in checkerboard mode.
        Provided by the Machine Readable Workbook.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <description>
        The asynchronous nest frequency
    </description>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>ATTN_AREA_1_ADDR</id>
    <description>
    Specifies the "intended" starting memory address for PHYP's ATTN area 1.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 1 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>ATTN_AREA_2_ADDR</id>
    <description>
    Specifies the "intended" starting memory address for PHYP's ATTN area 2.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 2 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory AVDD voltage domain ID.  All memory buffers in the same AVDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Block speculative deconfig from guard records during IPL.
        Flags when speculative deconfigurations should not be done for
        predictive gard records on during IPL due to out of hardware
        condition on prior IPL.  Note that this setting will survive
        reboots and persist until something changes, e.g. a part is
        replaced or guard is cleared.
        0 = Allow speculative deconfiguration
        1 = Block speculative deconfiguration
        </description>
    <id>BLOCK_SPEC_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels
        to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Specifies a target's CEC degraded mode domain.  For example, all
        DIMMs are part of the DIMM CEC degraded mode domain.
    </description>
    <hasStringConversion/>
    <id>CDM_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CDM_DOMAIN</id>
      </enumeration>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration specifying a target's CEC degraded mode domain
    </description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CPU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FABRIC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>IO</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CLOCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SECURITY</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>11</value>
    </enumerator>
    <id>CDM_DOMAIN</id>
  </enumerationType>

  <attribute>
    <description>
        Cec Degraded Mode Policy flags
        Use the CDM_POLICIES enum to decode.
        If the appropriate bit is 1 then the policy mode is enabled,
        and those type of Guard records are disabled.
    </description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>
        MFG_Guard policy:
        Used in MFG only to prevent and disable the following:
        . Storing or creation of new Guard records from Diagno`stic or other
            faults through error logs. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        . Storing or creation of Manual Guard record from user.
            NOTE: this does not stop FCO.
        . Using an already stored System or Manual Guard record from
            deconfiguring resources. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        </description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>
        Predictive_Guard policy:
        Used in Field or development to prevent and disable the following:
        . Storing or creation of new Guard records from diagnostics or other
            faults through error logs with the error_type of Predictive.
        . Using an already stored System Guard record with error_type of
            Predictive from deconfiguring resources.
        </description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure which defines a they IPL types
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Perform mainstore dump collection. Only valid for MPIPL
                0b0: Do not collect mainstore dump
                0b1: Perform mainstore dump collection
            </description>
        <name>PostDump</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>7</bits>
        <default>0</default>
        <description>Minor IPL Type</description>
        <name>MinorIPLType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes optional IPL flavors
    </description>
    <id>CEC_IPL_TYPE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to
        report the ECID data to the BMC and make it available for systems which
        have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
   </description>
    <id>CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>CHASSIS_LOCATION_CODE</id>
    <description>
      Location code of the chassis
    </description>
    <persistency>volatile</persistency>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <no_export/>
    <writeable/>
    <readable/>
  </attribute>

  <attribute>
    <id>CHECK_ATTN_AFTER_ISTEP_FAIL</id>
    <description>
      Flag to check for IPL attentions if channel failure is detected
    </description>
    <persistency>volatile-zeroed</persistency>
    <simpleType>
      <enumeration>
        <id>CHECK_ATTN_AFTER_ISTEP_FAIL</id>
        <default>DEFAULT</default>
      </enumeration>
    </simpleType>
    <writeable/>
    <readable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>DEFAULT</default>
    <description>
        Enumeration specifying the CHECK_ATTN_AFTER_ISTEP_FAIL values
        0 DEFAULT : Initial value and indicates FIR bits set if Ody HWP failed
        1 NO      : If Ody HWP Failed, indicates FIR bits NOT set
    </description>
    <enumerator>
      <name>DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>NO</name>
      <value>1</value>
    </enumerator>
    <id>CHECK_ATTN_AFTER_ISTEP_FAIL</id>
  </enumerationType>

  <attribute>
    <description>The address offset which each Chiplet types pervasive
     address space used to represent the a chiplet.
     0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets
     0x10 to 0x1F =&gt; All Cache Chiplets
     0x20 to 0x37 =&gt; All Core Chiplets
     0x38 to 0x3F =&gt; Multicast Operation
   </description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>CHIP_FAN_CFM</id>
    <description>
        The reference CFM for this processor at max fan speed. Value will be used
        to determine the WOF DIMM ambient credit.
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>CHIP_ID</id>
    <description>attribute indicating the chip's ID</description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>A unit (chiplet) 's  offset number within the chip. </description>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion/>
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ASIC</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>12</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>

  <attribute>
    <description>This attribute controls whether the
        SBE scratch data should be collected. This
        data can only be collected (aka read) or purged once per
        IPL. This is set to 1 at the start of draminit step
        and set to 0 once the data has been collected (aka read)
        or purged the first time in the IPL.
    </description>
    <id>COLLECT_SBE_SCRATCH_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>CPU Attribute</description>
    <id>CPU_ATTR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L1 Data Cache Line Size in bytes</description>
    <id>DATA_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L1 Data Cache Size in KB</description>
    <id>DATA_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>DCache Associative Sets</description>
    <id>DCACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>DCache Line Size in bytes</description>
    <id>DCACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines what Explorer logs to grab
        Prefixes:
        early = early in the IPL
        late  = later in the IPL
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image A side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>earlySavedLogA</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image B side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>earlySavedLogB</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Active log (RAM data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>earlyActiveLog</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>earlyReserved</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image A side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>lateSavedLogA</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image B side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>lateSavedLogB</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Active log (RAM data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>lateActiveLog</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>lateReserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Explorer logs to grab and report in the IPL</description>
    <id>DEBUG_OCMB_LOGS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Provide fine-grained control of the Odyssey SBE recovery process</description>
    <hasStringConversion/>
    <id>DEBUG_ODY_HRESET_CONTROL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <!-- Use uint8 vs enumeration to allow for easier overrides -->
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <description>Enumeration for DEBUG_ODY_HRESET_CONTROL</description>
    <enumerator>
      <name>DEFAULT</name>
      <!-- default behavior, 2 attempts then dump -->
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ONE_HRESET</name>
      <!-- do a single hreset then give up -->
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NO_HRESET</name>
      <!-- do no recovery at all -->
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NO_HRESET_CALL_DUMP</name>
      <!-- no hreset attempt, call for dump -->
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>CALL_DUMP_ON_FAIL</name>
      <!-- call for dump on first hreset fail -->
      <value>4</value>
    </enumerator>
    <id>DEBUG_ODY_HRESET_CONTROL</id>
  </enumerationType>

  <attribute>
    <description>If the Target is directly deconfigurable and GARDable; target
    may still be deconfigured in 'by association' processing.</description>
    <id>DECONFIG_GARDABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>DIMM_POWER</id>
    <description>
        The power to allocate to the DIMMs under this OCMB for a given
        utilization (specified by DIMM_POWER_UTIL).
        Written during power cap calculation and sent to the OCC via TMGT/HTMGT.
        The array size must match the DIMM_POWER_UTIL array and must be less
        than or equal to 12 (values are in cW)
    </description>
    <simpleType>
      <array>12</array>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>DIMM_POWER_UTIL</id>
    <description>
        The utilization value for each element of the DIMM_POWER attribute.
        Written during power cap calculation and sent to the OCC via TMGT/HTMGT.
        Values will be listed in increasing order and the array size must
        match the DIMM_POWER array. The array size will be up to 12 points.
        The values will be in integer percentages in the range from the minimum
        (MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL) to the maximum of 100%.
        The minimum and maximum will always be included in this array.
    </description>
    <simpleType>
      <array>12</array>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>DIMM_POWER_UTIL_INTERMEDIATE_POINTS</id>
    <description>
        The intermediate utilization values that should be used to determine
        the power to allocate to the DIMMs under an OCMB.
        The minimum (MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL) and the maximum (100%)
        are always used, so they do not need to be specified here.  Any values
        less than the minimum or greater than the maximum will be ignored.
        Values must be listed in increasing order and the array size must be
        less than or equal to 10.
    </description>
    <simpleType>
      <array>10</array>
      <uint8_t>
        <default>50,75,0,0,0,0,0,0,0,0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      Set to 1 to disable the delay that Hostboot does prior to sending
      error logs to the BMC to allow time for the BMC to check for
      power line disturbance errors. This attribute is intended
      to be set via attribute override.
    </description>
    <id>DISABLE_PLD_WAIT</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Predictive memory guard creation enable/disable.
        This attribute controls whether or not PRD will
        create guard records for predictive memory
        errors.
    </description>
    <id>DISABLE_PREDICTIVE_MEM_GUARD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Dummy attribute on the heap with zero initialization</description>
    <id>DUMMY_HEAP_ZERO_DEFAULT</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read/write permissions</description>
    <id>DUMMY_RW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>1,3,5</array>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <ignoreEkb/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Dummy attribute with write-only permissions</description>
    <id>DUMMY_WO</id>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>EC</id>
    <description>attribute indicating the chip target's EC level</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_EC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>EECACHE_DISABLE_AUTO_RESET</id>
    <description>
      Disable the ability to auto reset the EECACHE

      0 = Automatically clear the EECACHE on correctable errors
      1 = Disables the automatic EECACHE clearing to allow for debug

      Default:  0
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>State of the VPD synchronization
    between the in memory eecache, the SEEPROM and
    the EECACHE partition.  This will be used to
    track the modification of the VPD information
    and then used to trigger a refresh of the EECACHE
    partition during the IPL flow(s).
    </description>
    <id>EECACHE_VPD_STATE</id>
    <simpleType>
      <enumeration>
        <id>EECACHE_VPD_STATE</id>
        <default>VPD_GOOD</default>
      </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>VPD_GOOD</default>
    <description>
        Enumeration specifying status of VPD data
    </description>
    <enumerator>
      <name>VPD_GOOD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>VPD_NEEDS_REFRESH</name>
      <value>0x1</value>
    </enumerator>
    <id>EECACHE_VPD_STATE</id>
  </enumerationType>

  <attribute>
    <description>Specifies a target's eeprom content type.</description>
    <hasStringConversion/>
    <id>EEPROM_CONTENT_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>EEPROM_CONTENT_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>RAW</default>
    <description>Enumeration indicating a target's eeprom
        content type.
        RAW - eeprom has no specified layout
        ISDIMM - uses standard JEDEC layout for DDR memory
        IBM_FRUVPD - uses ipz converged vpd layout with records/keywords for
                     generic FRUs
        IBM_MVPD - use ipz converged vpd layout with records/keywords for
                   processor modules
        DDIMM - uses Differential DIMM layout
        SBE_BOOT_CODE - SBE code
        SBE_MEASUREMENT_CODE - Measurement code
        WOF_DATA - WOF data
        KEYSTORE - Keystore data
        PLANAR_OCMB_SPD - eeproms found on the backplane for ocmb SPD
    </description>
    <enumerator>
      <name>RAW</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>IBM_FRUVPD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>IBM_MVPD</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SBE_BOOT_CODE</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SBE_MEASUREMENT_CODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>WOF_DATA</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>KEYSTORE</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_OCMB_SPD</name>
      <value>9</value>
    </enumerator>
    <id>EEPROM_CONTENT_TYPE</id>
  </enumerationType>

  <attribute>
    <id>EEPROM_NV_INFO</id>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <name>i2cMasterPath</name>
        <description>Entity path to the chip that contains the I2C
                master.
            </description>
        <type>EntityPath</type>
        <default>physical:sys-0</default>
      </field>
      <field>
        <name>port</name>
        <description>Port from the I2C Master device. This is a 6-bit
                value, but then shifted 2 bits left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>devAddr</name>
        <description>Device address on the I2C bus. This is a 7-bit value,
                but then shifted 1 bit left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>engine</name>
        <description>I2C master engine. This is a 2-bit value,
                but then shifted 6 bits left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>byteAddrOffset</name>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. For NV controller it's only
                one byte addressing with no page select (3)
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <type>uint8_t</type>
        <default>0x03</default>
      </field>
      <field>
        <name>maxMemorySizeKB</name>
        <description>The number of kilobytes a device can hold.  'Zero'
                value possible for some devices.
            </description>
        <type>uint64_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>chipCount</name>
        <description>The number of chips making up an eeprom device.
            </description>
        <type>uint8_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>writePageSize</name>
        <description>The maximum number of bytes that can be written to
                a device at one time. 'Zero' value means no maximum value is
                expected or checked.
            </description>
        <type>uint64_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>writeCycleTime</name>
        <description>The amount of time in milliseconds a device requires
                on the completion of a write command to update its internal memory.
            </description>
        <type>uint64_t</type>
        <default>0x05</default>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>EEPROM_VPD_ACCESSIBILITY</id>
    <description>
      A bitmask value indicating whether an error has previously
      occurred on an access to the primary or secondary VPDs for this
      target.  This attribute will be checked if redundant VPD is supported.
    </description>
    <simpleType>
      <enumeration>
        <id>EEPROM_VPD_ACCESSIBILITY</id>
        <default>NONE_DISABLED</default>
      </enumeration>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NONE_DISABLED</default>
    <description>
      Enumeration indicating which VPDs are disabled on a
      target. These values can be OR-ed together to make a bitmask.
    </description>
    <!-- Real values for the attribute -->
    <enumerator>
      <name>NONE_DISABLED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CACHE_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PRIMARY_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY_DISABLED</name>
      <value>0x04</value>
    </enumerator>
    <!-- Special values which are combinations of other flags -->
    <enumerator>
      <name>LAST_DISABLED</name>
      <value>0x08</value>
    </enumerator>
    <id>EEPROM_VPD_ACCESSIBILITY</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains secondary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains primary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. DDR4 DIMMs require a special EEPROM
                page switching mechanic denoted here by a value of 1
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>EEPROM_VPD_REDUNDANCY</id>
    <description>
      Describes the possible EEPROM VPD redundancy available for target.
      Some of these are:
      isdimms have no redundancy present
      Unknown ddimms has possible redundancy
      4U ddimms have full redundancy present
      2U ddimms have no redundancy present
      Planar OCMBs have no redundancy present
      processors have full redundancy present
    </description>
    <simpleType>
      <enumeration>
        <id>EEPROM_VPD_REDUNDANCY</id>
        <default>POSSIBLE</default>
      </enumeration>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>POSSIBLE</default>
    <description>
      Enumeration indicating EEPROM VPD redundancy on a
      target.
    </description>
    <!-- Real values for the attribute -->
    <enumerator>
      <name>POSSIBLE</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>PRESENT</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>NOT_PRESENT</name>
      <value>0x02</value>
    </enumerator>
    <id>EEPROM_VPD_REDUNDANCY</id>
  </enumerationType>

  <attribute>
    <description>
        Holds the effective EC of the system.  Effective EC is the lowest EC
        among all the functional procs in the system.  Some cards may "downbin"
        the effective ECs of their contained processors, which could lower the
        effective EC of the system beyond what would occur when considering
        processor ECs alone
    </description>
    <id>EFFECTIVE_EC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Bitmask of threads to enable for each processor,
       Zero means enable all architected threads
    </description>
    <id>ENABLED_THREADS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion/>
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric chip id for this chip (position within the fabric).
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric group the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <!--
  @todo CQ:SW497175 Attribute FABRIC_PRESENT_GROUPS is now PROC_FABRIC_PRESENT_GROUPS
        Remove this attribute after HWSV is updated with new name
        The new attribute is made writeable in ekb_customized_attrs.xml
  -->
  <attribute>
    <description>Temp attr until hwsv is updated with new name</description>
    <id>FABRIC_PRESENT_GROUPS</id>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile</persistency>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Correlate HDAT node number (physical) to the logical node
        (based on the PIR) that contains the host boot image.
    </description>
    <id>FABRIC_TO_PHYSICAL_NODE_MAP</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <uint8_t>
        <default>0,255,255,255,255,255,255,255</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Node Position in the FAPI_NAME attribute for this target.
      This attribute is set by processMrw.pl and is only expected
      for targets known to FAPI.
    </description>
    <id>FAPINAME_NODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Chip position in the FAPI_NAME attribute for this target if applicable.
      This attribute is set by processMrw.pl and is only expected
      for targets known to FAPI.
    </description>
    <id>FAPINAME_POS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Unit position in the FAPI_NAME attribute for this target if applicable.
      This attribute is set by processMrw.pl and is only expected
      for targets known to FAPI.
    </description>
    <id>FAPINAME_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Common name across FAPI environments
    chip target -&gt; pu:k0:n0:s0:p00
    DIMM target -&gt; dimm:k0:n0:s0:p00
    chip unit target -&gt; pu.core:k0:n0:s0:p00:c0
    cage/system target -&gt; k0

    (chip type).(unit type):k(cage,always zero for us):n(node/drawer)
              :s(slot,always zero for us):p(chip position):c(core/unit position)
    pu  = generic processor
    </description>
    <id>FAPI_NAME</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>
        Enumeration defining special FAPI_POS values. FAPI_POS is based on logical connections to processor
        chips and is not guaranteed to be unique.
    </description>
    <enumerator>
      <name>NA</name>
      <value>0xFFFFFFFF</value>
    </enumerator>
    <id>FAPI_POS</id>
  </enumerationType>

  <attribute>
    <description>Field Core Override (FCO) is the override value for the
    number of functional cores allowed on the system.
    FCO is used when customers order a system with N cores but they only want
    to enable less than N cores to lower software license costs. A field in the
    anchor VPD is set by manufacturing to specify the maximum number of cores
    to enable. The number is maintained, even if some cores are garded out due
    to error.
    A value of 0 means all cores allowed;
    </description>
    <id>FIELD_CORE_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description> Force the SBE scratch data to be collected
        after draminit istep (with or without HWP failure).
    </description>
    <id>FORCE_SBE_SCRATCH_DATA_COLLECTION</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>FORCE_SERIAL_ISTEPS</id>
    <description>
    Forces all isteps to run hardware procedures serially, rather than
    in parallel.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>FORCE_SRAM_MMIO_OVER_I2C</id>
    <description>
    Force inband SRAM access to be over I2C instead of MMIO
    This is a way to get data when the MMIO path is not working
    (0x00 = use normal path, 0x01 = force i2c path)
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Defines presence detection states</description>
    <enumerator>
      <!-- SP did not attempt to discover this part -->
      <name>NO_ATTEMPT</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <!-- Part was detected -->
      <name>FOUND</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <!-- Discovery was attempted and found nothing -->
      <name>MISSING</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <!-- Part cannot be crosschecked -->
      <name>SKIP</name>
      <value>0x3</value>
    </enumerator>
    <id>FOUND_PRESENT_BY_SP</id>
  </enumerationType>

  <attribute>
    <description>
       Target (FRU) was detected as present by the service processor.
       This is used by Hostboot as a cross-check with its own internal
        detection code to ensure a consistent picture.
    </description>
    <id>FOUND_PRESENT_BY_SP</id>
    <readable/>
    <writeable/>
    <simpleType>
      <enumeration>
        <id>FOUND_PRESENT_BY_SP</id>
        <default>NO_ATTEMPT</default>
      </enumeration>
    </simpleType>
    <no_export/>
    <persistency>non-volatile</persistency>
  </attribute>

  <attribute>
    <id>FREQ_CORE_CEILING_MHZ</id>
    <description>
    The maximum core frequency in MHz.
    This is the same for all cores in the system.
    Data is provided by MVPD #V and is calculated as
    the minimum of the turbo frequencies.
  </description>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <!-- Required by FSP -->
  <attribute>
    <id>FREQ_PROC_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the processor refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC
        for each fru in the system.</description>
    <global/>
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the default master processor</description>
    <id>FSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the default master processor</description>
    <id>FSI_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Type of Master FSI connection to this slave (MFSI or cMFSI)</description>
    <hasStringConversion/>
    <id>FSI_MASTER_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <default>NO_MASTER</default>
        <id>FSI_MASTER_TYPE</id>
      </enumeration>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NO_MASTER</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>MFSI</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CMFSI</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NO_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>FSI_MASTER_TYPE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
                Set on FSI master chips (procs) if that chip uses slaveB
                to attach to the acting master chip.
            </description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>
        Reserved for any special flags we might need to access FSI
    </description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Slave cascade position</description>
    <id>FSI_SLAVE_CASCADE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of FSP IO Region</description>
    <id>FSP_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <enumerationType>
    <id>FUSED_CORE_MODE_HB</id>
    <description>Enum for FUSED_CORE_MODE_HB</description>
    <enumerator>
      <name>SMT4_DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SMT4_ONLY</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SMT8_ONLY</name>
      <value>8</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <id>FUSED_CORE_MODE_HB</id>
    <description>
        Stores the SMT setting read from the PVR that defines the fused mode.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Force a fused-core mode.  Note this will not match the true hardware
        state if using a part with fuses blown..
    </description>
    <id>FUSED_CORE_OPTION</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enum for FUSED_CORE_OPTION</description>
    <enumerator>
      <name>USING_DEFAULT_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>USING_NORMAL_CORES</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>USING_FUSED_CORES</name>
      <value>2</value>
    </enumerator>
    <id>FUSED_CORE_OPTION</id>
  </enumerationType>

  <attribute>
    <id>HBRT_HYP_ID</id>
    <description>
      Effective ID used by the hypervisor to specify a given target. A value
      of 0xFFFFFFFFFFFFFFFF means invalid/unknown.
  </description>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Hostboot HRMOR = (HB_HRMOR_NODAL_BASE * node) + offset. </description>
    <id>HB_HRMOR_NODAL_BASE</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x200000000000</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>HB_MIN_BACKING_CACHE_FC</id>
    <description>
        Number of Fused Cores needed to satisfy minimum backing cache requirement.
        To be valid Backing Cache Fused Cores (BCFC), a FC must have 2 non-ECO core
        children. This is because while HW initialization allows for individual
        cores, the SBE will only select paired non-ECO cores as backing cache. BCFC
        core children may be in either functional or functionalOverride HWAS_STATE.
        Cores set as functionalOverride are done so during Field Core Override (FCO)
        which leaves them in a state where their cache is still enabled and can be
        used in BCFCs.
    </description>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        The amount of mainstore that PHYP needs to preserve per node
        during MPIPL.
    </description>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>256</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings.
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Enable / Disable continuous trace.
                0b0: Continuous trace is disabled.
                0b1: Continuous trace is enabled.
            </description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for SCAN component.
                0b0: TRACS entries for SCAN have default behavior.
                0b1: TRACS entries for SCAN are enabled.
            </description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for DBG component.
                0b0: TRACS entries for DBG have default behavior.
                0b1: TRACS entries for DBG are enabled.
            </description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes how the SP has configured features in
      Hostboot.
    </description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
       Indicates the chip's EC level, distinct from ATTR_EC to handle
       non-standard mini-ECs, e.g. 1.01, separate from the real
       hardware-defined EC level.  By default, ATTR_HDAT_EC==ATTR_EC
       unless the chip has a mini-EC.
    </description>
    <id>HDAT_EC</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot runtime data section.
    </description>
    <id>HDAT_HBRT_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Biggest size for any of the hostboot
        runtime data sections.
    </description>
    <id>HDAT_HBRT_SECTION_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>9</array>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            purpose to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <!-- deprecated -->
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            type to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <!-- deprecated -->
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <!-- deprecated -->
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <!-- deprecated -->
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>THERMAL_SENSOR</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c04</name>
      <value>0x0D</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c412</name>
      <value>0x0E</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c32</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c64</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c16</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>NVDIA_GPU</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>NXP_LPC_Microcontroller_LPC11U35</name>
      <value>0x13</value>
    </enumerator>
    <enumerator>
      <name>9550</name>
      <value>0x14</value>
    </enumerator>
    <enumerator>
      <name>TCG_I2C_TPM</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot reserved memory section.
    </description>
    <id>HDAT_RSV_MEM_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>HDDW_ORDER</id>
    <description>PCIe slot HDDW order definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>HOMER_PHYS_ADDR</id>
    <description>
        Physical address where HOMER image is placed in mainstore.
    </description>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_HOMER_PHYS_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Value of the largest EID that host service sent.
        This is usually the last EID committed.
        (Note - EID is more accurate, PLID being kept to handle legacy code.)
    </description>
    <id>HOSTSVC_PLID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x89000000</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <description>Hot Plug Controller values for a specific processor.
        Purpose: Holds information about the hot plug controllers so that a
            Hardware procedure is able to turn them on and off.
        Data Format: up to 8 Hot Plug Controllers x 7 variables of information
            This data is at the processor level.
            The needed information and their individual sizes are as follows:
            (1) I2C Master processor engine (uint8_t)
            (2) I2C Master processor port (uint8_t)
            (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB)
            (4) Slave address (uint8_t)
            (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum)
            (6) I2C Master processor node (uint8_t)
            (7) I2C Master processor position (uint8_t)
            Thus, the information will be 8 bytes.
    </description>
    <simpleType>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            </default>
      </uint8_t>
      <array>8,8</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Hardware Unit ID
        SSSSNNNNTTTTTTTTCCiiiiiiiiiiiiii
        S=System
        N=Node Number
        T=Target Type (matches TYPE attribute)
        C=Context (for same TYPE that is on multiple kinds of chips)
          : 00=PROC_CHIP (for P10 backward compatibility),
          : 01=OCMB_CHIP
        i=Instance/Sequence number of target, relative to node
    </description>
    <id>HUID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <default>0xFFFFFFFF</default>
      <uint32_t/>
    </simpleType>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the services that are concerned
        with target changes (ie, via HCDB change).
        The values can be combined using a bitwise 'OR'.
    </description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>DEVTREE_SYNC</name>
      <value>0x00000040</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>
        Structure consisting of an EID (or reason), 6 booleans, and 2 reserved
        bits
      </description>
      <field>
        <default>0</default>
        <description>
             If this target was deconfigured,
             this will be a special DECONFIGURED_BY_ enum,
             OR it will be the errlog EID that caused it,
             either directly or by association,
        </description>
        <name>deconfiguredByEid</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
        </description>
        <name>poweredOn</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
        </description>
        <name>present</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not functional;
             0b1: Target is functional
        </description>
        <name>functional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
        </description>
        <name>dumpfunctional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             Set for speculative deconfig;
             0b0: target is not speculatively deconfigured;
             0b1: target is speculatively deconfigured;
        </description>
        <name>specdeconfig</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             If a core was deconfigured due to Field Core Override (FCO)
             set this bit. This is used by HB and BMC during reconfig
             loops to treat cores deconfigured by FCO as functional.
             0b0: leave target functional bit unchanged during reconfig loops
             0b1: set target functional bit to 1 during reconfig loops
        </description>
        <name>functionalOverride</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>2</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      HardWare Availability Service state attribute which keeps track of whether
      a given target is powered on (or not), present (or not), functional (or
      not), functional in terms of dump (or not), speculatively deconfigured (or
      not), and if deconfigured, the reason or EID associated with the
      deconfiguration.
    </description>
    <id>HWAS_STATE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Attribute.
        Keeps track of changedSinceChecked state, indicates if the
        target has changed since last checked by the appropriate service.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Mask.
        Used when a target changes (ie, via HCDB change) to set the
        HWAS_STATE_CHANGED_FLAG, so that the appropriate services will
        all handle the change.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>
        Structure consisting of an EID (or reason), 6 booleans, and 2 reserved
        bits
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
        </description>
        <name>poweredOn</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
        </description>
        <name>present</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not functional;
             0b1: Target is functional
        </description>
        <name>functional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
        </description>
        <name>dumpfunctional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             Set for speculative deconfig;
             0b0: target is not speculatively deconfigured;
             0b1: target is speculatively deconfigured;
        </description>
        <name>specdeconfig</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             If a core was deconfigured due to Field Core Override (FCO)
             set this bit. This is used by HB and BMC during reconfig
             loops to treat cores deconfigured by FCO as functional.
             0b0: leave target functional bit unchanged during reconfig loops
             0b1: set target functional bit to 1 during reconfig loops
        </description>
        <name>functionalOverride</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>2</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Copy of HWAS_STATE that is used for save/restore operations
      during testcase execution.
    </description>
    <id>HWAS_STATE_TESTSAVE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Designates the speed at which a given I2C bus should run.
        Creator: MRW
        Purpose: Used by FW to know the fastest possible bus speed that all of
            the devices on a given bus are able to use.
        Data Format: 4x16 array of uint16_t values.  The first index indicates
            the engine number of the bus.  The second index indicates the port
            number of the bus.  The value in the array is the I2C bus speed
            used for that engine/port combination in KHz.
    </description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,16</array>
      <uint16_t>
        <default>
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>I2C_CONTROL_INFO</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the I2C mux for
            this device
                     must enable to connect this device to its I2C master, if applicable.
                     0xFF indicates no I2C mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path of the I2C mux for this device, if any.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_A</id>
    <description>
      Disables the diagnostic reset for the engine

      We always want Engine A (FSI) to skip
      the diagnostic resets

      0 = Allows diagnostic resets
      1 = Disables diagnostic resets
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_B</id>
    <description>
      Disables the diagnostic reset for the engine

      Engine B diagnostic reset capabilities are
      determined by the I2C security OCMB states

      We need this value to persist during MPIPL
      but reset back to zero on cold IPL

      0 = Allows diagnostic resets
      1 = Disables diagnostic resets
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_C</id>
    <description>
      Disables the diagnostic reset for the engine

      Engine C diagnostic reset capabilities are
      determined by the I2C security OCMB states

      We need this value to persist during MPIPL
      but reset back to zero on cold IPL

      0 = Allows diagnostic resets
      1 = Disables diagnostic resets
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_D</id>
    <description>
      Disables the diagnostic reset for the engine

      Engine D is currently allowed to perform
      diagnostic resets (nothing alters this value)

      0 = Allows diagnostic resets
      1 = Disables diagnostic resets
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>I2C_INHIBIT_DIAGNOSTIC_RESET_ENGINE_E</id>
    <description>
      Disables the diagnostic reset for the engine

      We always want Engine E to skip
      the diagnostic resets

      0 = Allows diagnostic resets
      1 = Disables diagnostic resets
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which I2C access method to use at
        a point in time.  Only applicable if target supports one or more I2C
        types.  Only one bit (of the first two) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI I2C at this time.  0b1: Use FSI
            I2C at this time</description>
        <name>useFsiI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use Host I2C at this time.  0b1: Use
            Host I2C at this time</description>
        <name>useHostI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which I2C method to use</description>
    <id>I2C_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>MCS Inband Scom base address</description>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Assoc Sets</description>
    <id>ICACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>ICache Block Size in bytes</description>
    <id>ICACHE_BLOCK_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Icache Line Size in bytes</description>
    <id>ICACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>ICache Size in KB</description>
    <id>ICACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Controls whether target discovery code should assume the target is
      initially present, functional, and powered on (even though later
      operations may change this).  Commonly used to avoid having to do presence
      detect on certain targets.
          0x00: Do not assume target is initially available
          0x01: Assume target is initially available
    </description>
    <id>INIT_TO_AVAILABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <no_export/>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <description>INT - Thread Management Bar address
         MMIO consumed by HB/PHYP
    </description>
    <id>INT_CQ_TM_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Target-specific attribute that defines the injection criteria and
        action within an unsigned 64-bit bitfield.

        [00:07] Istep of injection target
        [08:15] Substep of injection target
        [16:23] DeconfigEnum of injection target
        [24:31] GARD ErrorType of injection target
        [32:63] Reserved

        Attribute Override Example:

            # Manual guard (0xd2) at istep 6.7 for ocmb chip 1
            target = k0:s0:n0:ocmb:p1
            ATTR_ISTEP_CALLOUT_INJECT_ACTION 0x060700D200000000 CONST

            # Enable iStep callout injections
            target = k0:s0
            ATTR_ISTEP_CALLOUT_INJECT_ENABLE 0x1 CONST
    </description>
    <id>ISTEP_CALLOUT_INJECT_ACTION</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Global boolean attribute that informs the iStepDispatcher to look
        for and perform [specified] injection actions. Default value of
        false (0), override to true (1) to enable injections.
    </description>
    <id>ISTEP_CALLOUT_INJECT_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>ISTEP_MODE</id>
    <description>If True, puts HostBoot into SPLess SingleStep mode.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_ISTEP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      Used to configure the parameters for enabling pause/stop between
      isteps. This attribute is set via attribute override.
    </description>
    <id>ISTEP_PAUSE_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Used to enable pause/stop in between isteps. This attribute is set via
      attribute override.
    </description>
    <id>ISTEP_PAUSE_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Indicate an inter-enclosure bus at this endpoint target.
                 0 = No, 1 = Yes
    </description>
    <id>IS_INTER_ENCLOSURE_BUS</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>IS_STANDALONE</id>
    <description>
        Attribute to determine if this is full system or standalone simics config.
        Useful for when full system configs should behave different from standalone.
        1 = Standalone simics
        0 = Full system hardware or simics
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>KEY_CLEAR_REQUEST</id>
    <description>
        Indicates types of Key Clear Requests are being made
    </description>
    <no_export/>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>KEY_CLEAR_REQUEST</id>
        <default>NONE</default>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <id>KEY_CLEAR_REQUEST</id>
    <description>
        Enum indicating the different possible Key Clear Request values
        NOTE: See "Host FW key clear requests" in HDAT spec
    </description>
    <enumerator>
      <description>
          (Default) Key Clear not requested
      </description>
      <name>NONE</name>
      <value>0x0000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear All" : Clear/reset all sensitive data controlled by platform
          firmware from the system
      </description>
      <name>ALL</name>
      <value>0x8000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear OS Keys" : This indicates OPAL to clear the OS secureboot keys
      </description>
      <name>OS_KEYS</name>
      <value>0x4000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear PowerVM System Key" : This indicates to PowerVM to clear the
          system key to the default state
      </description>
      <name>POWERVM_SYSKEY</name>
      <value>0x1000</value>
    </enumerator>
    <enumerator>
      <description>
          Reserved bits
      </description>
      <name>RESERVED_1</name>
      <value>0x2C00</value>
    </enumerator>
    <enumerator>
      <description>
          MFG mode and imprint driver only : Clear all latent sensitive data
          and treat as genesis IPL for MFG processing. Same behavior as
          KEY_CLEAR_ALL as well as clear/reset of any IBM sensitive data.
      </description>
      <name>MFG_ALL</name>
      <value>0x0200</value>
    </enumerator>
    <enumerator>
      <description>
          MFG mode and imprint driver only : Clear all sensitive data and
          leave storage empty
      </description>
      <name>MFG</name>
      <value>0x0100</value>
    </enumerator>
    <enumerator>
      <description>
          Reserved bits
      </description>
      <name>RESERVED_2</name>
      <value>0x00FF</value>
    </enumerator>
  </enumerationType>

  <enumerationType>
    <id>KEY_TRANSITION_STATE</id>
    <description>
        Enum indicating the current Secure Boot key transition state for the
        node.
    </description>
    <enumerator>
      <description>
            Secure Boot key transition not yet requested for the node
        </description>
      <name>KEY_TRANSITION_NOT_REQUESTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <description>
            About to write new system Secure Boot key to first SBE SEEPROM
            side in the node
        </description>
      <name>KEY_TRANSITION_STARTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <description>
            Failed to apply new system Secure Boot key to one or more functional
            SBE SEEPROM sides in the node
        </description>
      <name>KEY_TRANSITION_FAILED</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <description>
            Successfully applied new system Secure Boot key to every functional
            SBE SEEPROM side in the node
        </description>
      <name>KEY_TRANSITION_SUCCEEDED</name>
      <value>3</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <description>
    Attribute indicating the status of the Secure Boot key transition for
    the node
  </description>
    <hasStringConversion/>
    <id>KEY_TRANSITION_STATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <enumeration>
        <id>KEY_TRANSITION_STATE</id>
        <default>KEY_TRANSITION_NOT_REQUESTED</default>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Assoc Sets</description>
    <id>L2_CACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L2 Cache Line Size in bytes</description>
    <id>L2_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L2 Cache Size in KB</description>
    <id>L2_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L3 Cache Line Size in bytes</description>
    <id>L3_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L3 Cache Size in KB</description>
    <id>L3_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        The value of the last IPL-time EID. This attribute is used by HBRT to
        preserve the highest IPL-time EID in PNOR.
    </description>
    <id>LAST_IPLTIME_EID</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Logical Memory Block Size (LMB)
       Encoded Size:
       - 0x00 = 16 meg LMB
       - 0x01 = 32 meg LMB
       - 0x02 = 64 meg LMB
       - 0x03 = 128 meg LMB
       - 0x04 = 256 meg LMB (default)
       - 0x05 = 512 meg LMB
       - 0x06 = 1024 meg LMB
       - 0x07 = 2048 meg LMB
       - 0x08 = 4096 meg LMB
    </description>
    <id>LMB_SIZE</id>
    <simpleType>
      <uint8_t>
        <default>0x04</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>LPC Bus address - MMIO consumed by PHYP</description>
    <id>LPC_BUS_ADDR</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max chiplets per proc available in the system.
    </description>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MAX_COMPUTE_NODES_PER_SYSTEM</id>
    <description>
        The max compute nodes available in the system.
        Computed value based on CEC enclosures.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max DIMMs per MBA Port available in the system.
    </description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>MAX_DIMM_POWER</id>
    <description>
        The reference max power per OCMB of the largest DIMM accounted for in
        the system design (value in cW)
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <!-- End Required by FSP -->
  <attribute>
    <id>MAX_DMI_PER_PROC</id>
    <description>
        System attribute.
        The max DMI units per proc available in the system.
    </description>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max EX units per proc chip available in the system.
    </description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBAS per membuf available in the system.
    </description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBA ports per MBA available in the system.
    </description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MCS units available in the system.
    </description>
    <id>MAX_MCS_PER_SYSTEM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>4</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MAX_POWER</id>
    <description>Defines the maximum power consumption for a PCIe slot</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max proc chips per node available in the system.
    </description>
    <id>MAX_PROC_CHIPS_PER_NODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MBA_DIMM</id>
    <!-- deprecated -->
    <description>
       MBA port DIMM number of this DIMM
       (deprecated in favor of POS_ON_MEM_PORT)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MBA_PORT</id>
    <!-- deprecated -->
    <description>
       MBA port this DIMM is connected to
       (deprecated in favor of MEM_PORT)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Memory AVDD voltage domain offset in mV.</description>
    <id>MEM_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Base Address for all mainstore behind this processor</description>
    <id>MEM_BASE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MEM_PORT</id>
    <description>
       Memory port this DIMM is connected to
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Memory VCS voltage domain offset in mV.</description>
    <id>MEM_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VCS_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VDDR voltage domain offset in mV.</description>
    <id>MEM_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VDD voltage domain offset in mV.</description>
    <id>MEM_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VPP voltage domain offset in mV.</description>
    <id>MEM_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPP_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MFG_TRACE_ENABLE</id>
    <description>
        Override this to a non-zero value to have the FAPI manufacturing
        traces output to the console or go to a fsp trace buffer when
        console not enabled.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MGC_LOAD_SOURCE</id>
    <description>defines MGC load source</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The lowest frequency that a core can be set to in MHz.
        This is the same for all cores in the system.
        Data is provided by MVPD #V and is calculated as the
        Maximum of the power save frequencies.
    </description>
    <id>MIN_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>4800</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>MIRROR_BASE_ADDRESS</id>
    <description>System Mirrorable Base Address
       Bits8-12 Specifies System Selects
       Bits13-14 Memory select
       Bits15-18 Group ID (within an SMP)
       Bits19-21 Chip ID (8 Max)
       Bits22-63 Chip internal address (42 bits, 4TB)
       Mirroring uses memory select
    </description>
    <simpleType>
      <uint64_t>
        <default>0x4000000000000</default>
      </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_MIRROR_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MMIO_PHYS_ADDR</id>
    <description>
            Physical memory address this device has been mapped to.
    </description>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <description>
      System attribute
      8 bit rx_min_eye_height value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <description>
      System attribute.
      8 bit rx_min_eye_height value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <description>
      System attribute.
      6 bit rx_min_eye_width value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent MPE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during IPL.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent UE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when an
      RCD parity error (recovery enabled) attention count is equal to this
      value. A value of 0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the maximum number of Memory RCEs
      allowed per Rank during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_MEMORY_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for X bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion/>
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OCMB</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>POWER10</name>
      <value>145</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>AST2600</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <enumerator>
      <name>UCD9090</name>
    </enumerator>
    <enumerator>
      <name>UCD90120A</name>
    </enumerator>
    <enumerator>
      <name>UCD90320</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>

  <attribute>
    <description>MRU ID attribute for chip/unit class</description>
    <id>MRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Attribute indicating the default risk level for the system. Applied if
        scratch registers are not overriden
    </description>
    <id>MRW_DEFAULT_RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description> An array of the supported EC levels for each chip that is allowed to ship. The size of the array
          should only increase when the number of entries in the MRW increases.
          The array takes the form:
          Even Entries: cfam chip id
          Odd Entries: Required EC level of the preceeding Target Type
    </description>
    <id>MSL_FIELD_SUPPORTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>12</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description> An array of the supported EC levels for each chip that is allowed to use in MFG systems. The size of
          the array should only increase when the number of entries in the MRW increases.
          The array takes the form:
          Even Entries: cfam chip id
          Odd Entries: Required EC level of the preceeding Target Type
    </description>
    <id>MSL_MFG_ALLOW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>12</array>
      <uint16_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <!--attribute>
    <id>MRW_REQUIRED_TEST</id>
    <description>An attribute to test the mrwRequired keyword</description>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <mrwRequired/>
  </attribute-->
  <attribute>
    <description>AVDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>MBA DRAM data bus utilization percent to use to determine cfg_nm_n_per_mba</description>
    <id>MSS_DATABUS_UTIL_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>STR</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <default>OFF</default>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>STR</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration for Temperature refresh mode</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>

  <attribute>
    <id>MSS_PHY_SEQ_REFRESH</id>
    <description>
      Controls ENABLE/DISABLE of workaround that sets
      the PHY sequencer to trigger refresh after draminit.
    </description>
    <simpleType>
      <uint8_t/>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_PHY_SEQ_REFRESH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>VCS memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDDR memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic,
    3 = DEFAULT  - domain needs to be programmed, pgm values in sys xml file
    </description>
    <hasStringConversion/>
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VDDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>VPP memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the multi scome
        buffer size. The values can be combined using a
        bitwise 'OR'.  The values will need to be kept
        in sync with the FAPI enumerator values.  Also
        the enumeration type is used by the
        ATTR_MULTI_SCOM_BUFFER_MAX_SIZE.  Should
        note that the MULTI_SCOM_BUFFER_MAX_SIZE values
        are of type uint32_t
    </description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>

  <attribute>
    <id>NEST_PLL_FREQ_BUCKETS</id>
    <description>
      Constant defining number of NEST PLL frequency options ('buckets')
      to be built into unsigned HW image.
  </description>
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>NEST_PLL_FREQ_I2CDIV_LIST</id>
    <description>
      I2C bus divisor
      index is bucket number
      The values in this list will be factor of 1:64 to the NEST_PLL_FREQ_LIST
  </description>
    <simpleType>
      <uint32_t>
        <default>25,29,31,33,37</default>
      </uint32_t>
      <array>5</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>NEST_PLL_FREQ_LIST</id>
    <description>
      Nest PLL frequency in MHZ
      index is bucket number
  </description>
    <simpleType>
      <uint32_t>
        <default>1600,1866,2000,2133,2400</default>
      </uint32_t>
      <array>5</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Override normal reconfig loop behavior to fail the boot on
        a deconfig instead of triggering a reconfig loop (reboot)..
    </description>
    <id>NO_RECONFIG_ON_DECONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR base address values
        creator: platform
        consumer: proc_setup_bars
        firmware notes:
            64-bit address representing BAR RA
            NOTE: BAR register covers RA 14:51
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR size values
        creator: platform
        consumer: proc_setup_bars
        firmware notes: none
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the BAR size
        used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      NVDIMM(s) are armed for backup incase of power loss (DDR Reset_n goes low)
      This keeps track of the armed state
    </description>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <complexType>
      <description>Armed State</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Is NVDIMM armed</description>
        <name>armed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>NVDIMM controller error detected</description>
        <name>error_detected</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <id>NVDIMM_ARMED</id>
  </attribute>

  <attribute>
    <id>NV_OPS_TIMEOUT_MSEC</id>
    <description>
        NVDIMM timeout value for 6 main operations
        0 - CSAVE
        1 - Page Switch
        2 - Restore
        3 - ERASE
        4 - ARM
        5 - CHARGE

        This attribute is set to volatile because the timeout values vary
        depending on the vendor and capacity. The timeout values will be
        determined during init by reading the i2c registers on the NV
        controller.
        The indices are defined in src/usr/isteps/nvdimm.H and the attribute
        is consumed in nvdimm.C
    </description>
    <simpleType>
      <array>6</array>
      <uint32_t>
        <default>0,0,0,0,0,0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NV_STATUS_FLAG</id>
    <description>
        NVDIMM status flag. This is used to record the status and
        later report to OPAL/PHYP. Possible values:

        0x08 - contents not preserved (genesis)
        0x04 - contents preserved
        0x02 - failed to preserve contents
        0x01 - unable to preserve future contents
    </description>
    <simpleType>
      <uint8_t>
        <default>0x08</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>OBUS_BRICK_LANE_MASK</id>
    <description>
      Lane mask for which 8 lanes belong to this brick
      This is a right justified 24-bit value. Only 8 of the
      24 bits will be set representing the lanes belonging to
      the associated brick.
      Provided by the MRW.
  </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>OBUS_SLOT_INDEX</id>
    <description>
      Position of the obus slot that the Obus brick is connected to
      (represented in decimal). There is only one slot that a given
      brick connects to and there are only 6 slots per proc,
      so, we just need a single uint8_t representing the position
      of the slot.
      Provided by the MRW.
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        This attribute is to determine whether an occ is master capable.
        An OCC is master capable if it's parent processor is wired to the
        APSS.
    </description>
    <id>OCC_MASTER_CAPABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>OCMB_BOOT_SIDE</id>
    <description>
      The firmware image source from which to boot this OCMB. (Only
      used for Odyssey OCMBs.) Sides are swapped when booting from a
      given side fails, or when doing a code update.
    </description>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>OCMB_CODE_LEVEL_SUMMARY</id>
    <description>
      A human-readable string containing (portions of) the hashes of
      the relevant boot images running on the given OCMB. (Currently
      only used for Odyssey.)
    </description>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>256</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Whether or not we have successfully updated code on this OCMB
      on this boot attempt (including any reconfig loops) before.
    </description>
    <id>OCMB_CODE_UPDATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Force an image sync between the two sides on OCMB in istep 16.5
      regardless of whether the images match. This is used in OCMB
      flash check paths to attempt to fix the flash errors on non-current
      side.
    </description>
    <id>OCMB_FORCE_IMAGE_SYNC</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>OCMB_FW_STATE</id>
    <description>
      Whether this OCMB has out-of-date firmware.
    </description>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
    <simpleType>
      <enumeration>
        <id>OCMB_FW_STATE</id>
        <default>UNKNOWN</default>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default/>
    <description>
      Describes whether the OCMB firmware running on this device is up
      to date or not. This enumeration is used for the various OCMB
      Firmware update behaviors.
    </description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>UP_TO_DATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>OUT_OF_DATE</name>
      <value>2</value>
    </enumerator>
    <id>OCMB_FW_STATE</id>
  </enumerationType>

  <enumerationType>
    <default>DEFAULT_ALL</default>
    <description>Enumeration for the various OCMB Firmware update behaviors</description>
    <enumerator>
      <!-- Compare actual and desired versions, update if they do not match -->
      <name>CHECK_VERSIONS</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <!-- Force an update regardless of the current version in the hardware -->
      <name>FORCE_UPDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <!-- Do not update the firwmare, do not even check the versions -->
      <name>PREVENT_UPDATE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <!-- Compare actual and desired versions, but do not do any updates -->
      <name>CHECK_BUT_NO_UPDATE</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <!-- Force an update for the MDS -->
      <name>MDS_FORCE_UPDATE</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <!-- Same as FORCE_UPDATE, but only runs once -->
      <name>FORCE_UPDATE_ONCE</name>
      <value>5</value>
    </enumerator>
    <id>OCMB_FW_UPDATE_BEHAVIOR</id>
  </enumerationType>

  <attribute>
    <description>
       Force specific behavior for the OCMB Firmware update function.
    </description>
    <id>OCMB_FW_UPDATE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Status for OCMB Firmware update
       - update is needed
       - method of update (I2C vs MMIO) to try
       - i2c update has been tried
       - hard failure hit (failure after i2c update tried)
    </description>
    <id>OCMB_FW_UPDATE_STATUS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <complexType>
      <description>Structure which defines update status</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
              0b0: No update necessary
              0b1: At least one explorer needs update
          </description>
        <name>updateRequired</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Update via I2C
              0b0:  Next update via MMIO (default)
              0b1:  Next update via I2C
          </description>
        <name>updateI2c</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
              0b0: I2C update not done
              0b1: I2C update has been attempted
          </description>
        <name>i2cUpdateAttempted</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
              0b0: I2C update still available to try
              0b1: Hard failure (failure after I2C update)
          </description>
        <name>hardFailure</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>4</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Whether or not we have booted from the golden firmware image on
      this OCMB on this boot attempt (including any reconfig loops)
      before. Note that this is set to false (0) if we are currently
      attempting to boot from the golden side (because we have not
      booted from the golden side *before*).
    </description>
    <id>OCMB_GOLDEN_BOOT_ATTEMPTED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       If set, then the temporary code that universally disables scom
        checking on the Odyssey SBE is not executed.
       This makes the firmware act like the real shipped code,
    </description>
    <id>OCMB_IGNORE_SCOM_CHECK_DISABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>OCMB_ISTEP_MODE</id>
    <description>
        A mode flag to enable the Odyssey SPPE to be single stepped.
    </description>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Required delay (in seconds) between deasserting the OCMB reset before
       we attempt the first i2c operation out to the OCMB chip.
    </description>
    <id>OCMB_RESET_DELAY_SEC</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>10</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Code update rule that takes precedence over the code update
      table. This can be used to override the default behavior of the
      Odyssey Code Update FSM.

      Structure:

      Word 0           | Word 1
      VVVVVVVVWWXXYYZZ | AABBCCDD00000000

      VVVVVVVV: The event pattern to match. This is a bitwise-OR'd
                collection of elements from ody_upd_event_t.

      WWXXYYZZ: The state pattern to match.

            WW: Bitwise-OR'd collection of tristate_t representing the
                "update performed?" state variable.
            XX: Bitwise-OR'd collection of tristate_t representing the
                "golden boot performed?" state variable.
            YY: Bitwise-OR'd collection of ocmb_boot_side_t representing the
                "OCMB boot side" state variable.
            ZZ: Bitwise-OR'd collection of tristate_t representing the
                "OCMB FW up to date?" state variable.

      AABBCCDD: The actions for the FSM to perform when the event and
                state match the patterns in word 0. If these actions are taken,
                the actions that would have otherwise been taken by the FSM are
                ignored.

            AA: A single element of the update_action_t enumeration
                representing an action to take.
            BB: A single element of the update_action_t enumeration
                representing an action to take.
            CC: A single element of the update_action_t enumeration
                representing an action to take.
            DD: A single element of the update_action_t enumeration
                representing an action to take.

      Note that if the perform_code_update action is taken by this
      override, all code images on the OCMB are considered to be out
      of date and will be updated.
    </description>
    <id>ODYSSEY_PRIORITY_CODE_UPDATE_RULE</id>
    <simpleType>
      <array>2</array>
      <uint64_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>ODY_PNOR_COMBINED_IMAGES_HASH</id>
    <description>
      A single hash that is a combination of the hashes of all Odyssey
      firmwares in PNOR that pertain to this chip. This is used to
      detect when Hostboot firmware is updated on the system, so that
      the Odyssey firmware update process can be restarted if
      necessary.
    </description>
    <simpleType>
      <uint8_t/>
      <array>64</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path an OMI's associated OMIC parent target
    </description>
    <id>OMIC_PARENT</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
          Ordinal ID is a value which needs to be completely unique across the entire system for a given target
          type. Typically, this value corresponds to the HUID instance ordering but it's not required to. This ID must
          adhere to requirements PHYP imposes on Hostboot for the unit being represented.
      </description>
    <id>ORDINAL_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <description>
      Rules on how to handle a deconfigure to parent level
    </description>
    <id>PARENT_DECONFIG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <complexType>
      <description>Structure which defines a target's deconfigure rules.
        Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Are the rule bits set correctly?
        </description>
        <name>valid</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT be deconfigured by child rollup
            0b1: Target allowed to be deconfigured by child rollup
            </description>
        <name>childRollupAllowed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT rollup its deconfigure to its parent
            0b1: Target should deconfigure its parent if no more functioning
                 children of same type exist for its parent
        </description>
        <name>deconfigureParent</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path of the target's associated pervasive target
    </description>
    <id>PARENT_PERVASIVE</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path of an OMIC's associated PAUC parent target
    </description>
    <id>PAUC_PARENT</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Base address (target HRMOR) of the payload.  Value is in MB.</description>
    <id>PAYLOAD_BASE</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>The offset from base address of the payload entry-point.
        Current default is 0x180</description>
    <id>PAYLOAD_ENTRY</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x180</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Indicate that payload should be placed in mirrored memory.
        Set by the FSP based on the value of the registry key indicating
        the memory mirroring mode.
    </description>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Attribute indicating what kind of payload is to be started.
    </description>
    <hasStringConversion/>
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PAYLOAD_KIND</id>
        <default>PHYP</default>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>UNKNOWN</default>
    <description>
        Enumeration indicating what kind of payload is to be started
    </description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>

  <attribute>
    <id>PCIE_32BIT_DMA_SIZE</id>
    <description>PCIe slot 32bit DMA size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_32BIT_MMIO_SIZE</id>
    <description>PCIe slot 32bit MMIO size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_64BIT_DMA_SIZE</id>
    <description>PCIe slot 64bit DMA size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_64BIT_MMIO_SIZE</id>
    <description>PCIe slot 64bit MMIO size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_CAPABILITES</id>
    <description>Denotes the capabilities of this pcie slot</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Custom Card Identification Number (CCIN) of the NVME Backplane</description>
    <id>PCIE_NVME_CCIN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Designates the System PHB Configuration for NVME Backplanes
        Creator: MRW
        Purpose: Used by FW to know which PHBs to deconfigure based on NVME Backplane
        Data Format: 2x2 array of uint64_t values. The first entry in each array
            is the CCIN of the NVME backplane. The 2nd entry is a bit definition
            to show which PHBs on which Procs are disabled. This is also going to
            emulate the ATTR_PROC_PCIE_PHB_ACTIVE_BASE format. The bit set to 1
            signals the particular PHB is disabled.
                bit 0,1,2: Proc0 Pec0 PHB0/1/2
                bit 3: reserved
                bit 4,5,6: Proc0 Pec1 PHB0/1/2
                bit 7: reserved

                bit 8,9,10: Proc1 Pec0 PHB0/1/2
                bit 11: reserved
                bit 12,13,14: Proc1 Pec1 PHB0/1/2
                bit 15: reserved

                bit 16,17,18: Proc2 Pec0 PHB0/1/2
                bit 19: reserved
                bit 20,21,22: Proc2 Pec1 PHB0/1/2
                bit 23: reserved

                bit 24,25,26: Proc3 Pec0 PHB0/1/2
                bit 27: reserved
                bit 28,29,30: Proc3 Pec1 PHB0/1/2
                bit 31: reserved

                bit 32,33,34: Proc4 Pec0 PHB0/1/2
                bit 35: reserved
                bit 36,37,38: Proc4 Pec1 PHB0/1/2
                bit 39: reserved

                bit 40,41,42: Proc5 Pec0 PHB0/1/2
                bit 43: reserved
                bit 44,45,46: Proc5 Pec1 PHB0/1/2
                bit 47: reserved

                bit 48,49,50: Proc6 Pec0 PHB0/1/2
                bit 52: reserved
                bit 52,53,54: Proc6 Pec1 PHB0/1/2
                bit 55: reserved

                bit 56,57,58: Proc7 Pec0 PHB0/1/2
                bit 59: reserved
                bit 60,61,62: Proc7 Pec1 PHB0/1/2
                bit 63: reserved

           Example: [0x1234, 0x0000, 0x4567, 0x0040080000000000]
                [0x1234, 0x00000000] -- For NVME Backplane with CCIN 0x1234:
                           Do not deconfigure any PHBs on any Procs

                [0x4567, 0x0040080000000000) -- For NVME Backplane with CCIN 0x4567:
                       00 - Do not deconfigure any PHBs on Proc0
                       40 - Deconfigure PHB1 on Proc1 Pec0
                       08 - Deconfigure PHB0 on Proc2 Pec1
                       00 - Do not deconfigure any PHBs on Proc3
                       00 - Do not deconfigure any PHBs on Proc4
                       00 - Do not deconfigure any PHBs on Proc5
                       00 - Do not deconfigure any PHBs on Proc6
                       00 - Do not deconfigure any PHBs on Proc7
    </description>
    <id>PCIE_NVME_PHB_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>2,2</array>
      <uint64_t>
        <default>
            0,0,
            0,0
        </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
  </attribute>

  <attribute>
    <description>
        This attribute indicates if the PEC can be bifurcated. The value is determined from the workbook.
        0 - PEC is not bifurcateable
        1 - PEC can be bifurcated
        Note: Altering the lane map can be done using the HX keyword.
    </description>
    <id>PEC_IS_BIFURCATABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
          This attribute holds the contents of the HX keyword read by the FSP
          from a PCIe card. The keyword data is used to determine the PHB
          bifurcation settings.
          byte    0 = Keyword Version
                        0x00 - Keyword not used, ignore remaining data
                        0x01 - Data describes this enitity's logical PCIe device
                               to physical PCIe lane mapping as one or more
                               logical devices, each connected to a set of PCIe
                               lanes (always an integral multiple of 8 lanes)
          byte    1 = Number of x8 lane set entries X (0 to 7)
                      Each lane set entry is a one-byte value which indicates
                      whether the lane set is used by any logical device, and if
                      used, the logical device ID to which the lane set
                      is assigned, if this byte is zero the remaining keyword
                      data should be ignored.
          bytes 2+N = Lane set entry N
                      where N={0,1..X-1}
                      Each lane set entry maps a set of physical lanes
                      (8*N through N*8+7) to a logical device. Bit 0 indicates
                      whether the lane set is used by a logical device. If used,
                      the next three bits indicate which logical device ID
                      uses those lanes.

                      Bit0:
                         0b0 = Lanes not used by a logical device; ignore
                         0b1 = Lanes used by a logical device; logical device
                               id below is valid
                      Bit 1-3:
                         0b000 = reserved (when bit 0 = 0b0)
                         0b001 -&gt; 0b111
                      Bit 4-7
                      reserved

          Example: bifurcate PEC into 2-x8 devices PHB3 and PHB4
          HX keyword data  kw = { 01 02 B0 C0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = C0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 100 - lane set is assigned to device ID4
              kw[4:8]   - remaining data is ignored


         Example: un-bifurcate a slot which is by default bifurcated
          HX keyword data  kw = { 01 02 B0 B0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = B0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[4:8]   - remaining data is ignored

         HX keyword data must map to a valid slot configuration as defined by
         the system workbook.
    </description>
    <id>PEC_PCIE_HX_KEYWORD_DATA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <array>9</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Effective PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the effective PCIE IOP reversal value after taking into
            account any IOP bifurcations.  If no IOP bifurcations present, this
            is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED
            attribute.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given PEC/lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the PCIE IOP reversal value for cases where the IOP
            is bifurcated
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. The given index in
            the array is a mask which specifies which bit to invert in the lane
            swap settings for the given lane set
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the base PCIE IOP reversal value without considering IOP
            bifurcation.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value for the IOPs in the
            case where they are bifurcated.  The swap value controls how PCIE
            lanes are recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value without considering
            IOP bifurcation.  The swap value controls how PCIE lanes are
            recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask bifurcated configuration
        Creator: MRW
        Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP. For
            instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF
             means the IOP is bifurcated into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask base configuration
        Creator: MRW
        Purpose: Holds the base PCIE lane mask assuming no dynamic IOP
            bifurcations.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP.  For
            instance, lane set 0 value of 0xFFFF and lane set 1 value of 0x0000
            means the PEC is a x16. Lane set 0 value of 0xFF00 and lane
            set 1 value of 0x00FF, means the PEC is split into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <description>Entity path of the peer target of a bus target
    </description>
    <id>PEER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
      <default>physical:na</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Peer target's address of a bus (IOHS) connection.
                 NULL means address 0 for no peer target. If a
                 target instance overrides the default with the
                 peer target's PHYS_PATH. The target compiler will
                 convert the valid PHYS_PATH string into the runtime
                 virtual address of the peer target instance.
    </description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        VCS PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        DD PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>

  <attribute>
    <id>PG</id>
    <description>
    Chiplet Partial good info attribute. Provided by Ring scans
  </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      uint32_t attribute to be used for storing PG state of a PERV
      target during test cases. A 1 bit means the corresponding part
      is deconfigured; a 0 means it is not deconfigured.
    </description>
    <id>PG_SAVED</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF
            </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <id>PIB_I2C_NEST_PLL</id>
    <description>
    i2c pll for the system
    default is 0x26 (For PIB @500 MHz (2 GHz nest)) for
    I2C speed = ~1Mhz per Andreas Koenig.
</description>
    <simpleType>
      <uint32_t>
        <default>0x026</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PIB_I2C_REFCLOCK</id>
    <description>
    i2c reference clock for the system.
    default is 0x4 =&gt; I2C speed = ~1Mhz per Andreas Koenig
</description>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL
      (not an IPL by steps). This is read by Hostboot to determine if it needs
      to request the attribute overrides from HWSV before starting its IPL.
    </description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>PMIC_CALLBACK_STAGGER_TIME</id>
    <description>
        Time between starting calls for health check and telemetry callback setup in
        HBRT, in milliseconds. Default to five minutes each,
        MS_PER_SEC * 60 * 5, 0xFFFFFFFF = disabled
    </description>
    <simpleType>
      <uint32_t>
        <default>300000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PMIC_HEALTH_CHECK_DDR5_TIMER</id>
    <description>
        Time to wait before PHYP makes HBRT callback to handle the
        call to do the PMIC health check DDR5, time in milliseconds,
        default to 6 hours, MS_PER_SEC * 60 * 60 * 6, 0xFFFFFFFF = disabled
    </description>
    <simpleType>
      <uint32_t>
        <default>21600000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PMIC_HEALTH_CHECK_TIMER</id>
    <description>
        Time to wait before PHYP makes HBRT callback to handle the
        call to do the PMIC health check, time in milliseconds,
        default to 24 hours, MS_PER_SEC * 60 * 60 * 24, 0xFFFFFFFF = disabled
    </description>
    <simpleType>
      <uint32_t>
        <default>86400000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Save state of the sfc driver flash workarounds for runtime</description>
    <id>PNOR_FLASH_WORKAROUNDS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>POS_ON_MEM_PORT</id>
    <description>
       Position of this DIMM on its memory port
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      Used to tell PRD to make DD1 OMI x4 degrade logs predictive.
    </description>
    <id>PRD_DD1_OMI_DEGRADE_PREDICTIVE</id>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PRD_HWP_PLID</id>
    <description>
      PRD will perform error isolation for certain errors that may cause a HWP
      to fail. This attribute will be used by the HWP to store the PLID so that
      PRD can subsequently check it for a non-zero value and link the HWP PLID
      to the PRD error log.
    </description>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PREHEAT_PERCENT</id>
    <description>
        The percentage of this DIMM's preheat that affects the associated processor
        socket. (value in 0.01%)
    </description>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <range>
      <min>0</min>
      <max>10000</max>
    </range>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a target's primary capabilities.
        A target can only support at most FSI SCOM and one of the other two SCOM
        types.  Applicable for all targets.  Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support FSI SCOM;
            0b1: Target supports FSI SCOM
            </description>
        <name>supportsFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support XSCOM;
            0b1: Target supports FSI XSCOM</description>
        <name>supportsXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support inband SCOM</description>
        <name>supportsInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes capabilities of a target</description>
    <id>PRIMARY_CAPABILITIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Required Processor Compatibility Setting</description>
    <id>PROC_COMPATIBILITY_REQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PROC_COMPATIBILITY_REQ</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>ALLOW_COMPATIBILITY</default>
    <description>
        Enumeration specifying the compatibility setting for Processor ECs
        ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed
        FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level
        FORCED_NATIVE = set RISK_LEVEL to ECs native setting
    </description>
    <enumerator>
      <name>ALLOW_COMPATIBILITY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCED_COMPATIBILITY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCED_NATIVE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_COMPATIBILITY_REQ</id>
  </enumerationType>

  <attribute>
    <id>PROC_DCM_INSTALLED</id>
    <description>
      PROC_CHIP Attribute
        If true, the chip is installed on a Dual Chip Module
        Provided by the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the PROC_EPS_TABLE_TYPE</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_CAPI_MODE
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE
    </description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>

  <attribute>
    <description>Type of Master, ACTING_MASTER or MASTER_CANDIDATE or
      NOT_MASTER</description>
    <hasStringConversion/>
    <id>PROC_MASTER_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NOT_MASTER</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NOT_MASTER</default>
    <description>
        Enumeration indicating the role of proc as master/alt_master/not_master
    </description>
    <enumerator>
      <name>ACTING_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MASTER_CANDIDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NOT_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>PROC_MASTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration for processor module type that come from HDAT spec
        0x50 = DCM
        0x51 = SCM
    </description>
    <enumerator>
      <name>GODEL</name>
      <value>0x50</value>
    </enumerator>
    <enumerator>
      <name>BLAISE</name>
      <value>0x51</value>
    </enumerator>
    <id>PROC_MODULE_TYPE</id>
  </enumerationType>

  <attribute>
    <id>PROC_MODULE_TYPE</id>
    <description>
      Enumeration of the type of processor module used in the system.
      Expected to be filled out by the MRW and expected to be the same
      for every processor module in the system
    </description>
    <simpleType>
      <enumeration>
        <id>PROC_MODULE_TYPE</id>
      </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>

  <attribute>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <description>PCIE IOP lane configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP lane configuration
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_PCIE_IOVALID_ENABLE</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCIE iovalid enable valid mask
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOVALID_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot
        Creator: MRW
        Purpose: Used by FW to know whether the given PCIE lanes terminate at a
            pluggable slot or not.  If this is the case, and the platform
            supports bifurcation, the card's VPD should be interrogated to
            determine whether to bifurcate the IOP or not.
        Data Format: x4 array of uint8_t values.  The first value indicates
            whether lane set 0 terminates at a pluggable slot.  The
            next three values indicate the same for lane sets 1-3. A value of
            1 at a given array index indicates the lanes terminate at a
            pluggable slot, 0 otherwise.
    </description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen3 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x5454,0x5454,0x5454,0x5454,
            0x5454,0x5454,0x5454,0x5454,
            0x5454,0x5454,0x5454,0x5454,
            0x5454,0x5454,0x5454,0x5454,
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen4 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen5 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN5</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Effective PCIE Lane Mask
        Creator: Firmware
        Purpose: Holds the effective PCIE lane mask of each PEC after taking
            into account any IOP bifurcations. If no IOP bifurcations present,
            this is just the value of the PEC_PCIE_LANE_MASK_NON_BIFURCATED
            attribute
        Data Format: x4 array of uint16_t values.  The uint16_t value is a
            mask for lane 0, the next for lane 1 and so on until lane 3.
            A lane set mask indicates which groups of lanes are assigned to an
            IOP.  For instance, lane set 0 value of 0xFFFF and lane set 1 value
            of 0x0000 for PEC0 means PEC0 is a x16. Lane set 0 value of 0xFF00
            and lane set 2 value of 0x00FF for PEC0, means the IOP is bifurcated
            into two x8s.
    </description>
    <id>PROC_PCIE_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <description>
      This attribute holds the base MRW values that controls the latches required to configure the
      PHBs to swap its lanes if wiring to the connector/device is straight or reverse. On some
      systems Dynamic Bifurcation can occur (based on VPD values or some other indicator) which may
      tweak the value provided in this _BASE attribute and the ATTR_PROC_PCIE_LANE_REVERSAL used by
      the HWP directly. If no dynamic bifurcation occurs the _BASE attribute value and
      ATTR_PROC_PCIE_LANE_REVERSAL will be identical.

      creator: platform
      consumer: p10_pcie_scominit
      firmware notes:
        These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached.

       Attribute Name                     Definition                 Example    Comments                        Targeted HWP Attributes
       ATTR_PROC_PCIE_LANE_REVERSAL_BASE  (Stack0, Stack1, Stack2)   (1, 0, 0)  Reverse lanes on PHB0.          TC_PCI_LANE_CFG_DC_2H
                                                                                Do not reverse lanes on PHB1.   TC_PCI_LANE_CFG_DC_3H
                                                                                Do not reverse lanes on PHB2.   TC_PCI_LANE_CFG_DC_4H

       Register Address      Register Name             Bit    Signal Name                Bit Description
       8000009 / 9000009     TPPCI.PCI.CPLT_CONF1      0      TC_PCI_LANE_CFG_DC_0H      MSB for  LANE CFG  in the logic that configures x16, x8x8, x8x4x4
                                                       1      TC_PCI_LANE_CFG_DC_1H      LSB for LANE CFG  in the logic that configures x16, x8x8, x8x4x4

                                                       2      TC_PCI_SWAP_DC_2H          LANE SWAP control for Stack0
                                                       3      TC_PCI_SWAP_DC_3H          LANE SWAP control for Stack0
                                                       4      TC_PCI_SWAP_DC_4H          LANE SWAP control for Stack0

                                                       8      TC_PCI_IOVALID_DC_8H       IOVALID control for Stack0
                                                       9      TC_PCI_IOVALID_DC_9H       IOVALID control for Stack1
                                                       10     TC_PCI_IOVALID_DC_10H      IOVALID control for Stack2

    </description>
    <global/>
    <id>PROC_PCIE_LANE_REVERSAL_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>
              0x0,0x0,0x0
          </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>PROC_PCIE_NUM_PEC</id>
    <description>
      creator: platform
        Number of PCIe PEC units present on target
        Nimbus: 3
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx loff control
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx loff control for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
      <uint16_t/>
      <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx phase rotator control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx sigdet control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx vga control register3
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx vga control register3.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
      <uint16_t/>
      <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <description>
      This attribute holds the base values from the MRW to define how to configure the PEC as a x16,
      x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. On some systems Dynamic
      Bifurcation can occur (based on VPD values or some other indicator) which may tweak the value
      provided in this _BASE attribute and the ATTR_PROC_PCIE_PHB_ACTIVE used by the HWP directly.
      If no dynamic bifurcation occurs the _BASE attribute value and ATTR_PROC_PCIE_PHB_ACTIVE will
      be identical.

      creator: platform
      consumer: p10_pcie_scominit
      firmware notes:
        These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached.

       Attribute Name                  Definition                Example      Comments       Targeted Register Latches
       ATTR_PROC_PCIE_PHB_ACTIVE_BASE  (Stack0, Stack1, Stack2)  (1, 0, 0)    PHB0 enabled   TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H
                                                                              PHB1 disabled
                                                                              PHB2 disabled

       Register Latch Definition:
       PCI0 / PCI1
       Register Address      Register Name             Bit    Signal Name                Bit Description
       8000009 / 9000009     TPPCI.PCI.CPLT_CONF1      0      TC_PCI_LANE_CFG_DC_0H      MSB for  LANE CFG  in the logic that configures x16, x8x8, x8x4x4
                                                       1      TC_PCI_LANE_CFG_DC_1H      LSB for LANE CFG  in the logic that configures x16, x8x8, x8x4x4

                                                       2      TC_PCI_SWAP_DC_2H          LANE SWAP control for Stack0
                                                       3      TC_PCI_SWAP_DC_3H          LANE SWAP control for Stack0
                                                       4      TC_PCI_SWAP_DC_4H          LANE SWAP control for Stack0

                                                       8      TC_PCI_IOVALID_DC_8H       IOVALID control for Stack0
                                                       9      TC_PCI_IOVALID_DC_9H       IOVALID control for Stack1
                                                       10     TC_PCI_IOVALID_DC_10H      IOVALID control for Stack2

    </description>
    <global/>
    <id>PROC_PCIE_PHB_ACTIVE_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>
              0x1,0x1,0x1
          </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>PROC_PCIE_REFCLOCK_ENABLE</id>
    <description>PCIE refclock enable valid mask
      PCIE refclock enable valid mask
      creator: platform
      consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REFCLOCK_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used to boot a processor</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
  </enumerationType>

  <attribute>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
    <description>
    Specifies which SEEPROM image should be used to boot a processor
      FIRST  - the first image was selected
      SECOND - the second image was selected
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used for the boot master</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
  </enumerationType>

  <attribute>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
    <description>
    Specifies which SEEPROM image should be used for the boot master.
      FIRST  - the first image was selected
      SECOND - the second image was selected
      Platforms are expected to set this to FIRST in normal operation
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base Address of PSI Bridge Logic</description>
    <id>PSI_BRIDGE_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PSIHB - ESB space address - MMIO consumed by PHYP
    </description>
    <id>PSI_HB_ESB_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Raw value of system MTM
    </description>
    <id>RAW_MTM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      The number of reconfig loops allowed due to RCD parity errors when
      recovery is disabled. PRD will make a predictive callout and stop issuing
      reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is
      greater than this value. A value of 0 indicates that no reconfig loops are
      allowed due to RCD parity errors.
    </description>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      PRD will increment this count and issue a reconfig loop each time an RCD
      parity error (recovery disabled) is detected during Memory Diagnostics.
      This value will be cleared at the end of Memory Diagnostics if it is able
      to complete without the need to issue a reconfig loop.
    </description>
    <id>RCD_PARITY_RECONFIG_LOOP_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description> System attribute array that defines the reconfig loop test cases
      consumer: istep dispatcher reconfigLoopTestRunner function
      This array is loaded with data via attribute override. The attribute is
      then read  and then overlayed onto a test case structure.
  </description>
    <id>RECONFIG_LOOP_TESTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>5</array>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Indicates whether reconfigure loop tests are enabled.
        This attribute is set via attribute override
    </description>
    <id>RECONFIG_LOOP_TESTS_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>REDUNDANT_CLOCKS</id>
    <description>
        1 = System has redundant clock oscillators
        0 = System does not have redundant clock oscillators
        From the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>REL_POS</id>
    <description>
        Logical position of this unit/dimm relative to its immediate parent
    </description>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_REL_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Used to tell if a resource is critical to perform an IPL. If this
        attribute is set to 1 and the target is deconfigured, the IPL MUST
        terminate.
    </description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <global/>
  </attribute>

  <attribute>
    <description>Where did the RISK_LEVEL setting originate?
    This is used to make sure the MRW isn't setting an invalid level
    for FORCED_COMPATIBILITY.
    </description>
    <id>RISK_LEVEL_ORIGIN</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>RISK_LEVEL_ORIGIN</id>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>USER</default>
    <description>
        Enumeration specifying what was used to setup the RISK_LEVEL
    </description>
    <enumerator>
      <name>USER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MRW</name>
      <value>1</value>
    </enumerator>
    <id>RISK_LEVEL_ORIGIN</id>
  </enumerationType>

  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of RNG IO Region</description>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Policy indicating whether to perform the maximum amount of memory
            pattern testing possible or not.
        Set to 0x01 to perform the maximum amount of memory pattern testing
            possible.
        Set to 0x00 to perform the default amount of memory pattern testing.
    </description>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Indicates if ODYSSEY HWP are run from inside hostboot, rather than as a chipop.
        This attribute is set via attribute override.
    </description>
    <id>RUN_ODY_HWP_FROM_HOST</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
            uint8_t attribute to be used for storing functional state of a target during
            test cases.
        </description>
    <id>SAVED_STATE_UINT8</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SBE_BOOTLOADER_CODELEVEL</id>
    <description>
      SBE Bootloader code level (hash of the sbe bootloader)
    </description>
    <simpleType>
      <uint8_t/>
      <array>64</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_BUILD_TAG</id>
    <description>
        An ascii value of the SBE build tag
    </description>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>21</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_COMMIT_ID</id>
    <description>
        A hexadecimal value of the commit ID associated
        with the SBE.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_EKB_BUILD_TAG</id>
    <description>
        An ascii value of the SBE EKB build tag
    </description>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>21</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_FIFO_CAPABILITIES</id>
    <description>
        SBE capabilities based on Host_SBE_Interface_Specification
        (Allows for more capabilities than currently supported)
    </description>
    <simpleType>
      <array>40</array>
      <uint32_t>
        <default>
          0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0
        </default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_HANDLES_SMP_TPM_EXTEND</id>
    <description>
        0 = HB handles TPM extend
        1 = SBE handles TPM extend
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_IS_STARTED</id>
    <description>
        If 0, SBE for the processor has not been started.
        Otherwise, SBE for the processor has been started.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Number of SBE capabilities for a given target.
    </description>
    <id>SBE_NUM_CAPABILITIES</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Number of SBE images for a given target.
    </description>
    <id>SBE_NUM_IMAGES</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_RELEASE_TAG</id>
    <description>
        An ascii value of the SBE release tag
    </description>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>21</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_RUNTIME_CODELEVEL</id>
    <description>
      SBE Runtime code level.
    </description>
    <simpleType>
      <uint8_t/>
      <array>64</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_UPDATE_DISABLE</id>
    <description>
      Control execution of updateProcessorSbeSeeproms()

      if 0, enable SBE update of processor SEEPROM
      if 1, disable SBE update of processor SEEPROM

      Consumer:  sbe_update.C

      Default:  0
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>SBE_VERSION_INFO</id>
    <description>
        A hexadecimal value of the major and minor
        version of the SBE.  The major info is in the
        first 16 bits followed by the minor.
        0:15: Major Version
        16:31: Minor Version
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which SCOM to use at a point in
        time.  Only applicable if target supports one or more SCOM types.  Only
        one bit (of the first three) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI SCOM at this time.  0b1: Use FSI
            SCOM at this time</description>
        <name>useFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use XSCOM at this time.  0b1: Use XSCOM at
            this time</description>
        <name>useXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use inband SCOM at this time.  0b1: Use
            inband SCOM at this time</description>
        <name>useInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use SBE SCOM at this time.  0b1: Use
            SBE SCOM at this time</description>
        <name>useSbeScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
          0b0: Do not use I2C SCOM at this time.
          0b1: Use I2C SCOM at this time
        </description>
        <name>useI2cScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use SPI FSI SCOM at this time.  0b1: Use SPI FSI
            SCOM at this time</description>
        <name>useSpiFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>2</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which SCOM path to use</description>
    <id>SCOM_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT32_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT32_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT64_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t attribute
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT64_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT8_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT8_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
    <description>
        To deconfigure a TPM in a secure system - 01 to set TDP bit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>SECURE_VERSION_LOCKIN_POLICY</id>
    <description>
        This policy determines if a new FW Secure Version will be locked into
        the SBE Seeproms during the SBE Update process such that previous
        versions will no longer be supported.
        - 0b0 - (Default) Policy Disabled - Do NOT Lock In Secure Version
        - 0b1 - Policy Enabled - Do Lock In Secure Version
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>The number of minimum secure version currently installed on the system
    </description>
    <id>SECURE_VERSION_NUM</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>SECURE_VERSION_SEEPROM</id>
    <description>
        The value of the FW Secure Version found in the SBE Seeprom
        of the master processor used to boot this node. It will get
        updated, if necessary, by Hostboot on each IPL.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SLOT_INDEX</id>
    <description>PCIe slot index definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SLOT_NAME</id>
    <description>PCIe slot name definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>The amount of SMF memory requested
                 by the user, in bytes (read from NVRAM).
                 The minimum non-zero amount is 256MB.
    </description>
    <id>SMF_MEM_AMT_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SOCKET_POWER_TURBO</id>
    <description>
      The socket power in turbo mode.
      Controls how much power can be used.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>The number of spare cores on this proc chip read from partial good on EQ chiplets</description>
    <id>SPARE_CORES</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains SPARE info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of SPARE data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes of SPARE data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM SPARE info via SPI</description>
    <id>SPI_EEPROM_SPARE_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup VPD info, SBE measurement code, and Keystore.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Offset of the section (always 0 for hardware device)</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The size of the EEPROM in kilobytes</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the RAW value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>0</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the BACKUP MEASUREMENT/MVPD/WOF/SPARSE EEPROM via SPI</description>
    <id>SPI_EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup VPD info, SBE measurement code, and WOF data.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Offset of the section (always 0 for hardware device)</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The size of the EEPROM in kilobytes</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the RAW value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>0</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the PRIMARY MEASUREMENT/MVPD/KEYSTORE EEPROM via SPI</description>
    <id>SPI_EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains keystore info for HOSTBOOT.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_HOSTBOOT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the first partition of keystore info for OPAL.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_OPAL_0</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the second partition of keystore info for OPAL.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_OPAL_1</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the third partition of keystore info for OPAL.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_OPAL_2</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains keystore info for PHYP.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_PHYP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of VPD data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of BACKUP VPD data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the IBM_MVPD value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>3</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM BACKUP MVPD data via SPI</description>
    <id>SPI_MVPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains primary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of VPD data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of PRIMARY VPD in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the IBM_MVPD value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>3</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM PRIMARY MVPD via SPI</description>
    <id>SPI_MVPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup SBE boot code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of backup SBE boot code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of backup SBE boot code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_BOOT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>5</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the SBE backup boot code EEPROM via SPI</description>
    <id>SPI_SBE_BOOT_CODE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains primary SBE boot code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of primary SBE boot code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of primary SBE boot code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_BOOT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>5</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the primary SBE boot code EEPROM via SPI</description>
    <id>SPI_SBE_BOOT_CODE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the backup SBE measurement code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of SBE measurement code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of SBE measurement code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_MEASUREMENT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>6</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the backup SBE measurement code EEPROM via SPI</description>
    <id>SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the primary SBE measurement code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of SBE measurement code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of SBE measurement code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_MEASUREMENT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>6</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the SBE primary measurement code EEPROM via SPI</description>
    <id>SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which SPI access method to use at
        a point in time.  Only one bit (of the first two) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI SPI at this time.  0b1: Use FSI
            SPI at this time</description>
        <name>useFsiSPI</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use PIB SPI at this time.  0b1: Use
            PIB SPI at this time</description>
        <name>usePibSPI</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which SPI access method to use</description>
    <id>SPI_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing of an attached TPM chip via SPI.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI engine that drives the TPM. When
          the SPI_TPM_INFO object is being used, only this field should be edited. All the other
          fields do not change regardless of P10 system.</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x04</default>
        <description>SPI engine for TPM</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM chip via SPI</description>
    <id>SPI_TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains WOF data.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of WOF data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of WOF data + ECC in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the WOF_DATA value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>7</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the WOF data via SPI</description>
    <id>SPI_WOF_DATA_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SPPE_BOOTLOADER_MEASUREMENT_HASH</id>
    <description>
      The measured.hash for the SPPE's bootloader image. Comes from boot.pak
      that is built as part of Odyssey image builds. The measured.hash is included
      in OCMBFW PNOR partition and is used to perform secureboot verification of
      Odysseys during IPL.
    </description>
    <simpleType>
      <uint8_t/>
      <array>64</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SPPE_RUNTIME_MEASUREMENT_HASH</id>
    <description>
       The measured.hash for the SPPE's runtime image. Comes from rt.pak
       that is built as part of Odyssey image builds. The measured.hash is included
       in OCMBFW PNOR partition and is used to perform secureboot verification of
       Odysseys during IPL.
     </description>
    <simpleType>
      <uint8_t/>
      <array>64</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>
         Structure which defines a system's SP functions.
         Applicable for System target only.  Structure is read-only.
         Default values match OpenBMC implementation.
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             If this flag is set then mailboxEnabled MUST also be set

             0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD;
             0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD
            </description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI slave logic, Hostboot must;
             0b1: SP does initialize FSI slave logic so Hostboot should not
            </description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: There is no SP mailbox support;
             0b1: There is SP mailbox support
            </description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI master logic, Hostboot must;
             0b1: SP does initialize FSI master logic so Hostboot should not
            </description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform hardware change detection, Hostboot must;
             0b1: SP does perform hardware change detection (HCDB) so Hostboot should not
            </description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must;
             0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not
            </description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes what the SP is or is not doing in this system
    </description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN</id>
    <description>
      Specifies the starting memory address that corresponds to the TCE Token
      used by the FSP to transfer the PAYLOAD into system memory.
      If 0xFFFFFFFFFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>STOP5_DISABLE</id>
    <description> Control CME response to execution of PowerPC STOP instruction
    if OFF, treat STOP5 as STOP5
    if ON,  treat STOP5 as STOP4

    Producer: ???

    Consumer:  p8_hcode_image_build.C

    Platform default: OFF
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>
        Enumeration indication which Hot Plug Controllers are supported by
        the current system.
    </description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>

  <attribute>
    <description>
      STOP levels supported at runtime (sent to Host via HDAT):
        Bit 0: STOP0 Supported - Quiesce thread only
        Bit 1: STOP1 Supported - P8 Nap
        Bit 2: STOP2 Supported - P8 Fast Sleep
        Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs
        Bit 4: STOP4 supported - P8 Deep Sleep
        Bit 5: STOP5 Supported - WOF-friendly "Instant on"
        Bit 6,7: Reserved
        Bit 8: STOP8 supported - Half Quad Sleep
        Bit 9: STOP9 supported - P8 Fast Winkle
        Bit 10: Reserved
        Bit 11: STOP11 supported - P8 Deep Winkle
        Bit 12-15 : Reserved
        Bits 16..31 - Reserved
  </description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Do we support dynamically updating memory voltages?
        0 = no, 1 = yes
    </description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      If nonzero, will force "hang recovery gte level1" errors to
      checkstop the system after host_ipl_complete.
    </description>
    <id>SW511706_CHECKSTOP_ON_GTE_LV1_HANG</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>SYNC_BETWEEN_STEPS</id>
    <description>
        Attribute to enable targetting attribute sync when in istep mode.
        1 = sync will occur following each substep when ipl'ing in single step mode
        0 = sync will not be done after each step
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        This field is of the form "vendor,name" where the name indicates
        the family of the systems.  The textual portion of the string has
        a maximum length of 63 characters to accommodate a terminating NULL.
        Both vendor and name fields are lower case US ASCII. No special
        characters other than ",", "-", and "+" as described below should
        be used in the string.
    </description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,p10-openbmc</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <id>SYSTEM_THERMAL_RESISTANCE</id>
    <description>
        Used to convert ambient temperature changes to watts to prevent
        exceeding the socket limitations (value in degreesC/Watts * 100)
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        This field is of the form ?vendor,type? where the type indicates
        a type of system within the System Family. The textual portion of
        the string has a maximum length of 63 characters to accommodate a
        terminating NULL. Both vendor and name fields are lower case US
        ASCII. No special characters other than ",", "-", and "+" as described
        below should be used in the string.  If identification of specific
        models within a system type is desired, "-model" should be appended
        to the end of the name. The "-model" portion is optional and could be
        used to identify the packaging, specific model numbers, etc.
        NOTE: No Hostboot code should ever key off of this value.
    </description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <id>SYS_LOCATION_CODE</id>
    <description>
      Location code of the sys
    </description>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile</persistency>
    <no_export/>
    <writeable/>
    <readable/>
  </attribute>

  <attribute>
    <id>TCE_START_TOKEN_FOR_HDAT</id>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      HDAT section into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>TCE_START_TOKEN_FOR_PAYLOAD</id>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      PAYLOAD into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Test attribute; largest string possible given size</description>
    <id>TEST_MAX_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>abc</default>
        <sizeInclNull>4</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Test attribute; smallest string possible given size</description>
    <id>TEST_MIN_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>a</default>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute to test signed attribute
        functionality in the system</description>
    <id>TEST_NEGATIVE_FCN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>-6</default>
      </int8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Test attribute; string with no default supplied</description>
    <id>TEST_NO_DEFAULT_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Test attribute; string with empty default value</description>
    <id>TEST_NULL_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Thread Count</description>
    <id>THREAD_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Time Base frequency in MHZ</description>
    <id>TIME_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x800000</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Data Associative Sets</description>
    <id>TLB_DATA_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Data Entries</description>
    <id>TLB_DATA_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Instruction Associative Sets</description>
    <id>TLB_INSTR_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Instruction Entries</description>
    <id>TLB_INSTR_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Reserve Size in bytes</description>
    <id>TLB_RESERVE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TOD CHIP DATA for each CHIP
        The size of the TOD CHIP DATA must be equal to the sizeof(TodChipData)
    </description>
    <id>TOD_CPU_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>44</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Bitmask indicating what role this chip has in tod topology
    </description>
    <id>TOD_ROLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NON_MASTER</default>
    <description>
        Enumeration indicating what role this chip has in tod topology
    </description>
    <enumerator>
      <name>NON_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>TOD_ROLE</id>
  </enumerationType>

  <attribute>
    <id>TPM_ENABLED</id>
    <description>
        Kill-switch to withhold the use of TPM if any problem is found. HB code will not be updating
        this attribute.
        0: TPM is not enabled
        1: TPM is enabled
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>TPM_POISONED</id>
    <description>
        A flag indicating whether the TPM has been poisoned. A poisoned TPM
        has a random number extended into its PCR but not mirrorred to its
        log. That creates a disconnection between the TPM and its log, which
        in turn makes it impossible to perform remote attestation on the TPM.
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Setting to require(0x1) or not require(0x0) a functional TPM to
        boot the system.
    </description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <id>TPM_UNUSABLE</id>
    <description>
        Indicates whether the TPM is unusable. Hostboot should not read this
        value for any purpose other than tracing. This value should only be
        written to when there is a certainty that the TPM is not usable.
        This attribute is consumed by FSP during alignment check to determine
        the optimal boot configuration. This attribute can be removed if TPM
        gard is ever supported.
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion/>
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>PMIC</name>
      <value>78</value>
    </enumerator>
    <enumerator>
      <name>NMMU</name>
      <value>79</value>
    </enumerator>
    <enumerator>
      <name>PAU</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>IOHS</name>
      <value>81</value>
    </enumerator>
    <enumerator>
      <name>PAUC</name>
      <value>82</value>
    </enumerator>
    <enumerator>
      <name>FC</name>
      <value>83</value>
    </enumerator>
    <enumerator>
      <name>LPCREFCLKENDPT</name>
      <value>84</value>
    </enumerator>
    <enumerator>
      <name>GENERIC_I2C_DEVICE</name>
      <value>85</value>
    </enumerator>
    <enumerator>
      <name>MDS_CTLR</name>
      <value>86</value>
    </enumerator>
    <enumerator>
      <name>DCM</name>
      <value>87</value>
    </enumerator>
    <!-- gap left on purpose -->
    <enumerator>
      <name>POWER_IC</name>
      <value>102</value>
    </enumerator>
    <enumerator>
      <name>TEMP_SENSOR</name>
      <value>103</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>104</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>

  <attribute>
    <id>UCD_MFR_REVISION_OVERRIDE</id>
    <description>
        If non-zero then use value as the discovered MFR_REVISION value from
        the UCD device rather than the actual value from the device.
    </description>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      The ultra turbo frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V and is calculated as
      the minimum of the ultra turbo frequencies.
    </description>
    <id>ULTRA_TURBO_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_ULTRA_TURBO_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Indicator to Host Firmware to use the 11S SPD data
        for Part Number and Serial Number in DDIMM SPD instead
        of the standard location.
    </description>
    <id>USE_11S_SPD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Indicates if the ODYSSEY PIPE FIFO is available.
    </description>
    <id>USE_PIPE_FIFO</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>USE_TCES_FOR_DMAS</id>
    <description>
      Specifies whether or not the FSP is ready for Hostboot to enable TCEs
      for DMAs for the given IPL.  This is a temporary attribute which will
      be used to phase-in TCE support.
      If 0, DO NOT use TCEs;
      If 1, use TCEs
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Memory VCS voltage domain ID.  All memory buffers in the same VCS
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Voltage Memory Rail Manager ID.  Currently HB only needs
        to configured the Vddr voltage rail manager during the IPL.  The ID
        is an arbitary value and needed as correlation token between HB and
        HWSV.  It will be generated by the MRW processing scripts.
    </description>
    <id>VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory VDD voltage domain ID.  All memory buffers in the same VDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>

  <attribute>
    <id>VENDOR_ID</id>
    <description>PCIe vendor ID definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Record offset for this target's VPD</description>
    <id>VPD_REC_NUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0xFFFF</default>
      </uint16_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory VPP voltage domain ID.  All memory buffers in the same VPP
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System control to set the power limit for Workload Optimized
      Frequency (WOF) algorithms.  This is used to select the
      proper VFRT tables.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>

  <attribute>
    <id>WOF_TABLE_LID_NUMBER</id>
    <description>
      LID id used to load tables for Workload Optimized
      Frequency (WOF) algorithms.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <simpleType>
      <uint32_t>
        <!-- @todo-RTC:172776-Get rid of default value that points to ZZ -->
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>XIVE - Controller Bar address
        MMIO consumed by PHYP
    </description>
    <id>XIVE_CONTROLLER_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>XSCOM base address</description>
    <id>XSCOM_BASE_ADDRESS</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <no_export/>
  </attribute>

</attributes>
