<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types.xml $        -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2012,2017                        -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->

<attributes>

<!-- =====================================================================
     HOST BOOT ATTRIBUTE TYPES
     Contains the definition of all hostboot attributes which can be synced
     to/from FSP
     ================================================================= -->

<enumerationType>
    <id>CLASS</id>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>CARD</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>ENC</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>CHIP</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>UNIT</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>DEV</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>SYS</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>LOGICAL_CARD</name>
        <value>7</value>
    </enumerator>
    <enumerator>
        <name>BATTERY</name>
        <value>8</value>
    </enumerator>
    <enumerator>
        <name>LED</name>
        <value>9</value>
    </enumerator>
    <enumerator>
        <name>MAX</name>
        <value>10</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<!-- The script genHwsvMrwXml.pl hardcodes the HUID type field to match
     these values and should be kept in sync. Leave holes in in the range
     if a type is deleted. Not changing the values keeps the values
     consistent over builds making them easier to recognize.  -->
<enumerationType>
    <id>TYPE</id>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>SYS</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>NODE</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>DIMM</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>MEMBUF</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>PROC</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>EX</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>CORE</name>
        <value>7</value>
    </enumerator>
    <enumerator>
        <name>L2</name>
        <value>8</value>
    </enumerator>
    <enumerator>
        <name>L3</name>
        <value>9</value>
    </enumerator>
    <enumerator>
        <name>L4</name>
        <value>10</value>
    </enumerator>
    <enumerator>
        <name>MCS</name>
        <value>11</value>
    </enumerator>
    <enumerator>
        <name>MBA</name>
        <value>13</value>
    </enumerator>
    <enumerator>
        <name>XBUS</name>
        <value>14</value>
    </enumerator>
    <enumerator>
        <name>ABUS</name>
        <value>15</value>
    </enumerator>
    <enumerator>
        <name>PCI</name>
        <value>16</value>
    </enumerator>
    <enumerator>
        <name>DPSS</name>
        <value>17</value>
    </enumerator>
    <enumerator>
        <name>APSS</name>
        <value>18</value>
    </enumerator>
    <enumerator>
        <name>OCC</name>
        <value>19</value>
    </enumerator>
    <enumerator>
        <name>PSI</name>
        <value>20</value>
    </enumerator>
    <enumerator>
        <name>FSP</name>
        <value>21</value>
    </enumerator>
    <enumerator>
        <name>PNOR</name>
        <value>22</value>
    </enumerator>
    <enumerator>
        <name>OSC</name>
        <value>23</value>
    </enumerator>
    <enumerator>
        <name>TODCLK</name>
        <value>24</value>
    </enumerator>
    <enumerator>
        <name>CONTROL_NODE</name>
        <value>25</value>
    </enumerator>
    <enumerator>
        <name>OSCREFCLK</name>
        <value>26</value>
    </enumerator>
    <enumerator>
        <name>OSCPCICLK</name>
        <value>27</value>
    </enumerator>
    <enumerator>
        <name>REFCLKENDPT</name>
        <value>28</value>
    </enumerator>
    <enumerator>
        <name>PCICLKENDPT</name>
        <value>29</value>
    </enumerator>
    <enumerator>
        <name>NX</name>
        <value>30</value>
    </enumerator>
    <enumerator>
        <name>PORE</name>
        <value>31</value>
    </enumerator>
    <enumerator>
        <name>PCIESWITCH</name>
        <value>32</value>
    </enumerator>
    <enumerator>
        <name>CAPP</name>
        <value>33</value>
    </enumerator>
    <enumerator>
        <name>FSI</name>
        <value>34</value>
    </enumerator>
    <!-- Add P9 targets -->
    <enumerator>
        <name>EQ</name>
        <value>35</value>
    </enumerator>
    <enumerator>
        <name>MCA</name>
        <value>36</value>
    </enumerator>
    <enumerator>
        <name>MCBIST</name>
        <value>37</value>
    </enumerator>
    <enumerator>
        <name>MI</name>
        <value>38</value>
    </enumerator>
    <enumerator>
        <name>DMI</name>
        <value>39</value>
    </enumerator>
    <enumerator>
        <name>OBUS</name>
        <value>40</value>
    </enumerator>
    <enumerator>
        <name>NV</name>
        <value>41</value>
    </enumerator>
    <enumerator>
        <name>SBE</name>
        <value>42</value>
    </enumerator>
    <enumerator>
        <name>PPE</name>
        <value>43</value>
    </enumerator>
    <enumerator>
        <name>PERV</name>
        <value>44</value>
    </enumerator>
    <enumerator>
        <name>PEC</name>
        <value>45</value>
    </enumerator>
    <enumerator>
        <name>PHB</name>
        <value>46</value>
    </enumerator>
    <enumerator>
        <name>SYSREFCLKENDPT</name>
        <value>47</value>
    </enumerator>
    <enumerator>
        <name>MFREFCLKENDPT</name>
        <value>48</value>
    </enumerator>
    <enumerator>
        <name>TPM</name>
        <value>49</value>
    </enumerator>
    <enumerator>
        <name>SP</name>
        <value>50</value>
    </enumerator>
    <enumerator>
        <name>UART</name>
        <value>51</value>
    </enumerator>
    <enumerator>
        <name>PS</name>
        <value>52</value>
    </enumerator>
    <enumerator>
        <name>FAN</name>
        <value>53</value>
    </enumerator>
    <enumerator>
        <name>VRM</name>
        <value>54</value>
    </enumerator>
    <enumerator>
        <name>USB</name>
        <value>55</value>
    </enumerator>
    <enumerator>
        <name>ETH</name>
        <value>56</value>
    </enumerator>
    <enumerator>
        <name>PANEL</name>
        <value>57</value>
    </enumerator>
   <enumerator>
        <name>BMC</name>
        <value>58</value>
    </enumerator>
    <enumerator>
        <name>FLASH</name>
        <value>59</value>
    </enumerator>
    <enumerator>
        <name>SEEPROM</name>
        <value>60</value>
    </enumerator>
    <enumerator>
        <name>TMP</name>
        <value>61</value>
    </enumerator>
    <enumerator>
        <name>GPIO_EXPANDER</name>
        <value>62</value>
    </enumerator>
    <enumerator>
        <name>POWER_SEQUENCER</name>
        <value>63</value>
    </enumerator>
    <enumerator>
        <name>RTC</name>
        <value>64</value>
    </enumerator>
    <enumerator>
        <name>FANCTLR</name>
        <value>65</value>
    </enumerator>
    <!-- add any new types here, and increment TEST_FAIL and LAST_IN_RANGE -->
    <enumerator>
        <name>TEST_FAIL</name>
        <value>66</value>
    </enumerator>
    <enumerator>
        <name>LAST_IN_RANGE</name>
        <value>67</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<enumerationType>
    <id>MODEL</id>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>RESERVED</name><!-- Left here to keep later values the same -->
        <value>16</value>
    </enumerator>
    <enumerator>
        <name>VENICE</name>
    </enumerator>
    <enumerator>
        <name>MURANO</name>
    </enumerator>
    <enumerator>
        <name>NAPLES</name>
    </enumerator>
    <enumerator>
        <name>NIMBUS</name>
    </enumerator>
    <enumerator>
        <name>CUMULUS</name>
    </enumerator>
    <enumerator>
        <name>CENTAUR</name>
        <value>48</value>
    </enumerator>
    <enumerator>
        <name>JEDEC</name>
        <value>80</value>
    </enumerator>
    <enumerator>
        <name>CDIMM</name>
    </enumerator>
    <!-- POWER8 is system/node model, not processor chip level -->
    <enumerator>
        <name>POWER8</name>
        <value>112</value>
    </enumerator>
    <!-- POWER9 is system/node model, not processor chip level -->
    <enumerator>
        <name>POWER9</name>
        <value>144</value>
    </enumerator>
    <enumerator>
        <name>CECTPM</name>
    </enumerator>
    <enumerator>
        <name>BMC</name>
    </enumerator>
    <default>NA</default>
</enumerationType>

<enumerationType>
    <id>ENGINE_TYPE</id>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>ENGINE_IIC</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>ENGINE_SCOM</name>
        <value>2</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<enumerationType>
    <id>FSI_MASTER_TYPE</id>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
        <name>MFSI</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>CMFSI</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>NO_MASTER</name>
        <value>2</value>
    </enumerator>
    <default>NO_MASTER</default>
</enumerationType>

<attribute>
    <id>CLASS</id>
    <description>Attribute indicating the target's class</description>
    <simpleType>
        <enumeration>
            <id>CLASS</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>TYPE</id>
    <description>Attribute indicating the target's type</description>
    <simpleType>
        <enumeration>
            <id>TYPE</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>MODEL</id>
    <description>Attribute indicating the target's model</description>
    <simpleType>
        <enumeration>
            <id>MODEL</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>ENGINE_TYPE</id>
    <description>Attribute indicating the target's engine type</description>
    <simpleType>
        <enumeration>
            <id>ENGINE_TYPE</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>
<attribute>
    <id>SCRATCH_UINT8_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT8_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int8_t>
        </int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT8_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT8_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int8_t>
        </int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT8_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT16_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint16_t>
        </uint16_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT16_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>SCRATCH_UINT16_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint16_t>
        </uint16_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT16_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT16_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int16_t>
        </int16_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT16_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>SCRATCH_INT16_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int16_t>
        </int16_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT16_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT32_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT32_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT32_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT32_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT64_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int64_t>
        </int64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT64_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT64_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int64_t>
        </int64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT64_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>32</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2, 3, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT8_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int8_t>
        </int8_t>
        <array>32</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT8_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT8_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int8_t>
        </int8_t>
        <array>2, 3, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT8_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT16_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT16_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT16_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2, 3, 2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT16_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT16_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int16_t>
        </int16_t>
        <array>16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT16_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT16_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int16_t>
        </int16_t>
        <array>2, 3, 2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT16_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>8</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,3</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT32_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int32_t>
        </int32_t>
        <array>8</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT32_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT32_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int32_t>
        </int32_t>
        <array>2,3</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT32_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>SCRATCH_UINT64_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT64_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int64_t>
        </int64_t>
        <array>4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT64_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_INT64_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <int64_t>
        </int64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_INT64_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DUMMY_RW</id>
    <description>Dummy attribute with read/write permissions</description>
    <simpleType>
        <uint8_t>
            <default>5</default>
        </uint8_t>
        <array>1,3,5</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DUMMY_SCRATCH_PLAT_INIT_UINT8</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DUMMY_WO</id>
    <description>Dummy attribute with write-only permissions</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
</attribute>

<attribute>
    <id>DUMMY_RO</id>
    <description>Dummy attribute with read-only permissions</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DUMMY_HEAP_ZERO_DEFAULT</id>
    <description>Dummy attribute on the heap with zero initialization</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PHYS_PATH</id>
    <description>Physical hierarchical path to the target</description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>AFFINITY_PATH</id>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>POWER_PATH</id>
    <description>Hierarchical path to the target with respect to power</description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PRIMARY_CAPABILITIES</id>
    <description>Attribute which describes capabilities of a target</description>
    <complexType>
        <description>Structure which defines a target's primary capabilities.
        A target can only support at most FSI SCOM and one of the other two SCOM
        types.  Applicable for all targets.  Structure is read-only.
        </description>
        <field>
            <name>supportsFsiScom</name>
            <description>0b0: Target does not support FSI SCOM;
            0b1: Target supports FSI SCOM
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>supportsXscom</name>
            <description>0b0: Target does not support XSCOM;
            0b1: Target supports FSI XSCOM</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>supportsInbandScom</name>
            <description>0b0: Target does not support inband SCOM</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint8_t</type>
            <bits>5</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>CPU_ATTR</id>
    <description>CPU Attribute</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>SCOM_SWITCHES</id>
    <description>Attribute storing information about which SCOM path to use</description>
    <complexType>
        <description>Structure which defines which SCOM to use at a point in
        time.  Only applicable if target supports one or more SCOM types.  Only
        one bit (of the first three) can ever be set at any one time.
        </description>
        <field>
            <name>useFsiScom</name>
            <description>0b0: Do not use FSI SCOM at this time.  0b1: Use FSI
            SCOM at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>useXscom</name>
            <description>0b0: Do not use XSCOM at this time.  0b1: Use XSCOM at
            this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>useInbandScom</name>
            <description>0b0: Do not use inband SCOM at this time.  0b1: Use
            inband SCOM at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>useSbeScom</name>
            <description>0b0: Do not use SBE SCOM at this time.  0b1: Use
            SBE SCOM at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future expansion</description>
            <type>uint8_t</type>
            <bits>4</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FSI_MASTER_CHIP</id>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the default master processor</description>
    <nativeType>
        <name>EntityPath</name>
        <default>physical:sys-0</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ALTFSI_MASTER_CHIP</id>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the alternate master processor</description>
    <nativeType>
        <name>EntityPath</name>
        <default>physical:sys-0</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FSI_MASTER_TYPE</id>
    <description>Type of Master FSI connection to this slave (MFSI or cMFSI)</description>
    <simpleType>
        <enumeration>
            <id>FSI_MASTER_TYPE</id>
            <default>NO_MASTER</default>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
</attribute>

<attribute>
    <id>FSI_MASTER_PORT</id>
    <description>Which port is this chip hanging off of when booting from the default master processor</description>
    <simpleType>
        <uint8_t>
            <default>0xFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ALTFSI_MASTER_PORT</id>
    <description>Which port is this chip hanging off of when booting from the alternate master processor</description>
    <simpleType>
        <uint8_t>
            <default>0xFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>I2C_SLAVE_ADDRESS</id>
     <description>I2C Slave Address</description>
     <simpleType>
       <uint8_t>
         <default>0x00</default>
       </uint8_t>
     </simpleType>
     <persistency>non-volatile</persistency>
     <readable/>
     <hwpfToHbAttrMap>
        <id>ATTR_I2C_SLAVE_ADDRESS</id>
        <macro>DIRECT</macro>
     </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSI_SLAVE_CASCADE</id>
    <description>Slave cascade position</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FSI_OPTION_FLAGS</id>
    <description>
        Reserved for any special flags we might need to access FSI
    </description>
    <complexType>
        <description>FSI flags</description>
        <field>
            <name>flipPort</name>
            <description>
                Set on FSI master chips (procs) if that chip uses slaveB
                to attach to the acting master chip.
            </description>
            <type>uint16_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future expansion</description>
            <type>uint16_t</type>
            <bits>15</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EXECUTION_PLATFORM</id>
    <description>
        Which execution platform the HW Procedure is running on
        Some HWPs (e.g. special wakeup) use different registers for different
          platforms to avoid arbitration problems when multiple platforms do
          the same thing concurrently
        HOST = 0x01, FSP = 0x02, OCC = 0x03
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EXECUTION_PLATFORM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IS_SIMULATION</id>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IS_SIMULATION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HWAS_STATE</id>
    <description>HardWare Availability Service State Attribute.
        Keeps track of Target values poweredOn, present, functional</description>
    <complexType>
        <description>struct - 4 booleans and a PLID</description>
        <field>
            <name>deconfiguredByEid</name>
            <description>if this target was deconfigured,
                this will be a special DECONFIGURED_BY_ enum,
                OR it will be the errlog EID that caused it,
                either directly or by association,
            </description>
            <type>uint32_t</type>
            <default>0</default>
        </field>
        <field>
            <name>poweredOn</name>
            <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>present</name>
            <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>functional</name>
            <description>
             0b0: Target is not functional;
             0b1: Target is functional
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>dumpfunctional</name>
            <description>FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>specdeconfig</name>
            <description>Set for speculative deconfig;
             0b0: target not speculative deconfig;
             0b1: target is speculatively deconfigured;
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <description>HardWare Availability Service State Changed Attribute.
        Keeps track of changedSinceChecked state, indicates if the
        target has changed since last checked by the appropriate service.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <simpleType>
        <uint64_t>
            <default>0x0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <description>HardWare Availability Service State Changed Mask.
        Used when a target changes (ie, via HCDB change) to set the
        HWAS_STATE_CHANGED_FLAG, so that the appropriate services will
        all handle the change.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <simpleType>
        <uint64_t>
            <default>0x0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>HWAS_CHANGED_BIT</id>
    <description>Enumeration indicating the services that are concerned
        with target changes (ie, via HCDB change).
        The values can be combined using a bitwise 'OR'.
    </description>
    <enumerator>
        <name>GARD</name>
        <value>0x00000001</value>
    </enumerator>
    <enumerator>
        <name>MEMDIAG</name>
        <value>0x00000002</value>
    </enumerator>
    <enumerator>
        <name>PSIDIAG</name>
        <value>0x00000004</value>
    </enumerator>
    <!-- combination of all DIAG values -->
    <!-- if you add a DIAG flag above, add the bit in the mask below -->
    <enumerator>
        <name>DIAG_MASK</name>
        <value>0x00000006</value>
    </enumerator>
    <enumerator>
       <name>HOSTSVC_HBEL</name>
       <value>0x00000008</value>
    </enumerator>
</enumerationType>

<!-- For POD Testing -->
<attribute>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <description>Attribute which tests numeric POD types</description>
    <complexType>
        <description>Numeric POD type test structure</description>
        <field>
            <name>fsiPath</name>
            <description>Entity path for testing purposes</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>className</name>
            <description>Class for testing purposes</description>
            <type>CLASS</type>
            <default>CHIP</default>
        </field>
        <field>
            <name>uint8</name>
            <description>Test uint8</description>
            <type>uint8_t</type>
            <default>0xAB</default>
        </field>
        <field>
            <name>uint16</name>
            <description>Test uint16</description>
            <type>uint16_t</type>
            <default>0xABCD</default>
        </field>
        <field>
            <name>uint32</name>
            <description>Test uint32</description>
            <type>uint32_t</type>
            <default>0xABCDEF01</default>
        </field>
        <field>
            <name>uint64</name>
            <description>Test uint64</description>
            <type>uint64_t</type>
            <default>0xABCDEF0123456789</default>
        </field>
        <field>
            <name>int8</name>
            <description>Test int8</description>
            <type>int8_t</type>
            <default>-124</default>
        </field>
        <field>
            <name>int16</name>
            <description>Test int16</description>
            <type>int16_t</type>
            <default>-32764</default>
        </field>
        <field>
            <name>int32</name>
            <description>Test int32</description>
            <type>int32_t</type>
            <default>-2147483644</default>
        </field>
        <field>
            <name>int64</name>
            <description>Test int64</description>
            <type>int64_t</type>
            <default>-9223372036854775804</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DECONFIG_GARDABLE</id>
    <description>If the Target is directly deconfigurable and GARDable; target
    may still be deconfigured in 'by association' processing.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ISTEP_MODE</id>
    <description>If True, puts HostBoot into SPLess SingleStep mode.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ISTEP_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <description>Information needed to address the EEPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>
                The number of bytes a device requires to set its
                internal address/offset. DDR4 DIMMs require a special EEPROM
                page switching mechanic denoted here by a value of 1
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>chipCount</name>
            <description>The number of chips making up an eeprom device.
            </description>
            <type>uint8_t</type>
            <default>0x01</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0xA</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <description>Information needed to address the EERPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>chipCount</name>
            <description>The number of chips making up an eeprom device.
            </description>
            <type>uint8_t</type>
            <default>0x01</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0xA</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <description>Information needed to address the EERPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x100</default>
        </field>
        <field>
            <name>chipCount</name>
            <description>The number of chips making up an eeprom device.
            </description>
            <type>uint8_t</type>
            <default>0x04</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <description>Information needed to address the EERPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x100</default>
        </field>
        <field>
            <name>chipCount</name>
            <description>The number of chips making up an eeprom device.
            </description>
            <type>uint8_t</type>
            <default>0x04</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TPM_INFO</id>
    <description>Information needed to address the TPM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     TPM.</description>
        <field>
            <name>tpmEnabled</name>
            <description>Boolean indicating whether this TPM is available
              in the system</description>
            <type>uint8_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x01</default>
        </field>
        <field>
            <name>devAddrLocality0</name>
            <description>Device address on the I2C bus for Locality 0.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
            <type>uint8_t</type>
            <default>0xAE</default>
        </field>
        <field>
            <name>devAddrLocality1</name>
            <description>Device address on the I2C bus for Locality 1.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
            <type>uint8_t</type>
            <default>0xA8</default>
        </field>
        <field>
            <name>devAddrLocality2</name>
            <description>Device address on the I2C bus for Locality 2.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
            <type>uint8_t</type>
            <default>0xAA</default>
        </field>
        <field>
            <name>devAddrLocality3</name>
            <description>Device address on the I2C bus for Locality 3.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
            <type>uint8_t</type>
            <default>0xA4</default>
        </field>
        <field>
            <name>devAddrLocality4</name>
            <description>Device address on the I2C bus for Locality 4.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
            <type>uint8_t</type>
            <default>0xA6</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x00</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x01</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EC</id>
    <description>attribute indicating the chip target's EC level</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
       <id>ATTR_EC</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HDAT_EC</id>
    <description>
       Indicates the chip's EC level, distinct from ATTR_EC to handle
       non-standard mini-ECs, e.g. 1.01, separate from the real
       hardware-defined EC level.  By default, ATTR_HDAT_EC==ATTR_EC
       unless the chip has a mini-EC.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MINI_EC</id>
    <description>
       Specifies extra mini-EC versions beyond the standard Major.Minor
       Ex. 1.04 -> ATTR_EC=0x10, ATTR_MINI_EC=4
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
       <id>ATTR_MINI_EC</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_ID</id>
    <description>attribute indicating the chip's ID</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
       <id>ATTR_CHIP_ID</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSI_GP_REG_SCOM_ACCESS</id>
    <description>attribute indicating if the chip's FSI GP regs have scom access</description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
       <id>ATTR_FSI_GP_REG_SCOM_ACCESS</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_R_T0_EPS</id>
    <description>L2 tier0 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_R_T0_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_R_T1_EPS</id>
    <description>L2 tier1 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_R_T1_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_R_T2_EPS</id>
    <description>L2 tier2 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_FORCE_R_T2_EPS</id>
    <description>L2 force tier2 read epsilon protect (all tiers).</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_FORCE_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_W_EPS</id>
    <description>L2 write epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_W_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_R_T0_EPS</id>
    <description>L3 tier0 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_R_T0_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_R_T1_EPS</id>
    <description>L3 tier1 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_R_T1_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_R_T2_EPS</id>
    <description>L3 tier2 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_FORCE_R_T2_EPS</id>
    <description>L3 force tier2 read epsilon protect (all tiers).</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_FORCE_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_W_EPS</id>
    <description>L3 write epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_W_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_UNIT</id>
    <description>A unit (chiplet) 's  offset number within the chip. </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CHIP_UNIT_POS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>POSITION</id>
    <description>Position of target relative to node</description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MBA_PORT</id>
    <description>MBA port this DIMM is connected to</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MBA_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MBA_DIMM</id>
    <description>MBA port DIMM number of this DIMM</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MBA_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CEN_DQ_TO_DIMM_CONN_DQ</id>
    <description>
        Centaur DQ to DIMM connector DQ mapping for a JEDEC DIMM.
        Uint8 value for each Centaur DQ (0-79).
        The value is the corresponding DIMM Connector DQ.
    </description>
    <simpleType>
        <uint8_t>
            <!-- Default is 1:1 mapping, DQ0-DQ0, DQ1-DQ1 etc -->
            <!-- Data will eventually come from MRW -->
            <default>
                0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
                20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
                40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
                60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
            </default>
        </uint8_t>
        <array>80</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>PROC_EPS_TABLE_TYPE</id>
    <description>Enumeration indicating the PROC_EPS_TABLE_TYPE</description>
    <enumerator>
        <name>EPS_TYPE_LE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>EPS_TYPE_HE</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_EPS_TABLE_TYPE</id>
    <description>
        System attribute.
        Processor epsilon table type. Used to calculate the processor nest
        epsilon register values.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_EPS_TABLE_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <description>Enumeration indicating the PROC_FABRIC_PUMP_MODE</description>
    <enumerator>
        <name>MODE1</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>MODE2</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <description>
        System attribute.
        Processor SMP Fabric broadcast scope configuration.
        MODE1 = default = chip/group/system/remote group/foreign.
        MODE2 = group/system/remote group/foreign.
        Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <description>
        System attribute.
        If all MCS chiplets are in an interleaving group (1=true, 0=false).
        - If true the SMP fabric is setup in normal mode and multiple MCSs
          are grouped (disallowing systems with memory only under 1 MCS
          (i.e. systems with a single C-DIMM))
        - If false the SMP fabric is setup in checkerboard mode.
        Provided by the Machine Readable Workbook.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
        <uint8_t>
            <default>0x00</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ALL_MCS_IN_INTERLEAVING_GROUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FABRIC_NODE_ID</id>
    <description>
        DEPRECATED!!!!
        Chip attribute.
        Logical fabric node the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <simpleType><uint8_t>
        <default>0</default>
    </uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FABRIC_NODE_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FABRIC_GROUP_ID</id>
    <description>
        Chip attribute.
        Logical fabric group the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FABRIC_GROUP_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_EFF_FABRIC_GROUP_ID</id>
    <description>
    Effective fabric group ID associated with this chip.
    Directly drives programming of chip memory map layout.
    Compared with ATTR_PROC_FABRIC_GROUP_ID to configure FBC XOR masking.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_EFF_FABRIC_GROUP_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FABRIC_CHIP_ID</id>
    <description>
        Chip attribute.
        Logical fabric chip id for this chip (position within the fabric).
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FABRIC_CHIP_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_EFF_FABRIC_CHIP_ID</id>
    <description>
    Effective fabric chip ID associated with this chip.
    Directly drives programming of chip memory map layout.
    Compared with ATTR_PROC_FABRIC_CHIP_ID to configure FBC XOR masking.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_EFF_FABRIC_CHIP_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_HAS_SBE</id>
    <description>
        Chip attribute.
        If true, the chip has an SBE and the associated registers.
        Provided by the Machine Readable Workbook.
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CHIP_HAS_SBE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_PROC_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the processor refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PROC_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_PROC_REFCLOCK_KHZ</id>
    <description>
        System attribute.
        The frequency of the processor refclock in KHz.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PROC_REFCLOCK_KHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_MEM_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the memory refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_MEM_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MIN_FREQ_MHZ</id>
    <description>
        System attribute.
        The lowest frequency that a core can be set to in MHz.
        This is the same for all cores in the system.
        Data is provided by MVPD #V and is calculated as the
        Maximum of the power save frequencies.
    </description>
    <simpleType>
        <uint32_t>
            <default>4800</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_FLOOR_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DPO_MIN_FREQ_PERCENT</id>
    <description>
        Defines a negative percentage value that is applied to
        the ATTR_NOMINAL_FREQ_MHZ determined from MVPD #V.  It
        is used to explicitly raise the value of MIN_FREQ_MHZ above
        what is specified by MVPD #V data.  On FSP systems this
        is sourced from the power_management def file.
        Value must be between 0 and 100.
        A value of zero indicates no override.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FREQ_PB_MHZ</id>
    <description>
        System attribute.
        The frequency of a processor's PB chiplet in MHz.
        This is the same for all PB chiplets in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PB_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_A_MHZ</id>
    <description>
        System attribute.
        The frequency of a processor's A-bus chiplet in MHz.
        This is the same for all A-bus chiplets in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t>
        <default>0x1900</default>
    </uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_A_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_X_MHZ</id>
    <description>
        System attribute.
        The frequency of a processor's X-bus chiplet in MHz.
        This is the same for all X-bus chiplets in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_X_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HUID</id>
    <description>
        Hardware Unit ID
        SSSSNNNNTTTTTTTTiiiiiiiiiiiiiiii
        S=System
        N=Node Number
        T=Target Type (matches TYPE attribute)
        i=Instance/Sequence number of target, relative to node
    </description>
    <simpleType>
        <uint32_t></uint32_t>
        <default>0xFFFFFFFF</default>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>
<attribute>
    <id>SP_FUNCTIONS</id>
    <description>
      Attribute which describes what the SP is or is not doing in this system
    </description>
    <complexType>
        <description>Structure which defines a system's SP functions.
         Applicable for System target only.  Structure is read-only.
        </description>
        <field>
            <name>baseServices</name>
            <description>
             If this flag is set then mailboxEnabled MUST also be set

             0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD;
             0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>fsiSlaveInit</name>
            <description>
             0b0: SP does not initialize FSI slave logic, Hostboot must;
             0b1: SP does initialize FSI slave logic so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>mailboxEnabled</name>
            <description>
             0b0: There is no SP mailbox support;
             0b1: There is SP mailbox support
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>fsiMasterInit</name>
            <description>
             0b0: SP does not initialize FSI master logic, Hostboot must;
             0b1: SP does initialize FSI master logic so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>hardwareChangeDetection</name>
            <description>
             0b0: SP does not perform hardware change detection, Hostboot must;
             0b1: SP does perform hardware change detection (HCDB) so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>powerLineDisturbance</name>
            <description>
             0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must;
             0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint32_t</type>
            <bits>26</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>HB_SETTINGS</id>
    <description>
      Attribute which describes how the SP has configured features in
      Hostboot.
    </description>
    <complexType>
        <description>Structure which defines a system's HB settings.
         Applicable for System target only.
        </description>
        <field>
            <name>traceContinuous</name>
            <description>
            Enable / Disable continuous trace.
                0b0: Continuous trace is disabled.
                0b1: Continuous trace is enabled.
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>traceScanDebug</name>
            <description>
            Override trace debug selection for SCAN component.
                0b0: TRACS entries for SCAN have default behavior.
                0b1: TRACS entries for SCAN are enabled.
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>traceFapiDebug</name>
            <description>
            Override trace debug selection for DBG component.
                0b0: TRACS entries for DBG have default behavior.
                0b1: TRACS entries for DBG are enabled.
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint8_t</type>
            <bits>5</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>CEC_IPL_TYPE</id>
    <description>
      Attribute which describes optional IPL flavors
    </description>
    <complexType>
        <description>Structure which defines a they IPL types
         Applicable for System target only.
        </description>
        <field>
            <name>PostDump</name>
            <description>
            Perform mainstore dump collection. Only valid for MPIPL
                0b0: Do not collect mainstore dump
                0b1: Perform mainstore dump collection
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>MinorIPLType</name>
            <description>Minor IPL Type</description>
            <type>uint8_t</type>
            <bits>7</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>


<!-- Begin attributes (4) to test string support -->

<attribute>
    <id>TEST_NULL_STRING</id>
    <description>Test attribute; string with empty default value</description>
    <simpleType>
        <string>
            <default></default>
            <sizeInclNull>10</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>TEST_MIN_STRING</id>
    <description>Test attribute; smallest string possible given size</description>
    <simpleType>
        <string>
            <default>a</default>
            <sizeInclNull>10</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>TEST_MAX_STRING</id>
    <description>Test attribute; largest string possible given size</description>
    <simpleType>
        <string>
            <default>abc</default>
            <sizeInclNull>4</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>TEST_NO_DEFAULT_STRING</id>
    <description>Test attribute; string with no default supplied</description>
    <simpleType>
        <string>
            <sizeInclNull>10</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!-- End attributes (4) to test string support -->

<attribute>
    <id>FAPI_NAME</id>
    <description>Common name across FAPI environments
    chip target -> pu:k0:n0:s0:p00
    DIMM target -> dimm:k0:n0:s0:p00
    chip unit target -> pu.core:k0:n0:s0:p00:c0
    cage/system target -> k0

    (chip type).(unit type):k(cage,always zero for us):n(node/drawer)
              :s(slot,always zero for us):p(chip position):c(core/unit position)
    pu  = generic processor
    </description>
    <simpleType>
        <string>
            <default>unknown</default>
            <sizeInclNull>64</sizeInclNull>
        </string>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>


<attribute>
    <id>VPD_REC_NUM</id>
    <description>Record offset for this target's VPD</description>
    <simpleType>
        <uint16_t>
            <default>0xFFFF</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEER_TARGET</id>
    <description>Peer target's address of a A/X-bus connection.
                 NULL means address 0 for no peer target. If a
                 target instance overrides the default with the
                 peer target's PHYS_PATH. The target compiler will
                 convert the valid PHYS_PATH string into the runtime
                 virtual address of the peer target instance.
    </description>
    <simpleType>
        <Target_t>
            <default>NULL</default>
        </Target_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PAYLOAD_BASE</id>
    <description>Base address (target HRMOR) of the payload.  Value is in MB.</description>
    <simpleType>
        <uint64_t>
            <default>256</default>
        </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PAYLOAD_ENTRY</id>
    <description>The offset from base address of the payload entry-point.
        Current default is 0x180</description>
    <simpleType>
        <uint64_t>
            <default>0x180</default>
        </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<enumerationType>
    <id>PAYLOAD_KIND</id>
    <description>
        Enumeration indicating what kind of payload is to be started
    </description>
    <enumerator>
        <name>UNKNOWN</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>PHYP</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SAPPHIRE</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>NONE</name>
        <value>3</value>
    </enumerator>
    <default>UNKNOWN</default>
</enumerationType>

<attribute>
    <id>PAYLOAD_KIND</id>
    <description>
        Attribute indicating what kind of payload is to be started.
    </description>
    <simpleType>
        <enumeration>
            <id>PAYLOAD_KIND</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>HB_HRMOR_NODAL_BASE</id>
    <description>Hostboot HRMOR = (HB_HRMOR_NODAL_BASE * node) + offset. </description>
    <!-- This value is set by the FSP.
         Hostboot uses it to find the HRMOR of Hostboot images running on other nodes.
         The value of HB_HRMOR_NODAL_BASE does NOT include the offset -->
    <simpleType>
        <uint64_t>
            <default>0x200000000000</default> <!-- 32TB -->
        </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FABRIC_TO_PHYSICAL_NODE_MAP</id>
    <description>
        Correlate HDAT node number (physical) to the logical node
        (based on the PIR) that contains the host boot image.
    </description>
    <!-- 8 byte array.  The index is the physical node number. The value
    at that index is the hb instance number, based on the processor PIR, that
    contains or would contain the host boot image if the drawer exists or were
    to exist. Host boot uses this value and HB_HRMOR_NODAL_BASE to calculate
    the HRMOR of the hostboot image for each drawer.
    If the drawer does NOT physically exist then enter a logical node that
    does NOT physically exist.

    It's conceivable that there could be more than one logical node contained
    in a physical drawer, if that is ever the case then the FSP would need to
    modify this attribute to indicate which logical node contains the hostboot
    image for each drawer. -->
    <simpleType>
        <uint8_t>
            <!-- Default is for single node system -->
            <default>0,255,255,255,255,255,255,255</default>
        </uint8_t>
    <array>8</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!--    TARGETING attributes to support mss_setup_bars and proc_setup_bars  -->

<attribute>
  <id>PROC_MEM_BASES</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    Non-mirrored memory base addresses
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
        64-bit RA
        eight independent non-mirrored segments are supported
        (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MEM_SIZES</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    Size of non-mirrored memory regions
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
        for given index value, address space assumed to be contiguous
        from ATTR_PROC_MEM_BASES value at matching index
        eight independent non-mirrored segments are supported
        (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_SIZES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_BASES</id>
  <description>Mirrored memory base addresses
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
      64-bit RA
      four independent mirrored segments are supported
      (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_BASES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_SIZES</id>
  <description>Size of mirrored memory region
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
      for given index value, address space assumed to be contiguous
      from ATTR_PROC_MIRROR_BASES value at matching index
      four independent mirrored segments are supported
      (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_SIZES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_L3_BAR1_REG</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    L3 BAR1 register value
    creator: proc_setup_bars
    consumer: winkle image setup procedures
    notes:
          64-bit register value
          SCOM address: 0x1001080B
  </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_L3_BAR1_REG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_L3_BAR2_REG</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    L3 BAR2 register value
    creator: proc_setup_bars
    consumer: winkle image setup procedures
    notes:
      64-bit register value
      SCOM address: 0x10010813
  </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_L3_BAR2_REG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_L3_BAR_GROUP_MASK_REG</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    L3 BAR Group Mask register value
    creator: proc_setup_bars
    consumer: winkle image setup procedures
    notes:
      64-bit register value
      SCOM address: 0x10010816
  </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_L3_BAR_GROUP_MASK_REG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<attribute>
  <id>FREQ_CORE</id>
  <description>
    firmware notes:
      Nominal processor's core DPLL frequency (MHz).
      Default value provided by Machine Readable Workbook.
      This attribute is the current value.
      @note this should be initialized by istep 7.1 proc_a_x_pci_dmi_pll_setup
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_NOT_F_LINK</id>
  <description>
    firmware notes:
      Set IPL time mux/switch between PCIE PHB/F link function
      (one per foreign link)
  </description>
  <simpleType>
      <uint8_t>
          <default>1,1</default>
      </uint8_t>
      <array>2</array>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_NOT_F_LINK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_MCS_GROUPS</id>
    <description>
        Per MCS group number
        Value is index for PROC_MEM_BASES and PROC_MEM_SIZES arrays
        creator: mss_eff_grouping.C
        consumer: HDAT
    </description>
    <simpleType>
        <uint8_t>
            <default>0,0,0,0,0,0,0,0</default>
        </uint8_t>
    <array>8</array><!--per MCS-->
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_MCS_GROUPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
     Memory Map
     The attributes below are defined by the PHYP Memory Map
     documentation owned by Shawn Lambeth

     @todo: RTC:44128 will be used to automatically create this data
     ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== -->

<!-- ===== System Attributes ===== -->

<attribute>
    <id>XSCOM_BASE_ADDRESS</id>
    <description>System XSCOM base address</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <description>MCS Inband Scom base address</description>
    <simpleType>
        <uint64_t>
            <default>0x0003E00000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <description>PROC Inband Scom base address</description>
    <simpleType>
        <uint64_t>
            <default>0x0003E00000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MIRROR_BASE_ADDRESS</id>
    <description>System Mirrorable base address</description>
    <simpleType>
        <uint64_t>
            <default>0x0000800000000000</default><!-- 128 TB -->
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MIRROR_BASE_ADDRESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <description>Indicate that payload should be placed in mirrored memory.
        Set by the FSP based on the value of the registry key indicating
        the memory mirroring mode.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default> <!-- false -->
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!-- ===== Processor Chip Attributes ===== -->

<attribute>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <description>NPU MMIO BAR base address values
        creator: platform
        consumer: proc_setup_bars
        firmware notes:
            64-bit address representing BAR RA
            NOTE: BAR register covers RA 14:51
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
        <array>4,2</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>NPU_MMIO_BAR_SIZE</id>
    <description>Enumeration indicating the BAR size
        used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
        <name>2_MB</name>
        <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
        <name>1_MB</name>
        <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
        <name>512_KB</name>
        <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
        <name>256_KB</name>
        <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
        <name>128_KB</name>
        <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
        <name>64_KB</name>
        <value>0x0000000000010000</value>
    </enumerator>
</enumerationType>
<attribute>
    <id>NPU_MMIO_BAR_SIZE</id>
    <description>NPU MMIO BAR size values
        creator: platform
        consumer: proc_setup_bars
        firmware notes: none
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
        <array>4,2</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSP_BASE_ADDR</id>
    <description>Base Address of FSP IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 128GB, 4GB per proc -->
            <default>0x0003FFE000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FSP_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSP_BAR_SIZE</id>
    <description>Size of FSP IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- 4GB per Proc -->
            <default>0x0000000100000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PSI_BRIDGE_BASE_ADDR</id>
    <description>Base Address of PSI Bridge Logic</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 6GB, 1MB per link -->
            <!-- 0x0003FFFE80000000 + 0x100000*procnum -->
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>INTP_BASE_ADDR</id>
    <description>Base Address of Interrupt Presenter</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 2GB, 1MB per proc -->
            <!-- 0x0003FFFF80000000 + 0x100000*procnum -->
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_INTP_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PHB_BASE_ADDRS</id>
    <description>Base Address of PHB Register Space</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 7GB -->
            <!-- 0x0003FFFE40000000 + 0x400000*procnum + 0x100000*phbnum -->
            <default>
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF
            </default>
        </uint64_t>
        <array>4</array><!-- per PHB -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PCI_BASE_ADDRS_64</id>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>4</array><!-- per PHB -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PCI_BASE_ADDRS_32</id>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>4</array><!-- per PHB -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>


<attribute>
    <id>MEM_BASE</id>
    <description>Base Address for all mainstore behind this processor</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_MEM_BASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MIRROR_BASE</id>
    <description>Base Address for all mirrored mainstore behind this processor</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_MIRROR_BASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RNG_BASE_ADDR</id>
    <description>Base Address of RNG IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 3GB -->
            <!-- 0x0003FFFF40000000 + 0x1000*procnum -->
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RNG_BAR_SIZE</id>
    <description>Size of RNG IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- 4 KB per processor -->
            <default>0x000000000001000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>IMT_BASE_ADDR</id>
    <description>Base Address of In-Memory Trace Region
        Set by FSP-based tooling
    </description>
    <simpleType>
        <uint64_t>
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>IMT_BAR_SIZE</id>
    <description>Size of IMT IO Region
        Set by FSP-based tooling
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!-- ===== ===== End Memory Map ===== ===== ===== ===== ===== ===== -->

<attribute>
  <id>PROC_EPS_GB_PERCENTAGE</id>
  <description>
     firmware notes:
        Guardband percentage to apply to baseline epsilon values
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_GB_PERCENTAGE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_GB_DIRECTION</id>
  <description>
    firmware notes:
      Direction to apply guardband margin (positive/negative)
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_GB_DIRECTION</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_ASYNC_SAFE_MODE</id>
  <description>
    firmware notes:
      Set to force all asynchronous boundary crossings into safe mode.
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_ASYNC_SAFE_MODE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>FREQ_PCIE_MHZ</id>
  <description>
    The frequency of a processor's PCI-e bus in MHz.
    This is the same for all PCI-e busses in the system.
    Provided by the MRW.
  </description>
  <simpleType><uint32_t></uint32_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE_MHZ</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NOMINAL_FREQ_MHZ</id>
    <description>
      The nominal core frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_NOMINAL_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ULTRA_TURBO_FREQ_MHZ</id>
    <description>
      The ultra turbo frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V and is calculated as
      the minimum of the ultra turbo frequencies.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ULTRA_TURBO_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_FLAGS</id>
    <description>
        Provides the manufacturing flags. This is a bitfield.
        Multiple flags can be set at once. Use MNFG_FLAG_BIT
        to decode. Expected use-case is for FSP to write this
        attribute based on the MNFG component flags and for
        HWSV/Hostboot to read it.
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_FLAGS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MNFG_FLAG</id>
    <description>Enumeration indicating the mnfg flags
        that are set by the user.  The values can be
        combined using a bitwise 'OR'.  The values will
        need to be kept in sync with the FAPI
        enumerator values.  Also the enumeration type
        is used by the ATTR_MNFG_FLAGS attribute.  Should
        note that the MNFG_FLAG values are of type uint32_t
    </description>
    <enumerator>
        <!-- Use default mfg error thresholds and reporting values -->
        <name>THRESHOLDS</name>
        <value>0x00000001</value>
    </enumerator>
    <enumerator>
        <!-- Enable AVP execution -->
        <name>AVP_ENABLE</name>
        <value>0x00000002</value>
    </enumerator>
    <enumerator>
        <!-- Enable HDAT AVPs** -->
        <name>HDAT_AVP_ENABLE</name>
        <value>0x00000004</value>
    </enumerator>
    <enumerator>
        <!-- All SRCs are terminating (CEC hardware/procedural) -->
        <name>SRC_TERM</name>
        <value>0x00000008</value>
    </enumerator>
    <enumerator>
        <!-- Enable IPL memory diagnostics to report memory CE -->
        <name>IPL_MEMORY_CE_CHECKING</name>
        <value>0x00000010</value>
    </enumerator>
    <enumerator>
        <!-- Enable Fast Background Scrub -->
        <name>FAST_BACKGROUND_SCRUB</name>
        <value>0x00000020</value>
    </enumerator>
    <enumerator>
        <!-- Test DRAM Repairs -->
        <name>TEST_DRAM_REPAIRS</name>
        <value>0x00000040</value>
    </enumerator>
    <enumerator>
        <!-- Disable Dram Repairs -->
        <name>DISABLE_DRAM_REPAIRS</name>
        <value>0x00000080</value>
    </enumerator>
    <enumerator>
        <!-- Enable exhaustive pattern test -->
        <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
        <value>0x00000100</value>
    </enumerator>
    <enumerator>
        <!-- Enable standard pattern test -->
        <name>ENABLE_STANDARD_PATTERN_TEST</name>
        <value>0x00000200</value>
    </enumerator>
    <enumerator>
        <!-- Enable minimum pattern test -->
        <name>ENABLE_MINIMUM_PATTERN_TEST</name>
        <value>0x00000400</value>
    </enumerator>
    <enumerator>
        <!-- Disable Fabric eRepair -->
        <name>DISABLE_FABRIC_eREPAIR</name>
        <value>0x00000800</value>
    </enumerator>
    <enumerator>
        <!-- Disable Memory eRepair -->
        <name>DISABLE_MEMORY_eREPAIR</name>
        <value>0x00001000</value>
    </enumerator>
    <enumerator>
        <!-- Fabric deploy lane spares -->
        <name>FABRIC_DEPLOY_LANE_SPARES</name>
        <value>0x00002000</value>
    </enumerator>
    <enumerator>
        <!-- DMI deploy lane spares -->
        <name>DMI_DEPLOY_LANE_SPARES</name>
        <value>0x00004000</value>
    </enumerator>
    <enumerator>
        <!-- Forcibly run PSI diagnostics -->
        <name>PSI_DIAGNOSTIC</name>
        <value>0x00008000</value>
    </enumerator>
    <enumerator>
        <!-- Brazos Wrap Config -->
        <name>BRAZOS_WRAP_CONFIG</name>
        <value>0x00010000</value>
    </enumerator>
    <enumerator>
        <!-- FSP is responsible for updating Processor SBE Image -->
        <name>FSP_UPDATE_SBE_IMAGE</name>
        <value>0x00020000</value>
    </enumerator>
    <enumerator>
        <!-- Update both sides of SBE Image if update is needed -->
        <name>UPDATE_BOTH_SIDES_OF_SBE</name>
        <value>0x00040000</value>
    </enumerator>
</enumerationType>

<!-- Support for pm_hwp_attributes.xml -->

<attribute>
    <id>PROC_DPLL_DIVIDER</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_DPLL_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_POWER_PROXY_TRACE_TIMER</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_POWER_PROXY_TRACE_TIMER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PPT_TIMER_MATCH_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PPT_TIMER_MATCH_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PPT_TIMER_TICK</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PPT_TIMER_TICK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_AISS_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_AISS_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PSTATE_STEPSIZE</id>
    <description>
      PROC_CHIP Attribute

Used to setup the PMC voltage controller

Producer: proc_build_pstate_tables.C

Consumer: OCC pstate_init()
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PSTATE_STEPSIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_EXTERNAL_VRM_STEPDELAY_RANGE</id>
    <description>
      PROC_CHIP Attribute

A 4 bit field  selects one of the the upper 16bit of a 19bit counter (16+3) incremented in the nest/4 domain

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_EXTERNAL_VRM_STEPDELAY_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_EXTERNAL_VRM_STEPDELAY_VALUE</id>
    <description>
      PROC_CHIP Attribute

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_EXTERNAL_VRM_STEPDELAY_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PMC_HANGPULSE_DIVIDER</id>
    <description>
      PROC_CHIP Attribute

Producer:  proc_pm_init

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PMC_HANGPULSE_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PVSAFE_PSTATE</id>
    <description>
      PROC_CHIP Attribute
Pstate that is invoked in the PMC voltage controller upon the loss of the OCC Heartbeat..

Producer:  proc_pm_init.C

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PVSAFE_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_FRAME_SIZE</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x20 (32d)

Chip Select assertion duration is spi_frame_size + 2
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_FRAME_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_IN_DELAY_FRAME1</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x00 to spi_frame_size.  Values beyond spi_frame_size result in the input never being captured
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_IN_DELAY_FRAME1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_IN_DELAY_FRAME2</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x00 to spi_frame_size.  Values beyond spi_frame_size result in the input never being captured
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_IN_DELAY_FRAME2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CLOCK_POLARITY</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CLOCK_POLARITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CLOCK_PHASE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CLOCK_PHASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CLOCK_DIVIDER</id>
    <description>
      PROC_CHIP Attribute
For a 2.4GHz nest clock, this means that the SPI clk can be theoretically adjusted between 600MHz and 0.29MHz (cycle time 1.66ns...3.41us, in 1.66ns steps). However, a practical range is 0.5...25MHz.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CLOCK_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS</id>
    <description>
      PROC_CHIP Attribute
Consumer: proc_pmc_init
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS_VALUE</id>
    <description>
      PROC_CHIP Attribute

Delay is computed as:  (value * ~100ns_hang_pulse)  +0/-~100ns_hang_pulse time

0x00000: Wait 1 SPI Clock
0x00001 - 0x1FFFF: value = number of ~100ns_hang_pulses

For values greater than 0x00000, the actual delay is 1 SPI Clock + the time delay designated by the value defined. Max. delay at 0x1FFFF: 13.1ms + 1 SPI clock cycle.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTER_RETRY_DELAY_VALUE</id>
    <description>
      PROC_CHIP Attribute

Delay is computed as:  (value * ~100ns_hang_pulse)  +0/-~100ns_hang_pulse time

0x0000: Wait 1 SPI Clock
0x0001 - 0xFFFF: value = number of ~100ns_hang_pulses

For values greater than 0x00000, the actual delay is 1 SPI Clock + the time delay designated by the value defined. Max. delay at 0x1FFFF: 13.1ms + 1 SPI clock cycle.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTER_RETRY_DELAY_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTER_RETRY_DELAY</id>
    <description>
      PROC_CHIP Attribute
Consumer: proc_pmc_init
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTER_RETRY_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CRC_GEN_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CRC_GEN_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CRC_CHECK_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CRC_CHECK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_MAJORITY_VOTE_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_MAJORITY_VOTE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_MAX_RETRIES</id>
    <description>
      PROC_CHIP Attribute

0x00: No retry
0x01 to 0x1F: 1 to 31 respectively
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_MAX_RETRIES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CRC_POLYNOMIAL_ENABLES</id>
    <description>
      PROC_CHIP Attribute

An 8 bit mask vector to enable XORs in the CRC generation and checking LFSRs at the respective bit position. MSB (x^8) is omitted since it is always enabled, so the mask layout is (x^7,x^6,x^5,x^4,x^3,x^2,x^1,1)

Planned CRC8 polynomial: x^8 + x^7 + x^6 + x^4 + x^2 + 1
Value to enable planned polynomial: 0b1101_0101 (=0xD5)
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CRC_POLYNOMIAL_ENABLES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_OCC_HEARTBEAT_TIME</id>
    <description>
      PROC_CHIP Attribute
Consumer: OCC FW
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_OCC_HEARTBEAT_TIME</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_WINKLE_REQUEST_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute

Consumer: proc_pmc_init.C.  Will be translated to a DYNAMIC ATTRIBUTE for use by proc_pm..scominit  as a multiple of PM hang pulses.. Counter starts at 0, is increased with every tp_pmc_hang_pulse as long as PORE is busy and set the PMC local FIR bit 19 when count = threshold.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_WINKLE_REQUEST_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_ENTRY</id>
    <description>
      PROC_CHIP Attribute

Set Assisted if power off serialization is needed and SLEEP_TYPE=Fast;  Set to Hardware if the system can handle the unrelated powering off between cores.  Hardware setting decreases entry latency

Producer: MRWB

Consumer:  proc_pm_init and proc_pcbs_init
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_ENTRY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_EXIT</id>
    <description>
      PROC_CHIP Attribute

Set to Assisted if power on serialization is needed and SLEEP_TYPE=Fast;  Set to Hardware if the system can handle the unrelated powering off between cores.  Hardware setting decreases entry latency
Must be set to Assisted if ATTR_PM_SLEEP_TYPE=Deep as this necessary for restore.

Setting to Hardware is a test mode for Fast only.

Producer: MRWB

Consumer:  proc_pm_init and proc_pcbs_init.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_EXIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_TYPE</id>
    <description>
      PROC_CHIP Attribute
Selects which voltage level to place the Core domain PFETs upon Sleep entry. 0 = Vret (Fast Sleep Mode), 1 = Voff (Deep Sleep Mode)

Producer: MRWB

Consumer:  proc_pm_init and proc_pcbs_init
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_WINKLE_TYPE</id>
    <description>
      PROC_CHIP Attribute
Selects which voltage level to place the Core and ECO domain PFETs upon Winkle entry. 0 = Vret (Fast Winkle Mode), 1 = Voff (Deep Winkle Mode)
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_WINKLE_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute

0 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY0;

1 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY1
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute

0 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY0;

1 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY1
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute

0 in the bit position:  use ATTR_PM_PFET_POWERUP_ECO_DELAY0;

1 in the bit position:  use ATTR_PM_PFET_POWERUP_ECO_DELAY1
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PSTATE0_FREQUENCY</id>
    <description>
      PROC_CHIP Attribute

Producer: proc_build_gpstate.C

Consumers: proc_pcbs_init.C, proc_pcbs_lpst_init.C,
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PSTATE0_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_IVRMS_ENABLED</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_IVRMS_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SAFE_PSTATE</id>
    <description>
      PROC_CHIP Attribute

Valid Values:-128 thru 127

Producer: proc_pm_init.C

DYNAMIC_ATTRIBUTE

Consumer: proc_pcbs_init.C

Establishes the Pstate that the core chiplet will take on if:
psafe less-than-or-equal PMSR[global_actual_pstate]
AND any of the following conditions are true:
Loss of OCC Heartbeat if occ_heartbeat_en is set
PMGP0[force_safe_mode] is set

If psafe greater-than PMSR[global_actual_pstate], the  global_actual_pstate is forced.

The value of Psafe needs to be at or below the nominal Pstate to make sure safe operation of all chiplets.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SAFE_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NEST_LEAKAGE_PERCENT</id>
    <description>
        SYSTEM Attribute
        Nest leakage percentage used to calculate the Core leakage. Will
        eventually be read into OCC Pstate Parameter Block so the OCC can
        see it for it's calculations.

        Valid Values: 0% thru 100%
        Producer: Machine Readable Workbook
        Consumer: OCC Firmware
    </description>
    <simpleType>
        <uint8_t>
            <default>60</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_NEST_LEAKAGE_PERCENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_FULL_CSB_PSTATE</id>
    <description>
      PROC_CHIP Attribute
Defines the Pstate for the point at which clock sector buffers should be at full strength.  This is to support Vmin operation.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_FULL_CSB_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LFRLOW_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LFRLOW_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LFRUPPER_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LFRUPPER_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HFRLOW_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HFRLOW_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HFRHIGH_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HFRHIGH_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_FRAME_SIZE</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x10 (16d),

Chip Select assertion duration is spi_frame_size + 2
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_FRAME_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_OUT_COUNT</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x000 to spi_frame_size.  Values beyond spi_frame_size are ignored.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_OUT_COUNT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_IN_DELAY</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x000 to spi_frame_size.  Values beyond spi_frame_size result in the input never being captured
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_IN_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_IN_COUNT</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x000 to spi_frame_size.  The actual number of bits captured is spi_frame_size - spi_in_delay
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_IN_COUNT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_CLOCK_POLARITY</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_CLOCK_POLARITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_CLOCK_PHASE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_CLOCK_PHASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_CLOCK_DIVIDER</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_CLOCK_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_INTER_FRAME_DELAY_SETTING</id>
    <description>
      PROC_CHIP Attribute
Delay is computed as:  (value * ~100ns_hang_pulse)  +0/-~100ns_hang_pulse time

0x00000: Wait 1 PSS Clock
0x00001 - 0x1FFFF: value = number of ~100ns_hang_pulses

For values greater than 0x00000, the actual delay is 1 PSS Clock + the time delay designated by the value defined. Max. delay at 0x1FFFF: 13.1ms + 1 PSSI clock cycle.

Producer: proc_pm_init

Consumer: proc_pss_init
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_INTER_FRAME_DELAY</id>
    <description>
      PROC_CHIP Attribute

Consumer: proc_pm_init

Produces ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_INTER_FRAME_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_RCV_RESERV_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute
Divider for the 1us PBAX hang pulse.  A hang is detected after two divided hang pulses are received under the following conditions:
 Data Hi packet accepted and timeout waiting for Data Lo packet.
 Reservation aquired and timeout waiting for Data Hi packet.

00000  Data Timeout is Disabled
00001  divided hang pulse = PBAX hang pulse
00010  divided hang pulse = PBAX hang pulse/2
00011  divided hang pulse = PBAX hang pulse/3
. . .
11111   divided hang pulse = PBAX hang pulse/31
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_RCV_RESERV_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_SND_RETRY_COUNT_OVERCOMMIT_ENABLE</id>
    <description>
      PROC_CHIP Attribute
Mode bit to count overcommit retries for the send retry threshold when sending PBAX commands on the powerbus.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_SND_RETRY_COUNT_OVERCOMMIT_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_SND_RETRY_THRESHOLD</id>
    <description>
      PROC_CHIP Attribute
Defines the maximum number of retry attempts by the Send Engine for any phase of the PBAX transaction set before the operation is dropped and status bit are set.  This does not count PowerBus overcommit retries unless snd_retry_count_overcom bit is set.

0x00 :  No Timeout
0x01 :  1 attempt
0x02 :   2 attempts
.etc.
0xFF :  255 attempts
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_SND_RETRY_THRESHOLD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_SND_RESERV_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute
Divider for the 1us PBAX hang pulse.  A hang is detected after two divided hang pulses are received after attempting to acquire a reservation with the PBAX Receive engine before declaring a Send Reservation Timeout error.

00000  Send Reservation Timeout is Disabled
00001  divided hang pulse = PBAX hang pulse
00010  divided hang pulse = PBAX hang pulse/2
00011  divided hang pulse = PBAX hang pulse/3
. . .
11111   divided hang pulse = PBAX hang pulse/31
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_SND_RESERV_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_FSP</id>
    <description>
      EX_CHIPLET Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_FSP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_OCC</id>
    <description>
      EX_CHIPLET Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_OCC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_PHYP</id>
    <description>
      EX_CHIPLET Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_PHYP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLW_CONTROL_VECTOR_OFFSET</id>
    <description>
    Stores the offset in SLW image of this control vector for later use by scripts to control error injection.
    This value is added to the contents of PBABAR2 for given chip to calculated the memory address for this vector per chip.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLW_CONTROL_VECTOR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- End pm_hwp_attributes.xml -->


<!-- Support for pm_plat_attributes.xml -->

<attribute>
    <id>EXTERNAL_VRM_STEPSIZE</id>
    <description>
      SYSTEM Attribute
      Step size (binary in microvolts) to take upon external VRM voltage
      transitions. The value set here must take into account where internal
      VRMs are enabled or not as, when they are enabled, the step size must
      account for the tracking (eg PFET strength recalculation) for the step.

      Consumer: proc_build_pstate_tables.C, proc_pmc_init.C -config

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EXTERNAL_VRM_STEPDELAY</id>
    <description>
      SYSTEM Attribute
      Step delay (binary in microseconds) after a voltage change

      Consumer: proc_pmc_init -config

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EXTERNAL_VRM_STEPDELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      SPI Clock Frequency (binary in MHz)

      Consumer: proc_pm_effective

      Produces ATTR_PM_SPIVID_CLOCK_DIVIDER

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_PORT_ENABLE</id>
    <description>
      PROC_CHIP Attribute
      Defines the configuration of the SPIVID ports from the target.
      - NONE means that no VRM is attached.
      - PORTxNONRED means that the indicated port is used in a non-redundant
                    configuration.
      - REDUNDANT means that all three are connected and considered redundant.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_PORT_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SAFE_FREQUENCY</id>
    <description>
      Frequency (binary in KHz) indicating the frequency that the cores will be moved
      to in the event of the loss of the OCC Heartbeat.  This value needs to be the maximum
      of the DpoMin frequency for proper PowerBus operation and the PowerSave value for
      the present part.

      Provided by the Machine Readable Workbook after system characterization.

      The value is translated to the Pstate space.

      Producer:  Machine Readable Workbook

      Consumers: p8_build_gpstate_table.C

      DYNAMIC_ATTRIBUTE: ATTR_PM_SAFE_PSTATE
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SAFE_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz) for the point at which clock sector buffers
      should be at full strength.  This is to support Vmin operation.
      Setting cannot overlap the Low or High bands.

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LOW_BAND_LOWER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz)) for the lower end of the Low Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LOW_BAND_LOWER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LOW_BAND_UPPER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz) for the upper end of the Low Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LOW_BAND_UPPER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HIGH_BAND_LOWER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz) for the lower end of the High Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HIGH_BAND_LOWER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HIGH_BAND_UPPER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz)) for the upper end of the High Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HIGH_BAND_UPPER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_NODEID</id>
    <description>
      DEPRECATED!!!  Use PBAX_GROUPID instead
      PROC_CHIP Attribute
      Receive PBAX Nodeid. Value that indicates this PBA's PBAX Node affinity.
      This is matched to pbax_nodeid of the PMISC Address phase.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_NODEID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PBAX_GROUPID</id>
    <description>
      PROC_CHIP Attribute
      Receive PBAX Nodeid. Value that indicates this PBA's PBAX Node affinity.
      This is matched to pbax_nodeid of the PMISC Address phase.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PBAX_GROUPID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PBAX_CHIPID</id>
    <description>
      PROC_CHIP Attribute
      Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within
      the PBAX node.  Is matched to pbax_chipid of the Address phase if
      pbax_type=unicast.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PBAX_CHIPID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PBAX_BRDCST_ID_VECTOR</id>
    <description>
      PROC_CHIP Attribute
      Receive PBAX Broadcast Group. Vector that is indexed when decoded PMISC
      pbax_type=broadcast with the decoded PMISC pbax_chipid value.  If the
      bit in this vector at the decoded bit location is a 1, then this receive
      engine will participate in the broadcast operation.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PBAX_BRDCST_ID_VECTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_CORE_MAX</id>
    <description>
      SYSTEM Attribute
      Maximum frequency (binary in MHz) that any processor in the system will
      run. Used to define the top end of the PState range in the frequency space.
      From this, the ATTR_PROCPM_PSTATE0_FREQUENCY is computed using
      ATTR_SYSTEM_REFCLK_FREQUENCY to determine the step size.

      Consumers: proc_build_gpstate_table.C (among others)

      Data is is provided by MVPD #V and is calculated as the minimum
      of the turbo frequencies
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_MAX</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- End pm_plat_attributes.xml -->

<attribute>
    <id>OVERRIDE_MVPD_NOM_FREQ_MHZ</id>
   <description>Module VPD #V keyword Nominal Frequency in MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_NOM_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_NOM_VOLTAGE</id>
    <description>Module VPD #V keyword V-nest nominal voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_NOM_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_NOM_CURRENT</id>
    <description>Module VPD #V keyword I-nest nominal current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_NOM_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_NOM_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs nominal voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_NOM_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_NOM_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs nominal current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_NOM_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_PS_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword PowerSave Frequency in MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_PS_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_PS_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest powersave voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_PS_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_PS_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest powersave current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_PS_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_PS_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs powersave voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_PS_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_PS_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs powersave current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_PS_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_TURBO_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword turbo frequency in MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_TURBO_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_TURBO_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest turbo voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_TURBO_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_TURBO_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest turbo current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_TURBO_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_TURBO_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs turbo voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_TURBO_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_TURBO_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs turbo current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_TURBO_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>OVERRIDE_MVPD_FVMIN_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword fvmin frequency MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_FVMIN_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_FVMIN_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest fvmin voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_FVMIN_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_FVMIN_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest fvmin current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_FVMIN_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_FVMIN_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs fvmin voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_FVMIN_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_FVMIN_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs fvmin current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_FVMIN_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_LAB_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword lab frequency MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_LAB_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_LAB_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest lab voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_LAB_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_LAB_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest lab current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_LAB_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_LAB_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs lab voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_LAB_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_LAB_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs lab current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_LAB_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_CONFIG</id>
  <description>PCIE IOP lane configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP lane configuration
  </description>
  <simpleType><uint8_t></uint8_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_PHB_ACTIVE</id>
  <description>PCIE PHB valid mask
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Bit mask defining set of active/valid PHBs
        bit0=PHB0, bit1=PHB1, bit2=PHB2, bit3=PHB3
  </description>
  <simpleType><uint8_t></uint8_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PHB_ACTIVE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>AVDD_ID</id>
    <description>
        Memory AVDD voltage domain ID.  All memory buffers in the same AVDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDD_ID</id>
    <description>
        Memory VDD voltage domain ID.  All memory buffers in the same VDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VCS_ID</id>
    <description>
        Memory VCS voltage domain ID.  All memory buffers in the same VCS
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VPP_ID</id>
    <description>
        Memory VPP voltage domain ID.  All memory buffers in the same VPP
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDDR_ID</id>
    <description>Voltage Memory Rail Manager ID.  Currently HB only needs
        to configured the Vddr voltage rail manager during the IPL.  The ID
        is an arbitary value and needed as correlation token between HB and
        HWSV.  It will be generated by the genHwsvMrwXml.pl.
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>


<attribute>
    <id>NEST_VDDR_ID</id>
    <description>
        Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NEST_VIO_ID</id>
    <description>
        Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NEST_VDD_ID</id>
    <description>
        Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NEST_VDN_ID</id>
    <description>
        Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NEST_VCS_ID</id>
    <description>
        Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!--    Add attributes for sbe_config_update    -->
<attribute>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <description>
        The asynchronous nest frequency
    </description>
    <simpleType>
        <uint32_t>
            <default>2000</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ASYNC_NEST_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_REGIONS_TO_ENABLE</id>
    <description>
      Called to get data to customize an IPL or SLW image with data indicating
       which chip regions the SBE should enable
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CHIP_REGIONS_TO_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>BOOT_FREQ_MHZ</id>
    <description>
       EQ Boot frequency in MHZ.
    </description>
    <simpleType>
        <uint32_t>
            <default>2400</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_BOOT_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EX_GARD_BITS</id>
    <description>
      Vector to communicate the guarded EX chiplets to SBE
            One Guard bit per EX chiplet, bit location aligned to chiplet ID
      (bit 16: EX00, bit 17: EX01, bit 18: EX02 ... bit 31: EX15)
            Guarded EX chiplets are marked by a '1'.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EX_GARD_BITS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>PIB_I2C_REFCLOCK</id>
<description>
    i2c reference clock for the system.
    default is 0x4 => I2C speed = ~1Mhz per Andreas Koenig
</description>
    <simpleType>
        <uint32_t>
            <default>0x4</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIB_I2C_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_ADU_UNTRUSTED_BAR_BASE_ADDR</id>
    <description>
      ADU Untrusted BAR base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_ADU_UNTRUSTED_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>PIB_I2C_NEST_PLL</id>
<description>
    i2c pll for the system
    default is 0x26 (For PIB @500 MHz (2 GHz nest)) for
    I2C speed = ~1Mhz per Andreas Koenig.
</description>
    <simpleType>
        <uint32_t>
            <default>0x026</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIB_I2C_NEST_PLL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_ADU_UNTRUSTED_BAR_SIZE</id>
    <description>
      ADU Untrusted BAR size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 14:43
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_ADU_UNTRUSTED_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>SBE_IMAGE_OFFSET</id>
<description>
    HostBoot image for SBE, offset to account for ECC
    Default is calculated from Hostboot base image of 0x03f67000
</description>
    <simpleType>
        <uint32_t>
            <default>0xfff78000</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_IMAGE_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_IMAGE_MINIMUM_VALID_EXS</id>
    <description>
      The minimum number of valid EXs that is required to be used when
      customizing a SBE image. The customization will fail if it cannot
      create an image with at least this many EXs.
    </description>
    <simpleType>
        <uint32_t>
            <default>3</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_IMAGE_MINIMUM_VALID_EXS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR0_BASE_ADDR</id>
    <description>
      PSI Untrusted BAR0 base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR0_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>BOOT_VOLTAGE</id>
<description>
    Boot Voltage for system.
    0:2   -> port enables (3b - system design based:
        port 0 for non-redundant systems (100); all ports for non-redundant (111))
    3     -> Unused
     - current recommended default = 1000b
    4:7   -> phase enables (4b - defined by the system power design)
    - current recommended default = 0000b
    8:15  -> VDD voltage (1B in VRM-11 encoded form - 6.25mV increments)
        note: VPD is in 5mV increments
    - current recommended default   =   0x52
    16:23 -> VCS voltage (1B in VRM-11 encoded form - 6.25mV increments)
        note: VPD is in 5mV increments
    -current recommended default    =   0x4a
    24:31 -> Unused                 =   0x00
</description>
    <simpleType>
        <uint32_t>
            <default>0x80524a00</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_BOOT_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR0_SIZE</id>
    <description>
      PSI Untrusted BAR0 size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 14:43
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR0_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR1_BASE_ADDR</id>
    <description>
      PSI Untrusted BAR1 base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR1_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR1_SIZE</id>
    <description>
      PSI Untrusted BAR1 size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 14:43
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR1_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_SECURITY_SETUP_VECTOR</id>
    <description>
      Secureboot 64-bit proc_sbe_security_setup_vector used
      by proc_sbe_security_setup.S. 0s are an unsecure SBE image
      creator: platform
      firmware notes:
      64-bit proc_sbe_security_setup_vector
    </description>
    <simpleType>
        <uint64_t>
            <default>0x8000000080000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_SECURITY_SETUP_VECTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== Attributes supporting memory_attributes.xml HWPF Attributes ===== -->
<attribute>
    <id>MSS_VDDR_PROGRAM</id>
    <description>VDDR memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>
<attribute>
    <id>MSS_VPP_PROGRAM</id>
    <description>VPP memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>
<attribute>
    <id>MSS_VCS_PROGRAM</id>
    <description>VCS memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>
<attribute>
    <id>MSS_AVDD_PROGRAM</id>
    <description>AVDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>
<attribute>
    <id>MSS_VDD_PROGRAM</id>
    <description>VDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>MSS_VOLT_VDDR_MILLIVOLTS</id>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VDDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VOLT_VPP_MILLIVOLTS</id>  <!-- VPP_BASE -->
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VPP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VOLT_VCS_MILLIVOLTS</id>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VCS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>

<attribute>
    <id>MSS_VOLT_VDD_MILLIVOLTS</id>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VDD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>

<attribute>
    <id>MSS_VOLT_AVDD_MILLIVOLTS</id>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_AVDD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>


<!-- Calculated dynamic voltages -->
<attribute>
    <id>MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VDDR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>

<attribute>
    <id>MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>  <!-- VPP_BASE -->
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VPP_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>

<attribute>
    <id>MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VCS_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>

<attribute>
    <id>MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_VDD_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>

<attribute>
    <id>MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
<!-- TODO RTC:157672
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_AVDD_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
-->
</attribute>
<!-- end of Dynamic voltage -->


<attribute>
    <id>MSS_FREQ</id>
    <description>
      Frequency of this memory channel in MT/s (Mega Transfers per second),
      comprising of three DIMMs.
      Computed in mss_freq
      creator: mss_freq
      consumer: mss_eff_cnfg, others
      firmware notes: none
      MT1866 = 1866,
      MT2133 = 2133,
      MT2400 = 2400,
      MT2666 = 2666
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_FREQ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MFG_ID_CODE</id>
    <description>Manufacturer ID Code RCD: bits(31:16), Module: bits(15:0)</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MFG_ID_CODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RANKS_CONFIGED</id>
    <description>DIMM ranks configured. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RANKS_CONFIGED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_RANKS_PER_DIMM</id>
    <description>
      Number of ranks in each DIMM.
      Used in various locations and is computed in mss_eff_cnfg.
      values are 0,1,2, 4 up to 32
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_RANKS_PER_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_MFG_ID</id>
    <description>
        DRAM Manufacturer ID Code
        Decodes SPD Byte 350 and 351
        creator: mss_eff_cnfg
        consumer: power_thermal::decoder
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_MFG_ID</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WIDTH</id>
    <description>
      DRAM Device Width: X4, X8, X16, X32.
      Used in various locations and is computed in mss_eff_cnfg.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      X4 = 4, X8 = 8, X16 = 16, X32 = 32
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RANK_MIX</id>
    <description>
      DRAM Device Rank Mix
      Used in various locations and is computed in mss_eff_cnfg.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      SYMMETRICAL = 0, ASYMMETICAL = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RANK_MIX</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>EFF_PRIMARY_RANK_GROUP0</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP1</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP2</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP3</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP0</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP1</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP2</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP3</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP0</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP1</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP2</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP3</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP0</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP1</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP2</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP3</id>
    <description>
      RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
      creator: mss_eff_cnfg_rank_group
      consumer: various
      firmware notes: none
      INVALID = 255
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603. These termination data EFF attributes have corresponding
     VPD attributes that come from CVPD. When all HWPs are using the VPD
     versions, these EFF versions can be deleted -->

<attribute>
    <id>EFF_DRAM_RON</id>
    <description>
      DRAM Ron.
      Used in various locations and comes from the MT keyword of the VPD
      OHM48 is for DDR4.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RON</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR_VREF</id>
    <description>
      DRAM Write Vref.
      Used in various locations and comes from the MT keyword of the VPD or is computed in mss_eff_cnfg_termination.
      creator: VPD(MT) or mss_eff_cnfg_termination
      consumer: various.C and initfile
      firmware notes: none
      This is the nominal value
      This is for DDR3
      VDD420 = 420,
      VDD425 = 425,
      VDD430 = 430,
      VDD435 = 435,
      VDD440 = 440,
      VDD445 = 445,
      VDD450 = 450,
      VDD455 = 455,
      VDD460 = 460,
      VDD465 = 465,
      VDD470 = 470,
      VDD475 = 475,
      VDD480 = 480,
      VDD485 = 485,
      VDD490 = 490,
      VDD495 = 495,
      VDD500 = 500,
      VDD505 = 505,
      VDD510 = 510,
      VDD515 = 515,
      VDD520 = 520,
      VDD525 = 525,
      VDD530 = 530,
      VDD535 = 535,
      VDD540 = 540,
      VDD545 = 545,
      VDD550 = 550,
      VDD555 = 555,
      VDD560 = 560,
      VDD565 = 565,
      VDD570 = 570,
      VDD575 = 575
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WRDDR4_VREF</id>
    <description>DRAM Write Vref for DDR4. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WRDDR4_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_DQ_DQS</id>
    <description>Centaur DQ and DQS Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_DQ_DQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_ADDR</id>
    <description>Centaur Address Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CNTL</id>
    <description>Centaur Control Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CLK</id>
    <description>Centaur Clock Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CLK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_SPCKE</id>
    <description>Centaur Spare Clock Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_SPCKE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RCV_IMP_DQ_DQS</id>
    <description>Centaur DQ and DQS Receiver Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RCV_IMP_DQ_DQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_DQ_DQS</id>
    <description>Centaur DQ and DQS Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_DQ_DQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_ADDR</id>
    <description>Centaur Address Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CLK</id>
    <description>Centaur Clock Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CLK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_SPCKE</id>
    <description>Centaur Spare Clock Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_SPCKE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CNTL</id>
    <description>Centaur Control Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RD_VREF</id>
    <description>Centaur Read Vref. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RD_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603 down to here -->

<attribute>
    <id>EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CLK_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_SPCKE_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CNTL_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CLK_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_SPCKE_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_ADDR_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CNTL_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR_VREF_SCHMOO</id>
    <description>
      Enables for which VREF to use on the WR Schmoo.
      The LSB corresponds to the highest WR Vref
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR_VREF_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WRDDR4_VREF_SCHMOO</id>
    <description>
      Enables for which VREF to use on the WR Schmoo.
      The LSB corresponds to the highest WR Vref
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RD_VREF_SCHMOO</id>
    <description>Enables for which VREF value can be used in timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RD_VREF_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_SIZE</id>
    <description>
      DIMM Size, in GB Used in various locations and is computed in mss_eff_cnfg.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_BANKS</id>
    <description>Number of DRAM banks. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_BANKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ROWS</id>
    <description>Number of DRAM rows. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_ROWS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_COLS</id>
    <description>Number of DRAM columns. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_COLS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRRD</id>
    <description>DRAM Row ACT to Row ACT Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRRD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>EFF_DRAM_TRFI</id>
    <description>Refresh Interval. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRFI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TWTR</id>
    <description>DRAM Internal Write to Read Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TWTR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRTP</id>
    <description>
      Internal Read to Precharge Delay.
      From the DDR4 spec (79-4A).
      Each memory channel will have a value.
      creator: mss_eff_cnfg_timing
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRTP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRRD_DLR</id>
    <description>
        Minimum Activate to Activate Delay Time (different logical ranks)
        in nck (number of clock cycles).
        For 3DS, The tRRD_S time to a different logical rank is defined as tRRD_dlr.
        Each memory channel will have a value.
        creator: eff_confg
        consumer: various
        firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRRD_DLR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRFC_DLR</id>
    <description>
      Minimum Refresh Recovery Delay Time (different logical ranks)
      in nck (number of clock cyles).
      Selected tRFC value (tRFC_dlr1, tRFC_dlr2, or tRFC_dlr4)
      depends on MRW attribute that selects fine refresh mode (x1, x2, x4).
      For 3DS, The tRFC time to different logical ranks are defined as tRFC_dlr
      creator: eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRFC_DLR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TFAW_DLR</id>
    <description>
      Minimum Four Activate Window Delay Time
      in nck (number of clock cycles).
      For 3DS, the tFAW time to different logical ranks are defined as tFAW_dlr
      Each memory channel will have a value.
      creator: eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TFAW_DLR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TXS</id>
    <description>
      Exit Self-Refresh to commands not requiring a locked DLL.
      In nck (number of clock cycles).
      Each memory channel will have a value.
      creator: eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TXS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_CL</id>
    <description>
      CAS Latency.
      Each memory channel will have a value.
      creator: mss_freq
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_CL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_AL</id>
    <description>
      Additive Latency.
      Used in various locations and is computed in mss_eff_cnfg_timing.
      Each memory channel will have a value.
      creator: mss_eff_cnfg_timing
      consumer: various
      firmware notes: none
      DISABLE = 0, CL_MINUS_1 = 1, CL_MINUS_2 = 2
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_AL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_CWL</id>
    <description>
      CAS Write Latency.
      Used in various locations and is computed in mss_eff_cnfg_timing.
      Each memory channel will have a value.
      creator: mss_eff_cnfg_timing
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_CWL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RBT</id>
    <description>
      Read Burst Type.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      SEQUENTIAL = 0, INTERLEAVE = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RBT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TM</id>
    <description>
      Test Mode.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      NORMAL= 0, TEST = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DLL_RESET</id>
    <description>
      DLL Reset.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      NO = 0, YES = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DLL_RESET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR</id>
    <description>DRAM Write Recovery. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DLL_PPD</id>
    <description>
      DLL Precharge PD.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      SLOWEXIT = 0, FASTEXIT = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DLL_PPD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DLL_ENABLE</id>
    <description>
      DLL Enable.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      ENABLE = 0, DISABLE = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DLL_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TDQS</id>
    <description>
      TDQS.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TDQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TREFI</id>
    <description>
        Average Refresh Interval (tREFI)
        in nck (number of clock cycles).
        This depends on MRW attribute that selects fine refresh mode (x1, x2, x4).
        From DDR4 spec (79-4A).

        For 3DS, the tREFI time to the same logical rank is defined as
        tRFC_slr1, tRFC_slr2, or tRFC_slr4.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array> 2 </array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TREFI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR_LVL_ENABLE</id>
    <description>
      Write Level Enable.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      DISABLE = 0, ENABLE = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR_LVL_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_OUTPUT_BUFFER</id>
    <description>
      DRAM Qoff.
      Enables or disables DRAM output.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      ENABLE = 0, DISABLE = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_OUTPUT_BUFFER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_PASR</id>
    <description>
      Partial Array Self-Refresh.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      FULL = 0,
      FIRST_HALF = 1,
      FIRST_QUARTER = 2,
      FIRST_EIGHTH = 3,
      LAST_THREE_FOURTH = 4,
      LAST_HALF = 5,
      LAST_QUARTER = 6,
      LAST_EIGHTH = 7
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_PASR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ASR</id>
    <description>
      Auto Self-Refresh.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      SRT = 0, ASR = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_ASR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_SRT</id>
    <description>
      Self-Refresh Temperature Range.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      NORMAL = 0, EXTEND = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_SRT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_LOC</id>
    <description>
      Multi Purpose Register Location.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_LOC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_MODE</id>
    <description>
      Multi Purpose Register Mode.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      DISABLE = 0, ENABLE = 1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RCD_CNTL_WORD_0_15</id>
    <description>DIMM RCD Control Word. Initialized and used by HWPs.</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RCD_CNTL_WORD_0_15</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RCD_MIRROR_MODE</id>
    <description>
      RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: mss_dram_init
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RCD_MIRROR_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_MODE</id>
    <description>
    Specifies the schmoo mode to use during draminit_train_adv. Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_ADDR_MODE</id>
    <description>
    Specifies the schmoo mode to use during draminit_train_adv. Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_ADDR_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_TEST_VALID</id>
    <description>
    Specifies the schmoo test to run during draminit_train_adv. Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_TEST_VALID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_PARAM_VALID</id>
    <description>
    Specifies the schmoo parameters to use during draminit_train_adv. Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_PARAM_VALID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_WR_EYE_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_RD_EYE_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_DQS_CLK_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_RD_GATE_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_ADDR_CMD_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MEMCAL_INTERVAL</id>
    <description>
    Specifies the memcal interval in clocks. Initialized and used by HWPs.
    DISABLE = 0
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MEMCAL_INTERVAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_ZQCAL_INTERVAL</id>
    <description>
    Specifies the zqcal interval in clocks. Initialized and used by HWPs.
    DISABLE = 0
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_ZQCAL_INTERVAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_IBM_TYPE</id>
    <description>Specifies the memory topology type. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_IBM_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_DROPS_PER_PORT</id>
    <description>Specifies the number of DIMM dimensions that are valid per port. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_DROPS_PER_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_STACK_TYPE</id>
    <description>Specifies the DRAM package type. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_STACK_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_MASTER_RANKS_PER_DIMM</id>
    <description>Specifies the number of master ranks per DIMM. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_PACKAGES_PER_RANK</id>
    <description>Specifies the number of DRAM packages per rank. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_PACKAGES_PER_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIM_DIE_COUNT</id>
    <description>Specifies the number of DRAM dies per package. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIM_DIE_COUNT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <description>
     This is the throttled N commands per window
    of M DRAM clocks setting for cfg_nm_n_per_port.
    Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_M_DRAM_CLOCKS</id>
    <description>
      This is the throttled M DRAM clocks setting for cfg_nm_m.
      creator: mss_eff_cnfg
      consumer: mc_config
      firmware notes: none
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_M_DRAM_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
    <description>
      This is the throttle numerator setting for cfg_nm_n_per_slot
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_THERMAL_LIMIT</id>
    <description>
        DIMM Max Power based on a thermal limit
        Decoded from ATTR_MSS_MRW_THERMAL_POWER_LIMIT
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_THERMAL_LIMIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_DIES_PER_PACKAGE</id>
    <description>Specifies the number of DRAM dies per package. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_DIES_PER_PACKAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <description>DIMM throttle numerator. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLE_DENOMINATOR</id>
    <description>DIMM throttle denominator. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <description>This is the throttle numerator setting for cfg_nm_n_per_chip. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_WATT_TARGET</id>
    <description>
      Total memory power limit in cW for the dimms on the memory channel pair.
      Used to compute the throttles on the channel and/or dimms.
      creator: unknown.
      consumer: mss_eff_config.
      firmware notes: none.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_WATT_TARGET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_SLOPE</id>
    <description>DIMM Power slope value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MASTER_PWR_SLOPE</id>
    <description>Master Power slope value for dimm. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MASTER_PWR_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_SUPPLIER_PWR_SLOPE</id>
    <description>Supplier Power slope value for dimm. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_SUPPLIER_PWR_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_POWER_SLOPE2</id>
    <description>DIMM Power slope value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_SLOPE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_INT</id>
    <description>DIMM Power intercept value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_INT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MASTER_PWR_INTERCEPT</id>
    <description>
    Master Power intercept value for dimm
    Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MASTER_PWR_INTERCEPT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_SUPPLIER_PWR_INTERCEPT</id>
    <description>
    Supplier Power intercept value for dimm
    Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_SUPPLIER_PWR_INTERCEPT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_INT2</id>
    <description>Supplier Power intercept value for dimm</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_INT2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_TOTAL_POWER_SLOPE</id>
    <description>Master Total Power slope value for dimm</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_TOTAL_POWER_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_TOTAL_POWER_SLOPE2</id>
    <description>Supplier Total Power slope value for dimm</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_TOTAL_POWER_SLOPE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_TOTAL_POWER_INT</id>
    <description>Master Total Power intercept value for dimm</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_TOTAL_POWER_INT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_TOTAL_POWER_INT2</id>
    <description>Supplier Total Power intercept value for dimm</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_TOTAL_POWER_INT2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MAXBANDWIDTH_GBS</id>
    <description>DIMM Max Bandwidth in GBs output from thermal procedures. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MAXBANDWIDTH_GBS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MAXBANDWIDTH_MRS</id>
    <description>DIMM Max Bandwidth in MRs output from thermal procedures Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MAXBANDWIDTH_MRS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_MAXBANDWIDTH_GBS</id>
    <description>Channel Max Bandwidth in GBs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_MAXBANDWIDTH_GBS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS</id>
    <description>Pair Max Bandwidth in GBs output from thermal procedures. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_MAXBANDWIDTH_MRS</id>
    <description>Channel Max Bandwidth MRs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_MAXBANDWIDTH_MRS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS</id>
    <description>Channel Pair Max Bandwidth MRs output from thermal procedures. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MAXPOWER</id>
    <description>DIMM Max Power output from thermal procedures. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_MAXPOWER</id>
    <description>Channel Max Power output. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_PAIR_MAXPOWER</id>
    <description>Channel Pair Max Power output from thermal procedures. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_PAIR_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <description>
    Runtime throttled N commands per
    M DRAM clocks setting for cfg_nm_n_per_port.
    Initialized and used by HWPs.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_M_DRAM_CLOCKS</id>
    <description>
      Runtime for M DRAM clocks setting for cfg_nm_m
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
    <description>
      Runtime throttle numerator setting for cfg_nm_n_per_slot
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <description>Runtime throttle numerator setting for cfg_nm_n_per_mba. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLE_DENOMINATOR</id>
    <description>Runtime throttle denominator setting for cfg_nm_m. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <description>Runtime throttle numerator setting for cfg_nm_n_per_chip. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_ZSERIES</id>
    <description>Determines if the code is Zseries type or P Series.  The platform determines this and this attribute is mostly used in the initfiles so that we can share the same initialization code with the zSeries team</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_ZSERIES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- Note: This looks incorrect because memory_attributes.xml says it is platInit (therefore we should set it up to a sensible value),
     but recent discussions have concluded that a HWP will fill this in, this implementation is correct, memory_attributes.xml will eventually change. -->
<attribute>
    <id>MSS_NWELL_MISPLACEMENT</id>
    <description>Set by the platform depending on DD1 vs DD1.01.  If true, then SI settings affected by the NWELL problem are adjusted.  Used in eff_config</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_NWELL_MISPLACEMENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <description>
      Used in the setting of groups.  It is a bit vector.  If the value
      BITWISE_AND  0x01 = 0x01 then groups of 1 are enabled,
      if the value BITWISE_AND  0x02 = 0x02, then groups of 2 are possible,
      if the value BITWISE_AND  0x04 = 0x04, then group of 3 are possible,
      if the value BITWISE_AND  0x08 = 0x08, then groups of 4 are possible,
      if the value BITWISE_AND 0x20 = 0x20, then groups of 6 are possible,
      if the value BITWISE_AND 0x80 = 0x80, then groups of 8 are possible.
      If no groups can formed according to this input, then an error will
      be thrown.
      Provided by the MRW
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
        <uint8_t>
            <default>0xAF</default><!-- Maximum interleaving -->
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CACHE_ENABLE</id>
    <description>
        Specifies if a Memory Buffer chip L4 cache is enabled or disabled
        For good memory buffer chips, L4 is enabled
        Firmware can set to disabled for a particular chip if the cache is
          not functional
        1 = enabled, 0 = disabled.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CACHE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_PREFETCH_ENABLE</id>
    <description>
      Value of on or off.  Determines if prefetching enabled or not.
      See chapter 7 of the Centaur Workbook.
    </description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_PREFETCH_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CLEANER_ENABLE</id>
    <description>
      Value of on or off.
      Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles)
      enabled or not. See chapter 7 of the Centaur Workbook.
    </description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CLEANER_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_LAB_OVERRIDE_FOR_MEM_PLL</id>
    <description>override the default Centaur MEM PLL settings with user-specified scan chain data. 1 = ON, 0 = OFF.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_LAB_OVERRIDE_FOR_MEM_PLL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_MC_IN_GROUP</id>
    <description>A 8 bit vector that would be a designation of which MC are involved in the group. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>8</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_MC_IN_GROUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MCS_GROUP_32</id>
    <description>
       Data Structure from eff grouping to setup bars to help determine
       different groups
       Non-Mirroring array[0-7]  [0.17]:  0-- Port size; 1-- No of ports in group; 2-- Total group size of non-mirroring;
                                          3-- Base address; 4-11-- PortID number in group;
                                         12-- Alt Memory valid(0); 13-- Alt Memory valid (1);
                                         14-- Alt Group size (0); 15-- Alt Group size(1);
                                         16-- Alt Base address (0); 17-- Alt Base address (1);

                                         13-- Alternate Group Size; 14-- Alternate Base address
       Mirroring     array[8-15] [0:17]:  0-- Port size; 1-- No of ports in group; 2-- Total group size of mirroring;
                                          3-- Base address; 4-11-- PortID number;
                                         12-- Alt Memory valid(0); 13-- Alt Memory valid (1);
                                         14-- Alt Group size (0); 15-- Alt Group size(1);
                                         16-- Alt Base address (0); 17-- Alt Base address (1);
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>16,18</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MCS_GROUP_32</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_EFF_DIMM_FUNCTIONAL_VECTOR</id>
    <description>
      A bit vector (per Dean's request) specifying if a DIMM is functional.
      DIMM attributes, such as SIZE, are qualified by this bit vector.
      The attribute ANDed 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is functional.
      0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1 is functional.
      A fully populated system would have the value of 0xCC.
      Used in various locations and is computed in mss_eff_cnfg.
      Each memory channel will have a value. creator: mss_eff_cnfg consumer: various firmware notes: none
      This factors in functionality
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CAL_STEP_ENABLE</id>
    <description>
    A bit map ofvector denoting valid cal steps to run (0 is left most bit)
    [0] EXT_ZQCAL
    [1] WR_LEVEL
    [2] DQS_ALIGN
    [3] RDCLK_ALIGN
    [4] READ_CTR
    [5] READ_CTR_2D_VREF
    [6] WRITE_CTR
    [7] WRITE_CTR_2D_VREF
    [8] COARSE_WR
    [9] COARSE_RD
    [10]:[15] Reserved for future use
    COARSE_WR and COARSE_RD  will be consumed together to form COARSE_LVL.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CAL_STEP_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_IPL_COMPLETE</id>
    <description>A numerical number indicating if the memory procedures are complete.  written by mss_setup_bars when the bars are now functional in the processor.  </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_IPL_COMPLETE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_SLEW_RATE_DATA</id>
    <description>
      The 4 bit result of running the slew calibration algorithm at various rates and impedances.
      The first dimension is port, the second is the impedance of 24,30,34, and 40 Ohms.
      The 3rd dimension is the rate: 3,4,5 or 6 V/ns.
      Computed and sent to the correct data blocks in phy_reset.
      Also used in advanced training
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2, 4, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_SLEW_RATE_DATA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_SLEW_RATE_ADR</id>
    <description>
      The 4 bit result of running the slew calibration algorithm at various rates and impedances.
      The first dimension is the port.  The second is the impedance of 15, 20, 30 and 40 Ohms.
      The 3rd dimension is the rate:3, 4,5 or 6 V/ns.
      Computed and sent to the correct data blocks in phy_reset.
      Also used in advanced training
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2, 4, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_SLEW_RATE_ADR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ECID</id>
    <description>
    Bits 0 to 63 of the ECID in array entry 0 and bits 64 to 127 in ECID array entry 1
    Created from running proc_getecid.C for processors
    Created from running mss_get_cen_ecid.C for centaurs
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ECID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C1_HAS_POWER</id>
    <description>
        Indicates core 1 has power and has valid latch state that could be scanned
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C1_HAS_POWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C0_HAS_POWER</id>
    <description>
        Indicates core 0 has power and has valid latch state that could be scanned
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C0_HAS_POWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_HAS_POWER</id>
    <description>
        Indicates L3 has power and has valid latch state that could be scanned
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_HAS_POWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_HAS_POWER</id>
    <description>
        Indicates L2 has power and has valid latch state that could be scanned
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_HAS_POWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C1_PC_HAS_CLOCKS</id>
    <description>
        Indicates the core pervasive unit in core 1 has clocks running and scommable
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C1_PC_HAS_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C0_PC_HAS_CLOCKS</id>
    <description>
        Indicates the core pervasive unit in core 0 has clocks running and scommable
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C0_PC_HAS_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C1_EXEC_HAS_CLOCKS</id>
    <description>
        Indicates the execution units in core 1 have clocks running and scommable
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C1_EXEC_HAS_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C0_EXEC_HAS_CLOCKS</id>
    <description>
        Indicates the execution units in core 0 have clocks running and scommable
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C0_EXEC_HAS_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_HAS_CLOCKS</id>
    <description>
        Indicates the L3 region has clocks running and scommable
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_HAS_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_HAS_CLOCKS</id>
    <description>
        Indicates the L2 region has clocks running and scommable
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_HAS_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OBUS_RATIO_VALUE</id>
    <description>
        Holds Obus ratio value
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OBUS_RATIO_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CME_LOCAL_FIRMASK</id>
    <description>
    The FIR mask value that has to be restored to the CME FIR
    register. This value will be stored during the reset phase when the
    FIRMASK will be cleared as part of the cleanup action.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CME_LOCAL_FIRMASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>QUAD_PPM_ERRMASK</id>
    <description>
    The error mask value that has to be restored to the PPM
    ERRMASK register for the Quad. This value will be stored during the
    reset phase when the ERRMASK will be cleared as part of the
    cleanup action.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_QUAD_PPM_ERRMASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CORE_PPM_ERRMASK</id>
    <description>
    The error mask value that has to be restored to the PPM
    ERRMASK register for the CORE. This value will be stored during the
    reset phase when the ERRMASK will be cleared as part of the
    cleanup action.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CORE_PPM_ERRMASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SPD_OVERRIDE_ENABLE</id>
    <description>
    Set equal to 1 to activate the use of ATTR_SPD_OVERRIDE.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SPD_OVERRIDE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SPD_OVERRIDE</id>
    <description>
    Byte-for-byte override for the bucket of data that would
    normally come from SPD.  If ATTR_SPD_OVERRIDE_ENABLE!=0 then
    the value of this attribute will be returned to callers of
    fapi2::getSPD() instead of the actual SPD contents.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>512</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SPD_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_MW_ENABLE</id>
    <description>
        Set equal to 1 to activate the use of ATTR_VPD_OVERRIDE_MW.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_MW_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_MW</id>
    <description>
    Byte-for-byte override for the bucket of MW data that would
    normally come from VPD.  If ATTR_VPD_OVERRIDE_MW_ENABLE!=0 then
    the value of this attribute will be returned to callers of
    fapi2::getVPD() instead of the actual VPD contents.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>255</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_MW</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_MR_ENABLE</id>
    <description>
        Set equal to 1 to activate the use of ATTR_VPD_OVERRIDE_MR.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_MR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_MR</id>
    <description>
    Byte-for-byte override for the bucket of MR data that would
    normally come from VPD.  If ATTR_VPD_OVERRIDE_MR_ENABLE!=0 then
    the value of this attribute will be returned to callers of
    fapi2::getVPD() instead of the actual VPD contents.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>255</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_MR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_MT_ENABLE</id>
    <description>
    Set equal to 1 to activate the use of ATTR_VPD_OVERRIDE_MT.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_MT_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_MT</id>
    <description>
    Byte-for-byte override for the bucket of MT data that would
    normally come from VPD.  If ATTR_VPD_OVERRIDE_MT_ENABLE!=0 then
    the value of this attribute will be returned to callers of
    fapi2::getVPD() instead of the actual VPD contents.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>255</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_MT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_DQ_ENABLE</id>
    <description>
        Set equal to 1 to activate the use of ATTR_VPD_OVERRIDE_DQ.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_DQ_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_DQ</id>
    <description>
    Byte-for-byte override for the bucket of DQ data that would
    normally come from VPD.  If ATTR_VPD_OVERRIDE_DQ_ENABLE!=0 then
    the value of this attribute will be returned to callers of
    fapi2::getVPD() instead of the actual VPD contents.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>160</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_DQ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_CK_ENABLE</id>
    <description>
        Set equal to 1 to activate the use of ATTR_VPD_OVERRIDE_CK.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_CK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_OVERRIDE_CK</id>
    <description>
    Byte-for-byte override for the bucket of CK data that would
    normally come from VPD.  If ATTR_VPD_OVERRIDE_CK_ENABLE!=0 then
    the value of this attribute will be returned to callers of
    fapi2::getVPD() instead of the actual VPD contents.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VPD_OVERRIDE_CK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--TOOD RTC: 151938 Make sure that these are set up by parseMRW script-->
<attribute>
    <id>MSS_MRW_SUPPORTED_FREQ</id>
    <description>
    List of memory frequencies supported by the current system.
    </description>
    <simpleType>
        <uint32_t>
        <default>1866,2133,2400,2667</default>
        </uint32_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_SUPPORTED_FREQ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEMVPD_POS</id>
    <description>
      The position of the MCS target's VPD selector data, relative to the EEPROM
      that contains its data.  The VPD defition supports up to 16 values per
      EEPROM.
      For systems with an EEPROM per chip, this value should be equivalent to
      ATTR_CHIP_UNIT_POS.
      For systems with a single EEPROM for all chips, the value should follow
      the physical position in such a way to fit within the 16 available slots.
    </description>
    <simpleType>
        <uint8_t>
        <default>0xFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEMVPD_POS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PBA_LFIR</id>
    <description>
    The attribute stores the Local FIR value of PBA taken
    during the reset phase.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PBA_LFIR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OCC_LFIR</id>
    <description>
    The attribute stores the Local FIR value of OCC taken
    during the reset phase.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OCC_LFIR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_ALLOW_SINGLE_PORT</id>
    <description>
      When this value is true, then mss_eff config will allow a single port to have one dimm
      and will allow ports to have different sizes. Used in eff_config
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
            <array>2</array>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_ALLOW_SINGLE_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603. These phase rotator EFF attributes have corresponding
     VPD attributes that come from CVPD. When all HWPs are using the VPD
     versions, these EFF versions can be deleted -->

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CLK_P0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CLK_P0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CLK_P1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CLK_P1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CLK_P0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CLK_P0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CLK_P1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CLK_P1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A4</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A4</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A5</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A5</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A6</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A6</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A7</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A7</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A8</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A8</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A9</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A9</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A10</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A10</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A11</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A11</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A12</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A12</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A13</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A13</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A14</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A14</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A15</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A15</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_BA0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_BA0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_BA1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_BA1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_BA2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_BA2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_CASN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_CASN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_RASN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_RASN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_WEN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_WEN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_PAR</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_PAR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_ACTN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_ACTN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_ODT0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_ODT0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_ODT1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_ODT1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_ODT0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_ODT0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_ODT1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_ODT1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603 down to here -->

<attribute>
    <id>MSS_DQS_SWIZZLE_TYPE</id>
    <description>
      DQS Swizzle type is set by the platform to describe what kind of DQS connection is being used for register acceses.
      Type 0 is normal, type 1 is for systems with wiring like glacier 1, type 2 is for Pallmeto.
      Additional types maybe defined if new boards have even different DQS swizzle features
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DQS_SWIZZLE_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MCS_GROUP</id>
    <description>Data Structure from eff grouping to setup bars to help determine different groups
   Non- Mirroring [0-7] 0 -- MCS size //1-- No of MCS/group //2-- Total group size //3 -- Base address// 4-11 - MCS ID number// 12 --Alter.Bar //13 - A.Group Size // 14 - A.Base address
 //  Mirroring      [8-15] 0 -- MCS size //1-- No of MCS/group //2-- Total group size //3 -- Base address// 4-11 - MCS ID number// 12 --Alter.Bar //13 - A.Group Size // 14 - A.Base address
Measured in GB</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>16,16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MCS_GROUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CKE_MAP</id>
    <description>Rank to CKE map. Used in various locations and is computed in mss_eff_cnfg_cke_map. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.   creator: mss_eff_cnfg_cke_map consumer: various firmware notes: none</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CKE_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SPCKE_MAP</id>
    <description>Rank to Spare CKE map. Used in various locations and is computed in mss_eff_cnfg_cke_map. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.   creator: mss_eff_cnfg_cke_map consumer: various firmware notes: none</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SPCKE_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_SPARE</id>
    <description>
      Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg.
      creator: mss_eff_cnfg consumer: various firmware notes: load from spd
      OBSOLETE: Use ATTR_VPD_DIMM_SPARE
      NO_SPARE = 0, LOW_NIBBLE = 1, HIGH_NIBBLE = 2, FULL_BYTE = 3
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_SPARE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_PSRO</id>
    <description>Set by the centaur mss_get_cen_ecid function used diagnostic and chip characterization reporting</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_PSRO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== End Attributes supporting memory_attributes.xml HWPF Attributes ===== -->

<attribute>
    <id>EI_BUS_TX_LANE_INVERT</id>
    <description>
      This attribute represents the polarity of a differential wire pair on the DMI and A buses.
      creator: platform (generated based on MRW data)
      See defintion in common_attributes.xml for more information.
    </description>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EI_BUS_TX_LANE_INVERT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PERV_BNDY_PLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for perv_bndy_pll ring containing filter plls and xb_pll,nest_pll
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PERV_BNDY_PLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PB_BNDY_DMIPLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for pb_bndy_dmipll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PB_BNDY_DMIPLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AB_BNDY_PLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for ab_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AB_BNDY_PLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCI_BNDY_PLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for pci_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCI_BNDY_PLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PERV_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for perv_bndy_pll ring containing filter plls and xb_pll,nest_pll
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0x00100008</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PERV_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PB_BNDY_DMIPLL_SCAN_SELECT</id>
    <description>Scan select for ring image for pb_bndy_dmipll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PB_BNDY_DMIPLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AB_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for ab_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AB_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCI_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for pci_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCI_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== Supporting poreve_memory_attributes.xml ===== -->

<attribute>
    <id>SBE_SEEPROM_I2C_ADDRESS_BYTES</id>
    <description>
      The number of address bytes required to address the SEEPROM memory
      device that contains SBE IPL code.  This will vary by device based on
      the device capacity, and must be either 1, 2, 3 or 4.
    </description>
    <simpleType>
        <uint8_t>
            <default>2</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SEEPROM_I2C_ADDRESS_BYTES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_SEEPROM_I2C_DEVICE_ADDRESS</id>
    <description>
        sbe seeprom iic device address
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SEEPROM_I2C_DEVICE_ADDRESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_SEEPROM_I2C_PORT</id>
    <description>
        SBE seeprom iic port
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SEEPROM_I2C_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PNOR_I2C_ADDRESS_BYTES</id>
    <description>
      The number of address bytes required to address the PNOR memory device
      via the pseudo-I2C (LPC, ECCAX) controller.  This will vary by device
      based on the device capacity, and must be either 0, 1, 2, 3 or 4.

      This attribute will be set to 0 for chips with no PNOR attached
      (PoreVe will never run on these chips).

      Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
            <default>4</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PNOR_I2C_ADDRESS_BYTES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== End supporting poreve_memory_attributes.xml ===== -->

<!-- Support for sync_attributes.xml -->
<attribute>
    <id>SYNC_BETWEEN_STEPS</id>
    <description>
        Attribute to enable targetting attribute sync when in istep mode.
        1 = sync will occur following each substep when ipl'ing in single step mode
        0 = sync will not be done after each step
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
        <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYNC_BETWEEN_STEPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!-- End support for sync_attributes.xml -->

<!--    Support for proc_select_boot_master -->

<enumerationType>
    <id>PROC_SELECT_BOOT_MASTER</id>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
        <name>PRIMARY</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECONDARY</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_SELECT_BOOT_MASTER</id>
  <description>
    Specifies which chip should be used as the boot master
    Initialized by the platform.
      PRIMARY  - the primary master is used for the BOOT
      SECONDARY  - the alternate master is used for the BOOT
      Platforms are expected to set this to PRIMARY in normal operation
  </description>
  <simpleType>
    <uint8_t>
      <default>1</default>
    </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_MASTER</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<enumerationType>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
    <description>Enumeration indicating which SEEPROM image should be used for the boot master</description>
    <enumerator>
        <name>FIRST</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECOND</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_SELECT_SEEPROM_IMAGE</id>
  <description>
    Specifies which SEEPROM image should be used for the boot master.
      FIRST  - the first image was selected
      SECOND - the second image was selected
      Platforms are expected to set this to FIRST in normal operation
  </description>
  <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
    <description>Enumeration indicating which SEEPROM image should be used to boot a processor</description>
    <enumerator>
        <name>FIRST</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECOND</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
  <description>
    Specifies which SEEPROM image should be used to boot a processor
      FIRST  - the first image was selected
      SECOND - the second image was selected
  </description>
  <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ENABLED_THREADS</id>
    <description>
       Bitmask of threads to enable for each processor,
       Zero means enable all architected threads
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MAX_PROC_CHIPS_PER_NODE</id>
    <description>
        System attribute.
        The max proc chips per node available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <description>
        System attribute.
        The max EX units per proc chip available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <description>
        System attribute.
        The max DIMMs per MBA Port available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <description>
        System attribute.
        The max MBA ports per MBA available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <description>
        System attribute.
        The max MBAS per membuf available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <description>
        System attribute.
        The max chiplets per proc available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_MCS_PER_SYSTEM</id>
    <description>
        System attribute.
        The max MCS units available in the system.
    </description>
    <simpleType>
        <uint8_t>
            <default>4</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TEST_NEGATIVE_FCN</id>
    <description>Attribute to test signed attribute
        functionality in the system</description>
    <simpleType>
        <int8_t>
            <default>-6</default>
        </int8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
    <readable/>
</attribute>

<!-- Note: This attribute is only used by FSP -->
<attribute>
    <id>DMI_REFCLOCK_SWIZZLE</id>
    <description>
      Defines Murano/Venice/Naples FSI GP8 refclock enable field bit offset (0:7) associated with this MCS chip unit.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_REFCLOCK_SWIZZLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EI_BUS_TX_MSBSWAP</id>
    <description>
        Source: MRW: Downstream MSB Swap and Upstream MSB Swap
        Usage:  TX_MSBSWAP initfile setting for DMI and A buses

        This attribute represents whether or not a single clock group bus such as DMI and A bus was wired by the board designer using a feature
        called MSB Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip where 'n' is the width of the bus. A basic description
        of this capability is that the board designer can save layers on the board wiring by crossing the wiring between the two chips in
        a prescribed manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to lane 0 on the RX chip, lane 1 to lane 1 and so on.
        If a bus is MSB Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX chip, lane 1 to lane 'n-2', etc. Random or
        arbitrary wiring of TX to RX lanes on different chips is NOT ALLOWED.

        The Master Chip of two connected chips is defined as the chip with the smaller value of (100*Node + Pos).
        The Slave Chip of two connected chips is defined as the chip with the larger value of (100*Node + Pos).
        The Downstream direction is defined as the direction from the Master chip to the Slave chip.
        The Upstream direction is defined as the direction from the Slave chip to the Master chip.

        The Downstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream bus is wired msb to lsb etc. and
        0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0).

        The Upstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream bus is wired msb to lsb etc. and
        0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0).

        It is up to the platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the correct target endpoints.

    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EI_BUS_TX_MSBSWAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_FREQ_OVERRIDE</id>
    <description>
      FOR LAB USE ONLY: Frequency override of this memory channel in MT/s
      comprising of up to three DIMMs.
      Set by config file or an attribute writing program.
      Consumed by mss_freq.
      The default of AUTO means mss_freq will find the best frequencies given the DIMMs plugged in and other rules.
      Otherwise, this is the system frequency.
      firmware notes: Platforms should initialize this attribute to AUTO (0)
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_FREQ_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- mcbist attributes -->
<attribute>
    <id>MCBIST_PATTERN</id>
    <description>Enables mcbist data pattern selection.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_PATTERN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_TEST_TYPE</id>
    <description>Enables mcbist test type selection.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_TEST_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_PRINTING_DISABLE</id>
    <description>MCBIST support for printing</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_PRINTING_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_DATA_ENABLE</id>
    <description>MCBIST support for enabling data</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_DATA_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_USER_RANK</id>
    <description>MCBIST support for rank selection</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_USER_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_USER_BANK</id>
    <description>MCBIST support for bank selection</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_USER_BANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCHMOO_MULTIPLE_SETUP_CALL</id>
    <description>MCBIST for multiple setup</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCHMOO_MULTIPLE_SETUP_CALL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_MODES</id>
    <description>Can choose mcbist address mode for full,half or quarter addressing mode.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_MODES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_RANK</id>
    <description> Defines the rank for the Mcbist </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_START_ADDR</id>
    <description>Defines the start address for the Mcbist address range</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_START_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_END_ADDR</id>
    <description>Defines the end address for the Mcbist address range</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_END_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ERROR_CAPTURE</id>
    <description>Enables error capture; basically a flag.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ERROR_CAPTURE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_MAX_TIMEOUT</id>
    <description>Define mcbist Max timeout</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_MAX_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_PRINT_PORT</id>
    <description>Enable which port prints are required.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_PRINT_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_STOP_ON_ERROR</id>
    <description>Flag to stop Mcbist on Error.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_STOP_ON_ERROR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_DATA_SEED</id>
    <description>Define data seed for the random data pattern or test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_DATA_SEED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_INTER</id>
    <description>The address interleave map with user cases or deafult cases of BANK_RANK,RANK_BANK,BANK_ONLY,RANK_ONLYRANKS_DIMM0,RANKS_DIMM1,USER_PATTERN.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_INTER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_NUM_ROWS</id>
    <description>User defined constraint for limiting number of rows for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_NUM_ROWS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_NUM_COLS</id>
    <description>User defined constraint for limiting number of columns for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_NUM_COLS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_RANK</id>
    <description>User defined constraint for limiting number of ranks for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_BANK</id>
    <description>User defined constraint for limiting number of banks for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_BANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_SLAVE_RANK_ON</id>
    <description>If slave ranks exists;Restrict usage or enable addressing on them as well.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_SLAVE_RANK_ON</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_STR_MAP</id>
    <description>To Define custom addressing map ; Input by user.</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_STR_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_RAND</id>
    <description>Flag for Addressing to go sequential manner or random.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_RAND</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_REFCLOCK_ENABLE</id>
    <description>PCIE refclock enable valid mask
      PCIE refclock enable valid mask
      creator: platform
      consumer: p9_pcie_scominit
    </description>
    <simpleType>
       <uint8_t>
       </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_REFCLOCK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_PBIEX_ASYNC_SEL</id>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
        <name>SEL0</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>SEL1</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SEL2</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_PBIEX_ASYNC_SEL</id>
    <description>Selector for ATTR_PROC_EX_FUNC_L3_DELTA_DATA value to be returned by platform.
      creator: proc_build_smp
      firmware notes:
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PBIEX_ASYNC_SEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_DCM_INSTALLED</id>
    <description>
      PROC_CHIP Attribute
        If true, the chip is installed on a Dual Chip Module
        Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_DCM_INSTALLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<!-- === Attributes supporting erepair_thresholds.xml HWPF Attributes === -->
<attribute>
    <id>X_EREPAIR_THRESHOLD_FIELD</id>
    <description>
      This attribute represents the eRepair threshold value of X-Bus used
      in the field.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_X_EREPAIR_THRESHOLD_FIELD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>A_EREPAIR_THRESHOLD_FIELD</id>
    <description>
      This attribute represents the eRepair threshold value of A-Bus used
      in the field.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_A_EREPAIR_THRESHOLD_FIELD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DMI_EREPAIR_THRESHOLD_FIELD</id>
    <description>
      This attribute represents the eRepair threshold value of DMI-Bus used
      in the field.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_EREPAIR_THRESHOLD_FIELD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>X_EREPAIR_THRESHOLD_MNFG</id>
    <description>
      This attribute represents the eRepair threshold value of X-Bus used
      by Manufacturing.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_X_EREPAIR_THRESHOLD_MNFG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>A_EREPAIR_THRESHOLD_MNFG</id>
    <description>
      This attribute represents the eRepair threshold value of A-Bus used
      by Manufacturing.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_A_EREPAIR_THRESHOLD_MNFG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DMI_EREPAIR_THRESHOLD_MNFG</id>
    <description>
      This attribute represents the eRepair threshold value of DMI-Bus used
      by Manufacturing.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_EREPAIR_THRESHOLD_MNFG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!-- ===== End Attributes supporting erepair_thresholds.xml HWPF Attributes ===== -->

<!-- Mem PLL attributes ===== -->
<attribute>
    <id>MEMB_TP_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for Centaur tp_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0x00100008</default>
        </uint32_t>
    </simpleType>
    <readable/>
    <persistency>non-volatile</persistency>
    <hwpfToHbAttrMap>
        <id>ATTR_MEMB_TP_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_mba</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <description>
    Machine Readable Workbook Thermal Memory Power Limit
    Used to calculate throttles to be at or under the power limit
    Per DIMM basis
    Consumers: eff_config_thermal and bulk_pwr_throttles
    </description>
    <simpleType>
        <uint64_t>
         <default>0xffffe000000006a4,0,0,0,0,0,0,0,0,0</default>
        </uint64_t>
        <array>10</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_LPASR</id>
    <description>
      Low Power Auto Self-Refresh.
      This is for DDR4 MRS2.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_LPASR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_PAGE</id>
    <description>
      MPR Page Selection This is for DDR4 MRS3.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_PAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_GEARDOWN_MODE</id>
    <description>
      Gear Down Mode.
      This is for DDR4 MRS3.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_GEARDOWN_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PER_DRAM_ACCESS</id>
    <description>
      Per DRAM accessibility.
      This is for DDR4 MRS3.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PER_DRAM_ACCESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TEMP_READOUT</id>
    <description>
      Temperature sensor readout.
      This is for DDR4 MRS3.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_READOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_FINE_REFRESH_MODE</id>
    <description>Fine refresh mode. This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_FINE_REFRESH_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CRC_WR_LATENCY</id>
    <description>
      write latency for CRC and DM. This is for DDR4 MRS3.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CRC_WR_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_RD_FORMAT</id>
    <description>
      MPR READ FORMAT.
      This is for DDR4 MRS3.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_RD_FORMAT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MAX_POWERDOWN_MODE</id>
    <description>
      Max Power down mode.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MAX_POWERDOWN_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TEMP_REF_RANGE</id>
    <description>Temp ref range. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_REF_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TEMP_REF_MODE</id>
    <description>
      Temp controlled ref mode. This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_REF_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>EFF_TEMP_REFRESH_MODE</id>
    <description>
      Temp controlled ref mode. This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_REFRESH_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_INT_VREF_MON</id>
    <description>
      Internal Vref Monitor.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_INT_VREF_MON</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_INTERNAL_VREF_MONITOR</id>
    <description>
      Internal Vref Monitor.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_INTERNAL_VREF_MONITOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CS_CMD_LATENCY</id>
    <description>
      CS to CMD/ADDR Latency.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CS_CMD_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SELF_REF_ABORT</id>
    <description>
      Self Refresh Abort.
      This is for DDR4 MRS4.
      Computed in mss_eff_cnfg.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SELF_REF_ABORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RD_PREAMBLE_TRAIN</id>
    <description>
      Read Pre amble Training Mode. This is for DDR4 MRS4.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RD_PREAMBLE_TRAIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RD_PREAMBLE</id>
    <description>
      Read Pre amble. This is for DDR4 MRS4.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RD_PREAMBLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WR_PREAMBLE</id>
    <description>
      Write Pre amble. This is for DDR4 MRS4.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WR_PREAMBLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CA_PARITY_LATENCY</id>
    <description>
      C/A Parity Latency Mode. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CA_PARITY_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CRC_ERROR_CLEAR</id>
    <description>
    CRC Error Clear.
    This is for DDR4 MRS5.
    Computed in mss_eff_cnfg.
    Each memory channel will have a value.
    creator: mss_eff_cnfg
    consumer: various
    firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CRC_ERROR_CLEAR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CA_PARITY_ERROR_STATUS</id>
    <description>
      C/A Parity Error Status. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CA_PARITY_ERROR_STATUS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_ODT_INPUT_BUFF</id>
    <description>
      ODT Input Buffer during power down. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_ODT_INPUT_BUFF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CA_PARITY</id>
    <description>
      CA Parity Persistance Error. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CA_PARITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DATA_MASK</id>
    <description>
      Data Mask. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DATA_MASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WRITE_DBI</id>
    <description>
      Write DBI. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WRITE_DBI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_READ_DBI</id>
    <description>
      Read DBI. This is for DDR4 MRS5.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_READ_DBI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_VREF_DQ_TRAIN_VALUE</id>
    <description>
      vrefdq_train value. This is for DDR4 MRS6.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_VREF_DQ_TRAIN_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VREF_DQ_TRAIN_VALUE</id>
    <description>
      vrefdq_train value. This is for DDR4 MRS6.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VREF_DQ_TRAIN_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>EFF_VREF_DQ_TRAIN_RANGE</id>
    <description>
      vrefdq_train range. This is for DDR4 MRS6.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_VREF_DQ_TRAIN_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VREF_DQ_TRAIN_RANGE</id>
    <description>
      vrefdq_train range. This is for DDR4 MRS6.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VREF_DQ_TRAIN_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_VREF_DQ_TRAIN_ENABLE</id>
    <description>
      vrefdq_train enable. This is for DDR4 MRS6.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_VREF_DQ_TRAIN_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VREF_DQ_TRAIN_ENABLE</id>
    <description>
      vrefdq_train enable. This is for DDR4 MRS6.
      Computed in mss_eff_cnfg. Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VREF_DQ_TRAIN_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TCCD_L</id>
    <description>tccd_l. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TCCD_L</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WRITE_CRC</id>
    <description>
      Write CRC control for DDR4 in MRS2.
      Set in mss_eff_cnfg.
      Each memory channel will have a value.
      Creator: mss_eff_cnfg
      Consumer:various
      Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WRITE_CRC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_2N_MODE_ENABLED</id>
    <description>Describes if this MBA is in 2N address mode.  The DIMM attributes associated with this MBA describes if this mode is needed for SI.  The MR Keyword of the VPD gives and indication of the value needed. Set by eff_config and consumed in the mba_def.initfile.</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_2N_MODE_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_POWER_TEST_REV</id>
    <description>The power test revision number that is saved when data is saved on an ISDIMM.  If the power test changes, then a difference indicates that the power test needs to be rerun.  This attribute needs to stick around between IPLs</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_POWER_TEST_REV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FRU_ID</id>
    <description>FRU ID attribute used to report FRU information to the BMC
        for each fru in the system.</description>
    <simpleType><uint32_t><default>0</default></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <global/>
</attribute>

<attribute>
    <id>BMC_FRU_ID</id>
    <description>BMC FRU ID attribute to report the system firmware levels
        to the BMC.</description>
    <simpleType><uint32_t><default>0</default></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>CENTAUR_ECID_FRU_ID</id>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to
        report the ECID data to the BMC and make it available for systems which
        have then centaur chips soldered to the backplane.</description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <description>
      Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL
      (not an IPL by steps). This is read by Hostboot to determine if it needs
      to request the attribute overrides from HWSV before starting its IPL.
    </description>
    <simpleType><uint8_t><default>0x00</default></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>DUMMY_PERSISTENCY</id>
    <description>Cached value to test persistency</description>
    <simpleType>
       <uint8_t>
          <default>0</default>
       </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DUMMY_PERSISTENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IS_INTER_ENCLOSURE_BUS</id>
    <description>Indicate an inter-enclosure bus at this endpoint target.
                 0 = No, 1 = Yes
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PEER_PATH</id>
    <description>Entity path of the peer target of an Abus
    </description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PROC_OCC_SANDBOX_SIZE</id>
    <description> The amount of memory a user can reserve to store OCC sandbox
                  functions.
                  Used by p9_mss_eff_grouping.
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_OCC_SANDBOX_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_OCC_SANDBOX_BASE_ADDR</id>
    <description>OCC sandbox base address allocated
    </description>
    <simpleType><uint64_t></uint64_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_OCC_SANDBOX_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_MIRROR_PLACEMENT_POLICY</id>
    <description>Define placement policy/scheme for non-mirrored/mirrored memory
                 layout
      creator: platform
      consumer: opt_memmap
      firmware notes:
        NORMAL  = non-mirrored start: 0, mirrored start: 512TB
        FLIPPED = mirrored start: 0, non-mirrored start: 512TB
        SELECTIVE = non-mirrored/mirrored start (interleaved): 0
        DRAWER = non-mirrored start: 1TB*drawer, mirrored start: 512TB+(1TB*drawer/2)
    </description>
    <simpleType>
      <uint8_t>
            <!-- Normal -->
            <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEM_MIRROR_PLACEMENT_POLICY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AS_MMIO_BAR_BASE_ADDR</id>
    <description>AS MMIO BAR base address value
      creator: platform
      consumer: proc_setup_bars
      firmware notes:
        64-bit address representing BAR RA
        NOTE: BAR register covers RA 14:51
    </description>
    <simpleType>
       <uint64_t>
           <default>0</default>
       </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AS_MMIO_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AS_MMIO_BAR_ENABLE</id>
    <description>AS MMIO BAR enable
      creator: platform
      consumer: proc_setup_bars
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
            <!-- Disabled -->
            <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AS_MMIO_BAR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AS_MMIO_BAR_SIZE</id>
    <description>AS MMIO BAR size value
      creator: platform
      consumer: proc_setup_bars
      firmware notes: none
    </description>
    <simpleType>
       <uint64_t>
           <!-- 2_MB -->
           <default>0x0000000000200000</default>
       </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AS_MMIO_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RISK_LEVEL</id>
    <description>
        HWP/Init "risk level" enabled. Used by HB to pass to HB driven HWPs.
        FALSE = 0x0,TRUE = 0x1
        Override Attribute
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_RISK_LEVEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_FREQ_BIAS_PERCENTAGE</id>
    <description>
        Percentage to increase/decrease MEM frequency. two's complement number.
        Measured in 100's.  So the value of 100 is one percent increase.
        This frequency change comes from changing multipliers and dividers to
        get the desired frequency. The supported frequencies come from
        Tim Diemoz.
        Creator: platform set this to 0.  Users can set this to a valid value.
        VALID Values: (TBD % to TBD %) (Tuleta) (TBD % to TBD %) (Glacier)
        Set by: PLL settings written by Dave Cadigan
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_FREQ_BIAS_PERCENTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_MEM_SENSOR_CACHE_ADDR_MAP</id>
    <description>Machine Readable Workbook value detailing the wiring of the
                 8 dimm temperature sensors for non custom dimms, in DIMM A0,
                 A1,B0,B1,C0,C1,D0,D1 order. One nibble per sensor where
                 bit0 (MSB) is the i2c bus the sensor is attached to
                 (0 for master, 1 for spare) and bits 1:3 are for A2,A1,A0
                 of the sensor i2c address (where A2 is MSB)
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_MEM_SENSOR_CACHE_ADDR_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CDIMM_SENSOR_MAP_PRIMARY</id>
    <description>
        Custom DIMM Sensor Map for Primary I2C Port (1 byte of data):
            0x00 No sensors attached
            0x01 DIMM sensor 0 attached
            0x02 DIMM sensor 1 attached
            0x04 DIMM sensor 2 attached
            0x08 DIMM sensor 3 attached
            0x10 DIMM sensor 4 attached
            0x20 DIMM sensor 5 attached
            0x40 DIMM sensor 6 attached
            0x80 DIMM sensor 7 attached
            Comes from the VPD MW Keyword
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CDIMM_SENSOR_MAP_PRIMARY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CDIMM_SENSOR_MAP_SECONDARY</id>
    <description>
        Custom DIMM Sensor Map for Secondary I2C Port (1 byte of data):
            0x00 No sensors attached
            0x01 DIMM sensor 0 attached
            0x02 DIMM sensor 1 attached
            0x04 DIMM sensor 2 attached
            0x08 DIMM sensor 3 attached
            0x10 DIMM sensor 4 attached
            0x20 DIMM sensor 5 attached
            0x40 DIMM sensor 6 attached
            0x80 DIMM sensor 7 attached
            Comes from the VPD MW Keyword
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CDIMM_SENSOR_MAP_SECONDARY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ADDRESS_MIRRORING</id>
    <description>
        Address mirroring on the DIMM by rank, up to 4 ranks.
            0x08 means rank 0 is mirrored
            0x04 means rank 1 is mirrored
            0x02 means rank 2 is mirrored
            0x01 means rank 3 is mirrored
        Comes from EFF config reading the VPD_DRAM_ADDRESS_MIRRORING from the
        AM keyword of the VPD.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_ADDRESS_MIRRORING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_BLUEWATERFALL_BROKEN</id>
    <description>
        Set by the platform depending on DD1.0X vs DD1.03 or newer. If true,
        then draminit_train will modify dqs_clk_ps and gate to work around the
        issue. Set in get ecid which determines if we are at 1.03
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_BLUEWATERFALL_BROKEN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CDM_POLICIES</id>
    <description>
        Cec Degraded Mode Policy flags
        Use the CDM_POLICIES enum to decode.
        If the appropriate bit is 1 then the policy mode is enabled,
        and those type of Guard records are disabled.
    </description>
    <simpleType>
        <uint8_t>
            <default>0x00</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
    <readable/>
</attribute>

<enumerationType>
    <id>CDM_POLICIES</id>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
        <description>
        MFG_Guard policy:
        Used in MFG only to prevent and disable the following:
        . Storing or creation of new Guard records from Diagno`stic or other
            faults through error logs. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        . Storing or creation of Manual Guard record from user.
            NOTE: this does not stop FCO.
        . Using an already stored System or Manual Guard record from
            deconfiguring resources. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        </description>
        <name>MANUFACTURING_DISABLED</name>
        <value>0x01</value>
    </enumerator>
    <enumerator>
        <description>
        Predictive_Guard policy:
        Used in Field or development to prevent and disable the following:
        . Storing or creation of new Guard records from diagnostics or other
            faults through error logs with the error_type of Predictive.
        . Using an already stored System Guard record with error_type of
            Predictive from deconfiguring resources.
        </description>
        <name>PREDICTIVE_DISABLED</name>
        <value>0x02</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>FIELD_CORE_OVERRIDE</id>
    <description>Field Core Override (FCO) is the override value for the
    number of functional cores allowed on the system.
    FCO is used when customers order a system with N cores but they only want
    to enable less than N cores to lower software license costs. A field in the
    anchor VPD is set by manufacturing to specify the maximum number of cores
    to enable. The number is maintained, even if some cores are garded out due
    to error.
    A value of 0 means all cores allowed;
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HOSTSVC_PLID</id>
    <description>
        Value of the next PLID that host service should send
    </description>
    <simpleType>
        <uint32_t>
            <default>0x89000000</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <description>
        Policy indicating whether to perform the maximum amount of memory
            pattern testing possible or not.
        Set to 0x01 to perform the maximum amount of memory pattern testing
            possible.
        Set to 0x00 to perform the default amount of memory pattern testing.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>EFF_RLO</id>
    <description>Gives the RLO value to use for this port.  This comes from the MR Keyword of the VPD gives and indication of the value.  It will be writable until it comes from VPD. The value is a positive integer number.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RLO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WLO</id>
    <description>Read Latency Offset value that is used in the phy.  This value  comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WLO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_GPO</id>
    <description>Global Phy Offset value that is used in setting up the phy.  This value comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_GPO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CKE_PRI_MAP</id>
    <description>Contains the CKE MAP for the DIMM being plugged in.  It comes from the MT keyword but is not on a port basis --- meaning this Attribute may be split: with 16 bits associated with port A data and 16 bits with B. This value goes directly into the MBA01 Rank-to-primary-CKE mapping table register bits 0:31 (MBA01_MBAREF1Q) register. This attribute is writeable until it comes from the VPD</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CKE_PRI_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CKE_PWR_MAP</id>
    <description>Contains the CKE Power Domain mapping tables for the DIMM being plugged in.  It comes from the MT keyword but is not on a port basis --- meaning this Attribute may be split: with 32 bits associated with port A data and 32 bits with B. This value goes directly into the MBA01 Rank-to-CKE power domain mapping table bits 0:33 (MBA01_MBARPC1Q) register. This attribute is writeable until it comes from the VPD</description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CKE_PWR_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RDTAG</id>
    <description>Read Tag value that is used in setting up the phy.  It is expected that this value will come from the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RDTAG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TSYS_ADR</id>
    <description>TSYS for all address blocks in the MBA pair. This value comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TSYS_ADR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TSYS_DP18</id>
    <description>TSYS for all DP18 blocks in the MBA pair.  This value comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TSYS_DP18</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DQ_WR_OFFSET</id>
    <description>DQ write offset value that is used in setting up the phy's phase rotators before WR_LVL, 0x40 is HW Default.  It is expected that this value will come from the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DQ_WR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_BUFFER_LATENCY</id>
    <description>
      Additional buffer latency in the case of RDIMMs and LRDIMMs.
      It is expected that this value will come from the VPD
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_BUFFER_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LRDIMM_MR12_REG</id>
    <description>
      LRDIMM MR1,2 register.
      DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and 1, DRAM driver impedance for all ranks.
      Eff config should set this up.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LRDIMM_MR12_REG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LRDIMM_ADDITIONAL_CNTL_WORDS</id>
    <description>
        LRDIMM additional RCD control words as set by DIMM SPD:
        F[3,4]RC0A, F[3,4]RC0B, F[5,6]RC0A, F[5,6]RC0B, F[7,8]RC0A, F[7,8]RC0B, F[9,10]RC0A, F[9,10]RC0B,
        F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC0B, F[1]RC0C, F[1]RC0D, F[1]RC0E, F[1]RC0F.
        Eff config should set this up
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LRDIMM_RANK_MULT_MODE</id>
    <description>
      LRDIMM rank multiplication mode.
      Will be set at an MBA level with one policy to be used
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
         <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LRDIMM_RANK_MULT_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_IGNORE_XSTOP_FLAG</id>
    <description>Flag storage to have the Special Wakeup procedure ignore a checkstop condition.</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CPM_INFLECTION_POINTS</id>
    <description>Structure to communicate the CPM inflection points from the CPM code to the Pstate code
    Datablock consisting of:
        8 Inflection Point frequency entries (binary in ATTR_FREQ_PROC_REFCLOCK_KHZ / ATTR_PROC_DPLL_DIVIDER units)
        1 ValidRanges entry - the number of valid inflection points in the previous locations (unit origin)
        1 pMax frequency entry - the maximum allowed boosted frequency (binary in ATTR_FREQ_PROC_REFCLOCK_KHZ / ATTR_DPLL_DIVIDER units)
        6 spare entries
    Producer: p8_cpm_cal_load
    Consumer: p8_pstate_datablock
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
        <array>16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CPM_INFLECTION_POINTS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LAB_USE_JTAG_MODE</id>
    <description>This attribute controls how the procedures operate in JTAG mode under an environment called cronus flex.  For normal operation, this attribute should be set to FALSE. Platforms should initialize this attribute to FALSE.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LAB_USE_JTAG_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CONTROL_SWITCH</id>
    <description>This attribute enables control switches in the memory code.  This is a one hot vector:  Bit 7 controls the Bad Bit Mask function in draminit_training. The platform should initialize this to BBM_ON except if ATTR_LAB_USE_JTAG_MODE == TRUE, then the platform should set this attribute to BBM_ OFF.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CONTROL_SWITCH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--
<attribute>
    <id>MSS_DRAM_ACTIVATE_POWER_PERCENT</id>
    <description>DRAM Activation power percentage to determine the ras and cas weights for throttle controls
        will originates from VPD for custom DIMMs in the MW keyword byte 5 (MSB is on the left(big endian))
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DRAM_ACTIVATE_POWER_PERCENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
-->

<attribute>
    <id>MSS_THROTTLE_CONTROL_RAS_WEIGHT</id>
    <description>
      RAS weight to use for memory throttle control
      - set in thermal procedures
      </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_THROTTLE_CONTROL_CAS_WEIGHT</id>
    <description>
      CAS weight to use for memory throttle control
      - set in thermal procedures
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_BASES_ACK</id>
  <description>Mirrored memory base addresses
      creator: mss_setup_bars
      consumer: consumer: opt_mem_map
      Mem opt map uses this for the bases of the mirror ranges.
        (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_BASES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_SIZES_ACK</id>
  <description>Size of mirrored memory region up to a power of 2
      creator: mss_setup_bars
      consumer: opt_mem_map
      Mem opt map uses this to stack mirror ranges.  The real amount of memory behind the mirror group maybe less than the number reported here if there are memory holes
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_SIZES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MEM_BASES_ACK</id>
  <description>Non-mirrored memory base addresses
    creator: mss_setup_bars
    consumer: opt_mem_map
    Mem opt map uses this for the bases of the non-mirror ranges.
      (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MEM_SIZES_ACK</id>
  <description>Size of non-mirrored memory regions up to a power of 2
    creator: mss_setup_bars
    consumer: opt_mem_map
    Mem opt map uses this to stack mirror ranges.  The real amount of memory behind the mirror group maybe less than the number reported here if there are memory holes
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_SIZES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_RANDOM_SEED_VALUE</id>
    <description>Controls the MCBIST engine in the centaur chip.  The value will be set in mss_eff_config_shmoo.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_RANDOM_SEED_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_RANDOM_SEED_TYPE</id>
    <description>Controls the MCBIST engine in the centaur chip.  The value will be set in mss_eff_config_shmoo.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_RANDOM_SEED_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_BOOT_VOLTAGE_VID</id><!-- deprecated -->
    <description>
        Proc Boot Voltage
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_BOOT_VOLTAGE_VID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DISABLE_I2C_ACCESS</id>
    <description>
      Set to skip physical access to i2c interface in SBE execution.
      Consumed by SBE hooks to permit skipping of selected code when
      running on a test platform (i.e., wafer) which does not have a physical
      SEEPROM connected.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DISABLE_I2C_ACCESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PCI_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DD1_SLOW_PCI_REF_CLOCK</id>
    <description>
        Valid only for Nimbus DD1
        If set (=1), run the PCI Ref clock at 94MHz in order to enable
          experimental GEN4 support.
        If not set (=0), run the PCI Ref clock at 100MHz
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/><!-- SBE requirement only -->
    <hwpfToHbAttrMap>
        <id>ATTR_DD1_SLOW_PCI_REF_CLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEMB_DMI_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of DMI refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEMB_DMI_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEMB_DDR_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of DDR refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEMB_DDR_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_FILTER_PLL_SOURCE</id>
    <description>
        Defines source of MEM filter PLL input (FSI GP4 bit 23)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEM_FILTER_PLL_SOURCE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE</id>
    <description>To represent different sizes of Multiscom Buffer.
    It can take 11 different values
    MULTI_SCOM_BUFFER_SIZE_1KB   = 0x0000000000000400,
    MULTI_SCOM_BUFFER_SIZE_2KB   = 0x0000000000000800,
    MULTI_SCOM_BUFFER_SIZE_4KB   = 0x0000000000001000,
    MULTI_SCOM_BUFFER_SIZE_8KB   = 0x0000000000002000,
    MULTI_SCOM_BUFFER_SIZE_16KB  = 0x0000000000004000,
    MULTI_SCOM_BUFFER_SIZE_32KB  = 0x0000000000008000,
    MULTI_SCOM_BUFFER_SIZE_64KB  = 0x0000000000010000,
    MULTI_SCOM_BUFFER_SIZE_128KB = 0x0000000000020000,
    MULTI_SCOM_BUFFER_SIZE_256KB = 0x0000000000040000,
    MULTI_SCOM_BUFFER_SIZE_512KB = 0x0000000000080000,
    MULTI_SCOM_BUFFER_SIZE_1MB   = 0x0000000000100000
    </description>
    <simpleType>
      <uint64_t>
            <default>0x0000000000001000</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MULTI_SCOM_BUFFER_MAX_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
    <description>Enumeration indicating the multi scome
        buffer size. The values can be combined using a
        bitwise 'OR'.  The values will need to be kept
        in sync with the FAPI enumerator values.  Also
        the enumeration type is used by the
        ATTR_MULTI_SCOM_BUFFER_MAX_SIZE.  Should
        note that the MULTI_SCOM_BUFFER_MAX_SIZE values
        are of type uint32_t
    </description>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
        <value>0x00000400</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
        <value>0x00000800</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
        <value>0x00001000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
        <value>0x00002000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
        <value>0x00004000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
        <value>0x00008000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
        <value>0x00010000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
        <value>0x00020000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
        <value>0x00040000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
        <value>0x00080000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
        <value>0x00100000</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>DMI_DFE_OVERRIDE</id>
    <description>
      Defines where to apply DMI bus DFE override settings for HW244323.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_DFE_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CPM_TURBO_BOOST_PERCENT</id>
    <description>
     Percent of Boost Above Turbo for CPMs - (binary in 0.1 percent steps)

     Used in generating extra Pstate tables beyond those that would result from
     #V data.

     Producer:  DEF file as this is CCIN based

     Consumers: p8_build_gpstate_table.C, p8_cpm_cal_load.C

     Platform default:  0
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CPM_TURBO_BOOST_PERCENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_UNDERVOLTING_FRQ_MINIMUM</id>
    <description>
      Override for Minimum frequency for which undervolting is allowed.

      If value = 0, the value of VPD CPMin data point is passed to OCC FW via
      Pstate SuperStructure.

      If value != 0, this value will be passed to OCC FW via Pstate SuperStructure
      as the floor frequency for enabled CPMs.

      Will be internally rounded to the nearest ATTR_PROC_REFCLK_FREQUENCY / 8 value.

      Consumer: OCC FW; OCC Lab Tools

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_UNDERVOLTING_FRQ_MINIMUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_UNDERVOLTING_FREQ_MAXIMUM</id>
    <description>
      Override for Maximum frequency for which undervolting is allowed.

      If value = 0, the value of VPD Turbo data point is passed to OCC FW via
      Pstate SuperStructure.

      If value != 0, this value will be passed to OCC FW via Pstate SuperStructure
      as the ceiling frequency for enabled CPMs.

      Will be internally rounded to the nearest ATTR_PROC_REFCLK_FREQUENCY / 8 value.

      Consumer: OCC FW; OCC Lab Tools

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_UNDERVOLTING_FREQ_MAXIMUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_WINKLE_ENTRY</id>
    <description>Setting depends on di/dt charateristics of the system.

        Set Assisted if power off serialization is needed and WINKLE_TYPE=Fast;
        Set to Hardware if the system can handle the unrelated powering off between cores.
        Hardware setting decreases entry latency

        Producer: MRWB

        Consumer:  p8_poreslw_init.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_WINKLE_ENTRY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_WINKLE_EXIT</id>
    <description>Setting depends on di/dt charateristics of the system and the setting of ATTR_PM_WINKLE_TYPE.

        Set to Assisted if power on serialization is needed and WINKLE_TYPE=Fast;  Set to Hardware if the system
        can handle the unrelated powering off between cores.  Hardware setting decreases entry latency.
        Must be set to Assisted if ATTR_PM_WINKLE_TYPE=Deep as this necessary for restore.

        Setting to Hardware is a test mode for Fast only.

        Producer: MRWB

        Consumer:  p8_poreslw_init.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_WINKLE_EXIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_MASTER_TYPE</id>
    <description>
        Enumeration indicating the role of proc as master/alt_master/not_master
    </description>
    <enumerator>
        <name>ACTING_MASTER</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>MASTER_CANDIDATE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>NOT_MASTER</name>
        <value>2</value>
    </enumerator>
    <default>NOT_MASTER</default>
</enumerationType>

<attribute>
    <id>PROC_MASTER_TYPE</id>
    <description>Type of Master, ACTING_MASTER or MASTER_CANDIDATE or
      NOT_MASTER</description>
    <simpleType>
        <uint8_t>
            <default>NOT_MASTER</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <writeable/>
</attribute>

<attribute>
  <id>MSS_DATABUS_UTIL_PER_MBA</id>
  <description>MBA DRAM data bus utilization percent to use to determine cfg_nm_n_per_mba</description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
</attribute>

<attribute>
  <id>MSS_DATABUS_UTIL</id>
  <description>
    DRAM data bus utilization percent to use to determine ATTR_MSS_THROTTLED_N_COMMANDS
    creator: f/w
    consumer: mss_utils_to_throttle
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_DATABUS_UTIL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_THROTTLED_N_COMMANDS</id>
  <description>
    Throttled N commands (address operations) that are
    allowed within a window of M DRAM clocks.
    Nimbus workbook (Power and Thermal Controls).
    creator: mss_utils_to_throttle
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_THROTTLED_N_COMMANDS</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>EFF_DRAM_MAC</id>
  <description>
    Maximum Activate Count. Used in various locations and is computed in mss_eff_cnfg.
    creator: mss_eff_cnfg
    consumer: various
    firmware notes: none
  </description>
  <simpleType>
      <uint16_t></uint16_t>
      <array>2,2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_MAC</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>EFF_DRAM_MODULE_BUS_WIDTH</id>
  <description>
    Module Memory Bus Width.
    Used in various locations and is evaluated in mss_eff_cnfg.
    creator: mss_eff_cnfg
    consumer: various
    firmware notes: none
  </description>
  <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_MODULE_BUS_WIDTH</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>




<attribute>
  <id>MSS_UTIL_N_PER_MBA</id>
  <description>cfg_nm_n_per_mba throttle N value that was calculated from MSS_DATABUS_UTIL_PER_MBA</description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_UTIL_N_PER_MBA</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFFECTIVE_EC</id>
    <description>
        Holds the effective EC of the system.  Effective EC is the lowest EC
        among all the functional procs in the system.  Some cards may "downbin"
        the effective ECs of their contained processors, which could lower the
        effective EC of the system beyond what would occur when considering
        processor ECs alone
    </description>
    <simpleType>
        <uint8_t>
            <default>0x10</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
  <id>PROC_PBA_UNTRUSTED_BAR_BASE_ADDR</id>
    <description>PBA Untrusted BAR base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PBA_UNTRUSTED_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PBA_UNTRUSTED_BAR_SIZE</id>
    <description>PBA Untrusted BAR size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 23:43
    </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PBA_UNTRUSTED_BAR_SIZE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>MRU_ID</id>
    <description>MRU ID attribute for chip/unit class</description>
    <simpleType>
        <uint32_t>
            <default>0x00</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_INIT_STATE</id>
    <description>How far into the ipl istep the centaur has been brought up</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_INIT_STATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system</description>
    <simpleType>
        <uint8_t>
        <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
    <description>
            Machine Readable Workbook DIMM power
            curve percent uplife idle for this system
    </description>
    <simpleType>
        <uint8_t>
        <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%).  Used to determine memory throttle values.</description>
    <simpleType>
        <uint32_t>
        <default>0x00002328</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RECONFIGURE_LOOP</id>
    <description>
        Used to inidicate if a reconfigure loop is needed.
        Hostboot clears and sets this during istep dispatching.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_RECONFIGURE_LOOP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>RECONFIGURE_LOOP</id>
    <description>Enumeration of RECONFIGURE_LOOP flags</description>
    <!-- add enumerators (single bits) for anything that needs a reconfigure loop -->
    <enumerator>
        <description>
            Indicates HW has been deconfigured
        </description>
        <name>DECONFIGURE</name>
        <value>0x01</value>
    </enumerator>
    <enumerator>
        <description>
            Indicates a bad DQ bit was set in the BadDqBitmap
        </description>
        <name>BAD_DQ_BIT_SET</name>
        <value>0x02</value>
    </enumerator>
    <enumerator>
        <description>
            An RCD parity error has been detected
        </description>
        <name>RCD_PARITY_ERROR</name>
        <value>0x04</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PM_SYSTEM_IVRM_VPD_MIN_LEVEL</id>
    <description>Version level of #M that represents the minimum for IVRM characterized parts.
     If this value is non-zero and the #M version level is less than this value, IVRMs are disabled.
     If the #M version is greater than or equal to this value, the IVRMs are allowed to be enable from a level of part perspective.
     Producer: MRWB
     Consumer:  p8_build_pstate_datablock.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SYSTEM_IVRM_VPD_MIN_LEVEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLW_DEEP_WINKLE_EXIT_GOOD_HALT_ADDR</id>
    <description>
    Stores the offset in SLW image of the halt point for a good Deep Winkle Exit transition.
    This is value may used by FAPI code to check that the SLW engine achieved an expected state.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLW_DEEP_WINKLE_EXIT_GOOD_HALT_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLW_DEEP_SLEEP_EXIT_GOOD_HALT_ADDR</id>
    <description>
    Stores the offset in SLW image of the halt point for a good Deep Sleep Exit transition.
    This is value may used by FAPI code to check that the SLW engine achieved an expected state.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLW_DEEP_SLEEP_EXIT_GOOD_HALT_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_EFF_VPD_VERSION</id>
    <description>
        The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in ASCII) of the VINI VZ keyword
    </description>
    <simpleType>
        <uint32_t></uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_EFF_VPD_VERSION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DISABLE_SCRUB_AFTER_PATTERN_TEST</id>
    <description>
        1 = disable scrub after memdiags pattern test. 0 = scrub after memdiags pattern test.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DISABLE_SCRUB_AFTER_PATTERN_TEST</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PCBS_FSM_TRACE_EN</id>
    <description>
    Overridable attribute to allow for PCBS FSM tracing by Power Management procedures
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PCBS_FSM_TRACE_EN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_GLOBAL_FIR_TRACE_EN</id>
    <description>
    Overridable attribute to allow for Global checkstop and recoverable FIR tracing by Power Management procedures
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_GLOBAL_FIR_TRACE_EN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>Value of on or off.  On is 256 bit interleave.  Off, the translation is on 128  bit interleave mode.  See centaur workbook chapter 5.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
    <description>
       The MRW for a system should set this to TRUE for systems that must obey plug rules.  Lab environments should default this to off and allow the user to override using normal methods to test.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DERIVED_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>This dial sets the Centaur address bits used to interleave addresses between MBA01 and MBA23.  Valid values are 23 through 32.  See Centaur Spec Chapter 5 for details.   Used in the intifile </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DERIVED_MBA_ADDR_INTERLEAVE_BIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
    <description>At a system level, this attribute controls if interleaving is required, requested or never.  The MRW.</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_HWP_ATTR_VERSION</id>
    <description>Defines HWP version to be checked inside HWPs to determine if new code should be loaded/skipped/modified/etc.</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_HWP_ATTR_VERSION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>REDUNDANT_CLOCKS</id>
    <description>
        1 = System has redundant clock oscillators
        0 = System does not have redundant clock oscillators
        From the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_REDUNDANT_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_NEST_CAPABLE_FREQUENCIES</id>
    <description>
      The NEST frequencies the memory chip can run at computed by the mss_freq.
      The possibilities are ORed together.  The platform uses these value and
      the MRW to determine what frequency to boot the fabric (nest) if it can.
      There are two values: 8G and 9.6G
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_NEST_CAPABLE_FREQUENCIES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_HW_MIRRORING_ENABLE</id>
    <description>
       0 : HW mirroring is disabled.
       1 : HW mirroring is enabled.
       Provided by the MRW.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_HW_MIRRORING_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>TOD_ROLE</id>
    <description>
        Enumeration indicating what role this chip has in tod topology
    </description>
    <enumerator>
        <name>NON_MASTER</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>PRIMARY</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECONDARY</name>
        <value>2</value>
    </enumerator>
    <default>NON_MASTER</default>
</enumerationType>

<attribute>
    <id>TOD_ROLE</id>
    <description>
        Bitmask indicating what role this chip has in tod topology
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <description>
      System attribute.
      6 bit rx_min_eye_width value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_DMI_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <description>
      System attribute.
      8 bit rx_min_eye_height value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_DMI_MIN_EYE_HEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_ABUS_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <description>
      System attribute
      8 bit rx_min_eye_height value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_ABUS_MIN_EYE_HEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for X bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_XBUS_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <description>
        The amount of mainstore that PHYP needs to preserve per node
        during MPIPL.
    </description>
    <simpleType>
        <uint32_t>
            <default>256</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the master i2c bus</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the spare i2c bus</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DO_ABUS_DECONFIG</id>
    <description>
        Indicates if system should consider abus logic when deconfiguring in
        _deconfigureAssocProc(), will be overwritten on multi-node system
    </description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MEM_AVDD_OFFSET_MILLIVOLTS</id>
    <description>Memory AVDD voltage domain offset in mV.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_AVDD_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!-- For reconfig loop testing -->
<attribute>
  <id>RECONFIG_LOOP_TESTS</id>
  <description> System attribute array that defines the reconfig loop test cases
      consumer: istep dispatcher reconfigLoopTestRunner function
      This array is loaded with data via attribute override. The attribute is
      then read  and then overlayed onto a test case structure.
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>5</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
</attribute>

<attribute>
    <id>RECONFIG_LOOP_TESTS_ENABLE</id>
    <description>
        Indicates whether reconfigure loop tests are enabled.
        This attribute is set via attribute override
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MEM_VDD_OFFSET_MILLIVOLTS</id>
    <description>Memory VDD voltage domain offset in mV.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VDD_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_VCS_OFFSET_MILLIVOLTS</id>
    <description>Memory VCS voltage domain offset in mV.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VCS_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_VPP_OFFSET_MILLIVOLTS</id>
    <description>Memory VPP voltage domain offset in mV.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VPP_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_VDDR_OFFSET_MILLIVOLTS</id>
    <description>Memory VDDR voltage domain offset in mV.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VDDR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <description>Units: uV/Membuf
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <description>Units: uV/Membuf
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <description>Units: uV/Membuf
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <description>Units: uV/Membuf
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <description>Units: uV/Membuf
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <description>Units: uV/Membuf
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <description>Units: uV/DRAM
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <description>Units: uV/DRAM
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <description>Units: 1/Amps
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <description>Units: 1/Amps
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <description>Units: 1/Amps
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <description>Units: 1/Amps
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <description>Units: mV
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MSS_VOLT_OVERRIDE</id>
    <description>
      Possible DRAM voltage override.
      Firmware notes: Default should be NONE (0x00).
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VOLT_COMPLIANT_DIMMS</id>
    <description>
        Compliant Voltages. Created to call out non-compliant dimms
        if they exist in the system.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT_COMPLIANT_DIMMS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VDDR_OVERIDE_SPD</id>
    <description>
      Possible VDDR voltage override.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VDDR_OVERIDE_SPD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
        <name>OFF</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>POWER_DOWN</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>STR</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>PD_AND_STR</name>
        <value>3</value>
    </enumerator>
    <default>OFF</default>
</enumerationType>

<attribute>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
    <description>
        Memory power control settings programmed during IPL
        Used by OCC when exiting idle powersave mode
        Producer: MRW

        0x00 = OFF
        0x01 = POWER_DOWN
        0x02 = STR
        0x03 = PD_AND_STR
    </description>
    <simpleType>
        <uint8_t>
            <default>OFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_POWER_CONTROL_REQUESTED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
        <name>OFF</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>POWER_DOWN</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>STR</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>PD_AND_STR</name>
        <value>3</value>
    </enumerator>
    <default>NONE</default>
</enumerationType>


<attribute>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
    <description>
        Memory power control settings for IDLE powersave mode
        Used by OCC when entering idle powersave mode
        Producer: MRW

        0x00 = OFF
        0x01 = POWER_DOWN
        0x02 = STR
        0x03 = PD_AND_STR
    </description>
    <simpleType>
        <uint8_t>
            <default>OFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_WORKAROUND_RUN_FLAG</id>
    <description>
    Flag to store that the work-around for HW250017 as been run so that during any resets it is skipped.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_WORKAROUND_RUN_FLAG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_OCC_LFIR_MASK</id>
    <description>
    Upon an UE event, PRD may update some fir masks in occ domain. To avoid this update getting lost during occ reset, which could eventually cause multiple occ resets, this attribute is added to be the storage to remember the OCC_LFIR_MASK in the RESET phase so that reset procedures can later overlay this updated settings with the default instalation in INIT phase. See details in SW260003.
    Producer/Consumer: p8_pm_occ_firinit.C
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_OCC_LFIR_MASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBA_FIR_MASK</id>
    <description>
    Upon an UE event, PRD may update some fir masks in occ domain. To avoid this update getting lost during occ reset, which could eventually cause multiple occ resets, this attribute is added to be the storage to remember the PBA_FIR_MASK in the RESET phase so that reset procedures can later overlay this updated settings with the default instalation in INIT phase. See details in SW260003.
    Producer/Consumer: p8_pm_pba_firinit.C
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBA_FIR_MASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PMC_LFIR_MASK</id>
    <description>
    Upon an UE event, PRD may update some fir masks in occ domain. To avoid this update getting lost during occ reset, which could eventually cause multiple occ resets, this attribute is added to be the storage to remember the PMC_LFIR_MASK in the RESET phase so that reset procedures can later overlay this updated settings with the default instalation in INIT phase. See details in SW260003.
    Producer/Consumer: p8_pm_pmc_firinit.C
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PMC_LFIR_MASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_FIRINIT_DONE_ONCE_FLAG</id>
    <description>
    Due to SW260003, a flag is needed to remember if we executed the p8_pm_firinit procedures at least once.
    Producer/Consumer: p8_pm_firinit.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_FIRINIT_DONE_ONCE_FLAG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_ENABLE</id>
    <description>Control HW response to execution of PPC sleep instruction
      if OFF, treat sleep as nap
      if ON, treat sleep as sleep
      Producer: Hostboot
      Consumer:  p8_slw_build.C
    </description>
    <simpleType>
        <uint8_t>
            <default>0x0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>I2C_SWITCHES</id>
    <description>Attribute storing information about which I2C method to use</description>
    <complexType>
        <description>Structure which defines which I2C access method to use at
        a point in time.  Only applicable if target supports one or more I2C
        types.  Only one bit (of the first two) can ever be set at any one time.
        </description>
        <field>
            <name>useFsiI2C</name>
            <description>0b0: Do not use FSI I2C at this time.  0b1: Use FSI
            I2C at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>useHostI2C</name>
            <description>0b0: Do not use Host I2C at this time.  0b1: Use
            Host I2C at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future expansion</description>
            <type>uint8_t</type>
            <bits>6</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>OCC_MASTER_CAPABLE</id>
    <description>
        This attribute is to determine whether an occ is master capable.
        An OCC is master capable if it's parent processor is wired to the
        APSS.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>   <!-- false -->
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_DRAMINIT_RESET_DISABLE</id>
    <description>A disable switch for resetting the phy delay values at the beginning of calling mss_draminit_training.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DRAMINIT_RESET_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ISDIMM_POWER_CURVE_ALGORITHM_VERSION</id>
    <description>
      version of algorithm used to calculate ISDIMM power curves
    </description>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ISDIMM_POWER_CURVE_ALGORITHM_VERSION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_LANE_MASK</id>
    <description>Effective PCIE Lane Mask
        Creator: Firmware
        Purpose: Holds the effective PCIE lane mask of each PEC after taking
            into account any IOP bifurcations. If no IOP bifurcations present,
            this is just the value of the PEC_PCIE_LANE_MASK_NON_BIFURCATED
            attribute
        Data Format: x4 array of uint16_t values.  The uint16_t value is a
            mask for lane 0, the next for lane 1 and so on until lane 3.
            A lane set mask indicates which groups of lanes are assigned to an
            IOP.  For instance, lane set 0 value of 0xFFFF and lane set 1 value
            of 0x0000 for PEC0 means PEC0 is a x16. Lane set 0 value of 0xFF00
            and lane set 1 value of 0x00FF for PEC0, means the IOP is bifurcated
            into two x8s.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <description>Effective PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the effective PCIE IOP reversal value after taking into
            account any IOP bifurcations.  If no IOP bifurcations present, this
            is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED
            attribute.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given PEC/lane set.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the base PCIE IOP reversal value without considering IOP
            bifurcation.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given lane set.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEC_PCIE_IOP_SWAP_NON_BIFURCATED</id>
    <description>Base PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value without considering
            IOP bifurcation.  The swap value controls how PCIE lanes are
            recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEC_PCIE_LANE_MASK_NON_BIFURCATED</id>
    <description>PCIE Lane Mask base configuration
        Creator: MRW
        Purpose: Holds the base PCIE lane mask assuming no dynamic IOP
            bifurcations.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP.  For
            instance, lane set 0 value of 0xFFFF and lane set 1 value of 0x0000
            means the PEC is a x16. Lane set 0 value of 0xFF00 and lane
            set 1 value of 0x00FF, means the PEC is split into two x8s.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the PCIE IOP reversal value for cases where the IOP
            is bifurcated
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. The given index in
            the array is a mask which specifies which bit to invert in the lane
            swap settings for the given lane set
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <description>Bifurcated PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value for the IOPs in the
            case where they are bifurcated.  The swap value controls how PCIE
            lanes are recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <description>PCIE Lane Mask bifurcated configuration
        Creator: MRW
        Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP. For
            instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF
             means the IOP is bifurcated into two x8s.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PROC_PCIE_IS_SLOT</id>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot
        Creator: MRW
        Purpose: Used by FW to know whether the given PCIE lanes terminate at a
            pluggable slot or not.  If this is the case, and the platform
            supports bifurcation, the card's VPD should be interrogated to
            determine whether to bifurcate the IOP or not.
        Data Format: x4 array of uint8_t values.  The first value indicates
            whether lane set 0 terminates at a pluggable slot.  The
            next three values indicate the same for lane sets 1-3. A value of
            1 at a given array index indicates the lanes terminate at a
            pluggable slot, 0 otherwise.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>CDM_DOMAIN</id>
    <description>
        Enumeration specifying a target's CEC degraded mode domain
    </description>
    <enumerator>
        <name>NONE</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>CPU</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>DIMM</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>FABRIC</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>MEM</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>IO</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>NODE</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>CLOCK</name>
        <value>7</value>
    </enumerator>
    <enumerator>
        <name>PSI</name>
        <value>8</value>
    </enumerator>
    <enumerator>
        <name>FSP</name>
        <value>9</value>
    </enumerator>
    <enumerator>
        <name>ALL</name>
        <value>10</value>
    </enumerator>
    <default>NONE</default>
</enumerationType>

<attribute>
    <id>CDM_DOMAIN</id>
    <description>
        Specifies a target's CEC degraded mode domain.  For example, all
        DIMMs are part of the DIMM CEC degraded mode domain.
    </description>
    <simpleType>
        <enumeration>
            <id>CDM_DOMAIN</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <description>Designates the speed at which a given I2C bus should run.
        Creator: MRW
        Purpose: Used by FW to know the fastest possible bus speed that all of
            the devices on a given bus are able to use.
        Data Format: 4x4 array of uint16_t values.  The first index indicates
            the engine number of the bus.  The second index indicates the port
            number of the bus.  The value in the array is the I2C bus speed
            used for that engine/port combination in KHz.
    </description>
    <simpleType>
        <uint16_t>
            <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0</default>
        </uint16_t>
        <array>4,4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ISTEP_PAUSE_ENABLE</id>
    <description>
      Used to enable pause/stop in between isteps. This attribute is set via
      attribute override.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>
<enumerationType>
    <id>SUPPORTED_HOT_PLUG</id>
    <description>
        Enumeration indication which Hot Plug Controllers are supported by
        the current system.
    </description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>MAX5961</name>
        <value>0x01</value>
    </enumerator>
    <enumerator>
        <name>PCA9551</name>
        <value>0x02</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<attribute>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <description>Hot Plug Controller values for a specific processor.
        Purpose: Holds information about the hot plug controllers so that a
            Hardware procedure is able to turn them on and off.
        Data Format: up to 8 Hot Plug Controllers x 7 variables of information
            This data is at the processor level.
            The needed information and their individual sizes are as follows:
            (1) I2C Master processor engine (uint8_t)
            (2) I2C Master processor port (uint8_t)
            (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB)
            (4) Slave address (uint8_t)
            (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum)
            (6) I2C Master processor node (uint8_t)
            (7) I2C Master processor position (uint8_t)
            Thus, the information will be 8 bytes.
    </description>
    <simpleType>
        <uint8_t>
            <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            </default>
        </uint8_t>
        <array>8,8</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_HOT_PLUG_POWER_CONTROLLER_INFO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ISTEP_PAUSE_CONFIG</id>
    <description>
      Used to configure the parameters for enabling pause/stop between
      isteps. This attribute is set via attribute override.
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>OPT_MEMMAP_GROUP_POLICY</id>
    <description>
       Controls scope of grouping performed in memory map calculations
       Possible values defined in FAPI ATTR_OPT_MEMMAP_GROUP_POLICY
    </description>
    <simpleType>
        <uint8_t><default>0x00</default></uint8_t><!-- CHIP_AS_GROUP -->
    </simpleType>
    <readable/>
    <persistency>non-volatile</persistency>
    <hwpfToHbAttrMap>
        <id>ATTR_OPT_MEMMAP_GROUP_POLICY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MFG_TRACE_ENABLE</id>
    <description>
        Override this to a non-zero value to have the FAPI manufacturing
        traces output to the console or go to a fsp trace buffer when
        console not enabled.
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MFG_TRACE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TPM_REQUIRED</id>
    <description>
        Setting to require(0x1) or not require(0x0) a functional TPM to
        boot the system.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
  <id>PROC_PCIE_NUM_PHB</id>
  <description>
      creator: platform
        Number of PCIe PHB units present on target
        Murano/Venice: 3
        Naples: 4
        Nimbus: 6
        Cumulus: 6
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_NUM_PHB</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_NUM_IOP</id>
  <description>
      creator: platform
        Number of PCIe IOP units present on target
        Murano/Venice: 2
        Naples: 3
        Nimbus: 3
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_NUM_IOP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_NUM_PEC</id>
  <description>
      creator: platform
        Number of PCIe PEC units present on target
        Nimbus: 3
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_NUM_PEC</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_NUM_LANES</id>
  <description>
      creator: platform
        Number of PCIe I/O lanes supported by target
        Murano: 24
        Venice: 32
        Naples: 40
        Nimbus: 48
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_NUM_LANES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- === start configurable threshold attributes for PRD === -->

<attribute>
    <id>MNFG_TH_P8EX_L2_CACHE_CES</id>
    <description>
      This attribute represents the Maximum number of L2 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L2_DIR_CES</id>
    <description>
      This attribute represents the Maximum number of L2 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L3_CACHE_CES</id>
    <description>
      This attribute represents the Maximum number of L3 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L3_DIR_CES</id>
    <description>
      This attribute represents the Maximum number of L3 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FIELD_TH_P8EX_L2_LINE_DELETES</id>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FIELD_TH_P8EX_L3_LINE_DELETES</id>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FIELD_TH_P8EX_L2_COL_REPAIRS</id>
    <description>
      This attribute represents the Maximum number of L2 Column Repairs allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FIELD_TH_P8EX_L3_COL_REPAIRS</id>
    <description>
      This attribute represents the Maximum number of L3 Column Repairs allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L2_LINE_DELETES</id>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L3_LINE_DELETES</id>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L2_COL_REPAIRS</id>
    <description>
      This attribute represents the Maximum number of L2 Column Repairs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_P8EX_L3_COL_REPAIRS</id>
    <description>
      This attribute represents the Maximum number of L3 Column Repairs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO</id>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO</id>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during IPL.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_CEN_MBA_RT_RCE_PER_RANK</id>
    <description>
      This attribute represents the maximum number of Memory RCEs
      allowed per Rank during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_CEN_L4_CACHE_CES</id>
    <description>
      This attribute represents the maximum number of L4 Cache CEs allowed.
      creator: platform (generated based on MRW data)
    </description>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_RCD_PARITY_ERRORS</id>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when an
      RCD parity error (recovery enabled) attention count is equal to this
      value. A value of 0 defaults to the max threshold of 0xff.
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_MEMORY_IUES</id>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent UE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent MPE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!-- === end configurable threshold attributes for PRD === -->

<!-- === start RCD parity error reconfig loop attributes for PRD/MDIA === -->

<attribute>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <description>
      The number of reconfig loops allowed due to RCD parity errors when
      recovery is disabled. PRD will make a predictive callout and stop issuing
      reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is
      greater than this value. A value of 0 indicates that no reconfig loops are
      allowed due to RCD parity errors.
    </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>RCD_PARITY_RECONFIG_LOOP_COUNT</id>
    <description>
      PRD will increment this count and issue a reconfig loop each time an RCD
      parity error (recovery disabled) is detected during Memory Diagnostics.
      This value will be cleared at the end of Memory Diagnostics if it is able
      to complete without the need to issue a reconfig loop.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!-- === end RCD parity error reconfig loop attributes for PRD/MDIA === -->

<attribute>
    <id>RESOURCE_IS_CRITICAL</id>
    <description>
        Used to tell if a resource is critical to perform an IPL. If this
        attribute is set to 1 and the target is deconfigured, the IPL MUST
        terminate.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>


<attribute>
    <id>BRAZOS_RX_FIFO_OVERRIDE</id>
    <description>
      Defines where to apply Brazos rx_fifo_final_l2u_dly override settings for SW299500.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_BRAZOS_RX_FIFO_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- === Manufacturing threshold Attributes of PRD === -->

<attribute>
    <id>MSS_VMEM_REGULATOR_MAX_DIMM_COUNT</id>
    <description>
    Maximum number of installed DIMMs per VMEM regulator for all
    VMEM regulators in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
    <description>Machine Readable Workbook enablement of the HWP code to adjust
    the VMEM regulator power limit based on number of installed DIMMs.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
    <description>Machine Readable Workbook value for the maximum possible number
    of dimms that can be installed under any of the VMEM regulators.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>WOF_ENABLED</id>
    <description>
        Defines if the Workload Optimization Frequency (WOF) system feature
        where OCC algorithms will change (typically boost) the operational
        frequency based on measured power available and any currently idling
        cores.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_WOF_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TRUSTED_SLAVE_SCAN_PATH_ACTIVE</id>
    <description>
        Set to indicate state of master->slave scan path.
        Platform should default to false at beginning of IPL, and set to
        true once trusted XSCOM path is active to all slave chips in drawer
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TRUSTED_SLAVE_SCAN_PATH_ACTIVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FORCE_SKIP_SBE_MASTER_INTR_SERVICE</id>
    <description>
        Set to force skip of SBE interrupt service for master chip.
        Default is to disable the use of the SBE interrupt service.
    </description>
    <simpleType>
        <uint8_t>
        <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FORCE_SKIP_SBE_MASTER_INTR_SERVICE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FORCE_USE_SBE_SLAVE_SCAN_SERVICE</id>
    <description>
        Set to force use of SBE scan service for slave chips.
        Default is to enable the use of the SBE scan service
        only for slave chips with security enabled.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FORCE_USE_SBE_SLAVE_SCAN_SERVICE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_MASTER_INTR_SERVICE_DELAY_CYCLES</id>
    <description>
        Cycle delay of SBE master interrupt service loop wait statement.
        Paces rate of decrementer progress and prevents SBE from consuming PIB.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_MASTER_INTR_SERVICE_DELAY_CYCLES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_MASTER_INTR_SERVICE_DELAY_US</id>
    <description>
        Execution delay (in microseconds) of SBE master interrupt service loop.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_MASTER_INTR_SERVICE_DELAY_US</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VREF_CAL_CNTL</id>
    <description>Training Control over IPL
         - ENUM - 0x00=DISABLE /Skip V-ref Train; 0x01=DRAM - Enable V-Ref Train DRAM Level; 0x02=RANK Level Training;
                  0x03=PORT Level Training; 0x04=MBA Level; 0x05=CENTAUR level;
         Default Value = 0x01;
    </description>
    <simpleType>
        <uint8_t>
            <default>0x01</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VREF_CAL_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RCD_CNTL_WORD_X</id>
    <description>Additional RCD Control Word for DDR4. Used in mss_dram_init and is computed in mss_eff_cnfg.
                 Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.  Each memory channel will have a value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RCD_CNTL_WORD_X</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC00</id>
    <description>F0RC00: Global Features Control Word.For normal operation, output inversion is always enabled. For DIMM vendor test purpose, output
                 inversion can be disabled. When disabled, register tPDM is not guaranteed to be met.
                 NOTE: Default value - 0x00. Values Range from 0-8.
                 00 - Normal Operation; 01 - Output Inversion Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs disabled; So on.
                 No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
     </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC00</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC01</id>
    <description>F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually turned on or off to conserve power.
                 The system must read the module SPD to determine which clock outputs are used by the module. The PLL remains locked
                 on CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the lowest power mode.
                 Default value - 0x00. Values Range from 0-8. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC01</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC02</id>
    <description>F0RC02: Timing and IBT Control Word;
                 Default value - 0x00. Values Range from 0-8. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC02</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC03</id>
    <description>F0RC03 - CA and CS Signals Driver Characteristics Control Word;
                 Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 1st Nibble for CS and CA.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC03</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC04</id>
    <description>F0RC04 - ODT and CKE Signals Driver Characteristics Control Word;
                 Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 137, 2nd Nibble for ODT and CKE.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC04</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC05</id>
    <description>F0RC05 - Clock Driver Characteristics Control Word;
                 Default value - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte 138, 2nd Nibble for CK.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC05</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC06_07</id>
    <description>F0RC06: Command Space Control Word definition;
                 Default value - 0xF0 (NOP). Values Range from 00 to F0. F0RC07 not used. RDIMM
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC06_07</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC08</id>
    <description>F0RC08: Command Space Control Word definition;
                 Default value - 0x03. Values Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
                 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2;
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC08</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC09</id>
    <description>F0RC09: Command Space Control Word definition;
                 Default value - 0xF0 (NOP). Values Range from 00 to F0. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC09</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--HWSV needs to update names so we can remove this-->
<attribute>
    <id>EFF_DIMM_DDR4_RC10</id>
    <description>RDIMM Operating Speed;  Read from ATTR_MSS_FREQ;
                 Default value - 00. Values Range from 00 to 09. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC10</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC0A</id>
    <description>RDIMM Operating Speed;  Read from ATTR_MSS_FREQ;
                 Default value - 00. Values Range from 00 to 09. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC0A</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<!--HWSV needs to update names so we can remove this-->
<attribute>
    <id>EFF_DIMM_DDR4_RC11</id>
    <description>Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT_VDDR_MILLIVOLTS.
                 Default value - 14. Values Range from 00 to 15 decimal.  No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC11</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC0B</id>
    <description>Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT_VDDR_MILLIVOLTS.
                 Default value - 14. Values Range from 00 to 15 decimal.  No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC0B</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--HWSV needs to update names so we can remove this-->
<attribute>
    <id>EFF_DIMM_DDR4_RC12</id>
    <description>F0RC0C - Training Control Word;
                 Default value - 00. Values Range from 00 to 07 decimal.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC12</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC0C</id>
    <description>F0RC0C - Training Control Word;
                 Default value - 00. Values Range from 00 to 07 decimal.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC0C</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--HWSV needs to update names so we can remove this-->
<attribute>
    <id>EFF_DIMM_DDR4_RC13</id>
    <description>F0RC0D - DIMM Configuration Control Word;
                 Default value - 0x0B. Values Range from 00 to 15 decimal.
                 Dynamically calculated using 4 bits[0:3] Bit 0 - Address Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct / Quad CS mode etc);
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC13</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC0D</id>
    <description>F0RC0D - DIMM Configuration Control Word;
                 Default value - 0x0B. Values Range from 00 to 15 decimal.
                 Dynamically calculated using 4 bits[0:3] Bit 0 - Address Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct / Quad CS mode etc);
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC0D</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--HWSV needs to update names so we can remove this-->
<attribute>
    <id>EFF_DIMM_DDR4_RC14</id>
    <description>F0RC0E - Parity Control Word;  Default value - 00. Check from ATTR_EFF_CA_PARITY and assign; Values Range from 00 to 0F.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC14</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC0E</id>
    <description>F0RC0E - Parity Control Word;  Default value - 00. Check from ATTR_EFF_CA_PARITY and assign; Values Range from 00 to 0F.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC0E</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--HWSV needs to update names so we can remove this-->
<attribute>
    <id>EFF_DIMM_DDR4_RC15</id>
    <description>F0RC0F - Command Latency Adder Control Word;
                 Default value - 04. Values Range from 00 to 04. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC15</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC0F</id>
    <description>F0RC0F - Command Latency Adder Control Word;
                 Default value - 04. Values Range from 00 to 04. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC0F</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>EFF_DIMM_DDR4_RC_1x</id>
    <description>F0RC1x - Internal VrefCA Control Word;
                 Default value - 00. Values Range from 00 to 3F.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_1x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_2x</id>
    <description>F0RC2x: I2C Bus Control Word;
                 Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_2x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_3x</id>
    <description>F0RC3x - Fine Granularity RDIMM Operating Speed;
                 Default value = (Operating Freq - 1250)/20. Values Range from 00 to 61 Hex.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_3x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_4x</id>
    <description>F0RC4x: CW Source Selection Control Word;
                 Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_4x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_5x</id>
    <description>F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal High;
                 Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_5x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_6x</id>
    <description>F0RC6x: CW Data Control Word;
                 Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_6x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_7x</id>
    <description>F0RC7x: IBT Control Word;
                 Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_7x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_8x</id>
    <description>F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
                 Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_8x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_9x</id>
    <description>F0RC9x1: QxODT[1:0] Write Pattern Control Word;
                 Default value - 00. Values Range from 00 to FF.No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_9x</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_Ax</id>
    <description>F0RCAx1: QxODT[1:0] Read Pattern Control Word;
                 Default value - 00. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_Ax</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_RC_Bx</id>
    <description>F0RCBx: IBT and MRS Snoop Control Word;  Default value - 07. Values Range from 00 to FF. No need to calculate; User can override with desired experimental value.
                 creator: mss_eff_cnfg
                 consumer: mss_dram_init
                 firmware notes: none
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_DDR4_RC_Bx</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_LRDIMM_WORD_X</id>
    <description>Additional buffer control word for LRDIMM building of the BCW</description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>2,2</array>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_LRDIMM_WORD_X</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>EFF_LRDIMM_ADDITIONAL_CNTL_WORDS</id>
    <description>LRDIMM additional RCD control words as set by DIMM SPD:
                 F[3,4]RC10, F[3,4]RC11, F[5,6]RC10, F[5,6]RC11, F[7,8]RC10,
                 F[7,8]RC11, F[9,10]RC10, F[9,10]RC11, F[1]RC8, F[3]RC9,
                 F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15.
                 Eff config should set this up.
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_LRDIMM_ADDITIONAL_CNTL_WORDS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_DDR4_PDA_ENABLE</id>
    <description>Controls PDA train enable or PBA. 00 - Disable; 01 - PDA; 02 - PBA(Lrdimm)</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_DDR4_PDA_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
    <id>MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
    <description>
    Option to control MCS prefetch retry threshold, for performance
    optimization. This attribute controls the number of retries in the
    prefetch engine. Retry threshold available ranges from 16 to 30. Note:
    Values outside those ranges will default to 30. In MRW.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_MCS_PREFETCH_RETRY_THRESHOLD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!--Deprecated-->

<attribute>
    <id>EFF_DRAM_TCCD_S</id>
    <description>tccd_l. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
                 Creator: mss_eff_cnfg
                 Consumer:various
                 Firmware notes: none
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TCCD_S</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PHB_MMIO_ADDRS_64</id>
    <description>PHB0-PHB5 64 bits addresses
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>6</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PHB_MMIO_ADDRS_32</id>
    <description>PHB0-PHB5 32 bit addresses
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>6</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>`

<attribute>
    <id>PHB_XIVE_ESB_ADDRS</id>
    <description>PHB0-PHB5 XIVE ESB addresses
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>6</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PHB_REG_ADDRS</id>
    <description>PHB0-PHB5 Register Space addresses
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>6</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>XIVE_ROUTING_ESB_ADDR</id>
    <description>XIVE Routing ESB address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>XIVE_ROUTING_END_ADDR</id>
    <description>XIVE Routing END address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>XIVE_PRESENTATION_NVT_ADDR</id>
    <description>XIVE Presentation NVT address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VAS_HYPERVISOR_WINDOW_CONTEXT_ADDR</id>
    <description>VAS - Hypervisor Window Contexts address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VAS_USER_WINDOW_CONTEXT_ADDR</id>
    <description>VAS - User Window Context address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>LPC_BUS_ADDR</id>
    <description>LPC Bus address - MMIO consumed by PHYP</description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NVIDIA_NPU_PRIVILEGED_ADDR</id>
    <description>Nvidia Link - NPU Privileged Regs address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NVIDIA_NPU_USER_REG_ADDR</id>
    <description>Nvidia Link - NPU User Regs address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NVIDIA_PHY0_REG_ADDR</id>
    <description>Nvidia Link - Phy 0 Regs address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NVIDIA_PHY1_REG_ADDR</id>
    <description>Nvidia Link - Phy 1 Regs address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>XIVE_CONTROLLER_BAR_ADDR</id>
    <description>XIVE - Controller Bar address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>XIVE_PRESENTATION_BAR_ADDR</id>
    <description>XIVE - Presentation Bar address
        MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
   </simpleType>
   <persistency>non-volatile</persistency>
   <readable/>
</attribute>

<attribute>
    <id>XIVE_THREAD_MGMT1_BAR_ADDR</id>
    <description>XIVE - Thread Management Bar address register 1
         MMIO consumed by HB/PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>


<attribute>
    <id>PSI_HB_ESB_ADDR</id>
    <description>PSIHB - ESB space address - MMIO consumed by PHYP
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>NX_RNG_ADDR</id>
    <description>NX - RNG space - MMIO consumed by PHYP</description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>FUSED_CORE_OPTION</id>
    <description>Enum for FUSED_CORE_OPTION</description>
    <enumerator>
        <name>USING_DEFAULT_CORES</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>USING_NORMAL_CORES</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>USING_FUSED_CORES</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>FUSED_CORE_OPTION</id>
    <description>
        If not loading PHYP or OPAL, then use this to
        decide whether to use FUSED cores or NOT.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>ICACHE_LINE_SIZE</id>
    <description>Icache Line Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ICACHE_BLOCK_SIZE</id>
    <description>ICache Block Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ICACHE_SIZE</id>
    <description>ICache Size in KB</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ICACHE_ASSOC_SETS</id>
    <description>ICache Assoc Sets</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DCACHE_LINE_SIZE</id>
    <description>DCache Line Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DCACHE_ASSOC_SETS</id>
    <description>DCache Associative Sets</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>L2_CACHE_LINE_SIZE</id>
    <description>L2 Cache Line Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>L2_CACHE_SIZE</id>
    <description>L2 Cache Size in KB</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>L2_CACHE_ASSOC_SETS</id>
    <description>L2 Cache Assoc Sets</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>L3_CACHE_LINE_SIZE</id>
    <description>L3 Cache Line Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>L3_CACHE_SIZE</id>
    <description>L3 Cache Size in KB</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
 </attribute>

 <attribute>
     <id>TIME_BASE</id>
     <description>Time Base frequency in MHZ</description>
     <simpleType>
         <uint32_t>
            <default>0x800000</default>
        </uint32_t>
     </simpleType>
     <persistency>non-volatile</persistency>
     <readable/>
</attribute>

<attribute>
    <id>TLB_DATA_ENTRIES</id>
    <description>TLB Data Entries</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TLB_DATA_ASSOC_SETS</id>
    <description>TLB Data Associative Sets</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TLB_INSTR_ENTRIES</id>
    <description>TLB Instruction Entries</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TLB_INSTR_ASSOC_SETS</id>
    <description>TLB Instruction Associative Sets</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TLB_RESERVE_SIZE</id>
    <description>Reserve Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DATA_CACHE_SIZE</id>
    <description>L1 Data Cache Size in KB</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DATA_CACHE_LINE_SIZE</id>
    <description>L1 Data Cache Line Size in bytes</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>THREAD_COUNT</id>
    <description>Thread Count</description>
    <simpleType>
        <uint32_t>
            <default>0x4</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PFET_POWERUP_DELAY_NS</id>
    <description>
        Time (in nanoseconds) between PFET controller steps (7 of them) when turning
        the PFES ON
    </description>
    <simpleType>
        <uint32_t>
            <!-- Will be set by HWP -->
            <default>0</default>
        </uint32_t>
    </simpleType>
    <readable/>
    <persistency>non-volatile</persistency>
    <hwpfToHbAttrMap>
        <id>ATTR_PFET_POWERUP_DELAY_NS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>HDAT_RSV_MEM_NUM_SECTIONS</id>
    <description>
        Number of internal data pointers we have in
        the hostboot reserved memory section.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HDAT_HBRT_NUM_SECTIONS</id>
    <description>
        Number of internal data pointers we have in
        the hostboot runtime data section.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HDAT_HBRT_SECTION_SIZE</id>
    <description>
        Biggest size for any of the hostboot
        runtime data sections.
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>9</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<!--<attribute>
    <id>FREQ_PROC_REFCLOCK_KHZ</id>
    <description>
      The frequency of the processor refclock in kHz.
      Provided by the Machine Readable Workbook.
      This can be overridden to adjust the refclock frequency.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PROC_REFCLOCK_KHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>-->

<!--<attribute>
    <id>FREQ_MEM_REFCLOCK</id>
    <description>
      The frequency of the memory refclock in MHz.
      Provided by the Machine Readable Workbook.
      This is read by the set_ref_clock HWP to find out the desired frequency.
      This can be overridden to adjust the refclock frequency.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_MEM_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>-->

<attribute>
    <id>REQUIRED_SYNCH_MODE</id>
    <description>
      Specify the system policy to enforce synchronous mode between memory and
      nest. This drives the value of ATTR_MC_SYNC_MODE.
        0 = UNDETERMINED : Run synchronously if the dimm and nest freq matches
        1 = ALWAYS : Require matching frequencies and deconfigure memory that
                     does not match the nest
        2 = NEVER : Do not run synchronously, even if the frequencies match
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_REQUIRED_SYNCH_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_ALLOWED_DIMM_FREQ</id>
    <description>
      Maximum frequency (in MHz) that this system can run the DIMMs at.
      There are 5 possible values determined by the dimm configuration.
      For configurations which have mixed rank configurations, the lowest
      frequency based on ranks of either DIMM is chosen. For example if
      there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower
      max freq than 2R dual drop, then the 1R max freq would be the max allowed.
      [0]=One rank, single drop
      [1]=Two rank, single drop
      [2]=Four rank, single drop
      [3]=One rank, dual drop
      [4]=Two rank, dual drop
      A value of zero would indicate an unsupported configuration.
    </description>
    <simpleType>
        <uint32_t>
            <default>2400,2400,2400,2400,2400</default>
        </uint32_t>
        <array>5</array>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_MAX_ALLOWED_DIMM_FREQ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!--<attribute>
    <id>PROC_DPLL_DIVIDER</id>
    <description>
      The product of the DPLL internal prescalar divide (CD_DIV124_DC)
      and the output divider(CD_DPLLOUT124_DC).  This estalishes the step size of
      the DPLL in terms of this number divided into the processor reference clock.

      Platform default:  8
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_DPLL_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>-->

<attribute>
    <id>AVSBUS_FREQUENCY</id>
    <description>
      AVSBus Clock Frequency (binary in KHz)

      Consumer: p9_ocb_init.C

      Overridden by the Machine Readable Workbook.

      If default of 0 is read, HWP will set AVSBus frequency to 1MHz.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_AVSBUS_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDD_AVSBUS_BUSNUM</id>
    <description>
      Defines the AVSBus (0 or 1) which has the core VDD rail VRM

      Producer:  Machine Readable Workbook
      Consumers: p9_set_evid;
                p9_set_voltage (tool);
                p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VDD_AVSBUS_BUSNUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDN_AVSBUS_BUSNUM</id>
    <description>
      Defines the AVSBus (0 or 1) which has the chip VDN rail VRM

      Producer:  Machine Readable Workbook
      Consumers: p9_set_evid;
                p9_set_voltage (tool);
                p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VDN_AVSBUS_BUSNUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDD_AVSBUS_RAIL</id>
    <description>
      Defines the AVSBus rail selector number (0 - 15) for the VDD VRM on the bus
      defined by ATTR_AVSBUS_VDD_BUSNUM.

      Producer:  Machine Readable Workbook
      Consumers: p9_set_evid;
                p9_set_voltage (tool);
                p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VDD_AVSBUS_RAIL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDN_AVSBUS_RAIL</id>
    <description>
      Defines the AVSBus rail selector number (0 - 15) for the VDN VRM on the bus
      defined by ATTR_AVSBUS_VDN_BUSNUM.

      Producer:  Machine Readable Workbook
      Consumers:
      p9_set_avsbus_voltage (tool);
                  p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VDN_AVSBUS_RAIL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VCS_AVSBUS_RAIL</id>
    <description>
      Defines the AVSBus rail selector number (0 - 15) for the VCS VRM on the bus
      defined by ATTR_AVSBUS_VCS_BUSNUM.

      Producer:  Machine Readable Workbook
      Consumers:
      p9_set_avsbus_voltage (tool);
                  p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VCS_AVSBUS_RAIL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VCS_AVSBUS_BUSNUM</id>
    <description>
      Defines the AVSBus (0 or 1) which has the core VCS rail VRM

      Producer:  Machine Readable Workbook
      Consumers: p9_set_evid;
                p9_set_voltage (tool);
                p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VCS_AVSBUS_BUSNUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VCS_I2C_BUSNUM</id>
    <description>
      Defines the I2C bus number (0 - 15) that has the VCS VRM.

      Producer:  Machine Readable Workbook
      Consumers: p9_set_evid;
                  sp9_set_voltage (tool)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VCS_I2C_BUSNUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDD_BOOT_VOLTAGE</id>
    <description>
      Voltage (binary in 1mV units) to apply to the VDD VRM for booting.  Value
      chosen is system dependent and is a combination of the part's Vital Product
      Data (VPD) (typically the PowerSave value) and the minimum allowed for
      correct operation of the fabric bus.

      Producer: p9_setup_evid (first pass)

      Consumer: p9_setup_evid (second pass)
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VDD_BOOT_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VCS_BOOT_VOLTAGE</id>
    <description>
      Voltage (binary in 1mV units) to apply to the VCS VRM for booting.  Value
      chosen is system dependent and is a combination of the part's Vital Product
      Data (VPD) (typically the PowerSave value) and the minimum allowed for
      correct operation of the fabric bus.

      Producer: p9_setup_evid (first pass)

      Consumer: p9_setup_evid (second pass)
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VCS_BOOT_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>SPIPSS_FREQUENCY</id>
    <description>
      SPIPSS Clock Frequency (binary in KHz)

      Valid range: 500KHz to 2500KHz

      Consumer: p8_pss_init

      Overridden by the Machine Readable Workbook.

      If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_SPIPSS_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PM_APSS_CHIP_SELECT</id>
    <description>
      Defines which of the PSS chip selects (0 or 1) that the APSS is connected

      Provided by the Machine Readable Workbook.
      Consumer: p9_pm_pss_init
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_APSS_CHIP_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>PM_APSS_CHIP_SELECT</id>
    <description>Enumeration for the ATTR_PM_APSS_CHIP_SELECT</description>
    <enumerator>
        <name>NONE</name>
        <value>0xFF</value>
    </enumerator>
    <enumerator>
        <name>CS0</name>
        <value>0x00</value>
    </enumerator>
        <enumerator>
        <name>CS1</name>
        <value>0x01</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>FREQ_EXT_BIAS_ULTRATURBO</id>
    <description>
      UltraTurbo Frequency Bias - % of bias (signed twos complement in 0.5 percent
      steps) used in calculating the frequency associated with a Pstate.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC
                        CME Quad Pstate Region (CQPR) for CM Quad Manager

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_EXT_BIAS_ULTRATURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FREQ_EXT_BIAS_TURBO</id>
    <description>
      Turbo Frequency Bias - % of bias (signed twos complement in 0.5 percent
      steps) used in calculating the frequency associated with a Pstate.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC
                        CME Quad Pstate Region (CQPR) for CM Quad Manager

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_EXT_BIAS_TURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FREQ_EXT_BIAS_NOMINAL</id>
    <description>
      Nominal Frequency Bias - % of bias (signed twos complement in 0.5 percent
      steps) used in calculating the frequency associated with a Pstate.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC
                        CME Quad Pstate Region (CQPR) for CM Quad Manager

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_EXT_BIAS_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FREQ_EXT_BIAS_POWERSAVE</id>
    <description>
      PowerSave Frequency Bias - % of bias (signed twos complement in 0.5 percent
      steps) used in calculating the frequency associated with a Pstate.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC
                        CME Quad Pstate Region (CQPR) for CM Quad Manager

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_EXT_BIAS_POWERSAVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_VDD_BIAS_ULTRATURBO</id>
    <description>
      UltraTurbo VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the UltraTurbo VPD point used in calculating the
      the Global Pstate values.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_VDD_BIAS_ULTRATURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_VDD_BIAS_TURBO</id>
    <description>
      Turbo VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the UltraTurbo VPD point used in calculating the
      the Global Pstate values.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_VDD_BIAS_TURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_VDD_BIAS_NOMINAL</id>
    <description>
      Nominal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the UltraTurbo VPD point used in calculating the
      the Global Pstate values.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_VDD_BIAS_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_VDD_BIAS_POWERSAVE</id>
    <description>
      PowerSave VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the UltraTurbo VPD point used in calculating the
      the Global Pstate values.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_VDD_BIAS_POWERSAVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_VCS_BIAS</id>
    <description>
      VCS Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the VCS value stored in the UltraTurbo VPD
      point for setting the VCS rail.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_VCS_BIAS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_VDN_BIAS</id>
    <description>
      VDN Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the VDN value stored in the VPD for setting the
      VDN rail.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_VDN_BIAS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VOLTAGE_INT_VDD_BIAS</id>
    <description>
      TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS WELL
      AS THE IVRM VOLTAGE CALCULATION PROCESS
      Internal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
      steps) that is applied to the Local Pstate voltage *after* the
      ATTR_VOLTAGE_VDD_BIAS bias have been applied.

      Producer:  Attribute Overrides by Lab/Mfg Characterization Team

      Consumers: p9_build_pstate_datablock ->
                          Pstate Parameter Block (PSPB) for PGPE/OCC
                          CME Quad Pstate Region (CQPR) for CM Quad Manager

      Platform default:  0
    </description>
    <simpleType>
        <int32_t>
        </int32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_INT_VDD_BIAS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>STOP4_DISABLE</id>
    <description>
      Control CME response to execution of PowerPC STOP instruction

      if OFF, treat STOP4 as STOP4
      if ON, treat STOP4 as STOP2

      Producer: ???

      Consumer:  p8_hcd_image_build.C

      Platform default:  OFF
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_STOP4_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>STOP5_DISABLE</id>
    <description> Control CME response to execution of PowerPC STOP instruction
    if OFF, treat STOP5 as STOP5
    if ON,  treat STOP5 as STOP4

    Producer: ???

    Consumer:  p8_hcode_image_build.C

    Platform default: ON
    </description>
    <simpleType>
        <uint8_t>
          <default>1</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_STOP5_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>STOP8_DISABLE</id>
    <description>
      Control CME response to execution of PowerPC STOP instruction

      if OFF, treat STOP8 as STOP8
      if ON, treat STOP8 as STOP4

      Producer: ???

      Consumer:  p8_hcd_image_build.C

      Platform default:  OFF
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
        <hwpfToHbAttrMap>
        <id>ATTR_STOP8_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>STOP11_DISABLE</id>
    <description>
      Control CME response to execution of PowerPC STOP instruction

      if OFF, treat STOP8 as STOP11
      if ON, treat STOP8 as STOP8

      Producer: ???

      Consumer:  p8_hcd_image_build.C

      Platform default:  OFF
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_STOP11_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>SYSTEM_IVRMS_ENABLED</id>
    <description>
      System control to allow (if all other attribute tests yield
      true values) or categorically disallow IVRM enablement

      Producer: MRWB

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC
                        CME Quad Pstate Region (CQPR) for CM Quad Manager
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_IVRMS_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>SYSTEM_WOF_ENABLED</id>
    <description>
      System control to allow Work Load Optimized Frequency (WOF)
      algorithms to modify frequency based on active core count and other inputs.

      Producer: MRWB

      Consumers: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE/OCC

      Platform default:   FALSE
    </description>
    <simpleType>
      <uint8_t>
        <default>OFF</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_WOF_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<enumerationType>
    <id>SYSTEM_WOF_ENABLED</id>
    <description>Enumeration for Work Load Optimized Frequency</description>
    <enumerator>
        <name>OFF</name>
        <value>0x00</value>
    </enumerator>
    <enumerator>
        <name>ON</name>
        <value>0x01</value>
    </enumerator>
</enumerationType>

<enumerationType>
    <id>WOF_POWER_LIMIT</id>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
        <name>NOMINAL</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>TURBO</name>
        <value>1</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>WOF_POWER_LIMIT</id>
    <description>
      System control to set the power limit for Workload Optimized
      Frequency (WOF) algorithms.  This is used to select the
      proper VFRT tables.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>


<attribute>
    <id>SYSTEM_RESCLK_STEP_DELAY</id>
    <description>
      Minimum delay (in nanoseconds) between resonant clock transition steps

      Producer: MRWB

      Consumers: p9_build_pstate_datablock ->
                        CME Quad Pstate Region (CQPR) for CM Quad Manager

      Platform default:   0
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_STEP_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!--<attribute>
    <id>PFET_POWERUP_DELAY_NS</id>
    <description>
      Time (in nanoseconds) between PFET controller steps (7 of them) when turning
      the PFES ON

      Producer: MRWB

      Consumers: p9_pm_pfet_init

      Platform default:
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PFET_POWERUP_DELAY_NS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>-->

<attribute>
    <id>PFET_POWERDOWN_DELAY_NS</id>
    <description>
      Time (in nanoseconds) between PFET controller steps (7 of them) when turning
      the PFES OFF

      Producer: MRWB

      Consumers: p9_pm_pfet_init

      Platform default:
    </description>
    <simpleType>
        <uint32_t>
            <!-- Will be set by HWP -->
            <default>0</default>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PFET_POWERDOWN_DELAY_NS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PFET_VDD_VOFF_SEL</id>
    <description>
      Selection of the OFF setting for the core and cache chiplet VDD PFET controllers

      Producer: MRWB

      Consumers: p9_pm_pfet_init

      Platform default:
    </description>
    <simpleType>
        <uint8_t>
            <!-- Will be set by HWP -->
            <default>0</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PFET_VDD_VOFF_SEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>PFET_VDD_VOFF_SEL</id>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        DD PFET controllers
    </description>
    <enumerator>
        <name>NOOFF</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>ALLBUT1TO7OFF</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>ALLBUT2TO7OFF</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>ALLBUT3TO7OFF</name>
        <value>3</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT4TO7OFF</name>
        <value>4</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT5TO7OFF</name>
        <value>5</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT6TO7OFF</name>
        <value>6</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT7TO7OFF</name>
        <value>7</value>
    </enumerator>
        <enumerator>
        <name>ALLOFF</name>
        <value>8</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PFET_VCS_VOFF_SEL</id>
    <description>
      Selection of the OFF setting for the core and cache chiplet VCS PFET controllers

      Producer: MRWB

      Consumers: p9_pm_pfet_init

      Platform default:
    </description>
    <simpleType>
        <uint8_t>
            <!-- Will be set by HWP -->
            <default>0</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PFET_VCS_VOFF_SEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>PFET_VCS_VOFF_SEL</id>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        VCS PFET controllers
    </description>
    <enumerator>
        <name>NOOFF</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>ALLBUT1TO7OFF</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>ALLBUT2TO7OFF</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>ALLBUT3TO7OFF</name>
        <value>3</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT4TO7OFF</name>
        <value>4</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT5TO7OFF</name>
        <value>5</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT6TO7OFF</name>
        <value>6</value>
    </enumerator>
        <enumerator>
        <name>ALLBUT7TO7OFF</name>
        <value>7</value>
    </enumerator>
        <enumerator>
        <name>ALLOFF</name>
        <value>8</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PBAX_NODEID</id>
    <description>
      Receive PBAX Nodeid. Value that indicates this PBA's PBAX Node affinity.
      This is matched to pbax_nodeid of the PMISC Address phase.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t>
<!-- TODO RTC:162070 Temporary default -->
            <default>0</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PBAX_NODEID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>VCS_I2C_RAIL</id>
    <description>
      Step delay (binary in microseconds) after a voltage change

      Consumer: p9_build_pstate_datablock ->
                        Pstate Parameter Block (PSPB) for PGPE

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VCS_I2C_RAIL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>VDN_BOOT_VOLTAGE</id>
    <description>
      Voltage (binary in 1mV units) to apply to the VDN VRM for booting.  Value
      chosen is system dependent and is a combination of the part's Vital Product
      Data (VPD) (typically the PowerSave value) and the minimum allowed for
      correct operation of the fabric bus.

      Producer: p9_setup_evid (first pass)

      Consumer: p9_setup_evid (second pass)
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_VDN_BOOT_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<enumerationType>
    <id>FAPI_POS</id>
    <description>Enumeration defining special FAPI_POS values</description>
    <enumerator>
        <name>NA</name>
        <value>0xFFFFFFFF</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<attribute>
    <id>FAPI_POS</id>
    <description>
      Logical position of target within a system. This is derived from the SMP location
      of each processor and each target's relationship to a proc.
      - PROC = based on SMP groupid+chipid
      - MEMBUF = PROC:FAPI_POS * [max membuf per proc]
      - 1st level child unit = [parent chip]:FAPI_POS * [max children of this type per chip]
      - 2nd+ level child unit = [immediate parent unit]:FAPI_POS * [max units below parent]
      Note: This should not be used algorithmically by HWPs directly.
      Note: Value ignores physical drawer boundaries, the value is unique across the entire
            system.
      This data is derived from the MRW.
      Default of NA is 0xFFFFFFFF (to avoid confusion with legitimate 0
         values)
    </description>
    <simpleType>
        <uint32_t>
           <default>0xFFFFFFFF</default>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_FAPI_POS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
  <id>I2C_BUS_DIV_REF</id>
  <description>
      Ref clock I2C bus divider consumed by code running out of OTPROM
  </description>
  <simpleType>
      <uint16_t>
        <default>0x0003</default>
      </uint16_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_I2C_BUS_DIV_REF</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>NEST_PLL_BUCKET</id>
  <description>
      Select Nest I2C and pll setting from one of the supported frequencies
  </description>
  <simpleType>
      <uint8_t>
      <default>0x05</default>
      </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_NEST_PLL_BUCKET</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
     @todo: RTC:167266 set attributes from HWP nest PLL bucket data
     ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== -->
<attribute>
  <id>NEST_PLL_FREQ_BUCKETS</id>
  <description>
      Constant defining number of NEST PLL frequency options ('buckets')
      to be built into unsigned HW image.
  </description>
  <simpleType>
      <uint8_t>
          <default>0x05</default>
      </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_NEST_PLL_FREQ_BUCKETS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>NEST_PLL_FREQ_LIST</id>
  <description>
      Nest PLL frequency in MHZ
      index is bucket number
  </description>
  <simpleType>
      <uint32_t>
          <default>1600,1866,2000,2133,2400</default>
      </uint32_t>
      <array>5</array>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_NEST_PLL_FREQ_LIST</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>NEST_PLL_FREQ_I2CDIV_LIST</id>
  <description>
      I2C bus divisor
      index is bucket number
      The values in this list will be factor of 1:64 to the NEST_PLL_FREQ_LIST
  </description>
  <simpleType>
      <uint32_t>
          <default>25,29,31,33,37</default>
      </uint32_t>
      <array>5</array>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_NEST_PLL_FREQ_I2CDIV_LIST</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>
<!-- ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
     @todo: RTC:167266 set attributes from HWP nest PLL bucket data
     ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== -->

<attribute>
  <id>BOOT_FREQ</id>
  <description>EQ boot frequency</description>
  <simpleType>
      <uint32_t>
      </uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BOOT_FREQ</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_UPDATE_DISABLE</id>
    <description>
      Control execution of updateProcessorSbeSeeproms()

      if 0, enable SBE update of processor SEEPROM
      if 1, disable SBE update of processor SEEPROM

      Consumer:  sbe_update.C

      Default:  0
    </description>
    <simpleType>
        <uint8_t>
          <default>0</default>
        </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_UPDATE_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
  <id>BOOT_FLAGS</id>
  <description>Switch to using a flag to indicate SEEPROM side SBE</description>
  <simpleType>
      <uint32_t>
      </uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BOOT_FLAGS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>NODE_POS</id>
  <description>Indicate the node position in FSP based systems
  (unused in Spless systems)</description>
  <simpleType>
      <uint8_t>
      </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_NODE_POS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>CHIP_POS</id>
  <description>Indicate the chip position</description>
  <simpleType>
      <uint8_t>
      </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_CHIP_POS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>FUNCTIONAL_EQ_EC_VALID</id>
  <description>
    Indicates the validitiy of FW functional EQ/EQ register
    FALSE = 0x0, TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_FUNCTIONAL_EQ_EC_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>EQ_GARD</id>
  <description>Capturing EQ Gard value</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_EQ_GARD</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>EC_GARD</id>
  <description>Capturing EC Gard Value</description>
  <simpleType>
    <uint32_t>
    </uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_EC_GARD</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>I2C_BUS_DIV_REF_VALID</id>
  <description>Indicates the validity of ref clock I2C bus divider consumed by
      code running out of OTPROM
      FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_I2C_BUS_DIV_REF_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>FW_MODE_FLAGS_VALID</id>
  <description>Indicates the validity of FW flags. Ex: ISTEP_MODE,
      SBE_RUNTIME_MODE, MPIPL_MODE, SP_MODE, SBE_FFDC_ENABLE
      FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_FW_MODE_FLAGS_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>SBE_RUNTIME_MODE</id>
  <description>Indicates that SBE should go directly to runtime functionality
    FALSE = 0x0, TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_SBE_RUNTIME_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>IS_SP_MODE</id>
  <description>Indicates whether we are connected to FSP or not
    FSP_LESS = 0x0,FSP = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_IS_SP_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>SBE_FFDC_ENABLE</id>
  <description>Indicates whether SBE should collect FFDC
    FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_SBE_FFDC_ENABLE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>SBE_INTERNAL_FFDC_ENABLE</id>
  <description>Indicates that the SBE should send back internal FFDC on any
      chipOp failure response
      FALSE = 0x0,TRUE = 0x1</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_SBE_INTERNAL_FFDC_ENABLE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>BOOT_FREQUENCY_VALID</id>
  <description>Indicates if BOOT_FREQ_MULT and NEST_PLL_BUCKET are valid
      FALSE = 0x0,TRUE = 0x1</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BOOT_FREQUENCY_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>BOOT_FREQ_MULT</id>
  <description>EQ boot frequency multiplier</description>
  <simpleType>
    <uint16_t>
      <default>150</default>
    </uint16_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BOOT_FREQ_MULT</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>HWP_CONTROL_FLAGS_VALID</id>
  <description>
    Indicates if HWP control flags are valid
    FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_HWP_CONTROL_FLAGS_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>SYS_FORCE_ALL_CORES</id>
  <description>
  Indicates that SBE should init all cores
  FALSE = 0x0,TRUE = 0x1
  Override Attribute
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_SYS_FORCE_ALL_CORES</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>DISABLE_HBBL_VECTORS</id>
  <description>
  BootLoader HWP flag to not place 12K exception vectors.
  This flag is only applicable when security is disabled.
  FALSE = 0x0,TRUE = 0x1
  Override Attribute
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_DISABLE_HBBL_VECTORS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>CHIP_SELECTION_VALID</id>
  <description>Indicates that master/slave, node/chip selection attributes
  are valid
  FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_CHIP_SELECTION_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>CHIP_SELECTION</id>
  <description>master/slave bit
    MASTER = 0x0,SLAVE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_CHIP_SELECTION</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>SCRATCH6_VALID</id>
  <description>Indicate if scratch reg6 bits are valid
  FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_SCRATCH6_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
  <id>SCRATCH7_VALID</id>
  <description>Indicate if scratch reg7 bits are valid
    FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_SCRATCH7_VALID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>BACKUP_SEEPROM_SELECT</id>
  <description>Set with Primary SEEPROM</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BACKUP_SEEPROM_SELECT</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>BOOT_FMULT</id>
  <description>EQ boot frequency multiplier</description>
  <simpleType>
    <uint16_t>
    </uint16_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BOOT_FMULT</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>BRANCH_PIBMEM_ADDR</id>
  <description>Bransh Pibmem address</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_BRANCH_PIBMEM_ADDR</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>DEVICE_ID</id>
  <description>Device Identification</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_DEVICE_ID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>I2C_BUS_DIV_NEST</id>
  <description>I2C Bus speed based on nest freq, ref clock</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_I2C_BUS_DIV_NEST</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>LEN_OF_SEEPROM_DATA</id>
  <description>Length of Seeprom data</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_LEN_OF_SEEPROM_DATA</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>MB_BIT_RATE_DIVISOR_PLL</id>
  <description>MN Bitrate divisor pll</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_MB_BIT_RATE_DIVISOR_PLL</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>MB_BIT_RATE_DIVISOR_REFCLK</id>
  <description>MB_BIT_RATE_DIVISOR_REFCLK</description>
  <simpleType>
    <uint8_t>
        <default>133</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_MB_BIT_RATE_DIVISOR_REFCLK</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MC_SYNC_MODE</id>
  <description>MC mesh to use Nest mesh or not</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_MC_SYNC_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PG</id>
  <description>
    Chiplet Partial good info attribute. Provided by Ring scans
  </description>
  <simpleType>
    <uint16_t>
    </uint16_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PG</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>PROC_PB_BNDY_DMIPLL_DATA</id>
  <description>Ring image for pb_bndy_dmipll ring creator:
    platform firmware notes:</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_PB_BNDY_DMIPLL_DATA</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA</id>
  <description>Ring image for pb_bndy_dmipll ring for DC cal creator:
    platform firmware notes:</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_PB_BNDY_DMIPLL_FOR_DCCAL_DATA</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>PROC_PERV_BNDY_PLL_DATA</id>
  <description>Ring image for perv_bndy_pll ring containing filter plls
    and xb_pll,nest_pll creator: platform firmware notes:</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_PERV_BNDY_PLL_DATA</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>PROC_SBE_MASTER_CHIP</id>
  <description>
    Indicates if SBE on this chip is serving as hosboot drawer master
    FALSE = 0x0,TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_SBE_MASTER_CHIP</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>START_PIBMEM_ADDR</id>
  <description>Start of PIBMEM address</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_START_PIBMEM_ADDR</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>START_SEEPROM_ADDR</id>
  <description>Start of seeprom address</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_START_SEEPROM_ADDR</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>WAIT_N0</id>
  <description>Wait N0</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_WAIT_N0</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>WAIT_N1</id>
  <description>WAIT_N1</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_WAIT_N1</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>WAIT_N2</id>
  <description>WAIT_N2</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_WAIT_N2</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- Deprecated -->
<attribute>
  <id>WAIT_N3</id>
  <description>WAIT_N3</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_WAIT_N3</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- name changed in ekb, need to have both to push interim commits through -->
<attribute>
  <id>PROC_FABRIC_SYSTEM_ID</id>
  <description>
      Logical fabric system ID associated with this chip.
      Would only need to be a non-zero to support CCSM
      (coherent cluster shared memory) system topologies
      Provided by the MRW.
  </description>
  <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_SYSTEM_ID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>CLOCK_PLL_MUX</id>
  <description>setup clock mux settings</description>
  <simpleType>
    <uint32_t>
    </uint32_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_CLOCK_PLL_MUX</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>CLOCK_PLL_MUX0</id>
  <description>Clock Mux#0 settings</description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_CLOCK_PLL_MUX0</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>MASTER_CORE</id>
  <description>Indicates the master boot core chiplet selected by p9_sbe_select_ex.
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_MASTER_CORE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
  <id>MASTER_EX</id>
  <description>Indicates the EX targert associated with the master boot core selected
    by p9_sbe_select_ex.
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_MASTER_EX</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>STOPGPE_BOOT_COPIER_IVPR_OFFSET</id>
    <description>Set by p9_hcode_image build with the offset value from
    the HOMER base where the SGPE Boot Copier interrupt vectors reside.  This
    value must be 512B aligned. The HOMER base address will be pre-establish
    in PBABAR0 so the address needs to be off the form  0x8XXXXX00. The SGPE
    will be Sreset after this value is established.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_STOPGPE_BOOT_COPIER_IVPR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PSTATEGPE_BOOT_COPIER_IVPR_OFFSET</id>
    <description>Set by p9_hcode_image build with the offset value from
    the HOMER base where the PGPE Boot Copier interrupt vectors reside. This
    value must be 512B aligned. The HOMER base address will be pre-establish
    in PBABAR0 so the address needs to be off the form  0x8XXXXX00. The PGPE
    will be Sreset after this value is established
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
        <id>ATTR_PSTATEGPE_BOOT_COPIER_IVPR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
   <id>CHIPLET_ID</id>
   <description>The address offset which each Chiplet types pervasive
     address space used to represent the a chiplet.
     0x00 to 0x0F => For P9 all non-core and non-cache chiplets
     0x10 to 0x1F => All Cache Chiplets
     0x20 to 0x37 => All Core Chiplets
     0x38 to 0x3F => Multicast Operation
   </description>
   <simpleType>
       <uint8_t>
           <default>0xFF</default>
       </uint8_t>
   </simpleType>
   <persistency>non-volatile</persistency>
   <readable/>
</attribute>

<attribute>
    <id>SYSTEM_IPL_PHASE</id>
    <description>Define context for current phase of system IPL.
      Provided by the platform.
      HB_IPL = 0x1,HB_RUNTIME = 0x2,CACHE_CONTAINED = 0x4</description>
  <simpleType>
    <uint8_t>
      <default>0x01</default>
    </uint8_t>
  </simpleType>
  <hwpfToHbAttrMap>
    <id>ATTR_SYSTEM_IPL_PHASE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
</attribute>

<attribute>
  <id>ADU_XSCOM_BAR_BASE_ADDR</id>
  <description>Defines XSCOM base address on each processor level.
        address provided by the MRW </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <hwpfToHbAttrMap>
    <id>ATTR_ADU_XSCOM_BAR_BASE_ADDR</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
  <persistency>volatile-zeroed</persistency>
  <readable/>
</attribute>

<attribute>
    <id>PARENT_PERVASIVE</id>
    <description>
        Physical entity path of the target's associated pervasive target
    </description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
</attribute>

<!-- ********************************************************************** -->
<attribute>
  <id>FREQ_CORE_CEILING_MHZ</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    The maximum core frequency in MHz.
    This is the same for all cores in the system.
    Data is provided by MVPD #V and is calculated as
    the minimum of the turbo frequencies.
  </description>
  <simpleType>
    <uint32_t>
    </uint32_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
        <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
    <description>
        Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH
    </description>
    <!--  Note: Values must match numbers from nest_attributes.xml -->
    <enumerator>
        <name>2_BYTE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>4_BYTE</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_FABRIC_A_BUS_WIDTH</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Processor SMP A bus width.
    Provided by the MRW.
    2_BYTE = 0x01, 4_BYTE = 0x02
  </description>
  <simpleType><uint8_t><default>4_BYTE</default></uint8_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_A_BUS_WIDTH</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
    <description>
        Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH
    </description>
    <!--  Note: Values must match numbers from nest_attributes.xml -->
    <enumerator>
        <name>2_BYTE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>4_BYTE</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_FABRIC_X_BUS_WIDTH</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Processor SMP X bus width.
    Provided by the MRW.
    2_BYTE = 0x01, 4_BYTE = 0x02
  </description>
  <simpleType>
      <uint8_t><default>4_BYTE</default></uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_X_BUS_WIDTH</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_CCSM_MODE</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Processor SMP topology configuration.
    0 = default = 1 or 2 hop topology (PHYP image spans system)
    Provided by the MRW.
    OFF = 0x0 (default)
  </description>
  <simpleType>
    <uint8_t>
      <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_CCSM_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>OPTICS_CONFIG_MODE</id>
  <!-- <targetType>TARGET_TYPE_OBUS</targetType> -->
  <description>
    Per-link optics configuration
    0 = SMP (default)
    1 = CAPI 2.0
    2 = NV 2.0
    Provided by the MRW.
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_OPTICS_CONFIG_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
    <description>
        Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE
    </description>
    <!--  Note: Values must match numbers from nest_attributes.xml -->
    <enumerator>
        <name>OPTICS_IS_X_BUS</name>
        <value>0x0</value>
    </enumerator>
    <enumerator>
        <name>OPTICS_IS_A_BUS</name>
        <value>0x1</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Processor SMP optics mode.
    0 = Optics_is_X_bus (default)
    1 = Optics_is_A_bus
    Provided by the MRW.
    OPTICS_IS_X_BUS = 0x0, OPTICS_IS_A_BUS = 0x1
  </description>
  <simpleType>
    <uint8_t>
      <default>OPTICS_IS_X_BUS</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_SMP_OPTICS_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_FABRIC_CAPI_MODE</id>
    <description>
        Enumeration indicating the PROC_FABRIC_CAPI_MODE
    </description>
    <!--  Note: Values must match numbers from nest_attributes.xml -->
    <enumerator>
        <name>OFF</name>
        <value>0x0</value>
    </enumerator>
    <enumerator>
        <name>ON</name>
        <value>0x1</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_FABRIC_CAPI_MODE</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Processor CAPI attachment protocol mode.
    0 =  no: SMPA CAPI attachment (default)
    1 = yes: SMPA CAPI attachment
    Provided by the MRW.
  </description>
  <simpleType>
    <uint8_t>
      <default>OFF</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_CAPI_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<enumerationType>
    <id>PROC_FABRIC_ADDR_BAR_MODE</id>
    <description>
        Enumeration indicating the PROC_FABRIC_ADDR_BAR_MODE
    </description>
    <!--  Note: Values must match numbers from nest_attributes.xml -->
    <enumerator>
        <name>LARGE_SYSTEM</name>
        <value>0x0</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_FABRIC_ADDR_BAR_MODE</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Processor memory map configuration.
    0 = large system address map (default)
    Provided by the MRW.
  </description>
  <simpleType>
    <uint8_t>
      <default>LARGE_SYSTEM</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_ADDR_BAR_MODE</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<attribute>
  <id>PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    Indicates if the given chip should serve as the fabric system master.
    FALSE = 0x0, TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_SYSTEM_MASTER_CHIP</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_GROUP_MASTER_CHIP</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    Indicates if the given chip should serve as the fabric group master.
    FALSE = 0x0, TRUE = 0x1
  </description>
  <simpleType><uint8_t></uint8_t></simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_GROUP_MASTER_CHIP</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    For each fabric X link on this chip, specifies whether or not the chip at
    the receiving end of the link is present and configured
    FALSE = 0x0, TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t></uint8_t>
    <array>7</array>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    For each fabric A link on this chip, specifies whether or not the chip at
    the receiving end of the link is present and configured
    FALSE = 0x0, TRUE = 0x1
  </description>
  <simpleType>
    <uint8_t></uint8_t>
    <array>4</array>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_X_ATTACHED_CHIP_ID</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    For each fabric X link on this chip, specifies the fabric ID of the chip
    at the receiving end of the link.  Should be considered valid only if
    corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
  </description>
  <simpleType>
    <uint8_t></uint8_t>
    <array>7</array>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_X_ATTACHED_CHIP_ID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_A_ATTACHED_CHIP_ID</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    For each fabric A link on this chip, specifies the fabric ID of the chip
    at the receiving end of the link.  Should be considered valid only if
    corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
  </description>
  <simpleType>
    <uint8_t></uint8_t>
    <array>4</array>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_A_ATTACHED_CHIP_ID</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_X_ADDR_DIS</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    Indicates if link should be used to carry data only
    (in aggregate configurations).
    Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
    OFF = 0x0, ON = 0x1
  </description>
  <simpleType>
    <uint8_t></uint8_t>
    <array>7</array>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_X_ADDR_DIS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_A_ADDR_DIS</id>
  <!-- <targetType>TARGET_TYPE_PROC_CHIP</targetType> -->
  <description>
    Indicates if link should be used to carry data only
    (in aggregate configurations).
    Should be considered valid only if corresponding
    ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
    OFF = 0x0, ON = 0x1
  </description>
  <simpleType>
    <uint8_t></uint8_t>
    <array>4</array>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_FABRIC_A_ADDR_DIS</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_READ_CYCLES_T0</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Calculated read tier0 epsilon protection count.
  </description>
  <simpleType>
    <uint32_t></uint32_t>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_EPS_READ_CYCLES_T0</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_READ_CYCLES_T1</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Calculated read tier1 epsilon protection count.
  </description>
  <simpleType>
    <uint32_t></uint32_t>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_EPS_READ_CYCLES_T1</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_READ_CYCLES_T2</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Calculated read tier2 epsilon protection count.
  </description>
  <simpleType>
    <uint32_t></uint32_t>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_EPS_READ_CYCLES_T2</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_WRITE_CYCLES_T1</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Calculated write tier1 epsilon protection count.
  </description>
  <simpleType>
    <uint32_t></uint32_t>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_EPS_WRITE_CYCLES_T1</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_WRITE_CYCLES_T2</id>
  <!-- <targetType>TARGET_TYPE_SYSTEM</targetType> -->
  <description>
    Calculated write tier2 epsilon protection count.
  </description>
  <simpleType>
    <uint32_t></uint32_t>
  </simpleType>
  <writeable/>
  <readable/>
  <persistency>volatile-zeroed</persistency>
  <hwpfToHbAttrMap>
    <id>ATTR_PROC_EPS_WRITE_CYCLES_T2</id>
    <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_IOVALID_ENABLE</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCIE iovalid enable valid mask
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_IOVALID_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
    <readable/>
    <writeable/>
</attribute>
<attribute>
    <id>PROC_PCIE_BAR_ENABLE</id>
    <!-- TARGET_TYPE_PHB -->
    <description>
      PCIE MMIO BAR enable
      creator: platform
      consumer: p9_pcie_config
      firmware notes:
        Array index: BAR number (0:2)
        index 0~1 for MMIO BAR0/1
        index 2 for PHB register space
        DISABLE = 0x0, ENABLE = 0x1
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>3</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_BAR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>PROC_PCIE_BAR_BASE_ADDR</id>
    <!-- TARGET_TYPE_PHB -->
    <description>
        PCIE MMIO BAR base address value
        creator: platform
        consumer: p9_setup_bars
        firmware notes:
        64-bit address representing BAR RA
        Array index: BAR number (0:2)
        NOTE: BAR0/1 registers cover RA 8:47
        NOTE: BAR2 registers covers RA 8:49
        index 0~1 for BAR0/1
        index 2 for PHB
        index 3 for interrupt
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>PROC_PCIE_BAR_SIZE</id>
    <!-- TARGET_TYPE_PHB -->
    <description>
        PCIE MMIO BAR size values
        creator: platform
        consumer: p9_pcie_config
        firmware notes:
          Array index: BAR number (0:2)
          NOTE: supported MMIO BAR0/1 sizes are from 64KB-32PB
          NOTE: only supported PHB register size is 16KB
         32_PB = 0x8000000000000000,
         16_PB = 0xC000000000000000,
          8_PB = 0xE000000000000000,
          4_PB = 0xF000000000000000,
          2_PB = 0xF800000000000000,
          1_PB = 0xFC00000000000000,
        512_TB = 0xFE00000000000000,
        256_TB = 0xFF00000000000000,
        128_TB = 0xFF80000000000000,
         64_TB = 0xFFC0000000000000,
         32_TB = 0xFFE0000000000000,
         16_TB = 0xFFF0000000000000,
          8_TB = 0xFFF8000000000000,
          4_TB = 0xFFFC000000000000,
          2_TB = 0xFFFE000000000000,
          1_TB = 0xFFFF000000000000,
        512_GB = 0xFFFF800000000000,
        256_GB = 0xFFFFC00000000000,
        128_GB = 0xFFFFE00000000000,
         64_GB = 0xFFFFF00000000000,
         32_GB = 0xFFFFF80000000000,
         16_GB = 0xFFFFFC0000000000,
          8_GB = 0xFFFFFE0000000000,
          4_GB = 0xFFFFFF0000000000,
          2_GB = 0xFFFFFF8000000000,
          1_GB = 0xFFFFFFC000000000,
        512_MB = 0xFFFFFFE000000000,
        256_MB = 0xFFFFFFF000000000,
        128_MB = 0xFFFFFFF800000000,
         64_MB = 0xFFFFFFFC00000000,
         32_MB = 0xFFFFFFFE00000000,
         16_MB = 0xFFFFFFFF00000000,
          8_MB = 0xFFFFFFFF80000000,
          4_MB = 0xFFFFFFFFC0000000,
          2_MB = 0xFFFFFFFFE0000000,
          1_MB = 0xFFFFFFFFF0000000,
        512_KB = 0xFFFFFFFFF8000000,
        256_KB = 0xFFFFFFFFFC000000,
        128_KB = 0xFFFFFFFFFE000000,
         64_KB = 0xFFFFFFFFFF000000,
         16_KB = 0xFFFFFFFFFFFFFFFF
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>3</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>PROC_PCIE_HOTPLUG_I2C_DEVICE_ADDRESS</id>
    <!-- TARGET_TYPE_PROC_CHIP -->
    <description>
        I2C device address for PCIE hotplug controller
        creator: platform
        consumer: p9_pcie_hotplug
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_HOTPLUG_I2C_DEVICE_ADDRESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_HOTPLUG_ENABLE_ACTIONS</id>
    <!-- TARGET_TYPE_PROC_CHIP -->
    <description>
        Sequence of PCIE hotplug controller register writes required to enable
        slot power
        creator: platform
        consumer: p9_pcie_hotplug
        firmware notes:
        Primary array index: Sequence number
        Secondary array index: Address (0) / Data (1)
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>8,2</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_HOTPLUG_ENABLE_ACTIONS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_HOTPLUG_NUM_ENABLE_ACTIONS</id>
    <!-- TARGET_TYPE_PROC_CHIP -->
    <description>
        Number of valid entries in primary index of
        ATTR_PROC_PCIE_HOTPLUG_ENABLE_ACTIONS
        creator: platform
        consumer: p9_pcie_hotplug
        ZERO = 0x0,
        ONE = 0x1,
        TWO = 0x2,
        THREE = 0x3,
        FOUR = 0x4,
        FIVE = 0x5,
        SIX = 0x6,
        SEVEN = 0x7,
        EIGHT = 0x8
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_HOTPLUG_NUM_ENABLE_ACTIONS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_HOTPLUG_DISABLE_ACTIONS</id>
    <!-- TARGET_TYPE_PROC_CHIP -->
    <description>
        Sequence of PCIE hotplug controller register writes required to disable
        slot power
        creator: platform
        consumer: p9_pcie_hotplug
        firmware notes:
        Primary array index: Sequence number
        Secondary array index: Address (0) / Data (1)
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>8,2</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_HOTPLUG_DISABLE_ACTIONS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_HOTPLUG_NUM_DISABLE_ACTIONS</id>
    <!-- TARGET_TYPE_PROC_CHIP -->
    <description>
        Number of valid entries in primary index of
        ATTR_PROC_PCIE_HOTPLUG_DISABLE_ACTIONS
        creator: platform
        consumer: p9_pcie_hotplug

        ZERO = 0x0,
        ONE = 0x1,
        TWO = 0x2,
        THREE = 0x3,
        FOUR = 0x4,
        FIVE = 0x5,
        SIX = 0x6,
        SEVEN = 0x7,
        EIGHT = 0x8
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_HOTPLUG_NUM_DISABLE_ACTIONS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_CDR_GAIN</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx cdr gains
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx cdr gains for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_CDR_GAIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_PK_INIT</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
      PCS rx vga peak init value
      creator: platform
      consumer: p9_pcie_scominit
      firmware notes:
        The value of rx vga peak init for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
        lane 0~15 for each PCIE Lane
    </description>
    <simpleType>
        <uint8_t>
           <default>0</default>
        </uint8_t>
        <array>4,16</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_PK_INIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_INIT_GAIN</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
      PCS rx vga gain init value
      creator: platform
      consumer: p9_pcie_scominit
      firmware notes:
        The value of rx vga gain init for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
        lane 0~15 for each PCIE Lane
    </description>
    <simpleType>
        <uint8_t>
           <default>0</default>
        </uint8_t>
        <array>4,16</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_INIT_GAIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_SIGDET_LVL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
      PCS rx sigdet lvl value
      creator: platform
      consumer: p9_pcie_scominit
      firmware notes:
        The value of rx sigdet lvl for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
        <uint8_t>
           <default>0x0B</default>
        </uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_SIGDET_LVL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_ROT_EXTEL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
      Value of PCS RX ROT extel latch
      creator: platform
      consumer: p9_pcie_scominit
      firmware notes:
        0 for internal (default)
        1 for external (freezes phase rotators)
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_ROT_EXTEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_ROT_RST_FW</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
      Value of PCS RX ROT rstfw latch
      creator: platform
      consumer: p9_pcie_scominit
      firmware notes:
        0 normal, flywheel is enabled (default)
        1 assert reset to the phase rotator flywheel (disable the flywheel)
    </description>
    <simpleType>
        <uint8_t>
           <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_ROT_RST_FW</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_DFE_FDDC</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
      Value of PCS rx dfe func fddc control latch
      creator: platform
      consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_DFE_FDDC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx loff control
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx loff control for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx vga control register3
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx vga control register3.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS RX ROT CNTL CDR lookahead
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        0 for disable, 1 for enable
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_ROT_CDR_LOOKAHEAD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_ROT_CDR_SSC</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS RX ROT CNTL CDR ssc
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        0 for disable, 1 for enable
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_ROT_CDR_SSC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_PCLCK_CNTL_PLLA</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS pclck control plla
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_PCLCK_CNTL_PLLB</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS pclck control pllb
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_PCLCK_CNTL_PLLB</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_TX_DCLCK_ROT</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx dclck rotator override
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_TX_DCLCK_ROT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx fifo config offset
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx pcie receiver detect control register 1
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx pcie receiver detect control register 2
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_TX_PCIE_RECV_DETECT_CNTL_REG2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx power sequence enable
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_TX_POWER_SEQ_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx phase rotator control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_VGA_CNTL_REG1</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx vga control register 1
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_VGA_CNTL_REG2</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx vga control register 2
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_VGA_CNTL_REG2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx sigdet control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS system control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_PCS_M_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS m1-m4 control
        creator: platform
        consumer: p9_pcie_scominit
        Array index:
        0 -> M1
        1 -> M2
        2 -> M3
        3 -> M4
    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_PCS_M_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<!-- TODO: RTC 145692
     Temporary attributes used for p9_mss_eff_grouping test cases
     These attributes need to be removed and test cases need to use
     (TBD) attributes that specify the DIMM sizes used to calculate the
     result of getDimmSize() function called in p9_mss_eff_grouping -->
<attribute>
    <id>UNIT_TEST_MCA_MEMORY_SIZES</id>
    <!-- TARGET_TYPE_PROC_CHIP -->
    <description> The memory sizes behind the MCAs used for p9_mss_eff_grouping
                test case.
                Array [Port][DIMM] where num of ports = 8, num of dimms = 2
    </description>
    <simpleType>
        <uint32_t></uint32_t>
        <array>8,2</array>
    </simpleType>
    <readable/>
    <writeable/>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_UNIT_TEST_MCA_MEMORY_SIZES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_SWAP</id>
  <description>PCIE IOP swap configuration
      creator: platform
      consumer: p9_pcie_scominit
      firmware notes:
        Encoded PCIE IOP swap configuration
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_SWAP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_G3_PLL_CONTROL0</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      firmware notes:
        PCIe Gen3 PLL Control Register 0.
        ATUNE/CPISEL.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_G3_PLL_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_G2_PLL_CONTROL0</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      firmware notes:
        PCIe Gen2/Gen1 PLL Control Register 0.
        ATUNE/CPISEL.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_G2_PLL_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PLL_GLOBAL_CONTROL0</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe PLL Global Control Register 0.
        REFISRC/REFISINK.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PLL_GLOBAL_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PLL_GLOBAL_CONTROL1</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe PLL Global Control Register 1.
    ENBGDOCPSRC/ENBGDOCAMP/REFVREG.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PLL_GLOBAL_CONTROL1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PCS_CONTROL0</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe PCS Control Register 0.
        BITLOCKTIME/ADDDREMDELTA_810_B/STARTUPDELTA_810_B/ADDDREMDELTA_810_A/
        STARTUPDELTA_A/RXREJECTHANDLING/EQCOMLETERESPONSE.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PCS_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PCS_CONTROL1</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe PCS Control Register 1.
    RXSIGDETSETTING/ADDDREMDELTA_128130_B/STARTUPDELTA_128130_B/
        ADDDREMDELTA_128130_A/STARTUPDELTA_128130_A.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PCS_CONTROL1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_FIFO_OFFSET</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe TX FIFO Offset Register.
    G3OFFSET/G2OFFSET/G1OFFSET.
        Array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_FIFO_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_RCVRDETCNTL</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe TX Receiver Detect Control Register.
        VREFSEL/RCVRDETCNT/DETDRVC/PH1WAIT.
        Array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_RCVRDETCNTL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_BWLOSS1</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe TX Bandwidth Loss Coefficient Register.
        GEN3BWCOEFF/GEN2BWCOEFF/GEN1BWCOEFF.
        Array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_BWLOSS1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_RX_VGA_CONTROL2</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe RX VGA Control Register 2.
        GAIN2/GAIN1.
        Array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_RX_VGA_CONTROL2</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_RX_PEAK</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe RX Receiver Peaking Value Register.
    PEAK1/PEAK2/PEAK3.
        Array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_RX_PEAK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_RX_SDL</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe RX Signal Detect Level Register.
        SDLVL3/SDLVL2/SDLVL1.
        Array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_RX_SDL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_ZCAL_CONTROL</id><!-- @deprecated -->
  <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe ZCAL Control Register.
        CMPEVALDLY.
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_ZCAL_CONTROL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_FFE_GEN1</id><!-- @deprecated -->
    <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe TX FFE (Gen1)
        Array index: Lane number (0:15)
    </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_FFE_GEN1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_FFE_GEN2</id><!-- @deprecated -->
    <description>
      creator: platform (MRW)
      consumer: p9_pcie_scominit
      notes:
        PCIe TX FFE (Gen2)
        Array index: Lane number (0:15)
    </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>16</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_FFE_GEN2</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_XBUS_DCCAL_FLAGS</id>
    <!-- <targetType>TARGET_TYPE_XBUS</targetType> -->
    <description>
        Flags to indicate if rx / tx dccal has been run.
        NONE = 0x0,
          TX = 0x1,
          RX = 0x2
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_XBUS_DCCAL_FLAGS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_X_DEBUG</id>
    <!-- <targetType>TARGET_TYPE_XBUS</targetType> -->
    <description>
        Indicate if debug data should be taken pre / post linktraining.
        FALSE = 0x0,
        TRUE = 0x1
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_X_DEBUG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_X_MFG_CHK</id>
    <!-- <targetType>TARGET_TYPE_XBUS</targetType> -->
    <description>
        Indicate if manufacturing tests should be taken pre / post linktraining.
        FALSE = 0x0,
        TRUE = 0x1
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_X_MFG_CHK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_X_MFG_MIN_EYE_WIDTH</id>
    <!-- <targetType>TARGET_TYPE_XBUS</targetType> -->
    <description>
        Minimum eye width to allow passing through manufacturing.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_X_MFG_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_XBUS_MASTER_MODE</id>
    <description>
       Flag to indicate if the target is a master.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_XBUS_MASTER_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_XBUS_TX_MARGIN_RATIO</id>
    <!-- <targetType>TARGET_TYPE_XBUS</targetType> -->
    <description>
        Value to select amount of margin to be applied.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_XBUS_TX_MARGIN_RATIO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_XBUS_TX_FFE_PRECURSOR</id>
    <!-- <targetType>TARGET_TYPE_XBUS</targetType> -->
    <description>
        Value to select amount of tx ffe precusor to apply.
    </description>
    <simpleType>
        <uint8_t>
           <default>6</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_XBUS_TX_FFE_PRECURSOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>POUNDV_BUCKET_NUM_OVERRIDE</id>
  <description>
      1 if override of poundv bucket num is available.
      0 if override is unavailable.
  </description>
  <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
  </simpleType>
<!--TODO RTC:144077  This should be volatile-zeroed but cannot test
    without a way to do attribute overrides so we have to edit the system xml
    to have one of the EQ's have override set-->
  <persistency>volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_POUNDV_BUCKET_NUM_OVERRIDE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>POUNDV_BUCKET_NUM</id>
    <description>
        Attribute in place to allow override of which POUNDV
        bucket to use to set power management data.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
<!--TODO RTC:144077  This should be volatile-zeroed but cannot test
    without a way to do attribute overrides so we have to edit the system xml
    to have one of the EQ's have override set-->
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_POUNDV_BUCKET_NUM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
    <description>
        if set to 1, FAPI_ERR records are suppressed from being produced
        by p9_dump_stop_info.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
    <description>
        if set to 1, p9_dump_stop_info output will be written to error logs.
    </description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_IS_STARTED</id>
    <description>
        If 0, SBE for the processor has not been started.
        Otherwise, SBE for the processor has been started.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_IS_STARTED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_CORE_FLOOR_RATIO</id>
    <description>
      Processor SMP core floor/nest frequency ratio
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CORE_FLOOR_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_CORE_CEILING_RATIO</id>
    <description>
      Processor SMP core celing/nest frequency ratio
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CORE_CEILING_RATIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_OPTICS_CONFIG_MODE</id>
    <description>
        Per-link optics configuration
        0 = default = SMP
        1 = CAPI 2.0
        2 = NV 2.0
    </description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_OPTICS_CONFIG_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_X_ATTACHED_LINK_ID</id>
    <description>
      For each fabric X link on this chip, specifies the link ID of the chip at the
      receiving end of the link.  Should be considered valid only if corresponding
      ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG index is true.
    </description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>7</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_ATTACHED_LINK_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_A_ATTACHED_LINK_ID</id>
    <description>
      For each fabric A link on this chip, specifies the link ID of the chip at the
      receiving end of the link.  Should be considered valid only if corresponding
      ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG index is true.
    </description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_ATTACHED_LINK_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_X_AGGREGATE</id>
    <description>
      Indicates if X links on this chip should be configured in aggregate mode.
      OFF = 0x0,
      ON = 0x1
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_AGGREGATE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_X_LINK_DELAY</id>
    <description>
      Average of local/remote end link delay counter values.
      Used to designate coherent link in aggregate configurations.
      Should be considered valid only if corresponding ATTR_PROC_FABRIC_X_ATTACHED_CHIP_CNFG
      index is true.
      OFF = 0x0,
      ON = 0x1
    </description>
    <simpleType>
      <uint32_t></uint32_t>
      <array>7</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_X_LINK_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_A_AGGREGATE</id>
    <description>
      Indicates if A links on this chip should be configured in aggregate mode.
      OFF = 0x0,
      ON = 0x1
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_AGGREGATE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_FABRIC_A_LINK_DELAY</id>
    <description>
      Average of local/remote end link delay counter values.
      Used to designate coherent link in aggregate configurations.
      Should be considered valid only if corresponding ATTR_PROC_FABRIC_A_ATTACHED_CHIP_CNFG
      index is true.
      OFF = 0x0,
      ON = 0x1
    </description>
    <simpleType>
      <uint32_t></uint32_t>
      <array>4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_A_LINK_DELAY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_GEN</id>
    <description>
      DRAM Device Type.
      Decodes SPD byte 2.
      Generation of memory: DDR3, DDR4.
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_GEN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_TYPE</id>
    <description>
      Base Module Type.
      Decodes SPD Byte 3 (bits 3~0).
      Type of DIMM: RDIMM, UDIMM, LRDIMM as specified by the JEDIC standard.
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_HYBRID_MEMORY_TYPE</id>
    <description>
      Hybrid Media.
      Decodes SPD Byte 3 (bits 6~4)
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_HYBRID_MEMORY_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_HYBRID</id>
    <description>
      Hybrid.
      Decodes SPD Byte 3 (bit 7)
      creator: mss_eff_config
      consumer: various
      firmware notes: none
      NOT_HYBRID = 0, IS_HYBRID= 1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_HYBRID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DENSITY</id>
    <description>
      DRAM Density.
      Decodes SPD Byte 4 (bits 3~0).
      Total SDRAM capacity per die.
      For multi-die stacks (DDP, QDP, or 3DS), this represents
      the capacity of each DRAM die in the stack.
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_DENSITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_BANK_BITS</id>
    <description>
      Number of DRAM bank address bits.
      Actual number of banks is 2^N, where
      N is the number of bank address bits.
      Decodes SPD Byte 4 (bits 5~4).
      creator: spd_decoder
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_BANK_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_BANK_GROUP_BITS</id>
    <description>
      Bank Groups Bits.
      Decoded SPD Byte 4 (bits 7~6).
      Actual number of bank groups is 2^N,
      where N is the number of bank address bits.
      This value represents the number of bank groups
      into which the memory array is divided.
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_BANK_GROUP_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_COLUMN_BITS</id>
    <description>
      Column Address Bits.
      Decoded SPD Byte 5 (bits 2~0).
      Actual number of DRAM columns is 2^N,
      where N is the number of column address bits
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_COLUMN_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ROW_BITS</id>
    <description>
      Row Address Bits.
      Decodes Byte 5 (bits 5~3).
      Number of DRAM column address bits.
      Actual number of DRAM rows is 2^N,
      where N is the number of row address bits
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_ROW_BITS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIM_STACK_TYPE</id>
    <description>
      Primary SDRAM Package Type.
      Decodes Byte 6.
      This byte defines the primary set of SDRAMs.
      Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
      creator: mss_eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_PRIM_STACK_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_PPR</id>
    <description>
      Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_PPR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_SOFT_PPR</id>
    <description>
      Soft Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
      NOT_SUPPORTED = 0, SUPPORTED = 1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_SOFT_PPR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRCD</id>
    <description>
      Minimum RAS to CAS Delay Time
      in nck (number of clock cyles).
      Decodes SPD byte 25 (7~0) and byte 112 (7~0).
      Each memory channel will have a value.
      creator: eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRCD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRP</id>
    <description>
      SDRAM Row Precharge Delay Time
      in nck (number of clock cycles).
      Decodes SPD byte 26 (bits 7~0) and byte 121 (bits 7~0).
      Each memory channel will have a value.
      creator: eff_config
      consumer: various
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRAS</id>
    <description>
      Minimum Active to Precharge Delay Time
      in nck (number of clock cycles).
      Decodes SPD byte 27 (bits 3~0) and byte 28 (7~0).
      Each memory channel will have a value.
      creator: mss_eff_cnfg_timing
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRAS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRC</id>
    <description>
      Minimum Active to Active/Refresh Delay
      in nck (number of clock cyles).
      Decodes SPD byte 27 (bits 7~4), byte 29 (bits 7~0), and byte 120.
      Each memory channel will have a value.
      creator: eff_confg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRFC</id>
    <description>
      DDR4 Spec defined as Refresh Cycle Time (tRFC).
      SPD Spec refers it to the Minimum Refresh Recovery Delay Time.
      In nck (number of clock cyles).
      Decodes SPD byte 31 (bits 15~8) and byte 30 (bits 7~0) for tRFC1.
      Decodes SPD byte 33 (bits 15~8) and byte 32 (bits 7~0) for tRFC2.
      Decodes SPD byte 35 (bits 15~8) and byte 34 (bits 7~0) for tRFC4.
      Selected tRFC value depends on MRW attribute that selects refresh mode.
      For 3DS, The tRFC time to the same logical rank is defined as tRFC_slr and is
      specificed as the value as for a monolithic DDR4 SDRAM of equivalent density.
      creator: eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint16_t>
      </uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRFC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TFAW</id>
    <description>
      Minimum Four Activate Window Delay Time
      in nck (number of clock cycles).
      Decodes SPD byte 36 (bits 3~0) and byte 37 (bits 7~0).
      For 3DS, tFAW time to the same logical rank is defined as
      tFAW_slr_x4 or tFAW_slr_x8 (for x4 and x8 devices only) and
      specificed as the value as for a monolithic DDR4 SDRAM
      equivalent density.
      Each memory channel will have a value.
      creator: eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TFAW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRRD_S</id>
    <description>
      Minimum Activate to Activate Delay Time, different bank group
      in nck (number of clock cycles).
      Decodes SPD byte 38 (bits 7~0).
      For 3DS, The tRRD_S time to a different bank group in the
      same logical rank is defined as tRRD_slr and is
      specificed as the value as for a monolithic
      DDR4 SDRAM of equivalent density.
      Each memory channel will have a value.
      creator: eff_confg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRRD_S</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRRD_L</id>
    <description>
      Minimum Activate to Activate Delay Time, same bank group
      in nck (number of clock cycles).
      Decodes SPD byte 39 (bits 7~0).
      For 3DS, The tRRD_L time to the same bank group in the
      same logical rank is defined as tRRD_L_slr and is
      specificed as the value as for a monolithic
      DDR4 SDRAM of equivalent density.
      Each memory channel will have a value.
      creator: eff_confg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TRRD_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TCCD_L</id>
    <description>
      Minimum CAS to CAS Delay Time, same bank group
      in nck (number of clock cycles).
      Decodes SPD byte 40 (bits 7~0) and byte 117 (bits 7~0).
      This is for DDR4 MRS6.
      Each memory channel will have a value.
      Creator: eff_config
      Consumer:various
      Firmware notes: none
      4NCK = 4, 5NCK = 5, 6NCK = 6, 7NCK = 7, 8NCK = 8
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TCCD_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TWR</id>
    <description>
      Minimum Write Recovery Time.
      Decodes SPD byte 41 (bits 3~0) and byte 42 (bits 7~0).
      Each memory channel will have a value.
      creator: mss_eff_cnfg_timing
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TWR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TWTR_S</id>
    <description>
      Minimum Write to Read Time, different bank group
      in nck (number of clock cycles).
      Decodes SPD byte 43 (3~0) and byte 44 (bits 7~0).
      Each memory channel will have a value.
      creator: eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TWTR_S</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TWTR_L</id>
    <description>
      Minimum Write to Read Time, same bank group
      in nck (number of clock cycles).
      Decodes byte 43 (7~4) and byte 45 (bits 7~0).
      Each memory channel will have a value.
      creator: eff_config
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TWTR_L</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TMAW</id>
    <description>
      Maximum Activate Window
      in nck (number of clock cycles).
      Decodes SPD byte 7 (bits 5~4).
      Depends on tREFI multiplier.
      Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none
    </description>
    <simpleType>
      <uint16_t>
      </uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DRAM_TMAW</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC00</id>
    <description>
      F0BCW00 Host Interface DQ RTT_NOM Control
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC00</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC01</id>
    <description>
      F0BCW01 Host Interface DQ RTT_WR Control
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC01</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC02</id>
    <description>
      F0BCW02 Host Interface DQ RTT_PARK Control
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC02</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC03</id>
    <description>
      F0BCW03 Host Interface DQ Driver Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC03</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC04</id>
    <description>
      F0BCW04 DRAM Interface MDQ RTT Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC04</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC05</id>
    <description>
      F0BCW05 DRAM Interface MDQ Driver Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC05</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC06</id>
    <description>
      F0BCW06 Command Space Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC06</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC07</id>
    <description>
      F0BCW07 Rank Presence Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC07</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC08</id>
    <description>
      F0BCW08 RankSelection Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC08</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC09</id>
    <description>
      F0BCW09 Power Saving Settings Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC09</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC0A</id>
    <description>
      F0BCW0A LRDIMM Operating Speed
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC0A</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC0B</id>
    <description>
      F0BCW0B Operating Voltage Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC0B</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC0C</id>
    <description>
      F0BCW0C Buffer Training Mode Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC0C</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC0D</id>
    <description>
      F0BCW0D Reserved for future use
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC0D</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC0E</id>
    <description>
      F0BCW0E Parity Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC0E</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_BC0F</id>
    <description>
      F0BCW0F Error Status Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_BC0F</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F0BC1x</id>
    <description>
      F0BCW1x Buffer Configuration Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F0BC1x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BC2x</id>
    <description>
      F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BC2x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BC3x</id>
    <description>
      F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BC3x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BC4x</id>
    <description>
      F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BC4x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BC5x</id>
    <description>
      F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BC5x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F0BC6x</id>
    <description>
      F0BCW6x Fine Granularity Frequency Operating Speed Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F0BC6x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F70BC7x</id>
    <description>
      F70BCW7x Function Space Selector Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F70BC7x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BC8x</id>
    <description>
      F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BC8x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BC9x</id>
    <description>
      F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BC9x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BCAx</id>
    <description>
      F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BCAx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F30BCBx</id>
    <description>
      F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F30BCBx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F0BCCx</id>
    <description>
      F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable Control Word for rank 0
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F0BCCx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F0BCDx</id>
    <description>
      F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling Control Word for rank 0
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F0BCDx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F0BCEx</id>
    <description>
      F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling Control Word for rank 0
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F0BCEx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F0BCFx</id>
    <description>
      F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling Control Word for rank 2
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F0BCFx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F1BCCx</id>
    <description>
      F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable Control Word for rank 1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F1BCCx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F1BCDx</id>
    <description>
      F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling Control Word for rank 1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F1BCDx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F1BCEx</id>
    <description>
      F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable Control Word for rank 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F1BCEx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F1BCFx</id>
    <description>
      F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling Control Word for rank 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F1BCFx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC0x</id>
    <description>
      F4BCW0x MRS0 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC0x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC1x</id>
    <description>
      F4BCW1x MRS1 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC1x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC2x</id>
    <description>
      F4BCW2x MRS2 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC2x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC3x</id>
    <description>
      F4BCW3x MRS3 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC3x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC4x</id>
    <description>
      F4BCW4x MRS4 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC4x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC5x</id>
    <description>
      F4BCW5x MRS5 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC5x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F4BC6x</id>
    <description>
      F4BCW6x MRS6 snooped settings
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F4BC6x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F5BC0x</id>
    <description>
      F5BCW0x Upper and Lower MPR bits[7:0] for U0
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F5BC0x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F5BC1x</id>
    <description>
      F5BCW1x Upper and Lower MPR bits[15:8] for U1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F5BC1x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F5BC2x</id>
    <description>
      F5BCW2x Upper and Lower MPR bits[23:16] for U2
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F5BC2x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F5BC3x</id>
    <description>
      F5BCW3x Upper and Lower MPR bits[31:24] for U3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F5BC3x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F5BC5x</id>
    <description>
      F5BCW5x Host Interface Vref Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F5BC5x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F5BC6x</id>
    <description>
      F5BCW6x DRAM Interface Vref Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F5BC6x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F6BC0x</id>
    <description>
      F6BCW0x Upper and Lower MPR bits[39:32] for U4
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F6BC0x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F6BC1x</id>
    <description>
      F6BCW1x Upper and Lower MPR bits[47:40] for U5
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F6BC1x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F6BC2x</id>
    <description>
      F6BCW2x Upper and Lower MPR bits[55:48] for U6
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F6BC2x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F6BC3x</id>
    <description>
      F6BCW3x Upper and Lower MPR bits[63:56] for U7
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F6BC3x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F6BC4x</id>
    <description>
      F6BCW4x Buffer Training Configuration Control Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F6BC4x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F6BC5x</id>
    <description>
      F6BCW5x Buffer Training Status Word
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F6BC5x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BC8x</id>
    <description>
      F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BC8x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BC9x</id>
    <description>
      F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BC9x</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BCAx</id>
    <description>
      >F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BCAx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BCBx</id>
    <description>
      F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BCBx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BCCx</id>
    <description>
      F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BCCx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BCDx</id>
    <description>
      F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BCDx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BCEx</id>
    <description>
      F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BCEx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_DDR4_F74BCFx</id>
    <description>
      F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to 3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_EFF_DIMM_DDR4_F74BCFx</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
    <description>
      Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port
      Set to below optimum value/ rate.
      On a per port (MCA) basis
      Consumer: thermal_init
    </description>
    <simpleType>
      <uint16_t>
      </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
    <description>
      Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_slot
    </description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_SLOT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_MEM_M_DRAM_CLOCKS</id>
    <description>
      Machine Readable Workbook for the number of M DRAM clocks.
      One approach to curbing DRAM power usage is by throttling
      traffic through a programmable N commands over M window.
    </description>
    <simpleType>
      <uint32_t>
      <default>0x00000200</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_AVDD_OFFSET_DISABLE</id>
    <description>
      Used for to determine whether to apply an offset to AVDD. Supplied by MRW.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_AVDD_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_VDD_OFFSET_DISABLE</id>
    <description>
      Used for to determine whether to apply an offset to VDD. Supplied by MRW
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDD_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_VCS_OFFSET_DISABLE</id>
    <description>
      Used for to determine whether to apply an offset to VCS. Supplied by MRW.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VCS_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_VPP_OFFSET_DISABLE</id>
    <description>
      Used for to determine whether to apply an offset to VPP. Supplied by MRW.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VPP_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_VDDR_OFFSET_DISABLE</id>
    <description>
      Used for to determine whether to apply an offset to VDDR. Supplied by MRW.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_VDDR_OFFSET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_FINE_REFRESH_MODE</id>
    <description>
      Fine refresh mode.
      Should be defaulted to normal mode.
      This is for DDR4 MRS3.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_FINE_REFRESH_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_TEMP_REF_RANGE</id>
    <description>
      Temp ref range.
      Should be defaulted to extended range.
      This is for DDR4 MRS4.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_TEMP_REF_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_MRW_TEMP_REFRESH_RANGE</id>
    <description>
      Temp ref range.
      Should be defaulted to extended range.
      This is for DDR4 MRS4.
      Should be defaulted to extended range.
      NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C
      Used for calculating periodic refresh intervals
      JEDEC DDR4 spec 1716.78C from 07-2016
      page 46 4.8.1
    </description>
    <simpleType>
      <uint8_t>
      <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_TEMP_REFRESH_RANGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--Deprecated-->
<attribute>
    <id>MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
    <description>
      For resetting the phy delay values at the beginning of
      calling mss_draminit_training. YES means the values will be reset.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!--Deprecated-->

<attribute>
    <id>MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <description>
      Describes the settings for periodic calibration for all ports:
      Reading left to right
    </description>
    <simpleType>
      <uint16_t>
      </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
    <description>
      Describes the settings for periodic ZQ calibration for all ports:
      Reading left to right. For each bit: OFF = 0, ON = 1.
      Setting to 0 indicates to disable periodic zqcal.
      Byte 0:
      0: ZQCAL
      All others reserved for future use
    </description>
    <simpleType>
      <uint16_t>
      </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_0_VERSION_LAYOUT</id>
    <description>MR Keyword Layout Version Number.  Increases when attributes are added, removed, or redefined.  Does not reset.</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_0_VERSION_LAYOUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_1_VERSION_DATA</id>
    <description>MR Keyword Data Version Number.  Increases when data changes with the above layout version.  Resets when layout version number increments.</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_1_VERSION_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_2_SIGNATURE_HASH</id>
    <description>Hash Signature for the MR Keyword. The hash signature is 32bits for 256 bytes of data.</description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_2_SIGNATURE_HASH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_DRAM_2N_MODE</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A00</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A01</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A02</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A03</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A04</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A05</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A06</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A07</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A08</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A09</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A10</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A11</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A12</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A13</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_A17</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BA1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_BG1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_ADDR_C2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CLK_D0_P0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CLK_D0_P0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CLK_D0_P1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CLK_D0_P1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CLK_D1_P0</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CLK_D1_P0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CLK_D1_P1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CLK_D1_P1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ACTN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CMD_PAR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>VPD_MR_0_VERSION_LAYOUT</id>
    <description>MR Keyword Layout Version Number.  Increases when attributes are added, removed, or redefined.  Does not reset.</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_0_VERSION_LAYOUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>VPD_MR_1_VERSION_DATA</id>
    <description>MR Keyword Data Version Number.  Increases when data changes with the above layout version.  Resets when layout version number increments.</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_1_VERSION_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_2_SIGNATURE_FREQ_DROP</id>
    <description>MR Keyword type, nibble 0 = freq bin (0 = 1600, 1 = 1866, 2 = 2133, 3 = 2400, 4 = 2667, 5 = 2933, 6 = 3200), nibble 1 = num dimms per port (1 = single drop, 2 = dual drop)</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_2_SIGNATURE_FREQ_DROP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_2_SIGNATURE_HASH</id>
    <description>Hash Signature for the MR Keyword. The hash signature is 32bits for 256 bytes of data.</description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_2_SIGNATURE_HASH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>VPD_MR_DRAM_2N_MODE</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A00</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A01</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A02</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A03</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A04</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A05</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A06</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A07</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A08</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A09</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A10</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A11</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A12</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A13</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_A17</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_BA0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_BA1</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_BG0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_BG1</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_C0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_C1</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_ADDR_C2</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CLK_D0_P0</id>
    <description>Place holder description</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CLK_D0_P1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CLK_D1_P0</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CLK_D1_P1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CMD_ACTN</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CMD_PAR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CKE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CKE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CKE0</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CKE1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CKE2</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CKE3</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CSN0</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CSN1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CSN2</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_CSN3</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0</id>
<description>Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1</id>
    <description>Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_CSN1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0</id>
    <description>Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1</id>
    <description>Phase rotator delay value of Chip Select for Dimm#_CSN# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_CSN1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_ODT0</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_ODT1</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_ODT2</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_CNTL_ODT3</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0</id>
    <description>Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1</id>
    <description>Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D0_ODT1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0</id>
    <description>Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1</id>
    <description>Phase rotator delay value of On Die Termination for Dimm#_ODT# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_CNTL_D1_ODT1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_2N_MODE_AUTOSET</id>
    <description>Default value for 2N Mode from Signal Integrity.</description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_2N_MODE_AUTOSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint16_t></uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint16_t></uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_TSYS_ADR</id>
    <description>
    ADR WRClk Phase Rotator Offset Value in ticks. Ticks are 1/128 of one cycle of clock.
    Phase Rotator Static Offset value used to determine the Phase of the WrClk with respect to SysClk.
    For zero delay simulations, or simulations where the delay of the SysClk tree and the WrClk tree are equal,
    Set this field to 60h
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_TSYS_ADR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_TSYS_DATA</id>
    <description>
    DP16 WrClk Phase Rotator Offset Value in ticks. Ticks are 1/128 of one cycle of clock.
    Phase Rotator Static Offset value used to determine the Phase of the WrClk with respect to SysClk.
    For zero delay simulations, or simulations where the delay of the SysClk tree and the WrClk tree are equal,
    Set this field to 60h
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_TSYS_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_D0_CLK0</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_D0_CLK0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_D0_CLKN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_D0_CLK1</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_D0_CLK1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_D1_CLK0</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_D1_CLK0</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_MC_PHASE_ROT_D1_CLKN</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MR_MC_PHASE_ROT_D1_CLK1</id>
    <description>Phase rotator delay value of Clock for Dimm#_CLK# in ticks. Ticks are 1/128 of one cycle of clock.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MR_MC_PHASE_ROT_D1_CLK1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_0_VERSION_LAYOUT</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_0_VERSION_LAYOUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_1_VERSION_DATA</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_1_VERSION_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_2_SIGNATURE_HASH</id>
    <description>Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of data.</description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_2_SIGNATURE_HASH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_CKE_PRI_MAP</id>
    <description>Place holder description</description>
    <simpleType>
      <uint16_t></uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_CKE_PRI_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_CKE_PWR_MAP</id>
    <description>Place holder description</description>
    <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_CKE_PWR_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DIMM_RCD_IBT_CA</id>
    <description>Register Clock Driver, Input Bus Termination for Command/Address in tens of Ohms</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DIMM_RCD_IBT_CKE</id>
    <description>Register Clock Driver, Input Bus Termination for Clock Enable in tens of Ohms.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DIMM_RCD_IBT_CS</id>
    <description>Register Clock Driver, Input Bus Termination for Chip Select in tens of Ohms.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DIMM_RCD_IBT_CS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DIMM_RCD_IBT_ODT</id>
    <description>Register Clock Driver, Input Bus Termination for Clock Enable in tens of Ohms.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DIMM_RCD_IBT_ODT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DIMM_RCD_OUTPUT_TIMING</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DIMM_RCD_OUTPUT_TIMING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DRAM_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DRAM_RTT_NOM</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DRAM_RTT_NOM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


 <attribute>
    <id>MSS_VPD_MT_DRAM_RTT_PARK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DRAM_RTT_PARK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_DRAM_RTT_WR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_DRAM_RTT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_DRV_IMP_CLK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DRV_IMP_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DRV_IMP_CMD_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_DRV_IMP_CNTL</id>
    <description>Memory Controller side Drive Impedance for Clock Enable,
    ODT, Parity, and Reset Lines in Ohms.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DRV_IMP_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_DRV_IMP_CSCID</id>
    <description>
    Memory Controller side Drive Impedance for Chip Select and Chip ID Lines in Ohms.
    </description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DRV_IMP_CSCID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_DRV_IMP_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_RCV_IMP_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2, 5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_RCV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_PREAMBLE</id>
    <description>Number of clocks used for preamble.
    Calibration only uses 1 nCK preamble (DEFAULT).
    Mainline has both 1 nCK and 2 nCK preamble option.</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_PREAMBLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_SLEW_RATE_ADDR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_SLEW_RATE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_SLEW_RATE_CLK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_SLEW_RATE_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_SLEW_RATE_CNTL</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_SLEW_RATE_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_SLEW_RATE_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_SLEW_RATE_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_MC_SLEW_RATE_SPCKE</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_SLEW_RATE_SPCKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_ODT_RD</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_ODT_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_ODT_WR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_ODT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_OFFSET_GPO</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_OFFSET_GPO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_OFFSET_RLO</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_OFFSET_RLO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_OFFSET_WLO</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_OFFSET_WLO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_VREF_DRAM_WR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_VREF_DRAM_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_VREF_MC_RD</id>
    <description>Place holder description</description>
    <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_VREF_MC_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VPD_MT_WINDAGE_RD_CTR</id>
    <description>Place holder description</description>
    <simpleType>
      <int16_t></int16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_WINDAGE_RD_CTR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_0_VERSION_LAYOUT</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_0_VERSION_LAYOUT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_1_VERSION_DATA</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_1_VERSION_DATA</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_2_SIGNATURE_HASH</id>
    <description>Hash Signature for the MT Keyword. The hash signature is 32bits for 256 bytes of data.</description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_2_SIGNATURE_HASH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>



<attribute>
    <id>VPD_MT_2_SIGNATURE_DIMM0RANK_DIMM1RANK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_2_SIGNATURE_DIMM0RANK_DIMM1RANK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_CKE_PRI_MAP</id>
    <description>Place holder description</description>
    <simpleType>
      <uint16_t></uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_CKE_PRI_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_CKE_PWR_MAP</id>
    <description>Place holder description</description>
    <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_CKE_PWR_MAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_DIMM_RCD_IBT</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_DIMM_RCD_IBT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_DIMM_RCD_OUTPUT_TIMING</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_DRAM_DRV_IMP_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_DRAM_RTT_NOM</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_DRAM_RTT_NOM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


 <attribute>
    <id>VPD_MT_DRAM_RTT_PARK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_DRAM_RTT_PARK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_DRAM_RTT_WR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_DRAM_RTT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_DRV_IMP_ADDR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_DRV_IMP_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_DRV_IMP_CLK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_DRV_IMP_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_DRV_IMP_CNTL</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_DRV_IMP_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_DRV_IMP_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_DRV_IMP_SPCKE</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_DRV_IMP_SPCKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_RCV_IMP_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_SLEW_RATE_ADDR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_SLEW_RATE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_SLEW_RATE_CLK</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_SLEW_RATE_CLK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_SLEW_RATE_CNTL</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_SLEW_RATE_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_SLEW_RATE_DQ_DQS</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_MC_SLEW_RATE_SPCKE</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_MC_SLEW_RATE_SPCKE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_ODT_RD</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_ODT_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_ODT_WR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_ODT_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_OFFSET_GPO</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_OFFSET_GPO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_OFFSET_RLO</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_OFFSET_RLO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_OFFSET_WLO</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_OFFSET_WLO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_VREF_DRAM_WR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_VREF_DRAM_WR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_VREF_MC_RD</id>
    <description>Place holder description</description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_VREF_MC_RD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VPD_MT_WINDAGE_RD_CTR</id>
    <description>Place holder description</description>
    <simpleType>
      <uint16_t></uint16_t>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_VPD_MT_WINDAGE_RD_CTR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_DRAMINIT_RESET_DISABLE</id>
    <description>A disable switch for resetting the phy delay values at the beginning of calling mss_draminit_training.</description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MRW_DRAMINIT_RESET_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SECURITY_ENABLE</id>
    <description>Holds the state of Security Access Bit (SAB)</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SECURITY_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_PREFETCH_ENABLE</id>
    <description>0 = OFF 1 = ON Value of on or off.  Determines if prefetching enabled or not. See chapter 7 of the Centaur Workbook.</description>
    <simpleType>
      <uint8_t>
      <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_PREFETCH_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_CLEANER_ENABLE</id>
    <description>
      Value of on or off.
      Determines if the cleaner of the L4 cache (write modified entries to memory on idle cycles)
      enabled or not. See chapter 7 of the Centaur Workbook.
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_CLEANER_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SECURITY_MODE</id>
    <description>
        If SBE image has ATTR_SECURITY_MODE == 0b1, then leave SAB bit as is,
        else ATTR_SECURITY_MODE == 0b0, then clear SAB bit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SECURITY_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PFET_OFF_CONTROLS</id>
    <description>
        To disable force pfet off control from fuse status
        Override attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PFET_OFF_CONTROLS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
   <id>PIBMEM_REPAIR0</id>
    <description>
        Pibmem repair attribute 0
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIBMEM_REPAIR0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
    <id>PIBMEM_REPAIR1</id>
    <description>
        Pibmem repair attribute 1
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIBMEM_REPAIR1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--SBE ONLY-->
<attribute>
    <id>PIBMEM_REPAIR2</id>
    <description>
        Pibmem repair attribute 2
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIBMEM_REPAIR2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SENSEADJ_STEP</id>
    <description>
        IPL for skew adjust and duty cycle adjust
    </description>
    <simpleType>
      <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SENSEADJ_STEP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <description>
        Do we support dynamically updating memory voltages?
        0 = no, 1 = yes
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PROC_NHTM_BAR_BASE_ADDR</id>
    <description> The base address where the NHTM traces start.  They are
                  calculated based on the NHTM trace size requested by user.
                  This address in memory will be the location where NHTM0/1
                  traces are output.
                  Set by p9_mss_eff_grouping.
                  Used by p9_setup_bars and p9_htm_setup.
    </description>
    <simpleType><uint64_t></uint64_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_NHTM_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_NHTM_BAR_SIZE</id>
  <description> The amount of memory a user can reserve to store NHTM traces.
                This amount will be used to store both NHTM0 and NHTM1 traces.
                Used by p9_mss_eff_grouping.
  </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_NHTM_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_CHTM_BAR_BASE_ADDR</id>
    <description> The base addresses where the CHTM traces start.  They are
                  calculated based on the CHTM trace sizes requested by users.
                  There are 24 different CHTM regions, thus 24 different sizes.
                  Each region is to store HTM trace for a core.
                  Set by p9_mss_eff_grouping.
                  Used by p9_setup_bars.
    </description>
    <simpleType>
      <uint64_t></uint64_t>
      <array>24</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_CHTM_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_CHTM_BAR_SIZES</id>
    <description> The amount of memory a user can reserve to store CHTM traces.
                  There are 24 cores, thus 24 different sizes.
                  Used by p9_mss_eff_grouping.
    </description>
    <simpleType>
      <uint64_t>
      </uint64_t>
      <array>24</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_CHTM_BAR_SIZES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_TRACE_TYPE</id>
    <description> The Nest HTM trace type desired to be collected.  This setting
                  is applied to both NHTM0 and NHTM1.
                  DISABLE = 0x0, FABRIC = 0x1, EVENT = 0x2, OCC = 0x3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_TRACE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHTM_TRACE_TYPE</id>
    <description> The Core HTM trace type desired to be collected.
                  DISABLE = 0x0, CORE = 0x1, LLAT = 0x2, PPE = 0x3, DMW = 0x4
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
      <array>24</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHTM_TRACE_TYPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_TTYPEFILT_PAT</id>
    <description> Nest HTM: defines the TTYPE pattern to match in Fabric trace
                  mode.  These bits are used with the ttype Filter Mask to
                  indicate the TTYPE value that should be matched on the rcmd.
                  HTM Ttype Filter Control Register (1:7).
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_TTYPEFILT_PAT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_TSIZEFILT_PAT</id>
    <description> Nest HTM: defines the TSIZE pattern to match in Fabric trace
                  mode. These bits are used with the tsize filter mask to indicate
                  the TSIZE value that should be matched on the rcmd
                  HTM Ttype Filter Control Register (8:15).
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_TSIZEFILT_PAT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_TTYPEFILT_MASK</id>
    <description> Nest HTM: TTYPE pattern mask.
                  If mask bit is clear to 0, then do not need to match w/ the pattern.
                  If all mask bits are clear, no TTYPE pattern/masking is done.
                  The inversion of this attribute value will be programmed into
                  bits 17:23 of HTM Ttype Filter Control Register.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_TTYPEFILT_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_TSIZEFILT_MASK</id>
    <description> Nest HTM: TSIZE pattern mask.
                  If mask bit is clear to 0, then do not need to match w/ the pattern.
                  If all mask bits are clear, no TSIZE pattern/masking is done.
                  The inversion of this attribute value will be programmed into
                  bits 24:31 of HTM Ttype Filter Control Register.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_TSIZEFILT_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_TTYPEFILT_INVERT</id>
    <description> Nest HTM: TTYPE/TSIZE Capture Invert.
                  HTM Ttype Filter Control Register (32).
                  This bit controls the inversion of the ttype/tsize filter.
                  0 : Capture record based on ttype/tsize pattern matching
                  1 : Capture record based on ttype/tsize pattern NOT matching
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_TTYPEFILT_INVERT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CRESPFILT_INVERT</id>
    <description> Nest HTM: CRESP Filter Capture Invert.
                  HTM Ttype Filter Control Register (33).
                  This bit controls the inversion of the cresp filter.
                  0: Capture record based on cresp filter pattern/mask match
                  1: Capture record based on cresp filter pattern/mask NOT matching.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CRESPFILT_INVERT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_FILT_PAT</id>
    <description> Nest HTM: Filter Pattern.
                  HTM Filter Control Register (0:22).
                  In Fabric trace mode, defines the TTAG/Scope/Source pattern to
                  match in the RCMD and CRESP:
                      0:3   rcmd_ttag(0:2) Group ID Pattern for rcmd and cresp
                            filtering.
                      4:6   rcmd_ttag(3:5) Chip ID Pattern for rcmd and cresp
                            filtering.
                      7:16  rcmd_ttag(6:13) Unit ID Pattern for rcmd and cresp
                            (if from this chip) filtering.
                      17:19 rcmd_scope(0:2) Scope Pattern for rcmd and cresp
                            filtering.
                      20:21 rcmd_source(0:1) Source Pattern for rcmd filtering.
                      22    Powerbus PORT pattern for rcmd and cresp filtering.
                   In OCC trace mode, defines the occ_trace_data(0:22) pattern
                   to match:
                      0:22  occ_trace_data(0:22) pattern.
    </description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_FILT_PAT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_FILT_CRESP_PAT</id>
    <description> Nest HTM: defines the CRESP Filter pattern in FABRIC trace mode.
                  HTM Filter Control Register (27:31).
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_FILT_CRESP_PAT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_FILT_MASK</id>
    <description> Nest HTM FABRIC: Pattern mask.
                  HTM Filter Control Register (32:54).
                  Bits clear to 0 in this mask do not need to match with the
                  Filter Pattern.
                  If all bits are clear, no pattern/masking is done and all
                  Cresp/rcmd are captured in Fabric trace mode and all
                  OCC commands are captured in OCC mode.
                  The inversion of this attribute value will be programmed into
                  bits 32:54 of HTM Ttype Filter Control Register.
                  In Fabric Trace Mode:
                   32:35: rcmd_ttag(0:3) Group ID Mask
                   36:38: rcmd_ttag(4:6) Chip ID Mask
                   39:48: rcmd_ttag(7:16) Unit ID Pattern
                   49:51: rcmd_scope(0:2) Mask
                   52:53: rcmd_source(0:1) Mask
                   54in the : PowerBus PORT MASK (for rcmd and cresp filtering0
                   In OCC Trace Mode
                   32:54 occ_trace_data(0:22) Mask
    </description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_FILT_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_FILT_CRESP_MASK</id>
    <description> Nest HTM FABRIC: CRESP Filter Mask.
                  HTM Filter Control Register (59:63).
                  If mask bit is clear to 0, then do not need to match w/ the CRESP
                  Filter pattern.
                  If all mask bits are clear, no pattern matching is done.
                  The inversion of this attribute value will be programmed into
                  bits 59:63 of HTM Ttype Filter Control Register.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_FILT_CRESP_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_CONTENT_SEL</id>
    <description> Nest HTM: defines the NHTM trace mode.
                  HTM Collection Mode Register (1:2).
                  Only FABRIC is supported at this time.
                  FABRIC = 0x0, EVENT = 0x1, OCC = 0x2
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_CONTENT_SEL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_CAPTURE_GENERATED_WRITES</id>
    <description> Nest HTM: defines if the generated data writes are captured.
                  HTM Collection Mode Register (4).
                  0 - Ignore HTM generated data writes
                  1 - Capture even HTM generated writes if they meet the filtering
                      criteria.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_CAPTURE_GENERATED_WRITES</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_CAPTURE_ENABLE_FILTER_ALL</id>
    <description> Nest HTM: defines if the filtering will apply to ttype=PMISC
                  and ttype=Report Hang commands when filtering is enabled.
                  HTM Collection Mode Register (5).
                  0 - filtering ignored on PMISC
                  1 - Apply filtering to PMISC also
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_CAPTURE_ENABLE_FILTER_ALL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_CAPTURE_PRECISE_CRESP_MODE</id>
    <description> Nest HTM: defines if Precise cresp mode is disabled.
                  0 - Disable precisce cresp mode
                  1 - Enable precisce cresp mode
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_CAPTURE_PRECISE_CRESP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_CAPTURE_LIMIT_MEM_ALLOCATION</id>
    <description> Nest HTM: defines Limit Memory Allocation mode.
                   0 - Pre-allocate maximum memory buffers (NHTM=8)
                   1 - Pre-allocate only one half maximum memory buffers
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_CAPTURE_LIMIT_MEM_ALLOCATION</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_CAPTURE_PMISC_ONLY_CMD</id>
    <description> Nest HTM: defines PMISC only Command trace mode.
                   0 rCmd amd cResp port 0 only goes to NHTM0
                   1 rCmd and Cresp port 0 is stored alternately to NHTM0 and
                     NHTM1, switching based for each valid
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_CAPTURE_PMISC_ONLY_CMD</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_SYNC_STAMP_FORCE</id>
    <description> Control the number of cycles to wait to force a synchronization
                  stamp or reset the timer.  For NHTM only.
                  HTM Collection Mode Register (19:21).
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_SYNC_STAMP_FORCE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_HTMSC_MODE_WRITETOIO</id>
    <description> Use space option. For NHTM only.
                  HTM Collection Mode Register (22).
                  0 = Use HTM_CL_Write op to target system memory.
                      Do pre-allocation sequence. (default)
                  1 = Use ci_pr_st op to target anywhere else.
                      Dont do pre-allocate sequence.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_HTMSC_MODE_WRITETOIO</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHTM_HTMSC_MODE_CONTENT_SEL</id>
    <description> Core HTM: defines the CHTM trace mode.
                  HTM Collection Mode Register (1:2).
                  Only Direct Memory Write mode (IMA) is supported at this time.
                  CI = 0x0, LLAT = 0x1, PPE = 0x2, DMW = 0x3
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHTM_HTMSC_MODE_CONTENT_SEL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHTM_HTMSC_MODE_CAPTURE</id>
    <description> Core HTM: defines capture mode according to trace mode.
                  HTM Collection Mode Register (4:9).
                  When htm_mode_q(1 TO 2) == 00, i.e. Core Instruction Trace
                    00xxxx : tc_pc_trace_active asserted when HTM_STAT[Tracing]=1 to purge the ERAT when entering and exitting trace
                    01xxxx : tc_pc_trace_active asserted when HTM_MODE[HTM_Trace_enable]=1 to purge the ERAT only at the beginning
                  When htm_mode_q(1 TO 2) == 01, i.e. LLAT Trace
                    0xxxxx : capture on assertion of l2_htm_llat_disp_req, i.e. any dispatch request
                    1xxxxx : capture on assertion of l2_htm_llat_disp_req AND l2_llat_htm_rcdisp_occurred, i.e. only on passed dispatch
                    x0xxxx : capture on assertion of l2_htm_llat_disp_req, i.e. loads or stores
                    x1xxxx : capture on assertion of l2_htm_llat_disp_req AND l2_llat_htm_rcdisp_ld_not_st, i.e. only loads
                    xx0xxx : capture on assertion of l2_llat_htm_pbl3hit_dval
                    xx1xxx : no capture on assertion of l2_llat_htm_pbl3hit_dval - enable embedded timestamp
                  When htm_mode_q(1 TO 2) == 11, i.e. Direct Memory Write
                    1xxxxx : Enable HPMC-IMA Mode
    </description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHTM_HTMSC_MODE_CAPTURE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHTM_HTMSC_MODE_CORE_INSTR_STALL</id>
    <description> For CHTM only.
                   0: Core execution is stalled whenever the data buffers are almost full to prevent losing records.
                   1: Core execution is never stalled and entries may be discarded when buffer is full
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHTM_HTMSC_MODE_CORE_INSTR_STALL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MODE_WRAP</id>
    <description> Trace Wrap mode, used for both NHTM and CHTM
                  HTM Collection Mode Register (13).
                  0 = Wrap trace to beginning of Trace Memory
                  1 = Stop trace when top of Trace Memory is reached
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MODE_WRAP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MODE_DIS_TSTAMP</id>
    <description> TimeStamp Writes option, used for both NHTM and CHTM
                  HTM Collection Mode Register (14).
                  0 = Write of timestamps enabled to indicate elapsed time
                      between records.
                  1 = Timestamps written only to indicate record loss
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MODE_DIS_TSTAMP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MODE_SINGLE_TSTAMP</id>
    <description> Overflow Timestamps option, used for both NHTM and CHTM.
                  HTM Collection Mode Register (15).
                  0 = Timestamp written to indicate elapsed time overflow.
                  1 = Only one timestamp is written between entries, overflow
                      indication is lost
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MODE_SINGLE_TSTAMP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MODE_MARKERS_ONLY</id>
    <description> Nest HTM: Stamp/Marker only mode.
                  HTM Collection Mode Register (17).
                  0 = Normal trace
                  1 = Ignore incoming trace data and save only markers caused
                      by HTM_TRIG writes,
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MODE_MARKERS_ONLY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MODE_DIS_FORCE_GROUP_SCOPE</id>
    <description> Nest HTM: Group scope option.
                  HTM Collection Mode Register (18).
                  This is a powerbus debug bit
                  0 = htm write ops sent with group scope
                  1 = htm write ops sent with Vg scope using programmed
                      target bits.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MODE_DIS_FORCE_GROUP_SCOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MODE_VGTARGET</id>
    <description> Nest HTM: VG target mode.
                  HTM Collection Mode Register (24:39).
                  Vg Target bits should be configured if HTM_MEM[scope] is Vg
                  or if Disable Group Scope=1
    </description>
    <simpleType>
      <uint32_t>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MODE_VGTARGET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MEM_SCOPE</id>
    <description> Setting of memory scope for HTM collection.
                  HTM Memory Configuration Register (1:3)
                  LOCAL = 0x0, NEARNODE = 0x1, GROUP = 0x3, REMOTE = 0x4, VECTORED = 0x5
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MEM_SCOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_MEM_PRIORITY</id>
    <description> Setting of memory priority for HTM collection.
                  HTM Memory Configuration Register (4)
                  LOW = 0x0, HIGH = 0x1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_MEM_PRIORITY</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_CTRL_TRIG</id>
    <description> Setting of Trigger control for NHTM.
                  HTM Trigger Control Register (0:1)
                    00 local triggers are not forwarded to the PowerBus, it is
                       inserted into the trace when tracing.  Both local and
                       global triggers control the HTM
                    01 local triggers are not forwarded to the PowerBus, it is
                       inserted into the traCe when tracing.  Only local triggers
                       control the HTM
                    1x local triggers are forwarded to the PowerBus, it is not
                       inserted into the trace when tracing.  Only global
                       triggers control the HTM
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_CTRL_TRIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NHTM_CTRL_MARK</id>
    <description> Setting of Mark control for NHTM.
                  HTM Trigger Control Register (4:5)
                  00 local markers are not forwarded to the PowerBus.  Both
                     local and global markers are inserted into the trace
                  01 local markers are not forwarded to the PowerBus.  Only
                     local markers are inserted into the trace
                  10 local markers are forwarded to the PowerBus.  Only global
                     markers are inserted into the trace
                  11 local markers are forwarded to the PowerBus.  Markers
                     are not inserted into the trace (Fabric Trace Mode)
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_NHTM_CTRL_MARK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHTM_CTRL_TRIG</id>
    <description> Setting of Trigger control.
                  HTM Trigger Control Register (0:1)
                    00 local triggers are not forwarded to the PowerBus, it is
                       inserted into the trace when tracing.  Both local and
                       global triggers control the HTM
                    01 local triggers are not forwarded to the PowerBus, it is
                       inserted into the traCe when tracing.  Only local triggers
                       control the HTM
                    1x local triggers are forwarded to the PowerBus, it is not
                       inserted into the trace when tracing.  Only global
                       triggers control the HTM
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHTM_CTRL_TRIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHTM_CTRL_MARK</id>
    <description> Setting of Mark control.
                  HTM Trigger Control Register (4:5)
                  00 local markers are not forwarded to the PowerBus.  Both
                     local and global markers are inserted into the trace
                  01 local markers are not forwarded to the PowerBus.  Only
                     local markers are inserted into the trace
                  10 local markers are forwarded to the PowerBus.  Only global
                     markers are inserted into the trace
                  11 local markers are forwarded to the PowerBus.  Markers
                     are not inserted into the trace (Fabric Trace Mode)
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CHTM_CTRL_MARK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_DBG0_STOP</id>
    <description> Enable Stop on PB Chiplet Debug Trigger 0.
                  HTM Trigger Control Register (6)
                  DISABLE = 0x0, ENABLE = 0x1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_DBG0_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_DBG1_STOP</id>
    <description> Enable Stop on PB Chiplet Debug Trigger 1.
                  HTM Trigger Control Register (7)
                  DISABLE = 0x0, ENABLE = 0x1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_DBG1_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_RUN_STOP</id>
    <description> Enable trace stop on falling edge of PB chiplet trace run.
                  HTM Trigger Control Register (8)
                  DISABLE = 0x0, ENABLE = 0x1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_RUN_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_OTHER_DBG0_STOP</id>
    <description> Enable Stop using OCC Control.
                  HTM Trigger Control Register (9)
                  DISABLE = 0x0, ENABLE = 0x1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_OTHER_DBG0_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_XSTOP_STOP</id>
    <description> Enable Stop on chiplet XSTOP.
                  HTM Trigger Control Register (13)
                  ENABLE = 0x0, DISABLE = 0x1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_XSTOP_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_CHIP0_STOP</id>
    <description> Stop on PC_TC_DBG_Trigger0
                  1 = stop trigger Core Debug Trigger 0
                  0 = ignore Core Debug Trigger  0
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_CHIP0_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_CTRL_CHIP1_STOP</id>
    <description> Stop on PC_TC_DBG_Trigger1
                  1 = stop trigger Core Debug Trigger 1
                  0 = ignore Core Debug Trigger  1
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_CTRL_CHIP1_STOP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_IMA_PDBAR_SPLIT_CORE_MODE</id>
    <description> This bit controls the indexing of the PDBAR address for the
                  starting address of the write to the PDBAR space.
                  For CHTM only.
                  0 'Big Core' mode.
                  1 'Split Core' mode.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_IMA_PDBAR_SPLIT_CORE_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_IMA_PDBAR_SCOPE</id>
    <description>  This register defines the starting Scope of the PowerBus
                   operation. The Scope will be increased if necessary however
                   it is more efficient to have the request issued according to
                   where the target memory is located.
                       000 LOCAL scope
                       001 Reserved
                       010 NEAR NODE scope (Nn)
                       011 GROUP scope (G).
                       100 REMOTE scope (Rn).
                       101 VECTORED group scope (Vg).
                       110 Reserved
                       111 Reserved
                   Note 1: Since P9 uses a Group Class MCD, the HTM will always
                   force a 'Nodal' scope to 'Group' scope.  If the scope is
                   initialized to 'Vectored Group Scope', the HTM_MODE[Vg_Target]
                   bits must also be initialized.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_IMA_PDBAR_SCOPE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HTMSC_IMA_PDBAR_ADDR</id>
    <description>  IMA Write Physical Base Address
    </description>
    <simpleType>
      <uint64_t>
      </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_HTMSC_IMA_PDBAR_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP</id>
  <description>
    Selects the number of enabled pullup branches during READ mode.
    ONLY set range 0-7. Eg. 0x02 = b00000010 (1 branch selected),
    0x06 = b00000110 (2 branches selected)
  </description>
  <simpleType>
    <uint32_t></uint32_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_RD_UP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN</id>
  <description>
  Selects the number of enabled pulldown branches during WRITE mode.
  ONLY set range 0-7. Eg. 0x02 = b00000010 (1 branch selected),
  0x06 = b00000110 (2 branches selected)
  </description>
  <simpleType>
    <uint32_t></uint32_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_DOWN</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP</id>
  <description>
    Selects the number of enabled pullup branches during WRITE mode.
    ONLY set range 0-7. Eg. 0x02 = b00000010 (1 branch selected),
    0x06 = b00000110 (2 branches selected)
  </description>
  <simpleType>
    <uint32_t></uint32_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DQ_ACBOOST_WR_UP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MT_MC_DQ_CTLE_CAP</id>
  <description>
    Sets the capacitance value in the RC source degeneration for
    [PORT#][DP16 BLOCK#]. ONLY set range 0-3. (0x00 = No capacitor selected,
    0x01 = more caps selected, 0x02 = even more caps selected,
    0x03 = maximum capacitors selected)
  </description>
  <simpleType>
    <uint64_t></uint64_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DQ_CTLE_CAP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MT_MC_DQ_CTLE_RES</id>
  <description>
    Sets the resistance value in the RC source degeneration for
    [PORT#][DP16 BLOCK#]. Also defines the CTLE's DC Gain.
    ONLY set range 0-7. (0x00 = max resistance, 0x01 to 0x06 = decreasing resistance,
    0x07 = min resistance)
  </description>
  <simpleType>
    <uint64_t></uint64_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <writeable/>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MT_MC_DQ_CTLE_RES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>CP_FILTER_BYPASS</id>
  <description>
    To skip the locking sequence and check for lock of CP PLL
    Override attribute
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_CP_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>SS_FILTER_BYPASS</id>
  <description>
    To skip the locking sequence and check for lock of SS PLL
    Override attribute
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_SS_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>IO_FILTER_BYPASS</id>
  <description>
    To skip the locking sequence and check for lock of IO PLL
    Override attribute
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_IO_FILTER_BYPASS</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DPLL_BYPASS</id>
    <description>
        Skip locking sequence and check for lock of DPLL
        Override attribute
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DPLL_BYPASS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NEST_MEM_X_O_PCI_BYPASS</id>
    <description>
        Skip the locking sequence and check for lock of NEST/MEM/XBUS/OBUS/PCI PLLs
        Override attribute
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_NEST_MEM_X_O_PCI_BYPASS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>LPC_BASE_ADDR</id>
  <description>
    Defines LPC base address on each processor level.
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_LPC_BASE_ADDR</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FSP_BAR_ENABLE</id>
  <description>
      FSP BAR enable
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
        <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PSI_BRIDGE_BAR_ENABLE</id>
  <description>
      PSI Bridge BAR enable
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
        <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PSI_BRIDGE_BAR_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_PC_BAR_ENABLE</id>
    <description>
        INT CQ PC BAR enable
        DISABLE = 0x0, ENABLE = 0x1
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_PC_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET</id>
    <description>
        INT CQ PC BAR base address offset
        Attribute holds offset (relative to chip MMIO origin)
          to program into chip address range field of BAR
          (excludes system/memsel/group/chip fields)
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET_MASK</id>
    <description>
        INT CQ PC BAR base address offset mask
        Attribute holds offset mask (relative to chip MMIO origin)
          to program into chip address range field of BAR mask
          (excludes system/memsel/group/chip fields)
        Value defines which bits of VC_BAR are used during address compares
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_PC_BAR_BASE_ADDR_OFFSET_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_VC_BAR_ENABLE</id>
    <description>
        INT CQ VC BAR enable
        DISABLE = 0x0, ENABLE = 0x1
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_VC_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET</id>
    <description>
        INT CQ VC BAR base address offset
        Attribute holds offset (relative to chip MMIO origin)
          to program into chip address range field of BAR
          (excludes system/memsel/group/chip fields)
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET_MASK</id>
    <description>
        INT CQ VC BAR base address offset mask
        Attribute holds offset mask (relative to chip MMIO origin)
          to program into chip address range field of BAR mask
          (excludes system/memsel/group/chip fields)
        Value defines which bits of VC_BAR are used during address compares
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_VC_BAR_BASE_ADDR_OFFSET_MASK</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_TM1_BAR_ENABLE</id>
    <description>
        INT CQ TM1 BAR enable
        DISABLE = 0x0, ENABLE = 0x1
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_TM1_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_TM1_BAR_BASE_ADDR_OFFSET</id>
    <description>
        INT CQ TM1 BAR base address offset
        Attribute holds offset (relative to chip MMIO origin)
          to program into chip address range field of BAR
          (excludes system/memsel/group/chip fields)
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_TM1_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_TM1_BAR_PAGE_SIZE</id>
    <description>
        INT CQ TM1 BAR page size
        4K = 0x0, 64K = 0x1
        creator: platform
        consumer: p9_setup_bars
     </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_TM1_BAR_PAGE_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_IC_BAR_ENABLE</id>
    <description>
        INT CQ IC BAR enable
        DISABLE = 0x0, ENABLE = 0x1
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_IC_BAR_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_IC_BAR_BASE_ADDR_OFFSET</id>
    <description>
        INT CQ IC BAR base address offset
        Attribute holds offset (relative to chip MMIO origin)
          to program into chip address range field of BAR
          (excludes system/memsel/group/chip fields)
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint64_t></uint64_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_IC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_INT_CQ_IC_BAR_PAGE_SIZE</id>
    <description>
        INT CQ IC (Interrupt Controller) BAR page size
        4K = 0x0, 64K = 0x1
        creator: platform
        consumer: p9_setup_bars
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_INT_CQ_IC_BAR_PAGE_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_ENABLE</id>
    <description>
    Controls the enablement of Voltage Droop Monitors (VDM) in the system.
    OFF = 0x00, ON = 0x01

    Producer:  Machine Readable Workbook

    Consumers:
    p9_pstate_parameter_block to set flag for CME QuadManager Hcode
        reaction
    p9_hcd_cache procedures to power on VDMs before CME booting
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <readable/>
    <persistency>non-volatile</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_VDM_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>VDM_ENABLE</id>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
        <name>OFF</name>
        <value>0x00</value>
    </enumerator>
    <enumerator>
        <name>ON</name>
        <value>0x01</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>DPLL_DYNAMIC_FMAX_ENABLE</id>
    <description>
    Allow increased dynamic frequency in response to excess voltage margin
    Controlled by VDM_OVERVOLT threshold value in VDM Configuration Register.

    Producer: MRWB.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <readable/>
<!-- TODO RTC:170773 VPD -->
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_DYNAMIC_FMAX_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DPLL_DYNAMIC_FMIN_ENABLE</id>
    <description>
    Allow increased dynamic frequency in response to excess voltage margin
    Controlled by VDM_OVERVOLT threshold value in VDM Configuration Register.

    Producer: MRWB.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <readable/>
<!-- TODO RTC:170773 VPD -->
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_DYNAMIC_FMIN_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DPLL_DROOP_PROTECT_ENABLE</id>
    <description>
    Enable instantaneous frequency reduction in response to droop events
    Controlled by VDM_DROOP_SMALL, _LARGE and _XTREME threshold values in VDM
    Configuration Register. The amount of reduction is controlled by chip
    initialization values

    Producer: MRWB.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <readable/>
<!-- TODO RTC:170773 VPD -->
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_DROOP_PROTECT_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DPLL_VDM_RESPONSE</id>
    <description>
      Indicates the response of the DPLL frequency upon VDM events.  This
      control will only apply if ATTR_DPLL_VDM_JUMP_ENABLE is ON;
      Hardware WOF =  DROOP_PROTECT_OVERVOLT (slew to Fmax if margin exists)

      Producer: MRWB.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <readable/>
<!-- TODO RTC:170773 VPD -->
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_DPLL_VDM_RESPONSE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_DRAM_2N_MODE</id>
    <description>
      Allows user to manually turn on and off 2N Mode.
      AUTO indicates to use Signal Integrity generated setting (from VPD).
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <readable/>
    <persistency>volatile-zeroed</persistency>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_MRW_DRAM_2N_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- p9_setup_bars - Begin -->

<attribute>
  <id>PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
  <description>
      PCIE MMIO0 BAR base address offset
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 8:47
      (excludes system/memory select/group/chip fields)
      Array index: PHB number (0:5)
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
    <array>6</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR0_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
  <description>
      PCIE MMIO1 BAR base address offset
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 8:47
      (excludes system/memory select/group/chip fields)
      Array index: PHB number (0:5)
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
    <array>6</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_MMIO_BAR1_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET</id>
  <description>
      PCIE PHB register space BAR base address offset
      chip address range field of BAR -- RA bits 8:49
      (excludes system/memory select/group/chip fields)
      Array index: PHB number (0:5)
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
    <array>6</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REGISTER_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_XSCOM_BAR_BASE_ADDR_OFFSET</id>
  <description>
      XSCOM BAR base address offset
      Defines 16GB range (size implied) mapped for XSCOM usage
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:29
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_XSCOM_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_LPC_BAR_BASE_ADDR_OFFSET</id>
  <description>
      LPC BAR base address offset
      Defines 4GB range (size implied) mapped for LPC usage
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:31
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_LPC_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<attribute>
  <id>PROC_FSP_BAR_SIZE</id>
  <description>
    FSP BAR size value
    creator: platform
    consumer: p9_setup_bars
    firmware notes: none
  </description>
  <simpleType>
    <uint64_t>
        <default>0xFFFFFC00FFFFFFFF</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_SIZE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FSP_BAR_BASE_ADDR_OFFSET</id>
  <description>
      FSP BAR
      Defines range mapped for FSP MMIO
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:43
  </description>
  <simpleType>
    <uint64_t>
        <default>0x0000030100000000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FSP_MMIO_MASK_SIZE</id>
  <description>
      FSP MMIO mask size value AND mask applied to RA 32:35 when transmitting
      address to FSP
      NOTE: RA 8:31 are always replaced with zero
        4_GB = 0x00F0000000000000,
        2_GB = 0x0070000000000000,
        1_GB = 0x0030000000000000,
      512_MB = 0x0010000000000000,
      256_MB = 0x0000000000000000
  </description>
  <simpleType>
    <uint64_t>
        <default>0x0010000000000000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_MMIO_MASK_SIZE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET</id>
  <description>
      PSI Bridge BAR base address offset
      Defines 1MB range (size implied) mapped for PSI host-bridge
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:43
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
        <default>0x0000030203000000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NPU_PHY0_BAR_ENABLE</id>
  <description>
      NPU PHY0 (stack0) BAR enable
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
        <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY0_BAR_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NPU_PHY0_BAR_BASE_ADDR_OFFSET</id>
  <description>
      NPU PHY0 (stack0) BAR
      Defines 2MB range (size implied) mapped to PHY0 registers
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:42
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
        <default>0x0000030201200000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY0_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NPU_PHY1_BAR_ENABLE</id>
  <description>
      NPU PHY1 (stack1) BAR enable
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
        <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY1_BAR_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NPU_PHY1_BAR_BASE_ADDR_OFFSET</id>
  <description>
      NPU PHY1 (stack1) BAR
      Defines 2MB range (size implied) mapped to PHY1 registers
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:42
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
        <default>0x0000030201400000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_PHY1_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NPU_MMIO_BAR_ENABLE</id>
  <description>
      NPU MMIO (stack2) BAR enable
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
        <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NPU_MMIO_BAR_BASE_ADDR_OFFSET</id>
  <description>
      NPU MMIO (stack2) BAR
      Defines 16MB range mapped to all NPU registers
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:39
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
        <default>0x0000030200000000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NX_RNG_BAR_ENABLE</id>
  <description>
      NX RNG BAR enable
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
        <default>0</default>
    </uint8_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_BAR_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NX_RNG_BAR_BASE_ADDR_OFFSET</id>
  <description>
      NX RNG BAR
      Defines 8KB range (size implied) mapped for NX RNG function
      Attribute holds offset (relative to chip MMIO origin) to program into
      chip address range field of BAR -- RA bits 22:51
      (excludes system/memory select/group/chip fields)
  </description>
  <simpleType>
    <uint64_t>
        <default>0x00000302031D0000</default>
    </uint64_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_BAR_BASE_ADDR_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<!-- p9_setup_bars - End -->

<!--The following two NX_RING_FAILED attributes are essentially overrides
    so we will init them to zero -->
<attribute>
  <id>PROC_NX_RNG_FAILED_INT_ENABLE</id>
  <description>
      Enable optional post of interrupt when both NX RNG noise
      sources have failed.
      DISABLE = 0x0, ENABLE = 0x1
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_FAILED_INT_ENABLE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_NX_RNG_FAILED_INT_ADDR</id>
  <description>
      Address used to post interrupt when both NX RNG noise sources have failed
      creator: platform
      consumer: p9_rng_init_phase2
      firmware notes:
        64-bit address representing RA
        NOTE: register covers RA 8:51
  </description>
  <simpleType>
    <uint64_t>
    </uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_RNG_FAILED_INT_ADDR</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MR_DPHY_GPO</id>
  <description>
        Global phy offset in number of clocks
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_DPHY_GPO</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MR_DPHY_RLO</id>
  <description>
        Read latency offset in number of clocks
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_DPHY_RLO</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_MR_DPHY_WLO</id>
  <description>
        Write latency offset in number of clocks
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
    <array>2</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_MR_DPHY_WLO</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_HASCLOCKS</id>
    <description>
        Indicates the L2 region has clocks running and scommable

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_HASCLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_HASCLOCKS</id>
    <description>
        Indicates the L3 region has clocks running and scommable

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_HASCLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C0_EXEC_HASCLOCKS</id>
    <description>
        Indicates the execution units in core 0 have clocks running
       and scommable

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C0_EXEC_HASCLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C1_EXEC_HASCLOCKS</id>
    <description>
        Indicates the execution units in core 1 have clocks running
       and scommable

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C1_EXEC_HASCLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C0_PC_HASCLOCKS</id>
    <description>
        Indicates the core pervasive unit in core 0 has clocks
       running and scommable

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C0_PC_HASCLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C1_PC_HASCLOCKS</id>
    <description>
        Indicates the core pervasive unit in core 1 has clocks
       running and scommable

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C1_PC_HASCLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_HASPOWER</id>
    <description>
        Indicates L2 has power and has valid latch state that could
       be scanned

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_HASPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_HASPOWER</id>
    <description>
        Indicates L3 has power and has valid latch state that could
       be scanned

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_HASPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C0_HASPOWER</id>
    <description>
        Indicates core 0 has power and has valid latch state that
       could be scanned

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C0_HASPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>C1_HASPOWER</id>
    <description>
        Indicates core 1 has power and has valid latch state that
       could be scanned

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_C1_HASPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TARGET_HAS_POWER</id>
    <description>
        Functional Target has power
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TARGET_HAS_POWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TARGET_HAS_CLOCK</id>
    <description>
        Functional Target has clock
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TARGET_HAS_CLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TARGET_IS_SCOMMABLE</id>
    <description>
        Functional Target is scommable
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TARGET_IS_SCOMMABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_LOADLINE_VDD_UOHM</id>
    <description>

      Impedance (binary microOhms) of the load line from a processor VDD VRM to the
      Processor Module pins.  This value is applied to each processor instance.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_LOADLINE_VDD_UOHM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_DISTLOSS_VDD_UOHM</id>
    <description>

      Impedance (binary in microOhms) of the VDD distribution loss sense point
      to the circuit. This value is applied to each processor instance.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_DISTLOSS_VDD_UOHM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_VRM_VOFFSET_VDD_UV</id>
    <description>

      Offset voltage (binary in microvolts) to apply to the VDD VRM distribution
      to the processor module.  This value is applied to each processor instance.

      Note:  no loadline may be present in the system; thus, a value of 0 is
      legal.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_VRM_VOFFSET_VDD_UV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_LOADLINE_VDN_UOHM</id>
    <description>

      Impedance (binary microOhms) of the load line from a processor VDN VRM to
      the Processor Module pins.  This value is applied to each processor
      instance.

      Note:  no loadline may be present in the system; thus, a value of 0 is
      legal.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_LOADLINE_VDN_UOHM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_DISTLOSS_VDN_UOHM</id>
    <description>

      Impedance (binary in microOhms) of the VDN distribution loss sense point
      to the circuit. This value is applied to each processor instance.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_DISTLOSS_VDN_UOHM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_VRM_VOFFSET_VDN_UV</id>
    <description>

      Offset voltage (binary in microvolts) to apply to the VDN VRM distribution
      to the processor module.  This value is applied to each processor instance.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_VRM_VOFFSET_VDN_UV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_LOADLINE_VCS_UOHM</id>
    <description>

      Impedance (binary microOhms) of the load line from a processor VCS VRM to
      the Processor Module pins.  This value is applied to each processor
      instance.

      Note:  no loadline may be present in the system; thus, a value of 0 is
      legal.

      Producer: Machine Readable Workbook (per the power subsystem design)

      Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_LOADLINE_VCS_UOHM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_DISTLOSS_VCS_UOHM</id>
    <description>

      Impedance (binary in microOhms) of the VCS distribution loss sense point
      to the circuit. This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per
      system)

      Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_DISTLOSS_VCS_UOHM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_VRM_VOFFSET_VCS_UV</id>
    <description>

      Offset voltage (binary in microvolts) to apply to the VCS VRM distribution
      to the processor module.  This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per
      system)

      Consumer: FSP

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_VRM_VOFFSET_VCS_UV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>FREQ_BIAS_ULTRATURBO</id>
    <description>

     UltraTurbo Frequency Bias - % of bias (signed twos complement in 0.5
     percent steps) used in calculating the frequency associated with a Pstate
     - both Global and Local.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_BIAS_ULTRATURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_BIAS_TURBO</id>
    <description>

     Turbo Frequency Bias - % of bias (signed twos complement in 0.5 percent
     steps) used in calculating the frequency associated with a Pstate - both
     Global and Local.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_BIAS_TURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_BIAS_NOMINAL</id>
    <description>

     Nominal Frequency Bias - % of bias (signed twos complement in 0.5 percent
     steps) used in calculating the frequency associated with a Pstate - both
     Global and Local.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_BIAS_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_BIAS_POWERSAVE</id>
    <description>

     PowerSave Frequency Bias - % of bias (signed twos complement in 0.5 percent
     steps) used in calculating the frequency associated with a Pstate - both
     Global and Local.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_BIAS_POWERSAVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_EXT_VDD_BIAS_ULTRATURBO</id>
    <description>

     UltraTurbo VDD Voltage Bias - % of bias (signed twos complement in 0.5
     percent steps) that is applied to the UltraTurbo VPD point used in
     calculating the Global Pstate values.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_EXT_VDD_BIAS_ULTRATURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_EXT_VDD_BIAS_TURBO</id>
    <description>

     Turbo VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
     steps) that is applied to the UltraTurbo VPD point used in calculating the
     Global Pstate values.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_EXT_VDD_BIAS_TURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_EXT_VDD_BIAS_NOMINAL</id>
    <description>

     Nominal VDD Voltage Bias - % of bias (signed twos complement in 0.5 percent
     steps) that is applied to the UltraTurbo VPD point used in calculating the
     Global Pstate values.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_EXT_VDD_BIAS_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_EXT_VDD_BIAS_POWERSAVE</id>
    <description>

     PowerSave VDD Voltage Bias - % of bias (signed twos complement in 0.5
     percent steps) that is applied to the UltraTurbo VPD point used in
     calculating the Global Pstate values.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block


    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_EXT_VDD_BIAS_POWERSAVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_EXT_VCS_BIAS</id>
    <description>

     VCS Voltage Bias - % of bias (signed twos complement in 0.5 percent
     steps) that is applied to the VCS value stored in the UltraTurbo VPD
     point for setting the VCS rail.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

     Platform default:  0

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_EXT_VCS_BIAS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_EXT_VDN_BIAS</id>
    <description>

     VDN Voltage Bias - % of bias (signed twos complement in 0.5 percent
     steps) that is applied to the VDN value stored in the VPD for setting the
     VDN rail.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

     Platform default:  0

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_EXT_VDN_BIAS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_INT_VDD_BIAS_ULTRATURBO</id>
    <description>

     TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS
     WELL AS THE IVRM VOLTAGE CALCULATION PROCESS
     UltraTurbo Internal VDD Voltage Bias - % of bias (signed twos complement in
     0.5 percent steps) that is applied to the voltage computed (Vout) as part
     of the Local Pstate.  Note: the Vin Effective that models the Vin to the
     PFETs (i.e  accounting for system parameter losses) may include biassing
     based on ATTR_VOLTAGE_VDD_BIAS_ULTRATURBO.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

     Platform default:  0

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_INT_VDD_BIAS_ULTRATURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_INT_VDD_BIAS_TURBO</id>
    <description>

     TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS
     WELL AS THE IVRM VOLTAGE CALCULATION PROCESS
     TURBO Internal VDD Voltage Bias - % of bias (signed twos complement in 0.5
     percent steps) that is applied to the voltage computed (Vout) as part of
     the Local Pstate.  Note: the Vin Effective that models the Vin to the PFETs
     (i.e  accounting for system parameter losses) may include biassing based on
     ATTR_VOLTAGE_VDD_BIAS_TURBO.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

     Platform default:  0

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_INT_VDD_BIAS_TURBO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_INT_VDD_BIAS_NOMINAL</id>
    <description>

     TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS
     WELL AS THE IVRM VOLTAGE CALCULATION PROCESS
     Nominal Internal VDD Voltage Bias - % of bias (signed twos complement in
     0.5 percent steps) that is applied to the voltage computed (Vout) as part
     of the Local Pstate.  Note: the Vin Effective that models the Vin to the
     PFETs (i.e  accounting for system parameter losses) may include biassing
     based on ATTR_VOLTAGE_VDD_BIAS_NOMINAL.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

     Platform default:  0

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_INT_VDD_BIAS_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VOLTAGE_INT_VDD_BIAS_POWERSAVE</id>
    <description>

     TODO (RTC 136996) NEED TO LOOK AT PERCENTAGE IMPLEMENTATION IN CME CODE AS
     WELL AS THE IVRM VOLTAGE CALCULATION PROCESS
     PowerSave Internal VDD Voltage Bias - % of bias (signed twos complement in
     0.5 percent steps) that is applied to the voltage computed (Vout) as part of
     the Local Pstate.  Note: the Vin Effective that models the Vin to the PFETs
     (i.e  accounting for system parameter losses) may include biassing based on
     ATTR_VOLTAGE_VDD_BIAS_POWERSAVE.

     Producer:  Attribute Overrides by Lab/Mfg Characterization Team

     Consumer: p9_pstate_parameter_block

     Platform default:  0

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VOLTAGE_INT_VDD_BIAS_POWERSAVE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_DROOP_SMALL_OVERRIDE</id>
    <description>

          Voltage Droop Monitor (VDM) Small Threshold Select Value per VPD point
          The enum indicates a negative value below the VDM setting that will
          trigger a small droop event.

          Array of 5 entries:
            0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable

          If index 4 is non-zero, the other entries are considered valid.

          Producer: MRWB.

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_DROOP_SMALL_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_DROOP_LARGE_OVERRIDE</id>
    <description>

      Voltage Droop Monitor (VDM) Large Threshold Select Value per VPD point
      The enum indicates a negative value below the VDM setting that will
      trigger a large droop event.

      Array of 5 entries:
        0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable

      If index 4 is non-zero, the other entries are considered valid.

      Producer: Firmware override

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_DROOP_LARGE_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_DROOP_EXTREME_OVERRIDE</id>
    <description>

      Voltage Droop Monitor (VDM) Extreme Threshold Select Value per VPD point.
      The enum indicates a negative value below the VDM setting that will
      trigger an extreme droop event.

      Array of 5 entries:
        0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable

      If index 4 is non-zero, the other entries are considered valid.

      Producer: MRWB.

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_DROOP_EXTREME_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_OVERVOLT_OVERRIDE</id>
    <description>

      Voltage Droop Monitor (VDM) OverVoltage Threshold Select Value per VPD
      point. The enum indicates a positive value above the VDM setting that will
      indicate an overvolt droop condition.

      Array of 5 entries:
        0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable

      If index 4 is non-zero, the other entries are considered valid.

      Producer: MRWB.

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_OVERVOLT_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_FMAX_OVERRIDE_KHZ</id>
    <description>


          Producer: MRWB.

    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_FMAX_OVERRIDE_KHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_FMIN_OVERRIDE_KHZ</id>
    <description>



          Producer: MRWB.

    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_FMIN_OVERRIDE_KHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VDM_VID_COMPARE_OVERRIDE_MV</id>
    <description>

      Voltage Droop Monitor (VDM) Voltage Compare Voltage to expect when no
      droop is present (binary in mV)

      Array of 5 entries:
        0 = PowerSave, 1 = Nominal; 2 = Turbo; 3 = UltraTurbo; 4 = Enable

      If index 4 is non-zero, the other entries are considered valid.

      Producer: MRWB.

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>5</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VDM_VID_COMPARE_OVERRIDE_MV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IVRM_DEADZONE_MV</id>
    <description>

          Indicates the size of the deadzone where the iVRM cannot regulate
          (binary in millivolts)

          Producer: MRWB.

    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IVRM_DEADZONE_MV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TDP_RDP_CURRENT_FACTOR</id>
    <description>
         TODO RTC 157943 -- Placeholder description
    Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TDP_RDP_CURRENT_FACTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_RESCLK_FREQ_REGIONS</id>
    <description>

    Frequency discontinuity region points that defines the lower edge of a
    Resonant Region and where F[i] LT F[i+1] and 0 LE i LE 7.
    This yields:
       ATTR_RESCLK_FREQ_REGIONS[0] LE Region 0 LT ATTR_RESCLK_FREQ_REGIONS[1]
       ATTR_RESCLK_FREQ_REGIONS[1] LE Region 1 LT ATTR_RESCLK_FREQ_REGIONS[2]
       ATTR_RESCLK_FREQ_REGIONS[2] LE Region 2 LT ATTR_RESCLK_FREQ_REGIONS[3]
       etc.

    Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>8</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_FREQ_REGIONS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_RESCLK_FREQ_REGION_INDEX</id>
    <description>

    Defines the index into ATTR_RESCLK_VALUE[] to use for the frequency region.

    The frequency associated with the region is defined by
    ATTR_RESCLK_FREQ_REGIONS[i] and ATTR_RESCLK_FREQ_REGIONS[i+1] for
    0 LE i LE 7.

    Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>8</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_FREQ_REGION_INDEX</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_RESCLK_VALUE</id>
    <description>

    Array of Clock strength values that will we written in QACCR by CME Hcode

    Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>64</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_RESCLK_L3_VALUE</id>
    <description>

    Array of L3 Clock strength values to be used going between "High and Normal
    Voltage" and "Low Voltage" mode.   Low Voltage mode is define by
    ATTR_RESCLK_L3_VOLTAGE_THRESHOLD_MV.

    Entry 0 = "High and Normal Voltage" setting
    Entry 3 = "High and Normal Voltage" setting

    Entry 1 = transitional setting defined by the clock team
    Entry 2 = transitional setting defined by the clock team

    Contents of each entry will be written directly into L3 control bits in the
    QACCR(16:23) a RMW operations.  If the circuits demand a grey code whereby
    only 1 bit of this field can change at a time, the entries must be deal with
    such encoding.  The Hcode that these values does not perform that function;
    it merely steps from 0->3 when going below the voltage defined by
    ATTR_RESCLK_L3_VOLTAGE_THRESHOLD_MV and then steps 3->0 when going at or
    above the voltage defined by ATTR_RESCLK_L3_VOLTAGE_THRESHOLD_MV.

    Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_L3_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_RESCLK_L3_VOLTAGE_THRESHOLD_MV</id>
    <description>

    Voltage value (in millivolts) whereby voltage below this value will have
    the L3 clock strength moved to "Low" mode while values at or above this
    value will have the L3 clock strength moved to "High" mode.  The L3 clock
    strength values put in the hardware for this mode transtion are defined by
    ATTR_RESCLK_L3_VALUE.

    Consumers: p9_pstate_parameter_block

    </description>
    <simpleType>
        <uint16_t></uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_L3_VOLTAGE_THRESHOLD_MV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SAFE_FREQUENCY_MHZ</id>
    <description>

    Frequency (in MHz) to move to if the Power Management function fails.
    This is the same for all cores in the system.
    Provided by the MRW.

    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SAFE_FREQUENCY_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_OCC_THROTTLED_N_CMDS</id>
    <description>

        cfg_nm_n_per_port throttle N value that was calculated from MSS_DATABUS_UTIL

    </description>
    <simpleType>
        <uint32_t></uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_OCC_THROTTLED_N_CMDS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_OFFSET_WLO</id>
    <description>

      Write Latency Offset in number of Clocks

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_OFFSET_WLO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_OFFSET_GPO</id>
    <description>

      Global Offset in number of Clocks. Delta from the value calculated or taken from VPD.

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_OFFSET_GPO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_OFFSET_RLO</id>
    <description>

      Read Latency Offset in number of Clocks. Delta from the value calculated or taken from VPD.

    </description>
    <simpleType>
        <int8_t></int8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_OFFSET_RLO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_TSYS_ADR</id>
    <description>

      Phase rotator value for the memory sub-system clock in ticks.
      Ticks are 1/128 of one cycle of clock.

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_TSYS_ADR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_TSYS_DATA</id>
    <description>

      Phase rotator value for the memory sub-system data in ticks.
      Ticks are 1/128 of one cycle of clock.

    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_TSYS_DATA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_TOTAL_PWR_SLOPE</id>
    <description>

            VDDR+VPP Power slope value for dimm
            creator: mss_eff_config
            consumer: mss_bulk_pwr_throttles

    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_TOTAL_PWR_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_TOTAL_PWR_INTERCEPT</id>
    <description>

            VDDR+VPP Power intercept value for dimm
            creator: mss_eff_config
            consumer: mss_bulk_pwr_throttles

    </description>
    <simpleType>
        <uint16_t></uint16_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_TOTAL_PWR_INTERCEPT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_PORT_MAXPOWER</id>
    <description>
        Channel Pair Max Power output from thermal procedures
    </description>
    <simpleType>
        <uint32_t></uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_PORT_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_CKE_MAP</id>
  <description>
            The Memory Clock Enable MAP is a bit map describing the Memory Clock Enable signal to its respective rank.
            There are 8 bits, but only 4 are currently used
            [DIMM0 CKE0][DIMM0 CKE1][N/A][N/A][DIMM1 CKE0][DIMM1 CKE1][N/A][N/A]
            E.g. 0x80 -> 0b10000000, which means DIMM0 CKE0 is mapped to that rank.
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
    <array>2,2,4</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_CKE_MAP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_VPD_DQ_MAP</id>
  <description>
        [PORT][Dimm DQ PIN]  The map from the Dual
        Inline Memory Module (DIMM) Data (DQ) Pin to
        the Module Package Data (DQ) Pinout
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
    <array>2,72</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPD_DQ_MAP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
  <description>
        Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration. Units in cW
        Consumed in mss_eff_config_thermal
  </description>
  <simpleType>
    <uint32_t>
        <default>0x000006A4</default>
    </uint32_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
  <description>
        Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full configuration. Units in cW
        Used for Cumulus
        Consumed in mss_eff_config_thermal
  </description>
  <simpleType>
    <uint32_t>
    </uint32_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR3</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_IGNORE_PLUG_RULES</id>
  <description>
    Set to IGNORE if you want to ignore the plug rules. Sometimes
    this is needed in a partial-good configuration
  </description>
  <simpleType>
    <uint8_t>
    </uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_IGNORE_PLUG_RULES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_FAMILY</id>
    <description>
        This field is of the form "vendor,name" where the name indicates
        the family of the systems.  The textual portion of the string has
        a maximum length of 63 characters to accommodate a terminating NULL.
        Both vendor and name fields are lower case US ASCII. No special
        characters other than ",", "-", and "+" as described below should
        be used in the string.
    </description>
    <simpleType>
        <string>
            <default>ibm,p9</default>
            <sizeInclNull>64</sizeInclNull>
        </string>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>SYSTEM_TYPE</id>
    <description>
        This field is of the form ?vendor,type? where the type indicates
        a type of system within the System Family. The textual portion of
        the string has a maximum length of 63 characters to accommodate a
        terminating NULL. Both vendor and name fields are lower case US
        ASCII. No special characters other than ",", "-", and "+" as described
        below should be used in the string.  If identification of specific
        models within a system type is desired, "-model" should be appended
        to the end of the name. The "-model" portion is optional and could be
        used to identify the packaging, specific model numbers, etc.
        NOTE: No Hostboot code should ever key off of this value.
    </description>
    <simpleType>
        <string>
            <default>ibm,miscopenpower</default>
            <sizeInclNull>64</sizeInclNull>
        </string>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>TOD_CPU_DATA</id>
    <description>TOD CHIP DATA for each CHIP
        The size of the TOD CHIP DATA must be equal to the sizeof(TodChipData)
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    <!-- the size of the array must be equal to the sizeof(TodChipData)
    defined in TodTypes.H  -->
        <array>44</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
  <id>SUPPORTED_STOP_STATES</id>
  <description>
      STOP levels supported at runtime (sent to Host via HDAT):
        Bit 0: STOP0 Supported - Quiesce thread only
        Bit 1: STOP1 Supported - P8 Nap
        Bit 2: STOP2 Supported - P8 Fast Sleep
        Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs
        Bit 4: STOP4 supported - P8 Deep Sleep
        Bit 5: STOP5 Supported - WOF-friendly "Instant on"
        Bit 6,7: Reserved
        Bit 8: STOP8 supported - Half Quad Sleep
        Bit 9: STOP9 supported - P8 Fast Winkle
        Bit 10: Reserved
        Bit 11: STOP11 supported - P8 Deep Winkle
        Bit 12-15 : Reserved
        Bits 16..31 - Reserved
  </description>
  <simpleType>
    <uint32_t>
       <default>0x80000000</default>
    </uint32_t>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
</attribute>

<attribute>
    <id>SBE_IMAGE_MINIMUM_VALID_ECS</id>
    <description>
        The minimum number of valid ECs that is required to be used when
        customizing an SBE image. The customization will fail if it cannot
        create an image with at least this many ECs.
    </description>
    <simpleType>
        <uint8_t>
            <default>2</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_IMAGE_MINIMUM_VALID_ECS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>REL_POS</id>
    <description>
        Logical position of this unit/dimm relative to its immediate parent
    </description>
    <simpleType>
        <uint8_t>
            <default>0xFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_REL_POS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen3 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <simpleType>
        <uint16_t><default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default></uint16_t>
        <array>16</array><!-- Lane -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen4 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <simpleType>
        <uint16_t><default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default></uint16_t>
        <array>16</array><!-- Lane -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_CAL_ABORT_ON_ERROR</id>
    <description>
    Whether or not to abort on the first DDR PHY calibration error.
    Firmware should always have this set to NO. YES can be used in the
    lab for troubleshooting, screening, etc.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CAL_ABORT_ON_ERROR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_SYS_CONFIG</id>
    <description>
        System Configuration information - 1 indicates a chip present
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SYS_CONFIG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
    <description>
        To deconfigure a TPM in a secure system - 01 to set TDP bit
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PERF_24x7_INVOCATION_TIME_MS</id>
    <description>
    Time between invocations of the 24x7 performance collection function on
    GPE1.  The time (in milliseconds) is derived as  2^PERF_24x7_INVOCATION_TIME_MS
    with 0 indicating the function is OFF.
    Consumer: p9_hcode_image_build.c ->
                 SGPE Header field
    Provided by the Machine Readable Workbook to tune the collection.
    Platform default:  1
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PERF_24x7_INVOCATION_TIME_MS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CME_INSTRUCTION_TRACE_ENABLE</id>
    <description>
     Enables the SGPE Hcode to enable the CME instruction traces into the L3
     Trace array for debug.  Note:  all configured CMEs will be put into this
     mode if this attribute is ON.

     Consumer: p9_hcode_image_build.c ->
                  SGPE Header field

     Platform default:  OFF
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CME_INSTRUCTION_TRACE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CP_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of processor refclock receiver termination
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CP_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IO_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of PCI refclock receiver termination
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IO_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_PWR_INTERCEPT</id>
    <description>
        Machine Readable Workbook Power Curve Intercept for DIMM
        Used to get the VDDR and VDDR+VPP power curve for each DIMM
        Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT
        Key Value pair
        KEY (0-19): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-7,
        DIMM_WIDTH = 8-9,
        DIMM_DENSITY = 10-12,
        DIMM_STACK_TYPE = 13-14,
        DRAM_MFGID = 15-16,
        DIMMS_PER_PORT = 17-18,
        Bits 19-32: Not used
        VALUE (bits 32-63) in cW:
        VMEM power curve = 32-47
        VMEM+VPP power curve = 48-63
        Consumers: eff_config_thermal
    </description>
    <simpleType>
        <uint64_t>
        <default>
          0xffffe00002CC03AE,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
          </default>
        </uint64_t>
        <array>100</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_PWR_INTERCEPT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_PWR_SLOPE</id>
    <description>
        Machine Readable Workbook Power Curve Slope for DIMM
        Used to get the VDDR and VDDR+VPP power curve for each DIMM
        Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT
        Key Value pair
        KEY (0-19): In order
        DIMM_SIZE = bits 0-3,
        DIMM_GEN = 4-5,
        DIMM_TYPE = 6-7,
        DIMM_WIDTH = 8-9,
        DIMM_DENSITY = 10-12,
        DIMM_STACK_TYPE = 13-14,
        DRAM_MFGID = 15-16,
        DIMMS_PER_PORT = 17-18,
        Bits 19-32: Not used
        VALUE (bits 32-63) in cW:
        VMEM power curve = 32-47
        VMEM+VPP power curve = 48-63
        Consumers: eff_config_thermal
    </description>
    <simpleType>
        <uint64_t>
          <default>
          0xffffe00003FD0546,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,
          0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0,0x0
          </default>
        </uint64_t>
        <array>100</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_PWR_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>MSS_MRW_REFRESH_RATE_REQUEST</id>
    <description>
        Machine Readable Workbook Refresh Rate
        Desired refresh interval used in refresh register 0, MBAREF0Q_CFG_REFRESH_INTERVAL
        7.8 us (SINGLE)
        3.9 us (DOUBLE)
        7.02 us (SINGLE_10_PERCENT_FASTER)
        3.51 us (DOUBLE_10_PERCENT_FASTER)
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_REFRESH_RATE_REQUEST</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SAFE_VOLTAGE_MV</id>
    <description>
        Voltage (in mV) to move to if the Power Management function fails.
        Provided by the MRW.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SAFE_VOLTAGE_MV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IVRM_STRENGTH_LOOKUP</id>
    <description>
    Producer: MRWB.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>64</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IVRM_STRENGTH_LOOKUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IVRM_VIN_MULTIPLIER</id>
    <description>
    Producer: MRWB.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>64</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IVRM_VIN_MULTIPLIER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IVRM_VIN_MAX_MV</id>
    <description>
    Producer: MRWB.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IVRM_VIN_MAX_MV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IVRM_STEP_DELAY_NS</id>
    <description>
    Producer: MRWB.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IVRM_STEP_DELAY_NS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IVRM_STABILIZATION_DELAY_NS</id>
    <description>
    Producer: MRWB.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IVRM_STABILIZATION_DELAY_NS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SYSTEM_RESCLK_ENABLE</id>
    <description>
      Controls the enablement of resonant clocking in the system.

      Producer:  Machine Readable Workbook

      Consumers:
        p9_pstate_parameter_block to set flag for CME QuadManager Hcode
            reaction
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RESCLK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>BAD_DQ_BITMAP</id>
    <description>
      Bad DQ bitmap from a controller point of view.
      The data is a 10 byte bitmap for each of 4 possible ranks.
      The bad DQ data is stored in NVRAM, and it is stored in a special format
      translated to a DIMM Connector point of view.
      All of these details are hidden from the user of this attribute.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4,10</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_BAD_DQ_BITMAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VREF_CAL_ENABLE</id>
    <description>
        A bit vector denoting bits in every DP16 on the port to be calibrated.
        That is, all of the set bits will be calibrated for all DP16. A value
        of zero indicates the calibration should not be run.
    </description>
    <simpleType>
        <uint16_t>
        </uint16_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VREF_CAL_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VREF_DAC_NIBBLE</id>
    <description>
        Value for VREF DAC nibbles
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VREF_DAC_NIBBLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MVPD_FWMS</id>
    <description>
        Mark store records from MPVD Lx keyword
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,8</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MVPD_FWMS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_VCCD_OVERRIDE</id>
    <description>
        Whether or not to override VCCD. Defaults to no.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VCCD_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ORDINAL_ID</id>
    <description>Ordinal ID of a target</description>
    <simpleType>
        <uint32_t>
            <default>0xFFFFFFFF</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>RAW_MTM</id>
    <description>
       Raw value of system MTM
    </description>
    <simpleType>
    <string>
      <sizeInclNull>64</sizeInclNull>
    </string>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>SYSTEM_RING_DBG_MODE</id>
    <description>
       Debug modes supported for CME/SGPE Scan layout in HOMER
       SCAN_RING_NO_DEBUG = 0x00, SCAN_RING_TRACE_DEBUG = 0x01
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_RING_DBG_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
   <id>POUND_W_STATIC_DATA_ENABLE</id>
   <description>
     Enables pstate parameter block code to use the static #W data
     Consumer: p9_pstate_parameter_block.C ->

     Platform default:  OFF=0
   </description>
   <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
   </simpleType>
   <persistency>non-volatile</persistency>
   <readable/>
   <hwpfToHbAttrMap>
      <id>ATTR_POUND_W_STATIC_DATA_ENABLE</id>
      <macro>DIRECT</macro>
   </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>AUX_FUNC_INVOCATION_TIME_MS</id>
     <description>
     Time between invocations of auxiliary function on
     GPE1.  The time (in milliseconds) is derived as  2^ATTR_AUX_FUNC_INVOCATION_TIME_MS
     with 0 indicating the function is OFF.
     Consumer: p9_hcode_image_build.c ->
                  SGPE Header field
     Provided by the Machine Readable Workbook to tune the collection.
     Platform default:  1
     </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PGPE_HCODE_FUNCTION_ENABLE</id>
    <description>
        Enables the PGPE Hcode to physically perform frequency and voltage
        operations based on constructed parameters (eg #V VPD, system
        parameters, biases, WPF VFRTs. etc).  If OFF, the PGPE provides an
        immedicate good response to all Pstate/WOF IPC operations from the
        OCC for firmware integration testing purposes.

        Consumer: p9_hcode_image_build.c ->
                  PGPE Header field

        Platform default:  OFF
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
     <hwpfToHbAttrMap>
        <id>ATTR_PGPE_HCODE_FUNCTION_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

<attribute>
    <id>MSS_MEM_PORT_POS_OF_FAIL_THROTTLE</id>
    <description>
        This is the fapi position of the port that failed to calculate
        memory throttles given the passed in watt target and or utilization
    </description>
    <simpleType>
    <uint64_t></uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_PORT_POS_OF_FAIL_THROTTLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MRW_UNSUPPORTED_RANK_CONFIG</id>
    <description>
      Each MCA value is a 64-bit vector, where each byte represents an unsupported rank configuration.
      Each nibble in the byte represents the total count of ranks (master and slave)
      on each DIMM. The left-most nibble represents slot 0 and the right represents 1.
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_UNSUPPORTED_RANK_CONFIG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>XIVE_HW_RESET</id>
    <description>
      Used to tell INTRP code whether to use the XIVE HW Reset
      or a software based reset.
      0 = Software based reset
      1 = XIVE HW reset
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_SBE_SEEPROM_SIZE</id>
    <description>
      Defines the maximum Seeprom storage size for the fully-customized SBE image
      permitted by the platform.
      For platforms (FSP/HB FW) which require the image to be constrained into a
      physical storage device (SEEPROM), this should reflect the maximum size of that
      memory (e.g., 256KB).
      For platforms (Cronus) which may use a customized image in a virtual
      envrionment with no physical storage constraints, this size may be
      larger than the physical SEEPROM size.
    </description>
    <simpleType>
        <uint32_t>
            <default>0x40000</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MAX_SBE_SEEPROM_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DO_MSS_WR_VREF</id>
    <description>
        In sub DD1.02 Nimbus in the WR VREF algorithm, certain work-arounds are needed
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DO_MSS_WR_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- @fixme RTC:166754 Remove old attribute -->
<attribute>
    <id>DO_MSS_VCCD_OVERRIDE</id>
    <description>
      Override VREG control information sub DD1.02
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DO_MSS_VCCD_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SKIP_HW_VREF_CAL</id>
    <description>

      In sub DD1.02 Nimbus the HW VREF calibrations should not be run

    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SKIP_HW_VREF_CAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SKIP_RD_VREF_VREFSENSE_OVERRIDE</id>
    <description>

      In sub DD1.03 Nimbus the HW VREF calibrations should not be run

    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SKIP_RD_VREF_VREFSENSE_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DO_MSS_VREF_DAC</id>
    <description>
      VREF DAC work-around for Nimbus sub DD1.02
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DO_MSS_VREF_DAC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- @fixme RTC:166754 Remove old attribute -->
<attribute>
    <id>DO_MSS_VREG_COARSE</id>
    <description>
        VREG Coarse work-around for Nimbus sub DD1.02
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DO_MSS_VREG_COARSE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DO_MSS_TRAINING_BAD_BITS</id>
    <description>
      For Nimbus pre DD1.02 we want to pass DDR training if we see 'correctable'
      errors. This isn't the case for post-DD1.02 where we want to pass/fail
      training based on the results from the PHY itself
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DO_MSS_TRAINING_BAD_BITS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RTT_NOM</id>
    <description>
        RTT_NOM value read to be programmed into MRS02
        For RDIMMS, this is based off of the VPD
        For LRDIMMS, this comes from the SPD
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RTT_NOM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RTT_NOM_OVERRIDE_DISABLE</id>
    <description>
      Set equal to 1 to disable setting of RTT_NOM to use RTT_WR values
      during WR_LEVEL calibration.
    </description>
    <simpleType>
      <uint8_t></uint8_t>
      <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <writeable/>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_RTT_NOM_OVERRIDE_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RTT_WR</id>
    <description>
        RTT_WR value read to be programmed into MRS02
        For RDIMMS, this is based off of the VPD
        For LRDIMMS, this comes from the SPD
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RTT_WR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RTT_PARK</id>
    <description>
        RTT_PARK value read to be programmed into MRS05
        For RDIMMS, this is based off of the VPD
        For LRDIMMS, this comes from the SPD
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RTT_PARK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RANK_GROUP_OVERRIDE</id>
    <description>

          Override PHY RANK_PAIR settings. First uint16 value is for RANK_PAIR0
          register value, and second is for RANK_PAIR1. Note that DIMM1 ranks in
          a dual-drop config will be converted from Centaur canonical number
          (4,5) to correct PHY settings (2,3). Set this attribute to zero
          to use default settings.

    </description>
    <simpleType>
        <uint16_t>
            <default>0x0</default>
        </uint16_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RANK_GROUP_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <description>
        Used to tell I2C code whether to run
        I2C Engine 2 Port 0 in diag mode or not
        0 = Use Diag Mode
        1 = Disable Diag Mode
    </description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_MRW_DRAM_WRITE_CRC</id>
    <description>
        Enables DRAM Write CRC
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_DRAM_WRITE_CRC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <description>Enumeration for Temperature refresh mode</description>
    <enumerator>
        <name>DISABLE</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>ENABLE</name>
        <value>1</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
    <description>
        Used in MR4 A3
        Temperature refresh mode
        Should be defaulted to disable
    </description>
    <simpleType>
        <uint8_t>
          <default>DISABLE</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MRW_TEMP_REFRESH_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DO_BLUE_WATERFALL_ADJUST</id>
    <description>
      For Nimbus pre DD1.** we want to adjust the blue waterfall values
      and their associated gate delays if the blue waterfalls are 0.
      Post DD1.** will have a hardware enabled fix for this.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DO_BLUE_WATERFALL_ADJUST</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NDL_MESHCTRL_SETUP</id>
    <description>Control NDL training:meshctrl setup</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_NDL_MESHCTRL_SETUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_REORDER_QUEUE_SETTING</id>
    <description>Contains the settings for write/read reorder queue</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_REORDER_QUEUE_SETTING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>HDAT_I2C_DEVICE_TYPE</id>
    <description>Pulled from the MRW, this describes the device
            type to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
        <name>955X</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SEEPROM</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>NUVOTON_TPM</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>MEX_FPGA</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>UCX90XX</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>NVLINK</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>UNKNOWN</name>
        <value>FF</value>
    </enumerator>
</enumerationType>

<enumerationType>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
    <description>Pulled from the MRW, this describes the device
            purpose to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
        <name>CABLE_CARD_PRES</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>CABLE_CARD_POWER_SENSE</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>CABLE_CARD_POWER_CONTROL</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>TPM</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>MODULE_VPD</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>DIMM_SPD</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>PROC_MODULE_VPD</name>
        <value>7</value>
    </enumerator>
    <enumerator>
        <name>SBE_SEEPROM</name>
        <value>8</value>
    </enumerator>
    <enumerator>
        <name>PLANAR_VPD</name>
        <value>9</value>
    </enumerator>
    <enumerator>
        <name>PCI_HOTPLUG</name>
        <value>A</value>
    </enumerator>
    <enumerator>
        <name>NVLINK</name>
        <value>B</value>
    </enumerator>
    <enumerator>
        <name>UNKNOWN</name>
        <value>FF</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PNOR_FLASH_WORKAROUNDS</id>
    <description>Save state of the sfc driver flash workarounds for runtime</description>
    <simpleType>
        <uint32_t><default>0</default></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>



<attribute>
    <id>SYSTEM_DISABLE_QUEUED_SCAN</id>
    <description>
    Queued scan mode disable status. This attribute eventually decides if queued
    scan is to be supported by CME Hcode.

    Consumers: p9_hcode_image_build
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYSTEM_DISABLE_QUEUED_SCAN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

</attributes>
