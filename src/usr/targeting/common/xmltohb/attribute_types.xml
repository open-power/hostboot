<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types.xml $        -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- COPYRIGHT International Business Machines Corp. 2011,2014              -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->

<attributes>

<!-- =====================================================================
     HOST BOOT ATTRIBUTE TYPES
     Contains the definition of all hostboot attributes which can be synced
     to/from FSP
     ================================================================= -->

<enumerationType>
    <id>CLASS</id>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>CARD</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>ENC</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>CHIP</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>UNIT</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>DEV</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>SYS</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>LOGICAL_CARD</name>
        <value>7</value>
    </enumerator>
    <enumerator>
        <name>MAX</name>
        <value>8</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<!-- The script genHwsvMrwXml.pl hardcodes the HUID type field to match
     these values and should be kept in sync. Leave holes in in the range
     if a type is deleted. Not changing the values keeps the values
     consistent over builds making them easier to recognize.  -->
<enumerationType>
    <id>TYPE</id>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>SYS</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>NODE</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>DIMM</name>
        <value>3</value>
    </enumerator>
    <enumerator>
        <name>MEMBUF</name>
        <value>4</value>
    </enumerator>
    <enumerator>
        <name>PROC</name>
        <value>5</value>
    </enumerator>
    <enumerator>
        <name>EX</name>
        <value>6</value>
    </enumerator>
    <enumerator>
        <name>CORE</name>
        <value>7</value>
    </enumerator>
    <enumerator>
        <name>L2</name>
        <value>8</value>
    </enumerator>
    <enumerator>
        <name>L3</name>
        <value>9</value>
    </enumerator>
    <enumerator>
        <name>L4</name>
        <value>10</value>
    </enumerator>
    <enumerator>
        <name>MCS</name>
        <value>11</value>
    </enumerator>
    <enumerator>
        <name>MBA</name>
        <value>13</value>
    </enumerator>
    <enumerator>
        <name>XBUS</name>
        <value>14</value>
    </enumerator>
    <enumerator>
        <name>ABUS</name>
        <value>15</value>
    </enumerator>
    <enumerator>
        <name>PCI</name>
        <value>16</value>
    </enumerator>
    <enumerator>
        <name>DPSS</name>
        <value>17</value>
    </enumerator>
    <enumerator>
        <name>APSS</name>
        <value>18</value>
    </enumerator>
    <enumerator>
        <name>OCC</name>
        <value>19</value>
    </enumerator>
    <enumerator>
        <name>PSI</name>
        <value>20</value>
    </enumerator>
    <enumerator>
        <name>FSP</name>
        <value>21</value>
    </enumerator>
    <enumerator>
        <name>PNOR</name>
        <value>22</value>
    </enumerator>
    <enumerator>
        <name>OSC</name>
        <value>23</value>
    </enumerator>
    <enumerator>
        <name>TODCLK</name>
        <value>24</value>
    </enumerator>
    <enumerator>
        <name>CONTROL_NODE</name>
        <value>25</value>
    </enumerator>
    <enumerator>
        <name>OSCREFCLK</name>
        <value>26</value>
    </enumerator>
    <enumerator>
        <name>OSCPCICLK</name>
        <value>27</value>
    </enumerator>
    <enumerator>
        <name>REFCLKENDPT</name>
        <value>28</value>
    </enumerator>
    <enumerator>
        <name>PCICLKENDPT</name>
        <value>29</value>
    </enumerator>
    <enumerator>
        <name>NX</name>
        <value>30</value>
    </enumerator>
    <enumerator>
        <name>PORE</name>
        <value>31</value>
    </enumerator>
    <enumerator>
        <name>PCIESWITCH</name>
        <value>32</value>
    </enumerator>
    <enumerator>
        <name>CAPP</name>
        <value>33</value>
    </enumerator>
    <enumerator>
        <name>FSI</name>
        <value>34</value>
    </enumerator>
    <!-- add any new types here, and increment TEST_FAIL and LAST_IN_RANGE -->
    <enumerator>
        <name>TEST_FAIL</name>
        <value>35</value>
    </enumerator>
    <enumerator>
        <name>LAST_IN_RANGE</name>
        <value>36</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<enumerationType>
    <id>MODEL</id>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>RESERVED</name><!-- Left here to keep later values the same -->
        <value>16</value>
    </enumerator>
    <enumerator>
        <name>VENICE</name>
    </enumerator>
    <enumerator>
        <name>MURANO</name>
    </enumerator>
    <enumerator>
        <name>CENTAUR</name>
        <value>48</value>
    </enumerator>
    <enumerator>
        <name>JEDEC</name>
        <value>80</value>
    </enumerator>
    <enumerator>
        <name>CDIMM</name>
    </enumerator>
    <enumerator>
        <name>POWER8</name>
        <value>112</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<enumerationType>
    <id>ENGINE_TYPE</id>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
        <name>NA</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>ENGINE_IIC</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>ENGINE_SCOM</name>
        <value>2</value>
    </enumerator>
    <default>NA</default>
</enumerationType>

<enumerationType>
    <id>FSI_MASTER_TYPE</id>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
        <name>MFSI</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>CMFSI</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>NO_MASTER</name>
        <value>2</value>
    </enumerator>
    <default>NO_MASTER</default>
</enumerationType>

<attribute>
    <id>CLASS</id>
    <description>Attribute indicating the target's class</description>
    <simpleType>
        <enumeration>
            <id>CLASS</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>TYPE</id>
    <description>Attribute indicating the target's type</description>
    <simpleType>
        <enumeration>
            <id>TYPE</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>MODEL</id>
    <description>Attribute indicating the target's model</description>
    <simpleType>
        <enumeration>
            <id>MODEL</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>ENGINE_TYPE</id>
    <description>Attribute indicating the target's engine type</description>
    <simpleType>
        <enumeration>
            <id>ENGINE_TYPE</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>32</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT8_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2, 3, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT8_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>8</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT32_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,3</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT32_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_ARRAY_1</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_ARRAY_1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCRATCH_UINT64_ARRAY_2</id>
    <description>Scratch attribute that can be used for dev/test</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCRATCH_UINT64_ARRAY_2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DUMMY_RW</id>
    <description>Dummy attribute with read/write permissions</description>
    <simpleType>
        <uint8_t>
            <default>5</default>
        </uint8_t>
        <array>1,3,5</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DUMMY_SCRATCH_PLAT_INIT_UINT8</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DUMMY_WO</id>
    <description>Dummy attribute with write-only permissions</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
</attribute>

<attribute>
    <id>DUMMY_RO</id>
    <description>Dummy attribute with read-only permissions</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DUMMY_HEAP_ZERO_DEFAULT</id>
    <description>Dummy attribute on the heap with zero initialization</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PHYS_PATH</id>
    <description>Physical hierarchical path to the target</description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>AFFINITY_PATH</id>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>POWER_PATH</id>
    <description>Hierarchical path to the target with respect to power</description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PRIMARY_CAPABILITIES</id>
    <description>Attribute which describes capabilities of a target</description>
    <complexType>
        <description>Structure which defines a target's primary capabilities.
        A target can only support at most FSI SCOM and one of the other two SCOM
        types.  Applicable for all targets.  Structure is read-only.
        </description>
        <field>
            <name>supportsFsiScom</name>
            <description>0b0: Target does not support FSI SCOM;
            0b1: Target supports FSI SCOM
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>supportsXscom</name>
            <description>0b0: Target does not support XSCOM;
            0b1: Target supports FSI XSCOM</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>supportsInbandScom</name>
            <description>0b0: Target does not support inband SCOM</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint8_t</type>
            <bits>5</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>SCOM_SWITCHES</id>
    <description>Attribute storing information about which SCOM path to use</description>
    <complexType>
        <description>Structure which defines which SCOM to use at a point in
        time.  Only applicable if target supports one or more SCOM types.  Only
        one bit (of the first three) can ever be set at any one time.
        </description>
        <field>
            <name>useFsiScom</name>
            <description>0b0: Do not use FSI SCOM at this time.  0b1: Use FSI
            SCOM at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>useXscom</name>
            <description>0b0: Do not use XSCOM at this time.  0b1: Use XSCOM at
            this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>useInbandScom</name>
            <description>0b0: Do not use inband SCOM at this time.  0b1: Use
            inband SCOM at this time</description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future expansion</description>
            <type>uint8_t</type>
            <bits>5</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FSI_MASTER_CHIP</id>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the default master processor</description>
    <nativeType>
        <name>EntityPath</name>
        <default>physical:sys-0</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ALTFSI_MASTER_CHIP</id>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the alternate master processor</description>
    <nativeType>
        <name>EntityPath</name>
        <default>physical:sys-0</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FSI_MASTER_TYPE</id>
    <description>Type of Master FSI connection to this slave (MFSI or cMFSI)</description>
    <simpleType>
        <enumeration>
            <id>FSI_MASTER_TYPE</id>
            <default>NO_MASTER</default>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
</attribute>

<attribute>
    <id>FSI_MASTER_PORT</id>
    <description>Which port is this chip hanging off of when booting from the default master processor</description>
    <simpleType>
        <uint8_t>
            <default>0xFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ALTFSI_MASTER_PORT</id>
    <description>Which port is this chip hanging off of when booting from the alternate master processor</description>
    <simpleType>
        <uint8_t>
            <default>0xFF</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FSI_SLAVE_CASCADE</id>
    <description>Slave cascade position</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>FSI_OPTION_FLAGS</id>
    <description>
        Reserved for any special flags we might need to access FSI
    </description>
    <complexType>
        <description>FSI flags</description>
        <field>
            <name>flipPort</name>
            <description>
                Set on FSI master chips (procs) if that chip uses slaveB
                to attach to the acting master chip.
            </description>
            <type>uint16_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future expansion</description>
            <type>uint16_t</type>
            <bits>15</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EXECUTION_PLATFORM</id>
    <description>
        Which execution platform the HW Procedure is running on
        Some HWPs (e.g. special wakeup) use different registers for different
          platforms to avoid arbitration problems when multiple platforms do
          the same thing concurrently
        HOST = 0x01, FSP = 0x02, OCC = 0x03
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EXECUTION_PLATFORM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IS_SIMULATION</id>
    <description>env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_IS_SIMULATION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HWAS_STATE</id>
    <description>HardWare Availability Service State Attribute.
        Keeps track of Target values poweredOn, present, functional</description>
    <complexType>
        <description>struct - 4 booleans and a PLID</description>
        <field>
            <name>deconfiguredByEid</name>
            <description>if this target was deconfigured,
                this will be a special DECONFIGURED_BY_ enum,
                OR it will be the errlog EID that caused it,
                either directly or by association,
            </description>
            <type>uint32_t</type>
            <default>0</default>
        </field>
        <field>
            <name>poweredOn</name>
            <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>present</name>
            <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>functional</name>
            <description>
             0b0: Target is not functional;
             0b1: Target is functional
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>dumpfunctional</name>
            <description>FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
    </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <description>HardWare Availability Service State Changed Attribute.
        Keeps track of changedSinceChecked state, indicates if the
        target has changed since last checked by the appropriate service.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <simpleType>
        <uint64_t>
            <default>0x0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <description>HardWare Availability Service State Changed Mask.
        Used when a target changes (ie, via HCDB change) to set the
        HWAS_STATE_CHANGED_FLAG, so that the appropriate services will
        all handle the change.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <simpleType>
        <uint64_t>
            <default>0x0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>HWAS_CHANGED_BIT</id>
    <description>Enumeration indicating the services that are concerned
        with target changes (ie, via HCDB change).
        The values can be combined using a bitwise 'OR'.
    </description>
    <enumerator>
        <name>GARD</name>
        <value>0x00000001</value>
    </enumerator>
    <enumerator>
        <name>MEMDIAG</name>
        <value>0x00000002</value>
    </enumerator>
    <enumerator>
        <name>PSIDIAG</name>
        <value>0x00000004</value>
    </enumerator>
    <!-- combination of all DIAG values -->
    <!-- if you add a DIAG flag above, add the bit in the mask below -->
    <enumerator>
        <name>DIAG_MASK</name>
        <value>0x00000006</value>
    </enumerator>
    <enumerator>
       <name>HOSTSVC_HBEL</name>
       <value>0x00000008</value>
   </enumerator>
</enumerationType>

<!-- For POD Testing -->
<attribute>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <description>Attribute which tests numeric POD types</description>
    <complexType>
        <description>Numeric POD type test structure</description>
        <field>
            <name>fsiPath</name>
            <description>Entity path for testing purposes</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>className</name>
            <description>Class for testing purposes</description>
            <type>CLASS</type>
            <default>CHIP</default>
        </field>
        <field>
            <name>uint8</name>
            <description>Test uint8</description>
            <type>uint8_t</type>
            <default>0xAB</default>
        </field>
        <field>
            <name>uint16</name>
            <description>Test uint16</description>
            <type>uint16_t</type>
            <default>0xABCD</default>
        </field>
        <field>
            <name>uint32</name>
            <description>Test uint32</description>
            <type>uint32_t</type>
            <default>0xABCDEF01</default>
        </field>
        <field>
            <name>uint64</name>
            <description>Test uint64</description>
            <type>uint64_t</type>
            <default>0xABCDEF0123456789</default>
        </field>
        <field>
            <name>int8</name>
            <description>Test int8</description>
            <type>int8_t</type>
            <default>-124</default>
        </field>
        <field>
            <name>int16</name>
            <description>Test int16</description>
            <type>int16_t</type>
            <default>-32764</default>
        </field>
        <field>
            <name>int32</name>
            <description>Test int32</description>
            <type>int32_t</type>
            <default>-2147483644</default>
        </field>
        <field>
            <name>int64</name>
            <description>Test int64</description>
            <type>int64_t</type>
            <default>-9223372036854775804</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>DECONFIG_GARDABLE</id>
    <description>If the Target is directly deconfigurable and GARDable; target
    may still be deconfigured in 'by association' processing.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>ISTEP_MODE</id>
    <description>If True, puts HostBoot into SPLess SingleStep mode.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <description>Information needed to address the EEPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <description>Information needed to address the EERPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <description>Information needed to address the EERPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <description>Information needed to address the EERPROM slaves</description>
    <complexType>
        <description>Structure to define the addressing for an I2C
                     slave device.</description>
        <field>
            <name>i2cMasterPath</name>
            <description>Entity path to the chip that contains the I2C
                         master</description>
            <type>EntityPath</type>
            <default>physical:sys-0</default>
        </field>
        <field>
            <name>port</name>
            <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>devAddr</name>
            <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>engine</name>
            <description>I2C master engine. This is a 2-bit
                         value.</description>
            <type>uint8_t</type>
            <default>0x80</default>
        </field>
        <field>
            <name>byteAddrOffset</name>
            <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
            <type>uint8_t</type>
            <default>0x02</default>
        </field>
        <field>
            <name>maxMemorySizeKB</name>
            <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writePageSize</name>
            <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
        <field>
            <name>writeCycleTime</name>
            <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
            <type>uint64_t</type>
            <default>0x0</default>
        </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>EC</id>
    <description>attribute indicating the chip target's EC level</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
       <id>ATTR_EC</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_ID</id>
    <description>attribute indicating the chip's ID</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
       <id>ATTR_CHIP_ID</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSI_GP_REG_SCOM_ACCESS</id>
    <description>attribute indicating if the chip's FSI GP regs have scom access</description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
       <id>ATTR_FSI_GP_REG_SCOM_ACCESS</id>
       <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_R_T0_EPS</id>
    <description>L2 tier0 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_R_T0_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_R_T1_EPS</id>
    <description>L2 tier1 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_R_T1_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_R_T2_EPS</id>
    <description>L2 tier2 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_FORCE_R_T2_EPS</id>
    <description>L2 force tier2 read epsilon protect (all tiers).</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_FORCE_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L2_W_EPS</id>
    <description>L2 write epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L2_W_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_R_T0_EPS</id>
    <description>L3 tier0 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_R_T0_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_R_T1_EPS</id>
    <description>L3 tier1 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_R_T1_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_R_T2_EPS</id>
    <description>L3 tier2 read epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_FORCE_R_T2_EPS</id>
    <description>L3 force tier2 read epsilon protect (all tiers).</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_FORCE_R_T2_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>L3_W_EPS</id>
    <description>L3 write epsilon register value.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_L3_W_EPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_UNIT</id>
    <description>A unit (chiplet) 's  offset number within the chip. </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CHIP_UNIT_POS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>POSITION</id>
    <description>Position of target relative to node</description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MBA_PORT</id>
    <description>MBA port this DIMM is connected to</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MBA_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MBA_DIMM</id>
    <description>MBA port DIMM number of this DIMM</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MBA_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CEN_DQ_TO_DIMM_CONN_DQ</id>
    <description>
        Centaur DQ to DIMM connector DQ mapping for a JEDEC DIMM.
        Uint8 value for each Centaur DQ (0-79).
        The value is the corresponding DIMM Connector DQ.
    </description>
    <simpleType>
        <uint8_t>
            <!-- Default is 1:1 mapping, DQ0-DQ0, DQ1-DQ1 etc -->
            <!-- Data will eventually come from MRW -->
            <default>
                0,1,2,3,4,5,6,7,8,9,10,11,12,13,14,15,16,17,18,19,
                20,21,22,23,24,25,26,27,28,29,30,31,32,33,34,35,36,37,38,39,
                40,41,42,43,44,45,46,47,48,49,50,51,52,53,54,55,56,57,58,59,
                60,61,62,63,64,65,66,67,68,69,70,71,72,73,74,75,76,77,78,79
            </default>
        </uint8_t>
        <array>80</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<enumerationType>
    <id>PROC_EPS_TABLE_TYPE</id>
    <description>Enumeration indicating the PROC_EPS_TABLE_TYPE</description>
    <enumerator>
        <name>EPS_TYPE_LE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>EPS_TYPE_HE</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_EPS_TABLE_TYPE</id>
    <description>
        System attribute.
        Processor epsilon table type. Used to calculate the processor nest
        epsilon register values.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_EPS_TABLE_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <description>Enumeration indicating the PROC_FABRIC_PUMP_MODE</description>
    <enumerator>
        <name>MODE1</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>MODE2</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_FABRIC_PUMP_MODE</id>
    <description>
        System attribute.
        Processor SMP Fabric broadcast scope configuration.
        MODE1 = default = chip/group/system/remote group/foreign.
        MODE2 = group/system/remote group/foreign.
        Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FABRIC_PUMP_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_X_BUS_WIDTH</id>
    <description>Enumeration indicating the PROC_X_BUS_WIDTH</description>
    <enumerator>
        <name>W4BYTE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>W8BYTE</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_X_BUS_WIDTH</id>
    <description>
        System attribute.
        Processor SMP X bus width.
        Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_X_BUS_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <description>
        System attribute.
        If all MCS chiplets are in an interleaving group (1=true, 0=false).
        - If true the SMP fabric is setup in normal mode and multiple MCSs
          are grouped (disallowing systems with memory only under 1 MCS
          (i.e. systems with a single C-DIMM))
        - If false the SMP fabric is setup in checkerboard mode.
        Provided by the Machine Readable Workbook.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
        <uint8_t>
            <default>0x00</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ALL_MCS_IN_INTERLEAVING_GROUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FABRIC_NODE_ID</id>
    <description>
        Chip attribute.
        Logical fabric node the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FABRIC_NODE_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FABRIC_CHIP_ID</id>
    <description>
        Chip attribute.
        Logical fabric chip id for this chip (position within the fabric).
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FABRIC_CHIP_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_HAS_SBE</id>
    <description>
        Chip attribute.
        If true, the chip has an SBE and the associated registers.
        Provided by the Machine Readable Workbook.
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CHIP_HAS_SBE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_PROC_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the processor refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PROC_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_PROC_REFCLOCK_KHZ</id>
    <description>
        System attribute.
        The frequency of the processor refclock in KHz.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PROC_REFCLOCK_KHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_MEM_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the memory refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_MEM_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MIN_FREQ_MHZ</id>
    <description>
        System attribute.
        The lowest frequency that a core can be set to in MHz.
        This is the same for all cores in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_FLOOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_PB</id>
    <description>
        System attribute.
        The frequency of a processor's PB chiplet in MHz.
        This is the same for all PB chiplets in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_PB</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_A</id>
    <description>
        System attribute.
        The frequency of a processor's A-bus chiplet in MHz.
        This is the same for all A-bus chiplets in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_A</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_X</id>
    <description>
        System attribute.
        The frequency of a processor's X-bus chiplet in MHz.
        This is the same for all X-bus chiplets in the system.
        Provided by the MRW.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_X</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HUID</id>
    <description>
        Hardware Unit ID
        SSSSNNNNTTTTTTTTiiiiiiiiiiiiiiii
        S=System
        N=Node Number
        T=Target Type (matches TYPE attribute)
        i=Instance/Sequence number of target, relative to node
    </description>
    <simpleType>
        <uint32_t></uint32_t>
        <default>0xFFFFFFFF</default>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>SP_FUNCTIONS</id>
    <description>
      Attribute which describes what the SP is or is not doing in this system
    </description>
    <complexType>
        <description>Structure which defines a system's SP functions.
         Applicable for System target only.  Structure is read-only.
        </description>
        <field>
            <name>baseServices</name>
            <description>
             If this flag is set then mailboxEnabled MUST also be set

             0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD;
             0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>fsiSlaveInit</name>
            <description>
             0b0: SP does not initialize FSI slave logic, Hostboot must;
             0b1: SP does initialize FSI slave logic so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>mailboxEnabled</name>
            <description>
             0b0: There is no SP mailbox support;
             0b1: There is SP mailbox support
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>fsiMasterInit</name>
            <description>
             0b0: SP does not initialize FSI master logic, Hostboot must;
             0b1: SP does initialize FSI master logic so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>hardwareChangeDetection</name>
            <description>
             0b0: SP does not perform hardware change detection, Hostboot must;
             0b1: SP does perform hardware change detection (HCDB) so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>powerLineDisturbance</name>
            <description>
             0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must;
             0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not
            </description>
            <type>uint32_t</type>
            <bits>1</bits>
            <default>1</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint32_t</type>
            <bits>26</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>HB_SETTINGS</id>
    <description>
      Attribute which describes how the SP has configured features in
      Hostboot.
    </description>
    <complexType>
        <description>Structure which defines a system's HB settings.
         Applicable for System target only.
        </description>
        <field>
            <name>traceContinuous</name>
            <description>
            Enable / Disable continuous trace.
                0b0: Continuous trace is disabled.
                0b1: Continuous trace is enabled.
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>traceScanDebug</name>
            <description>
            Override trace debug selection for SCAN component.
                0b0: TRACS entries for SCAN have default behavior.
                0b1: TRACS entries for SCAN are enabled.
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint8_t</type>
            <bits>6</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>CEC_IPL_TYPE</id>
    <description>
      Attribute which describes optional IPL flavors
    </description>
    <complexType>
        <description>Structure which defines a they IPL types
         Applicable for System target only.
        </description>
        <field>
            <name>PostDump</name>
            <description>
            Perform mainstore dump collection. Only valid for MPIPL
                0b0: Do not collect mainstore dump
                0b1: Perform mainstore dump collection
            </description>
            <type>uint8_t</type>
            <bits>1</bits>
            <default>0</default>
        </field>
        <field>
            <name>reserved</name>
            <description>Reserved for future use</description>
            <type>uint8_t</type>
            <bits>7</bits>
            <default>0</default>
        </field>
        </complexType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>


<!-- Begin attributes (4) to test string support -->

<attribute>
    <id>TEST_NULL_STRING</id>
    <description>Test attribute; string with empty default value</description>
    <simpleType>
        <string>
            <default></default>
            <sizeInclNull>10</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>TEST_MIN_STRING</id>
    <description>Test attribute; smallest string possible given size</description>
    <simpleType>
        <string>
            <default>a</default>
            <sizeInclNull>10</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>TEST_MAX_STRING</id>
    <description>Test attribute; largest string possible given size</description>
    <simpleType>
        <string>
            <default>abc</default>
            <sizeInclNull>4</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>TEST_NO_DEFAULT_STRING</id>
    <description>Test attribute; string with no default supplied</description>
    <simpleType>
        <string>
            <sizeInclNull>10</sizeInclNull>
        </string>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!-- End attributes (4) to test string support -->

<attribute>
    <id>VPD_REC_NUM</id>
    <description>Record offset for this target's VPD</description>
    <simpleType>
        <uint16_t>
            <default>0xFFFF</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PEER_TARGET</id>
    <description>Peer target's address of a A/X-bus connection.
                 NULL means address 0 for no peer target. If a
                 target instance overrides the default with the
                 peer target's PHYS_PATH. The target compiler will
                 convert the valid PHYS_PATH string into the runtime
                 virtual address of the peer target instance.
    </description>
    <simpleType>
        <Target_t>
            <default>NULL</default>
        </Target_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PAYLOAD_BASE</id>
    <description>Base address (target HRMOR) of the payload.  Value is in MB.</description>
    <simpleType>
        <uint64_t>
            <default>256</default>
        </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PAYLOAD_ENTRY</id>
    <description>The offset from base address of the payload entry-point.
        Current default is 0x180</description>
    <simpleType>
        <uint64_t>
            <default>0x180</default>
        </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<enumerationType>
    <id>PAYLOAD_KIND</id>
    <description>
        Enumeration indicating what kind of payload is to be started
    </description>
    <enumerator>
        <name>UNKNOWN</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>PHYP</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SAPPHIRE</name>
        <value>2</value>
    </enumerator>
    <enumerator>
        <name>NONE</name>
        <value>3</value>
    </enumerator>
    <default>UNKNOWN</default>
</enumerationType>

<attribute>
    <id>PAYLOAD_KIND</id>
    <description>
        Attribute indicating what kind of payload is to be started.
    </description>
    <simpleType>
        <enumeration>
            <id>PAYLOAD_KIND</id>
        </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hasStringConversion/>
</attribute>

<attribute>
    <id>HB_HRMOR_NODAL_BASE</id>
    <description>Hostboot HRMOR = (HB_HRMOR_NODAL_BASE * node) + offset. </description>
    <!-- This value is set by the FSP.
         Hostboot uses it to find the HRMOR of Hostboot images running on other nodes.
         The value of HB_HRMOR_NODAL_BASE does NOT include the offset -->
    <simpleType>
        <uint64_t>
            <default>0x200000000000</default> <!-- 32TB -->
        </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>FABRIC_TO_PHYSICAL_NODE_MAP</id>
    <description>
        Correlate HDAT node number (physical) to the logical node
        (based on the PIR) that contains the host boot image.
    </description>
    <!-- 8 byte array.  The index is the physical node number. The value
    at that index is the hb instance number, based on the processor PIR, that
    contains or would contain the host boot image if the drawer exists or were
    to exist. Host boot uses this value and HB_HRMOR_NODAL_BASE to calculate
    the HRMOR of the hostboot image for each drawer.
    If the drawer does NOT physically exist then enter a logical node that
    does NOT physically exist.

    It's conceivable that there could be more than one logical node contained
    in a physical drawer, if that is ever the case then the FSP would need to
    modify this attribute to indicate which logical node contains the hostboot
    image for each drawer. -->
    <simpleType>
        <uint8_t>
            <!-- Default is for single node system -->
            <default>0,255,255,255,255,255,255,255</default>
        </uint8_t>
    <array>8</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!--    TARGETING attributes to support mss_setup_bars and proc_setup_bars  -->

<attribute>
  <id>PROC_MEM_BASES</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    Non-mirrored memory base addresses
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
        64-bit RA
        eight independent non-mirrored segments are supported
        (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MEM_SIZES</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    Size of non-mirrored memory regions
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
        for given index value, address space assumed to be contiguous
        from ATTR_PROC_MEM_BASES value at matching index
        eight independent non-mirrored segments are supported
        (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_SIZES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_BASES</id>
  <description>Mirrored memory base addresses
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
      64-bit RA
      four independent mirrored segments are supported
      (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_BASES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_SIZES</id>
  <description>Size of mirrored memory region
    creator: mss_setup_bars
    consumer: proc_setup_bars, platform
    firmware notes:
      for given index value, address space assumed to be contiguous
      from ATTR_PROC_MIRROR_BASES value at matching index
      four independent mirrored segments are supported
      (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array><!--per group-->
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_SIZES</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_L3_BAR1_REG</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    L3 BAR1 register value
    creator: proc_setup_bars
    consumer: winkle image setup procedures
    notes:
          64-bit register value
          SCOM address: 0x1001080B
  </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_L3_BAR1_REG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_L3_BAR2_REG</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    L3 BAR2 register value
    creator: proc_setup_bars
    consumer: winkle image setup procedures
    notes:
      64-bit register value
      SCOM address: 0x10010813
  </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_L3_BAR2_REG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_L3_BAR_GROUP_MASK_REG</id>
  <description>
    read/write HWP attribute mapped to TARGETING
    L3 BAR Group Mask register value
    creator: proc_setup_bars
    consumer: winkle image setup procedures
    notes:
      64-bit register value
      SCOM address: 0x10010816
  </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_L3_BAR_GROUP_MASK_REG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<attribute>
  <id>FREQ_CORE</id>
  <description>
    firmware notes:
      Nominal processor's core DPLL frequency (MHz).
      Default value provided by Machine Readable Workbook.
      This attribute is the current value.
      @note this should be initialized by istep 7.1 proc_a_x_pci_dmi_pll_setup
  </description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_NOT_F_LINK</id>
  <description>
    firmware notes:
      Set IPL time mux/switch between PCIE PHB/F link function
      (one per foreign link)
  </description>
  <simpleType>
      <uint8_t>
          <default>1,1</default>
      </uint8_t>
      <array>2</array>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_NOT_F_LINK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_MCS_GROUPS</id>
    <description>
        Per MCS group number
        Value is index for PROC_MEM_BASES and PROC_MEM_SIZES arrays
        creator: mss_eff_grouping.C
        consumer: HDAT
    </description>
    <simpleType>
        <uint8_t>
            <default>0,0,0,0,0,0,0,0</default>
        </uint8_t>
    <array>8</array><!--per MCS-->
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_MCS_GROUPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== ===== ===== ===== ===== ===== ===== ===== ===== =====
     Memory Map
     The attributes below are defined by the PHYP Memory Map
     documentation owned by Shawn Lambeth

     @todo: RTC:44128 will be used to automatically create this data
     ===== ===== ===== ===== ===== ===== ===== ===== ===== ===== -->

<!-- ===== System Attributes ===== -->

<attribute>
    <id>XSCOM_BASE_ADDRESS</id>
    <description>System XSCOM base address</description>
    <simpleType>
        <uint64_t>
            <!-- 1020TB, 32GB per proc -->
            <default>0x0003FC0000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <description>MCS Inband Scom base address</description>
    <simpleType>
        <uint64_t>
            <default>0x0003E00000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <description>PROC Inband Scom base address</description>
    <simpleType>
        <uint64_t>
            <default>0x0003E00000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MIRROR_BASE_ADDRESS</id>
    <description>System Mirrorable base address</description>
    <simpleType>
        <uint64_t>
            <default>0x0002000000000000</default><!-- 512 TB -->
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <description>Indicate that payload should be placed in mirrored memory.
        Set by the FSP based on the value of the registry key indicating
        the memory mirroring mode.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default> <!-- false -->
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<!-- ===== Processor Chip Attributes ===== -->

<attribute>
    <id>FSP_BASE_ADDR</id>
    <description>Base Address of FSP IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 128GB, 4GB per proc -->
            <default>0x0003FFE000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FSP_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSP_BAR_SIZE</id>
    <description>Size of FSP IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- 4GB per Proc -->
            <default>0x0000000100000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FSP_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FSP_MMIO_MASK_SIZE</id>
    <description>MMIO Mask for FSP IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- @fixme : what is this value? -->
            <default>0x0000000100000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_FSP_MMIO_MASK_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PSI_BRIDGE_BASE_ADDR</id>
    <description>Base Address of PSI Bridge Logic</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 6GB, 1MB per link -->
            <!-- 0x0003FFFE80000000 + 0x100000*procnum -->
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>INTP_BASE_ADDR</id>
    <description>Base Address of Interrupt Presenter</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 2GB, 1MB per proc -->
            <!-- 0x0003FFFF80000000 + 0x100000*procnum -->
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_INTP_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PHB_BASE_ADDRS</id>
    <description>Base Address of PHB Register Space</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 7GB -->
            <!-- 0x0003FFFE40000000 + 0x400000*procnum + 0x100000*phbnum -->
            <default>
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF
            </default>
        </uint64_t>
        <array>4</array><!-- per PHB -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PCI_BASE_ADDRS_64</id>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>4</array><!-- per PHB -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PCI_BASE_ADDRS_32</id>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>4</array><!-- per PHB -->
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>


<attribute>
    <id>MEM_BASE</id>
    <description>Base Address for all mainstore behind this processor</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_MEM_BASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MIRROR_BASE</id>
    <description>Base Address for all mirrored mainstore behind this processor</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_MIRROR_BASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RNG_BASE_ADDR</id>
    <description>Base Address of RNG IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- Starts at 1024TB - 3GB -->
            <!-- 0x0003FFFF40000000 + 0x1000*procnum -->
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RNG_BAR_SIZE</id>
    <description>Size of RNG IO Region</description>
    <simpleType>
        <uint64_t>
            <!-- 4 KB per processor -->
            <default>0x000000000001000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>IMT_BASE_ADDR</id>
    <description>Base Address of In-Memory Trace Region
        Set by FSP-based tooling
    </description>
    <simpleType>
        <uint64_t>
            <default>0xFFFFFFFFFFFFFFFF</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>IMT_BAR_SIZE</id>
    <description>Size of IMT IO Region
        Set by FSP-based tooling
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!-- ===== ===== End Memory Map ===== ===== ===== ===== ===== ===== -->

<attribute>
  <id>PROC_EPS_GB_PERCENTAGE</id>
  <description>
     firmware notes:
        Guardband percentage to apply to baseline epsilon values
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_GB_PERCENTAGE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_EPS_GB_DIRECTION</id>
  <description>
    firmware notes:
      Direction to apply guardband margin (positive/negative)
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_EPS_GB_DIRECTION</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_FABRIC_ASYNC_SAFE_MODE</id>
  <description>
    firmware notes:
      Set to force all asynchronous boundary crossings into safe mode.
  </description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_ASYNC_SAFE_MODE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>FREQ_PCIE</id>
  <description>
    The frequency of a processor's PCI-e bus in MHz.
    This is the same for all PCI-e busses in the system.
    Provided by the MRW.
  </description>
  <simpleType><uint32_t></uint32_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_FREQ_PCIE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>NOMINAL_FREQ_MHZ</id>
    <description>
      The nominal core frequency in MHz.
      This is the same for all cores in the system.
      Provided by the Machine Readable Workbook.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_NOMINAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_FLAGS</id>
    <description>
        Provides the manufacturing flags. This is a bitfield.
        Multiple flags can be set at once. Use MNFG_FLAG_BIT
        to decode. Expected use-case is for FSP to write this
        attribute based on the MNFG component flags and for
        HWSV/Hostboot to read it.
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_FLAGS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MNFG_FLAG</id>
    <description>Enumeration indicating the mnfg flags
        that are set by the user.  The values can be
        combined using a bitwise 'OR'.  The values will
        need to be kept in sync with the FAPI
        enumerator values.  Also the enumeration type
        is used by the ATTR_MNFG_FLAGS attribute.  Should
        note that the MNFG_FLAG values are of type uint32_t
    </description>
    <enumerator>
        <!-- Use default mfg error thresholds and reporting values -->
        <name>THRESHOLDS</name>
        <value>0x00000001</value>
    </enumerator>
    <enumerator>
        <!-- Enable AVP execution -->
        <name>AVP_ENABLE</name>
        <value>0x00000002</value>
    </enumerator>
    <enumerator>
        <!-- Enable HDAT AVPs** -->
        <name>HDAT_AVP_ENABLE</name>
        <value>0x00000004</value>
    </enumerator>
    <enumerator>
        <!-- All SRCs are terminating (CEC hardware/procedural) -->
        <name>SRC_TERM</name>
        <value>0x00000008</value>
    </enumerator>
    <enumerator>
        <!-- Enable IPL memory diagnostics to report memory CE -->
        <name>IPL_MEMORY_CE_CHECKING</name>
        <value>0x00000010</value>
    </enumerator>
    <enumerator>
        <!-- Enable Fast Background Scrub -->
        <name>FAST_BACKGROUND_SCRUB</name>
        <value>0x00000020</value>
    </enumerator>
    <enumerator>
        <!-- Test DRAM Repairs -->
        <name>TEST_DRAM_REPAIRS</name>
        <value>0x00000040</value>
    </enumerator>
    <enumerator>
        <!-- Disable Dram Repairs -->
        <name>DISABLE_DRAM_REPAIRS</name>
        <value>0x00000080</value>
    </enumerator>
    <enumerator>
        <!-- Enable exhaustive pattern test -->
        <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
        <value>0x00000100</value>
    </enumerator>
    <enumerator>
        <!-- Enable standard pattern test -->
        <name>ENABLE_STANDARD_PATTERN_TEST</name>
        <value>0x00000200</value>
    </enumerator>
    <enumerator>
        <!-- Enable minimum pattern test -->
        <name>ENABLE_MINIMUM_PATTERN_TEST</name>
        <value>0x00000400</value>
    </enumerator>
    <enumerator>
        <!-- Disable Fabric eRepair -->
        <name>DISABLE_FABRIC_eREPAIR</name>
        <value>0x00000800</value>
    </enumerator>
    <enumerator>
        <!-- Disable Memory eRepair -->
        <name>DISABLE_MEMORY_eREPAIR</name>
        <value>0x00001000</value>
    </enumerator>
    <enumerator>
        <!-- Fabric deploy lane spares -->
        <name>FABRIC_DEPLOY_LANE_SPARES</name>
        <value>0x00002000</value>
    </enumerator>
    <enumerator>
        <!-- DMI deploy lane spares -->
        <name>DMI_DEPLOY_LANE_SPARES</name>
        <value>0x00004000</value>
    </enumerator>
    <enumerator>
        <!-- Forcibly run PSI diagnostics -->
        <name>PSI_DIAGNOSTIC</name>
        <value>0x00008000</value>
    </enumerator>
    <enumerator>
        <!-- Brazos Wrap Config -->
        <name>BRAZOS_WRAP_CONFIG</name>
        <value>0x00010000</value>
    </enumerator>
    <enumerator>
        <!-- FSP is responsible for updating Processor SBE Image -->
        <name>FSP_UPDATE_SBE_IMAGE</name>
        <value>0x00020000</value>
    </enumerator>
</enumerationType>

<!-- Support for pm_hwp_attributes.xml -->

<attribute>
    <id>PROC_DPLL_DIVIDER</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_DPLL_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_POWER_PROXY_TRACE_TIMER</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_POWER_PROXY_TRACE_TIMER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PPT_TIMER_MATCH_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PPT_TIMER_MATCH_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PPT_TIMER_TICK</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PPT_TIMER_TICK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_AISS_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_AISS_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PSTATE_STEPSIZE</id>
    <description>
      PROC_CHIP Attribute

Used to setup the PMC voltage controller

Producer: proc_build_pstate_tables.C

Consumer: OCC pstate_init()
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PSTATE_STEPSIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_EXTERNAL_VRM_STEPDELAY_RANGE</id>
    <description>
      PROC_CHIP Attribute

A 4 bit field  selects one of the the upper 16bit of a 19bit counter (16+3) incremented in the nest/4 domain

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_EXTERNAL_VRM_STEPDELAY_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_EXTERNAL_VRM_STEPDELAY_VALUE</id>
    <description>
      PROC_CHIP Attribute

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_EXTERNAL_VRM_STEPDELAY_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PMC_HANGPULSE_DIVIDER</id>
    <description>
      PROC_CHIP Attribute

Producer:  proc_pm_init

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PMC_HANGPULSE_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PVSAFE_PSTATE</id>
    <description>
      PROC_CHIP Attribute
Pstate that is invoked in the PMC voltage controller upon the loss of the OCC Heartbeat..

Producer:  proc_pm_init.C

Consumer: proc_pm.scominit
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PVSAFE_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_FRAME_SIZE</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x20 (32d)

Chip Select assertion duration is spi_frame_size + 2
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_FRAME_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_IN_DELAY_FRAME1</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x00 to spi_frame_size.  Values beyond spi_frame_size result in the input never being captured
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_IN_DELAY_FRAME1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_IN_DELAY_FRAME2</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x00 to spi_frame_size.  Values beyond spi_frame_size result in the input never being captured
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_IN_DELAY_FRAME2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CLOCK_POLARITY</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CLOCK_POLARITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CLOCK_PHASE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CLOCK_PHASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CLOCK_DIVIDER</id>
    <description>
      PROC_CHIP Attribute
For a 2.4GHz nest clock, this means that the SPI clk can be theoretically adjusted between 600MHz and 0.29MHz (cycle time 1.66ns...3.41us, in 1.66ns steps). However, a practical range is 0.5...25MHz.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CLOCK_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS</id>
    <description>
      PROC_CHIP Attribute
Consumer: proc_pmc_init
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS_VALUE</id>
    <description>
      PROC_CHIP Attribute

Delay is computed as:  (value * ~100ns_hang_pulse)  +0/-~100ns_hang_pulse time

0x00000: Wait 1 SPI Clock
0x00001 - 0x1FFFF: value = number of ~100ns_hang_pulses

For values greater than 0x00000, the actual delay is 1 SPI Clock + the time delay designated by the value defined. Max. delay at 0x1FFFF: 13.1ms + 1 SPI clock cycle.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTERFRAME_DELAY_WRITE_STATUS_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTER_RETRY_DELAY_VALUE</id>
    <description>
      PROC_CHIP Attribute

Delay is computed as:  (value * ~100ns_hang_pulse)  +0/-~100ns_hang_pulse time

0x0000: Wait 1 SPI Clock
0x0001 - 0xFFFF: value = number of ~100ns_hang_pulses

For values greater than 0x00000, the actual delay is 1 SPI Clock + the time delay designated by the value defined. Max. delay at 0x1FFFF: 13.1ms + 1 SPI clock cycle.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTER_RETRY_DELAY_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_INTER_RETRY_DELAY</id>
    <description>
      PROC_CHIP Attribute
Consumer: proc_pmc_init
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_INTER_RETRY_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CRC_GEN_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CRC_GEN_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CRC_CHECK_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CRC_CHECK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_MAJORITY_VOTE_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_MAJORITY_VOTE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_MAX_RETRIES</id>
    <description>
      PROC_CHIP Attribute

0x00: No retry
0x01 to 0x1F: 1 to 31 respectively
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_MAX_RETRIES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_CRC_POLYNOMIAL_ENABLES</id>
    <description>
      PROC_CHIP Attribute

An 8 bit mask vector to enable XORs in the CRC generation and checking LFSRs at the respective bit position. MSB (x^8) is omitted since it is always enabled, so the mask layout is (x^7,x^6,x^5,x^4,x^3,x^2,x^1,1)

Planned CRC8 polynomial: x^8 + x^7 + x^6 + x^4 + x^2 + 1
Value to enable planned polynomial: 0b1101_0101 (=0xD5)
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_CRC_POLYNOMIAL_ENABLES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_OCC_HEARTBEAT_TIME</id>
    <description>
      PROC_CHIP Attribute
Consumer: OCC FW
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_OCC_HEARTBEAT_TIME</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_WINKLE_REQUEST_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute

Consumer: proc_pmc_init.C.  Will be translated to a DYNAMIC ATTRIBUTE for use by proc_pm..scominit  as a multiple of PM hang pulses.. Counter starts at 0, is increased with every tp_pmc_hang_pulse as long as PORE is busy and set the PMC local FIR bit 19 when count = threshold.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_WINKLE_REQUEST_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_ENTRY</id>
    <description>
      PROC_CHIP Attribute

Set Assisted if power off serialization is needed and SLEEP_TYPE=Fast;  Set to Hardware if the system can handle the unrelated powering off between cores.  Hardware setting decreases entry latency

Producer: MRWB

Consumer:  proc_pm_init and proc_pcbs_init
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_ENTRY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_EXIT</id>
    <description>
      PROC_CHIP Attribute

Set to Assisted if power on serialization is needed and SLEEP_TYPE=Fast;  Set to Hardware if the system can handle the unrelated powering off between cores.  Hardware setting decreases entry latency
Must be set to Assisted if ATTR_PM_SLEEP_TYPE=Deep as this necessary for restore.

Setting to Hardware is a test mode for Fast only.

Producer: MRWB

Consumer:  proc_pm_init and proc_pcbs_init.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_EXIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLEEP_TYPE</id>
    <description>
      PROC_CHIP Attribute
Selects which voltage level to place the Core domain PFETs upon Sleep entry. 0 = Vret (Fast Sleep Mode), 1 = Voff (Deep Sleep Mode)

Producer: MRWB

Consumer:  proc_pm_init and proc_pcbs_init
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLEEP_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_WINKLE_TYPE</id>
    <description>
      PROC_CHIP Attribute
Selects which voltage level to place the Core and ECO domain PFETs upon Winkle entry. 0 = Vret (Fast Winkle Mode), 1 = Voff (Deep Winkle Mode)
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_WINKLE_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_CORE_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute

0 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY0;

1 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY1
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_CORE_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_CORE_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute

0 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY0;

1 in the bit position:  use ATTR_PM_PFET_POWERUP_CORE_DELAY1
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_CORE_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERUP_ECO_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute

0 in the bit position:  use ATTR_PM_PFET_POWERUP_ECO_DELAY0;

1 in the bit position:  use ATTR_PM_PFET_POWERUP_ECO_DELAY1
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERUP_ECO_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY0</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY1</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY0_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY0_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_DELAY1_VALUE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_DELAY1_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PFET_POWERDOWN_ECO_SEQUENCE_DELAY_SELECT</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PFET_POWERDOWN_ECO_SEQUENCE_DELAY_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PSTATE0_FREQUENCY</id>
    <description>
      PROC_CHIP Attribute

Producer: proc_build_gpstate.C

Consumers: proc_pcbs_init.C, proc_pcbs_lpst_init.C,
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PSTATE0_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_IVRMS_ENABLED</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_IVRMS_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SAFE_PSTATE</id>
    <description>
      PROC_CHIP Attribute

Valid Values:-128 thru 127

Producer: proc_pm_init.C

DYNAMIC_ATTRIBUTE

Consumer: proc_pcbs_init.C

Establishes the Pstate that the core chiplet will take on if:
psafe less-than-or-equal PMSR[global_actual_pstate]
AND any of the following conditions are true:
Loss of OCC Heartbeat if occ_heartbeat_en is set
PMGP0[force_safe_mode] is set

If psafe greater-than PMSR[global_actual_pstate], the  global_actual_pstate is forced.

The value of Psafe needs to be at or below the nominal Pstate to make sure safe operation of all chiplets.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SAFE_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_ENABLE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_FULL_CSB_PSTATE</id>
    <description>
      PROC_CHIP Attribute
Defines the Pstate for the point at which clock sector buffers should be at full strength.  This is to support Vmin operation.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_FULL_CSB_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LFRLOW_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LFRLOW_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LFRUPPER_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LFRUPPER_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HFRLOW_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HFRLOW_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HFRHIGH_PSTATE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HFRHIGH_PSTATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_FRAME_SIZE</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x10 (16d),

Chip Select assertion duration is spi_frame_size + 2
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_FRAME_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_OUT_COUNT</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x000 to spi_frame_size.  Values beyond spi_frame_size are ignored.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_OUT_COUNT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_IN_DELAY</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x000 to spi_frame_size.  Values beyond spi_frame_size result in the input never being captured
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_IN_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_IN_COUNT</id>
    <description>
      PROC_CHIP Attribute

Supported values: 0x000 to spi_frame_size.  The actual number of bits captured is spi_frame_size - spi_in_delay
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_IN_COUNT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_CLOCK_POLARITY</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_CLOCK_POLARITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_CLOCK_PHASE</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_CLOCK_PHASE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_CLOCK_DIVIDER</id>
    <description>
      PROC_CHIP Attribute
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_CLOCK_DIVIDER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_INTER_FRAME_DELAY_SETTING</id>
    <description>
      PROC_CHIP Attribute
Delay is computed as:  (value * ~100ns_hang_pulse)  +0/-~100ns_hang_pulse time

0x00000: Wait 1 PSS Clock
0x00001 - 0x1FFFF: value = number of ~100ns_hang_pulses

For values greater than 0x00000, the actual delay is 1 PSS Clock + the time delay designated by the value defined. Max. delay at 0x1FFFF: 13.1ms + 1 PSSI clock cycle.

Producer: proc_pm_init

Consumer: proc_pss_init
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_INTER_FRAME_DELAY</id>
    <description>
      PROC_CHIP Attribute

Consumer: proc_pm_init

Produces ATTR_PM_SPIPSS_INTER_FRAME_DELAY_SETTING
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_INTER_FRAME_DELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_RCV_RESERV_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute
Divider for the 1us PBAX hang pulse.  A hang is detected after two divided hang pulses are received under the following conditions:
 Data Hi packet accepted and timeout waiting for Data Lo packet.
 Reservation aquired and timeout waiting for Data Hi packet.

00000  Data Timeout is Disabled
00001  divided hang pulse = PBAX hang pulse
00010  divided hang pulse = PBAX hang pulse/2
00011  divided hang pulse = PBAX hang pulse/3
. . .
11111   divided hang pulse = PBAX hang pulse/31
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_RCV_RESERV_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_SND_RETRY_COUNT_OVERCOMMIT_ENABLE</id>
    <description>
      PROC_CHIP Attribute
Mode bit to count overcommit retries for the send retry threshold when sending PBAX commands on the powerbus.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_SND_RETRY_COUNT_OVERCOMMIT_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_SND_RETRY_THRESHOLD</id>
    <description>
      PROC_CHIP Attribute
Defines the maximum number of retry attempts by the Send Engine for any phase of the PBAX transaction set before the operation is dropped and status bit are set.  This does not count PowerBus overcommit retries unless snd_retry_count_overcom bit is set.

0x00 :  No Timeout
0x01 :  1 attempt
0x02 :   2 attempts
.etc.
0xFF :  255 attempts
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_SND_RETRY_THRESHOLD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_SND_RESERV_TIMEOUT</id>
    <description>
      PROC_CHIP Attribute
Divider for the 1us PBAX hang pulse.  A hang is detected after two divided hang pulses are received after attempting to acquire a reservation with the PBAX Receive engine before declaring a Send Reservation Timeout error.

00000  Send Reservation Timeout is Disabled
00001  divided hang pulse = PBAX hang pulse
00010  divided hang pulse = PBAX hang pulse/2
00011  divided hang pulse = PBAX hang pulse/3
. . .
11111   divided hang pulse = PBAX hang pulse/31
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_SND_RESERV_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_FSP</id>
    <description>
      EX_CHIPLET Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_FSP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_OCC</id>
    <description>
      EX_CHIPLET Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_OCC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_PHYP</id>
    <description>
      EX_CHIPLET Attribute
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_PHYP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLW_CONTROL_VECTOR_OFFSET</id>
    <description>
    Stores the offset in SLW image of this control vector for later use by scripts to control error injection.
    This value is added to the contents of PBABAR2 for given chip to calculated the memory address for this vector per chip.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLW_CONTROL_VECTOR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- End pm_hwp_attributes.xml -->


<!-- Support for pm_plat_attributes.xml -->

<attribute>
    <id>PM_EXTERNAL_VRM_STEPSIZE</id>
    <description>
      SYSTEM Attribute
      Step size (binary in microvolts) to take upon external VRM voltage
      transitions. The value set here must take into account where internal
      VRMs are enabled or not as, when they are enabled, the step size must
      account for the tracking (eg PFET strength recalculation) for the step.

      Consumer: proc_build_pstate_tables.C, proc_pmc_init.C -config

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_EXTERNAL_VRM_STEPSIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_EXTERNAL_VRM_STEPDELAY</id>
    <description>
      SYSTEM Attribute
      Step delay (binary in microseconds) after a voltage change

      Consumer: proc_pmc_init -config

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_EXTERNAL_VRM_STEPDELAY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      SPI Clock Frequency (binary in MHz)

      Consumer: proc_pm_effective

      Produces ATTR_PM_SPIVID_CLOCK_DIVIDER

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIVID_PORT_ENABLE</id>
    <description>
      PROC_CHIP Attribute
      Defines the configuration of the SPIVID ports from the target.
      - NONE means that no VRM is attached.
      - PORTxNONRED means that the indicated port is used in a non-redundant
                    configuration.
      - REDUNDANT means that all three are connected and considered redundant.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIVID_PORT_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SAFE_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Indicates the frequency that the cores will be moved to in the event of
      the loss of the OCC Heartbead.  This value needs to be at or below the
      nominal frequency to make sure safe operation of all chiplets.

      Valid Values:-128 thru 127

      The value is translated to the Pstate space.

      Consumer: proc_pm_effective.C

      DYNAMIC_ATTRIBUTE: ATTR_PM_SAFE_PSTATE

      Consumer: proc_pcbs_init.C

      Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SAFE_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz) for the point at which clock sector buffers
      should be at full strength.  This is to support Vmin operation.
      Setting cannot overlap the Low or High bands.

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_FULL_CLOCK_SECTOR_BUFFER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LOW_BAND_LOWER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz)) for the lower end of the Low Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LOW_BAND_LOWER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_LOW_BAND_UPPER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz) for the upper end of the Low Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_LOW_BAND_UPPER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HIGH_BAND_LOWER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz) for the lower end of the High Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HIGH_BAND_LOWER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_RESONANT_CLOCK_HIGH_BAND_UPPER_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      Frequency (binary in MHz)) for the upper end of the High Frequency
      Resonant band

      Provided by the Machine Readable Workbook after system characterization.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_RESONANT_CLOCK_HIGH_BAND_UPPER_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPIPSS_FREQUENCY</id>
    <description>
      SYSTEM Attribute
      SPIPSS Clock Frequency (binary in MHz)

      Valid range: 0.5MHz to 25MHz

      Consumer: proc_pmc_init

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPIPSS_FREQUENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_APSS_CHIP_SELECT</id>
    <description>
      PROC_CHIP Attribute
      Defines which of the PSS chip selects that the APSS is connected

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_APSS_CHIP_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_NODEID</id>
    <description>
      PROC_CHIP Attribute
      Receive PBAX Nodeid. Value that indicates this PBA's PBAX Node affinity.
      This is matched to pbax_nodeid of the PMISC Address phase.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_NODEID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_CHIPID</id>
    <description>
      PROC_CHIP Attribute
      Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within
      the PBAX node.  Is matched to pbax_chipid of the Address phase if
      pbax_type=unicast.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_CHIPID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PBAX_BRDCST_ID_VECTOR</id>
    <description>
      PROC_CHIP Attribute
      Receive PBAX Broadcast Group. Vector that is indexed when decoded PMISC
      pbax_type=broadcast with the decoded PMISC pbax_chipid value.  If the
      bit in this vector at the decoded bit location is a 1, then this receive
      engine will participate in the broadcast operation.

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PBAX_BRDCST_ID_VECTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FREQ_CORE_MAX</id>
    <description>
      SYSTEM Attribute
      Maximum frequency (binary in MHz) that any processor in the system will
      run. Used to define the top end of the PState range in the frequency space.
      From this, the ATTR_PROCPM_PSTATE0_FREQUENCY is computed using
      ATTR_SYSTEM_REFCLK_FREQUENCY to determine the step size.

      Consumers: proc_build_gpstate_table.C (among others)

      Set by the HWSV freq/voltage service based on MVPD #V
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_FREQ_CORE_MAX</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- End pm_plat_attributes.xml -->

<attribute>
    <id>OVERRIDE_MVPD_NOM_FREQ_MHZ</id>
   <description>Module VPD #V keyword Nominal Frequency in MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_NOM_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_NOM_VOLTAGE</id>
    <description>Module VPD #V keyword V-nest nominal voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_NOM_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_NOM_CURRENT</id>
    <description>Module VPD #V keyword I-nest nominal current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_NOM_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_NOM_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs nominal voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_NOM_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_NOM_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs nominal current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_NOM_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_PS_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword PowerSave Frequency in MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_PS_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_PS_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest powersave voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_PS_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_PS_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest powersave current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_PS_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_PS_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs powersave voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_PS_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_PS_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs powersave current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_PS_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_TURBO_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword turbo frequency in MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_TURBO_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_TURBO_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest turbo voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_TURBO_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_TURBO_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest turbo current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_TURBO_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_TURBO_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs turbo voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_TURBO_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_TURBO_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs turbo current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_TURBO_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<attribute>
    <id>OVERRIDE_MVPD_FVMIN_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword fvmin frequency MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_FVMIN_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_FVMIN_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest fvmin voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_FVMIN_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_FVMIN_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest fvmin current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_FVMIN_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_FVMIN_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs fvmin voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_FVMIN_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_FVMIN_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs fvmin current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_FVMIN_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_LAB_FREQ_MHZ</id>
    <description>
    Module VPD #V keyword lab frequency MHZ
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_LAB_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_NEST_LAB_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-nest lab voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_NEST_LAB_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_NEST_LAB_CURRENT</id>
    <description>
    Module VPD #V keyword I-nest lab current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_NEST_LAB_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_V_CS_LAB_VOLTAGE</id>
    <description>
    Module VPD #V keyword V-cs lab voltage
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_V_CS_LAB_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>OVERRIDE_MVPD_I_CS_LAB_CURRENT</id>
    <description>
    Module VPD #V keyword I-cs lab current
consumer: p8_build_pstate_datablock, others
firmware notes: Used as override attribute for pstate procedure
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_OVERRIDE_MVPD_I_CS_LAB_CURRENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_CONFIG</id>
  <description>PCIE IOP lane configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP lane configuration
  </description>
  <simpleType><uint8_t></uint8_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_SWAP</id>
  <description>PCIE IOP swap configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP swap configuration
        Array index: IOP number (0:1)
  </description>
  <simpleType>
      <uint8_t></uint8_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_SWAP</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_PHB_ACTIVE</id>
  <description>PCIE PHB valid mask
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Bit mask defining set of active/valid PHBs
        bit0=PHB0, bit1=PHB1, bit2=PHB2
  </description>
  <simpleType><uint8_t></uint8_t></simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PHB_ACTIVE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_G3_PLL_CONTROL0</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      firmware notes:
        PCIe Gen3 PLL Control Register 0.
        ATUNE/CPISEL.
        Array index: IOP number(0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_G3_PLL_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_G2_PLL_CONTROL0</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      firmware notes:
        PCIe Gen2/Gen1 PLL Control Register 0.
        ATUNE/CPISEL.
        Array index: IOP number(0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_G2_PLL_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PLL_GLOBAL_CONTROL0</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe PLL Global Control Register 0.
        REFISRC/REFISINK.
        Array index: IOP number (0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PLL_GLOBAL_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PLL_GLOBAL_CONTROL1</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe PLL Global Control Register 1.
    ENBGDOCPSRC/ENBGDOCAMP/REFVREG.
        Array index: IOP number (0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PLL_GLOBAL_CONTROL1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PCS_CONTROL0</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe PCS Control Register 0.
        BITLOCKTIME/ADDDREMDELTA_810_B/STARTUPDELTA_810_B/ADDDREMDELTA_810_A/
        STARTUPDELTA_A/RXREJECTHANDLING/EQCOMLETERESPONSE.
        Array index: IOP number (0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PCS_CONTROL0</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_PCS_CONTROL1</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe PCS Control Register 1.
    RXSIGDETSETTING/ADDDREMDELTA_128130_B/STARTUPDELTA_128130_B/
        ADDDREMDELTA_128130_A/STARTUPDELTA_128130_A.
        Array index: IOP number (0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_PCS_CONTROL1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_FIFO_OFFSET</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe TX FIFO Offset Register.
    G3OFFSET/G2OFFSET/G1OFFSET.
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_FIFO_OFFSET</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_RCVRDETCNTL</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe TX Receiver Detect Control Register.
        VREFSEL/RCVRDETCNT/DETDRVC/PH1WAIT.
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_RCVRDETCNTL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_BWLOSS1</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe TX Bandwidth Loss Coefficient Register.
        GEN3BWCOEFF/GEN2BWCOEFF/GEN1BWCOEFF.
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_BWLOSS1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_RX_VGA_CONTROL2</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe RX VGA Control Register 2.
        GAIN2/GAIN1.
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_RX_VGA_CONTROL2</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_RX_PEAK</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe RX Receiver Peaking Value Register.
    PEAK1/PEAK2/PEAK3.
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_RX_PEAK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_RX_SDL</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe RX Signal Detect Level Register.
        SDLVL3/SDLVL2/SDLVL1.
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_RX_SDL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_ZCAL_CONTROL</id>
  <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe ZCAL Control Register.
        CMPEVALDLY.
        Array index: IOP number (0:1)
  </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_ZCAL_CONTROL</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VMEM_ID</id>
    <description>Voltage Memory Rail Manager ID.  Currently HB only needs
        to configured the Vmem voltage rail manger during the IPL.  The ID
        is an arbitary value and needed as correlation token between HB and
        HWSV.  It will be generated by the genHwsvMrwXml.pl.
    </description>
    <simpleType>
        <uint16_t>
            <default>0</default>
        </uint16_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!--    Add attributes for sbe_config_update    -->

<attribute>
<id>NEST_FREQ_MHZ</id>
<description>
    Nest frequency in MHz
    Default should be 2000 MHz per Greg Still
</description>
    <simpleType>
        <uint32_t>
            <default>2000</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_NEST_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CHIP_REGIONS_TO_ENABLE</id>
    <description>
      Called to get data to customize an IPL or SLW image with data indicating
        which chip regions the SBE should enable
      The data is in the format of the Module VPD PG (Partial Good Vector)
        keyword which is an 32 entry array of 16bit words, each word
        represents a chiplet and a defined set of bits within the word
        represents regions that are good. The 16 bit word is embedded within
        a 64bit word as described in the MVPD spec to reflect the clock
        controller region register layout:
          bits 0:3 are reserved -> set to 0
          bits 4:19 are the 16 bit data word
          bits 20:63 are reserved -> set to 0
      A platform needs to return data indicating the chip regions to enable,
      this may not be just the MVPD partial-good data, it may also not enable
      other chips and chiplets it has decided are non-functional - this is
      why it is not a standard MVPD query.
    </description>
    <simpleType>
        <uint64_t></uint64_t>
        <array>32</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CHIP_REGIONS_TO_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>BOOT_FREQ_MHZ</id>
    <description>
       Boot frequency in MHZ.  Default is 50% of nominal.
    </description>
    <simpleType>
        <uint32_t>
            <default>2400</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_BOOT_FREQ_MHZ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EX_GARD_BITS</id>
    <description>
      Vector to communicate the guarded EX chiplets to SBE
            One Guard bit per EX chiplet, bit location aligned to chiplet ID
      (bit 16: EX00, bit 17: EX01, bit 18: EX02 ... bit 31: EX15)
            Guarded EX chiplets are marked by a '1'.
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EX_GARD_BITS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>PIB_I2C_REFCLOCK</id>
<description>
    i2c reference clock for the system.
    default is 0x4 => I2C speed = ~1Mhz per Andreas Koenig
</description>
    <simpleType>
        <uint32_t>
            <default>0x4</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIB_I2C_REFCLOCK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_ADU_UNTRUSTED_BAR_BASE_ADDR</id>
    <description>
      ADU Untrusted BAR base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_ADU_UNTRUSTED_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>PIB_I2C_NEST_PLL</id>
<description>
    i2c pll for the system
    default is 0x26 (For PIB @500 MHz (2 GHz nest)) for
    I2C speed = ~1Mhz per Andreas Koenig.
</description>
    <simpleType>
        <uint32_t>
            <default>0x026</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PIB_I2C_NEST_PLL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_ADU_UNTRUSTED_BAR_SIZE</id>
    <description>
      ADU Untrusted BAR size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 14:43
    </description>
    <simpleType>
        <uint64_t>
            <!-- 64Mb -->
            <default>0x0000000004000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_ADU_UNTRUSTED_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>SBE_IMAGE_OFFSET</id>
<description>
    HostBoot image for SBE, offset to account for ECC
    Default is calculated from Hostboot base image of 0x3ece000
</description>
    <simpleType>
        <uint32_t>
            <default>0xffef0000</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_IMAGE_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_IMAGE_MINIMUM_VALID_EXS</id>
    <description>
      The minimum number of valid EXs that is required to be used when
      customizing a SBE image. The customization will fail if it cannot
      create an image with at least this many EXs.
    </description>
    <simpleType>
        <uint32_t>
            <default>3</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_IMAGE_MINIMUM_VALID_EXS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR0_BASE_ADDR</id>
    <description>
      PSI Untrusted BAR0 base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR0_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
<id>BOOT_VOLTAGE</id>
<description>
    Boot Voltage for system.
    0:2   -> port enables (3b - system design based:
        port 0 for non-redundant systems (100); all ports for non-redundant (111))
    3     -> Unused
     - current recommended default = 1000b
    4:7   -> phase enables (4b - defined by the system power design)
    - current recommended default = 0000b
    8:15  -> VDD voltage (1B in VRM-11 encoded form - 6.25mV increments)
        note: VPD is in 5mV increments
    - current recommended default   =   0x52
    16:23 -> VCS voltage (1B in VRM-11 encoded form - 6.25mV increments)
        note: VPD is in 5mV increments
    -current recommended default    =   0x4a
    24:31 -> Unused                 =   0x00
</description>
    <simpleType>
        <uint32_t>
            <default>0x80524a00</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_BOOT_VOLTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR0_SIZE</id>
    <description>
      PSI Untrusted BAR0 size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 14:43
    </description>
    <simpleType>
        <uint64_t>
            <!-- 64Mb -->
            <default>0x0000000004000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR0_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR1_BASE_ADDR</id>
    <description>
      PSI Untrusted BAR1 base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR1_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PSI_UNTRUSTED_BAR1_SIZE</id>
    <description>
      PSI Untrusted BAR1 size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 14:43
    </description>
    <simpleType>
        <uint64_t>
            <!-- 64Mb -->
            <default>0x0000000004000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PSI_UNTRUSTED_BAR1_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_SECURITY_SETUP_VECTOR</id>
    <description>
      Secureboot 64-bit proc_sbe_security_setup_vector used
      by proc_sbe_security_setup.S. 0s are an unsecure SBE image
      creator: platform
      firmware notes:
      64-bit proc_sbe_security_setup_vector
    </description>
    <simpleType>
        <uint64_t>
            <default>0x0000000000000000</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_SECURITY_SETUP_VECTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== Attributes supporting memory_attributes.xml HWPF Attributes ===== -->

<attribute>
    <id>MSS_VOLT</id>
    <description>DRAM Voltage. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_VOLT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_FREQ</id>
    <description>Frequency of memory channel in MHz. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_FREQ</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MFG_ID_CODE</id>
    <description>DIMM Manufacturer ID Code. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MFG_ID_CODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RANKS_CONFIGED</id>
    <description>DIMM ranks configured. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RANKS_CONFIGED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_RANKS_PER_DIMM</id>
    <description>Number of ranks per DIMM. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_RANKS_PER_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_TYPE</id>
    <description>Type of DIMM. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CUSTOM_DIMM</id>
    <description>DIMM is a custom DIMM. Sometimes this is known as a CDIMM, but technically, we could support Custom DIMMs of different types than an UDIMM, such as RDIMM and LRDIMM.  Created in mss_eff_cnfg</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CUSTOM_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WIDTH</id>
    <description>DRAM Device Width. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_GEN</id>
    <description>DRAM Generation. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_GEN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP0</id>
    <description>Primary RankGroup0. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP1</id>
    <description>Primary RankGroup1. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP2</id>
    <description>Primary RankGroup2. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PRIMARY_RANK_GROUP3</id>
    <description>Primary RankGroup3. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PRIMARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP0</id>
    <description>Secondary RankGroup0. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP1</id>
    <description>Secondary RankGroup1. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP2</id>
    <description>Secondary RankGroup2. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SECONDARY_RANK_GROUP3</id>
    <description>Secondary RankGroup3. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SECONDARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP0</id>
    <description>Tertiary RankGroup0. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP1</id>
    <description>Tertiary RankGroup1. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP2</id>
    <description>Tertiary RankGroup2. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TERTIARY_RANK_GROUP3</id>
    <description>Tertiary RankGroup3. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TERTIARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP0</id>
    <description>Quaternary RankGroup0. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP1</id>
    <description>Quaternary RankGroup1. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP2</id>
    <description>Quaternary RankGroup2. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_QUATERNARY_RANK_GROUP3</id>
    <description>Quaternary RankGroup3. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_QUATERNARY_RANK_GROUP3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603. These termination data EFF attributes have corresponding
     VPD attributes that come from CVPD. When all HWPs are using the VPD
     versions, these EFF versions can be deleted -->

<attribute>
    <id>EFF_ODT_RD</id>
    <description>Rank Read ODT. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_ODT_RD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_ODT_WR</id>
    <description>Rank Write ODT. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_ODT_WR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RON</id>
    <description>DRAM Ron. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RON</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RTT_NOM</id>
    <description>DRAM Rtt_Nom. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RTT_NOM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RTT_WR</id>
    <description>DRAM Rtt_WR. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RTT_WR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR_VREF</id>
    <description>DRAM Write Vref. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WRDDR4_VREF</id>
    <description>DRAM Write Vref for DDR4. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WRDDR4_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_DQ_DQS</id>
    <description>Centaur DQ and DQS Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_DQ_DQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_ADDR</id>
    <description>Centaur Address Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CNTL</id>
    <description>Centaur Control Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CLK</id>
    <description>Centaur Clock Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CLK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_SPCKE</id>
    <description>Centaur Spare Clock Drive Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_SPCKE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RCV_IMP_DQ_DQS</id>
    <description>Centaur DQ and DQS Receiver Impedance. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RCV_IMP_DQ_DQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_DQ_DQS</id>
    <description>Centaur DQ and DQS Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_DQ_DQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_ADDR</id>
    <description>Centaur Address Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CLK</id>
    <description>Centaur Clock Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CLK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_SPCKE</id>
    <description>Centaur Spare Clock Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_SPCKE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CNTL</id>
    <description>Centaur Control Slew Rate. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CNTL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RD_VREF</id>
    <description>Centaur Read Vref. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RD_VREF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603 down to here -->

<attribute>
    <id>EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CLK_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_SPCKE_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_DRV_IMP_CNTL_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO</id>
    <description>Enables for which impedance values can be used and tested in a timing test. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CLK_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_SPCKE_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_ADDR_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_SLEW_RATE_CNTL_SCHMOO</id>
    <description>Slew Rates that can be selected during timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR_VREF_SCHMOO</id>
    <description>Enables for which VREF to use on the WR Schmoo. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR_VREF_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WRDDR4_VREF_SCHMOO</id>
    <description>Enables for which VREF to use on the WR Schmoo for DDR4. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_RD_VREF_SCHMOO</id>
    <description>Enables for which VREF value can be used in timing adjustments. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_RD_VREF_SCHMOO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_SIZE</id>
    <description>DIMM Size. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_BANKS</id>
    <description>Number of DRAM banks. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_BANKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ROWS</id>
    <description>Number of DRAM rows. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_ROWS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_COLS</id>
    <description>Number of DRAM columns. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_COLS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DENSITY</id>
    <description>DRAM Density. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DENSITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRCD</id>
    <description>DRAM RAS to CAS Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRCD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRRD</id>
    <description>DRAM Row ACT to Row ACT Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRRD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRP</id>
    <description>DRAM Row Precharge Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRAS</id>
    <description>DRAM ACT to Precharge Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRAS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRC</id>
    <description>DRAM ACT to ACT/Refresh Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRFI</id>
    <description>Refresh Interval. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRFI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRFC</id>
    <description>DRAM Refresh Recovery Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRFC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TWTR</id>
    <description>DRAM Internal Write to Read Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TWTR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TRTP</id>
    <description>DRAM Internal Read to Precharge Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TRTP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TFAW</id>
    <description>DRAM Four ACT Window Delay. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TFAW</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_BL</id>
    <description>DRAM Burst Length. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_BL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_CL</id>
    <description>DRAM CAS Latency. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_CL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_AL</id>
    <description>DRAM Additive Latency. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_AL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_CWL</id>
    <description>DRAM CAS Write Latency. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_CWL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_RBT</id>
    <description>DRAM Read Burst Type. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_RBT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TM</id>
    <description>DRAM Test Mode. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DLL_RESET</id>
    <description>DRAM DLL Reset. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DLL_RESET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR</id>
    <description>DRAM Write Recovery. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DLL_PPD</id>
    <description>DRAM DLL Precharge PD. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DLL_PPD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_DLL_ENABLE</id>
    <description>DRAM DLL Enable. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_DLL_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_TDQS</id>
    <description>DRAM TDQS. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_TDQS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_WR_LVL_ENABLE</id>
    <description>DRAM Write Level Enable. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_WR_LVL_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_OUTPUT_BUFFER</id>
    <description>DRAM output buffer. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_OUTPUT_BUFFER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_PASR</id>
    <description>DRAM Partial Array Self-Refresh. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_PASR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ASR</id>
    <description>DRAM Auto Self-Refresh. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_ASR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_SRT</id>
    <description>DRAM Self-Refresh Temperature Range. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_SRT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_LOC</id>
    <description>Multi Purpose Register Location. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_LOC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_MODE</id>
    <description>Multi Purpose Register Mode. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RCD_CNTL_WORD_0_15</id>
    <description>DIMM RCD Control Word. Initialized and used by HWPs.</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RCD_CNTL_WORD_0_15</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RCD_IBT</id>
    <description>DIMM RCD IBT. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RCD_IBT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_RCD_MIRROR_MODE</id>
    <description>DIMM RCD Mirror mode. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_RCD_MIRROR_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_MODE</id>
    <description>Specifies the schmoo mode to use during draminit_train_adv. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_ADDR_MODE</id>
    <description>Specifies the schmoo mode to use during draminit_train_adv. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_ADDR_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_TEST_VALID</id>
    <description>Specifies the schmoo test to run during draminit_train_adv. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_TEST_VALID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_PARAM_VALID</id>
    <description>Specifies the schmoo parameters to use during draminit_train_adv. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_PARAM_VALID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_WR_EYE_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_RD_EYE_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_DQS_CLK_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_RD_GATE_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SCHMOO_ADDR_CMD_MIN_MARGIN</id>
    <description>Specifies the schmoo minimum margin to use during draminit_train_adv. Used to signal possible SI issues in memory.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MEMCAL_INTERVAL</id>
    <description>Specifies the memcal interval in clocks. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MEMCAL_INTERVAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_ZQCAL_INTERVAL</id>
    <description>Specifies the zqcal interval in clocks. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_ZQCAL_INTERVAL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_IBM_TYPE</id>
    <description>Specifies the memory topology type. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_IBM_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_DROPS_PER_PORT</id>
    <description>Specifies the number of DIMM dimensions that are valid per port. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_DROPS_PER_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_STACK_TYPE</id>
    <description>Specifies the DRAM package type. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_STACK_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_MASTER_RANKS_PER_DIMM</id>
    <description>Specifies the number of master ranks per DIMM. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_PACKAGES_PER_RANK</id>
    <description>Specifies the number of DRAM packages per rank. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_PACKAGES_PER_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_NUM_DIES_PER_PACKAGE</id>
    <description>Specifies the number of DRAM dies per package. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_NUM_DIES_PER_PACKAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <description>DIMM throttle numerator. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLE_DENOMINATOR</id>
    <description>DIMM throttle denominator. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <description>This is the throttle numerator setting for cfg_nm_n_per_chip. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_WATT_TARGET</id>
    <description>Channel total memory watts. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_WATT_TARGET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_SLOPE</id>
    <description>DIMM Power slope value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_SLOPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_SLOPE2</id>
    <description>DIMM Power slope value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_SLOPE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_INT</id>
    <description>DIMM Power intercept value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_INT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_POWER_INT2</id>
    <description>DIMM Power intercept value. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_POWER_INT2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MAXBANDWIDTH_GBS</id>
    <description>DIMM Max Bandwidth in GBs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MAXBANDWIDTH_GBS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MAXBANDWIDTH_MRS</id>
    <description>DIMM Max Bandwidth in MRs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MAXBANDWIDTH_MRS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_MAXBANDWIDTH_GBS</id>
    <description>Channel Max Bandwidth in GBs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_MAXBANDWIDTH_GBS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS</id>
    <description>Channel Pair Max Bandwidth in GBs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_MAXBANDWIDTH_MRS</id>
    <description>Channel Max Bandwidth MRs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_MAXBANDWIDTH_MRS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS</id>
    <description>Channel Pair Max Bandwidth MRs. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_MAXPOWER</id>
    <description>DIMM Max Power output. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2,2</array><!-- [drop][port] -->
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_MAXPOWER</id>
    <description>Channel Max Power output. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CHANNEL_PAIR_MAXPOWER</id>
    <description>Channel Pair Max Power output. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CHANNEL_PAIR_MAXPOWER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <description>Runtime throttle numerator setting for cfg_nm_n_per_mba. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLE_DENOMINATOR</id>
    <description>Runtime throttle denominator setting for cfg_nm_m. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <description>Runtime throttle numerator setting for cfg_nm_n_per_chip. Initialized and used by HWPs.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_RUNTIME_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_ZSERIES</id>
    <description>Determines if the code is Zseries type or P Series.  The platform determines this and this attribute is mostly used in the initfiles so that we can share the same initialization code with the zSeries team</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_ZSERIES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- Note: This looks incorrect because memory_attributes.xml says it is platInit (therefore we should set it up to a sensible value),
     but recent discussions have concluded that a HWP will fill this in, this implementation is correct, memory_attributes.xml will eventually change. -->
<attribute>
    <id>MSS_NWELL_MISPLACEMENT</id>
    <description>Set by the platform depending on DD1 vs DD1.01.  If true, then SI settings affected by the NWELL problem are adjusted.  Used in eff_config</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_NWELL_MISPLACEMENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_INTERLEAVE_ENABLE</id>
    <description>
        Used in the setting of MCS groups. It is a bitfield.
        - If 0x01 is set then groups of 1 are enabled and the SMP fabric must
          be set in checkerboard mode (see ALL_MCS_IN_INTERLEAVING_GROUP).
        - If 0x02 is set then groups of 2 are possible.
        - If 0x04 is set then groups of 4 are possible.
        - If 0x08 is set then groups of 8 are possible.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
        <uint8_t>
            <default>0x07</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_INTERLEAVE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CACHE_ENABLE</id>
    <description>
        Specifies if a Memory Buffer chip L4 cache is enabled or disabled
        For good memory buffer chips, L4 is enabled
        Firmware can set to disabled for a particular chip if the cache is
          not functional
        1 = enabled, 0 = disabled.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CACHE_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_PREFETCH_ENABLE</id>
    <description>Prefteching enable. 1 = enable, 0 = disable.</description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_PREFETCH_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CLEANER_ENABLE</id>
    <description>L4 cleaner enable. 1 = enable, 0 = disable.</description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CLEANER_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_LAB_OVERRIDE_FOR_MEM_PLL</id>
    <description>override the default Centaur MEM PLL settings with user-specified scan chain data. 1 = ON, 0 = OFF.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_LAB_OVERRIDE_FOR_MEM_PLL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_MC_IN_GROUP</id>
    <description>A 8 bit vector that would be a designation of which MC are involved in the group. Initialized and used by HWPs.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>8</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_MC_IN_GROUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MCS_GROUP_32</id>
    <description>Data Structure from eff grouping to setup bars to help determine different groups
   Non- Mirroring [0-7] 0 -- MCS size //1-- No of MCS/group //2-- Total group size //3 -- Base address// 4-11 - MCS ID number// 12 --Alter.Bar //13 - A.Group Size // 14 - A.Base address
 //  Mirroring      [8-15] 0 -- MCS size //1-- No of MCS/group //2-- Total group size //3 -- Base address// 4-11 - MCS ID number// 12 --Alter.Bar //13 - A.Group Size // 14 - A.Base address
Measured in GB</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
        <array>16,16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MCS_GROUP_32</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_EFF_DIMM_FUNCTIONAL_VECTOR</id>
    <description>A bit vector (per Dean's request) specifying if a DIMM is functional.  DIMM attributes, such as SIZE, are qualified by this bit vector.  The attribute ANDed 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is functional.  0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1 is functional.  A fully populated system would have the value of 0xCC. Used in various locations and is computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.  Each memory channel will have a value. creator: mss_eff_cnfg consumer: various firmware notes: none
This factors in functionality</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CAL_STEP_ENABLE</id>
    <description>A bit vector denoting valid cal steps to run during dram_init_train. [0] EXT_ZQCAL
[1] WR_LEVEL
[2] DQS_ALIGN
[3] RDCLK_ALIGN
[4] READ_CTR
[5] WRITE_CTR
[6] COARSE_WR
[7] COARSE_RD
bits6:7  will be consumed together to form COARSE_LVL. </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CAL_STEP_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MEM_IPL_COMPLETE</id>
    <description>A numerical number indicating if the memory procedures are complete.  written by mss_setup_bars when the bars are now functional in the processor.  </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MEM_IPL_COMPLETE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_SLEW_RATE_DATA</id>
    <description>The 4 bit result of running the slew calibration algorithm at various rates and impedances</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2, 4, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_SLEW_RATE_DATA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_SLEW_RATE_ADR</id>
    <description>The 4 bit result of running the slew calibration algorithm at various rates and impedances</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2, 4, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_SLEW_RATE_ADR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ECID</id>
    <description>
    Bits 0 to 63 of the ECID in array entry 0 and bits 64 to 127 in ECID array entry 1
    Created from running proc_getecid.C for processors
    Created from running mss_get_cen_ecid.C for centaurs
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_ECID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_ALLOW_SINGLE_PORT</id>
    <description>When this value is true, then mss_eff config will allow a single port to have one dimm and will allow ports to have different sizes.  Used in eff_config</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_ALLOW_SINGLE_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603. These phase rotator EFF attributes have corresponding
     VPD attributes that come from CVPD. When all HWPs are using the VPD
     versions, these EFF versions can be deleted -->

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CLK_P0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CLK_P0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CLK_P1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CLK_P1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CLK_P0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CLK_P0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CLK_P1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CLK_P1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A4</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A4</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A5</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A5</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A6</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A6</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A7</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A7</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A8</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A8</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A9</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A9</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A10</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A10</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A11</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A11</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A12</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A12</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A13</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A13</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A14</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A14</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_A15</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_A15</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_BA0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_BA0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_BA1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_BA1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_BA2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_BA2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_CASN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_CASN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_RASN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_RASN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_CMD_WEN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_CMD_WEN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_PAR</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_PAR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M_ACTN</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M_ACTN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CKE3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CKE3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_CSN3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_CSN3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_ODT0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_ODT0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M0_CNTL_ODT1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M0_CNTL_ODT1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CKE3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CKE3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN2</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN2</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_CSN3</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_CSN3</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_ODT0</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_ODT0</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CEN_PHASE_ROT_M1_CNTL_ODT1</id>
    <description>Phase rotator value that comes from termination on the CDIMM VPD</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CEN_PHASE_ROT_M1_CNTL_ODT1</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- TODO RTC 87603 down to here -->

<attribute>
    <id>MSS_DQS_SWIZZLE_TYPE</id>
    <description>DQS Swizzle type is set by the platform to describe what kind of DQS connection is being used for register acceses. Type 0 is normal, type 1 is for systems with wiring like glacier 1.  Additional types maybe defined if new boards have even different DQS swizzle features</description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DQS_SWIZZLE_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_MCS_GROUP</id>
    <description>Data Structure from eff grouping to setup bars to help determine different groups
   Non- Mirroring [0-7] 0 -- MCS size //1-- No of MCS/group //2-- Total group size //3 -- Base address// 4-11 - MCS ID number// 12 --Alter.Bar //13 - A.Group Size // 14 - A.Base address
 //  Mirroring      [8-15] 0 -- MCS size //1-- No of MCS/group //2-- Total group size //3 -- Base address// 4-11 - MCS ID number// 12 --Alter.Bar //13 - A.Group Size // 14 - A.Base address
Measured in GB</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>16,16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_MCS_GROUP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CKE_MAP</id>
    <description>Rank to CKE map. Used in various locations and is computed in mss_eff_cnfg_cke_map. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.   creator: mss_eff_cnfg_cke_map consumer: various firmware notes: none</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CKE_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SPCKE_MAP</id>
    <description>Rank to Spare CKE map. Used in various locations and is computed in mss_eff_cnfg_cke_map. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.   creator: mss_eff_cnfg_cke_map consumer: various firmware notes: none</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SPCKE_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DIMM_SPARE</id>
    <description>Spare DRAM availability. Used in various locations and is computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.   creator: mss_eff_cnfg consumer: various firmware notes: load from spd</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DIMM_SPARE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_PSRO</id>
    <description>Set by the centaur mss_get_cen_ecid function used diagnostic and chip characterization reporting</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_PSRO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== End Attributes supporting memory_attributes.xml HWPF Attributes ===== -->

<attribute>
    <id>EI_BUS_TX_LANE_INVERT</id>
    <description>
      This attribute represents the polarity of a differential wire pair on the DMI and A buses.
      creator: platform (generated based on MRW data)
      See defintion in common_attributes.xml for more information.
    </description>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EI_BUS_TX_LANE_INVERT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PERV_BNDY_PLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for perv_bndy_pll ring containing filter plls and xb_pll,nest_pll
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PERV_BNDY_PLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PB_BNDY_DMIPLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for pb_bndy_dmipll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PB_BNDY_DMIPLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AB_BNDY_PLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for ab_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AB_BNDY_PLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCI_BNDY_PLL_CHIPLET_ID</id>
    <description>Chiplet ID for ring image for pci_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCI_BNDY_PLL_CHIPLET_ID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PERV_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for perv_bndy_pll ring containing filter plls and xb_pll,nest_pll
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0x00100008</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PERV_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PB_BNDY_DMIPLL_SCAN_SELECT</id>
    <description>Scan select for ring image for pb_bndy_dmipll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PB_BNDY_DMIPLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AB_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for ab_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AB_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCI_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for pci_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCI_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== Supporting poreve_memory_attributes.xml ===== -->

<attribute>
    <id>SBE_SEEPROM_I2C_ADDRESS_BYTES</id>
    <description>
      The number of address bytes required to address the SEEPROM memory
      device that contains SBE IPL code.  This will vary by device based on
      the device capacity, and must be either 1, 2, 3 or 4.
    </description>
    <simpleType>
        <uint8_t>
            <default>2</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SEEPROM_I2C_ADDRESS_BYTES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_SEEPROM_I2C_DEVICE_ADDRESS</id>
    <description>
      A 2-element array containing the I2C device address of the primary (0)
      and secondary (1) SEEPROM devices containing SBE IPL code.
      Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SEEPROM_I2C_DEVICE_ADDRESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SBE_SEEPROM_I2C_PORT</id>
    <description>
      A 2-element array containing the I2C controller port number of the
      primary (0) and secondary (1) SEEPROM devices containing SBE IPL code.
      Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SBE_SEEPROM_I2C_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PNOR_I2C_ADDRESS_BYTES</id>
    <description>
      The number of address bytes required to address the PNOR memory device
      via the pseudo-I2C (LPC, ECCAX) controller.  This will vary by device
      based on the device capacity, and must be either 0, 1, 2, 3 or 4.

      This attribute will be set to 0 for chips with no PNOR attached
      (PoreVe will never run on these chips).

      Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
            <default>4</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PNOR_I2C_ADDRESS_BYTES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- ===== End supporting poreve_memory_attributes.xml ===== -->

<!-- Support for sync_attributes.xml -->
<attribute>
    <id>SYNC_BETWEEN_STEPS</id>
    <description>
        Attribute to enable targetting attribute sync when in istep mode.
        1 = sync will occur following each substep when ipl'ing in single step mode
        0 = sync will not be done after each step
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
        <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SYNC_BETWEEN_STEPS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!-- End support for sync_attributes.xml -->

<!--    Support for proc_select_boot_master -->

<enumerationType>
    <id>PROC_SELECT_BOOT_MASTER</id>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
        <name>PRIMARY</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECONDARY</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_SELECT_BOOT_MASTER</id>
  <description>
    Specifies which chip should be used as the boot master
    Initialized by the platform.
      PRIMARY  - the primary master is used for the BOOT
      SECONDARY  - the alternate master is used for the BOOT
      Platforms are expected to set this to PRIMARY in normal operation
  </description>
  <simpleType>
    <uint8_t>
      <default>1</default>
    </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_MASTER</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>


<enumerationType>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
    <description>Enumeration indicating which SEEPROM image should be used for the boot master</description>
    <enumerator>
        <name>FIRST</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECOND</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_SELECT_SEEPROM_IMAGE</id>
  <description>
    Specifies which SEEPROM image should be used for the boot master.
      FIRST  - the first image was selected
      SECOND - the second image was selected
      Platforms are expected to set this to FIRST in normal operation
  </description>
  <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
    <description>Enumeration indicating which SEEPROM image should be used to boot a processor</description>
    <enumerator>
        <name>FIRST</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECOND</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
  <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
  <description>
    Specifies which SEEPROM image should be used to boot a processor
      FIRST  - the first image was selected
      SECOND - the second image was selected
  </description>
  <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
  </simpleType>
  <persistency>volatile</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>ENABLED_THREADS</id>
    <description>
       Bitmask of threads to enable for each processor,
       Zero means enable all architected threads
    </description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MAX_PROC_CHIPS_PER_NODE</id>
    <description>
        System attribute.
        The max proc chips per node available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <description>
        System attribute.
        The max EX units per proc chip available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <description>
        System attribute.
        The max DIMMs per MBA Port available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <description>
        System attribute.
        The max MBA ports per MBA available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <description>
        System attribute.
        The max MBAS per membuf available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <description>
        System attribute.
        The max chiplets per proc available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MAX_MCS_PER_SYSTEM</id>
    <description>
        System attribute.
        The max MCS units available in the system.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<!-- Note: This attribute is only used by FSP -->
<attribute>
    <id>DMI_REFCLOCK_SWIZZLE</id>
    <description>
      Defines Murano/Venice FSI GP8 refclock enable field bit offset (0:7) associated with this MCS chip unit.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_REFCLOCK_SWIZZLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EI_BUS_TX_MSBSWAP</id>
    <description>
        Source: MRW: Downstream MSB Swap and Upstream MSB Swap
        Usage:  TX_MSBSWAP initfile setting for DMI and A buses

        This attribute represents whether or not a single clock group bus such as DMI and A bus was wired by the board designer using a feature
        called MSB Swap where lane 0 of the TX chip wires to lane n-1 on the RX chip where 'n' is the width of the bus. A basic description
        of this capability is that the board designer can save layers on the board wiring by crossing the wiring between the two chips in
        a prescribed manner. In a non-MSB Swapped bus Lane 0 on the TX chip wires to lane 0 on the RX chip, lane 1 to lane 1 and so on.
        If a bus is MSB Swapped then lane 0 of the TX chip wires to lane 'n-1' of the RX chip, lane 1 to lane 'n-2', etc. Random or
        arbitrary wiring of TX to RX lanes on different chips is NOT ALLOWED.

        The Master Chip of two connected chips is defined as the chip with the smaller value of (100*Node + Pos).
        The Slave Chip of two connected chips is defined as the chip with the larger value of (100*Node + Pos).
        The Downstream direction is defined as the direction from the Master chip to the Slave chip.
        The Upstream direction is defined as the direction from the Slave chip to the Master chip.

        The Downstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Downstream bus is wired msb to lsb etc. and
        0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0).

        The Upstream TX_MSBSWAP from the MRW is a uint8 value. 0x01 means the Upstream bus is wired msb to lsb etc. and
        0x00 means the bus is wired normally, msb to msb, lsb to lsb (lane0 to lane0).

        It is up to the platform code to set up each ATTR_EI_BUS_TX_MSBSWAP value for the correct target endpoints.

    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EI_BUS_TX_MSBSWAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_FREQ_OVERRIDE</id>
    <description>FOR LAB USE ONLY: Frequency override of this memory channel in MHz, comprising of up to three DIMMs.  Set by config file or an attribute writing program.  Consumed by mss_freq.  The default of AUTO means mss_freq will find the best frequencies given the DIMMs plugged in and other rules.  Otherwise, this is the system frequency.
firmware notes: Platforms should initialize this attribute to AUTO (0)</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_FREQ_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!-- mcbist attributes -->
<attribute>
    <id>MCBIST_PATTERN</id>
    <description>Enables mcbist data pattern selection.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_PATTERN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_TEST_TYPE</id>
    <description>Enables mcbist test type selection.</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_TEST_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_PRINTING_DISABLE</id>
    <description>MCBIST support for printing</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_PRINTING_DISABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_DATA_ENABLE</id>
    <description>MCBIST support for enabling data</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_DATA_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_USER_RANK</id>
    <description>MCBIST support for rank selection</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_USER_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_USER_BANK</id>
    <description>MCBIST support for bank selection</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_USER_BANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>SCHMOO_MULTIPLE_SETUP_CALL</id>
    <description>MCBIST for multiple setup</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_SCHMOO_MULTIPLE_SETUP_CALL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_MODES</id>
    <description>Can choose mcbist address mode for full,half or quarter addressing mode.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_MODES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_RANK</id>
    <description> Defines the rank for the Mcbist </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_START_ADDR</id>
    <description>Defines the start address for the Mcbist address range</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_START_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_END_ADDR</id>
    <description>Defines the end address for the Mcbist address range</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_END_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ERROR_CAPTURE</id>
    <description>Enables error capture; basically a flag.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ERROR_CAPTURE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_MAX_TIMEOUT</id>
    <description>Define mcbist Max timeout</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_MAX_TIMEOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_PRINT_PORT</id>
    <description>Enable which port prints are required.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_PRINT_PORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_STOP_ON_ERROR</id>
    <description>Flag to stop Mcbist on Error.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_STOP_ON_ERROR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_DATA_SEED</id>
    <description>Define data seed for the random data pattern or test</description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_DATA_SEED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_INTER</id>
    <description>The address interleave map with user cases or deafult cases of BANK_RANK,RANK_BANK,BANK_ONLY,RANK_ONLYRANKS_DIMM0,RANKS_DIMM1,USER_PATTERN.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_INTER</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_NUM_ROWS</id>
    <description>User defined constraint for limiting number of rows for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_NUM_ROWS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_NUM_COLS</id>
    <description>User defined constraint for limiting number of columns for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_NUM_COLS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_RANK</id>
    <description>User defined constraint for limiting number of ranks for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_RANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_BANK</id>
    <description>User defined constraint for limiting number of banks for addressing.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_BANK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_SLAVE_RANK_ON</id>
    <description>If slave ranks exists;Restrict usage or enable addressing on them as well.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_SLAVE_RANK_ON</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_STR_MAP</id>
    <description>To Define custom addressing map ; Input by user.</description>
    <simpleType>
        <uint64_t>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_STR_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_ADDR_RAND</id>
    <description>Flag for Addressing to go sequential manner or random.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_ADDR_RAND</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_PCIE_REFCLOCK_ENABLE</id>
    <description>PCIE refclock enable valid mask
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Bit mask defining state of refclock drive enables
        bit0=PCI0, bit1=PCI1, bit2=PCI2
    </description>
    <simpleType>
       <uint8_t>
         <default>0xE0</default>
       </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PCIE_REFCLOCK_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_PBIEX_ASYNC_SEL</id>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
        <name>SEL0</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>SEL1</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SEL2</name>
        <value>2</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PROC_PBIEX_ASYNC_SEL</id>
    <description>Selector for ATTR_PROC_EX_FUNC_L3_DELTA_DATA value to be returned by platform.
      creator: proc_build_smp
      firmware notes:
    </description>
    <simpleType><uint8_t></uint8_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_PBIEX_ASYNC_SEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_DCM_INSTALLED</id>
    <description>
      PROC_CHIP Attribute
        If true, the chip is installed on a Dual Chip Module
        Provided by the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_DCM_INSTALLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>


<!-- === Attributes supporting erepair_thresholds.xml HWPF Attributes === -->
<attribute>
    <id>X_EREPAIR_THRESHOLD_FIELD</id>
    <description>
      This attribute represents the eRepair threshold value of X-Bus used
      in the field.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_X_EREPAIR_THRESHOLD_FIELD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>A_EREPAIR_THRESHOLD_FIELD</id>
    <description>
      This attribute represents the eRepair threshold value of A-Bus used
      in the field.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_A_EREPAIR_THRESHOLD_FIELD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DMI_EREPAIR_THRESHOLD_FIELD</id>
    <description>
      This attribute represents the eRepair threshold value of DMI-Bus used
      in the field.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_EREPAIR_THRESHOLD_FIELD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>X_EREPAIR_THRESHOLD_MNFG</id>
    <description>
      This attribute represents the eRepair threshold value of X-Bus used
      by Manufacturing.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_X_EREPAIR_THRESHOLD_MNFG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>A_EREPAIR_THRESHOLD_MNFG</id>
    <description>
      This attribute represents the eRepair threshold value of A-Bus used
      by Manufacturing.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_A_EREPAIR_THRESHOLD_MNFG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DMI_EREPAIR_THRESHOLD_MNFG</id>
    <description>
      This attribute represents the eRepair threshold value of DMI-Bus used
      by Manufacturing.
      creator: platform (generated based on MRW data)
      See defintion in erepair_thresholds.xml for more information.
    </description>
    <simpleType>
      <uint8_t>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_EREPAIR_THRESHOLD_MNFG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
<!-- ===== End Attributes supporting erepair_thresholds.xml HWPF Attributes ===== -->

<!-- Mem PLL attributes ===== -->
<attribute>
    <id>MEMB_TP_BNDY_PLL_SCAN_SELECT</id>
    <description>Scan select for ring image for Centaur tp_bndy_pll ring
      creator: platform
      firmware notes:
    </description>
    <simpleType>
        <uint32_t>
            <default>0x00100008</default>
        </uint32_t>
    </simpleType>
    <readable/>
    <persistency>non-volatile</persistency>
    <hwpfToHbAttrMap>
        <id>ATTR_MEMB_TP_BNDY_PLL_SCAN_SELECT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_mba</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_MBA</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_SAFEMODE_MEM_THROTTLE_DENOMINATOR</id>
    <description>Machine Readable Workbook safe mode throttle value for denominator cfg_nm_m</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_SAFEMODE_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
    <description>Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_chip</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_SAFEMODE_MEM_THROTTLE_NUMERATOR_PER_CHIP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_THERMAL_MEMORY_POWER_LIMIT</id>
    <description>Machine Readable Workbook Thermal Memory Power Limit</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_THERMAL_MEMORY_POWER_LIMIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_LPASR</id>
    <description> Low Power Auto Self-Refresh. This is for DDR4 MRS2.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_LPASR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_PAGE</id>
    <description>MPR Page Selection This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_PAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_GEARDOWN_MODE</id>
    <description>Gear Down Mode. This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_GEARDOWN_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_PER_DRAM_ACCESS</id>
    <description>Per DRAM accessibility.  This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_PER_DRAM_ACCESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TEMP_READOUT</id>
    <description>Temperature sensor readout. This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_READOUT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_FINE_REFRESH_MODE</id>
    <description>Fine refresh mode. This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_FINE_REFRESH_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CRC_WR_LATENCY</id>
    <description>write latency for CRC and DM. This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CRC_WR_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MPR_RD_FORMAT</id>
    <description>MPR READ FORMAT. This is for DDR4 MRS3.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MPR_RD_FORMAT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_MAX_POWERDOWN_MODE</id>
    <description>Max Power down mode. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_MAX_POWERDOWN_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TEMP_REF_RANGE</id>
    <description>Temp ref range. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_REF_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TEMP_REF_MODE</id>
    <description>Temp controlled ref mode. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TEMP_REF_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_INT_VREF_MON</id>
    <description>Internal Vref Monitor.. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_INT_VREF_MON</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CS_CMD_LATENCY</id>
    <description>CS to CMD/ADDR Latency. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CS_CMD_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_SELF_REF_ABORT</id>
    <description>Self Refresh Abort. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_SELF_REF_ABORT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RD_PREAMBLE_TRAIN</id>
    <description>Read Pre amble Training Mode. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RD_PREAMBLE_TRAIN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RD_PREAMBLE</id>
    <description>Read Pre amble. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RD_PREAMBLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WR_PREAMBLE</id>
    <description>Write Pre amble. This is for DDR4 MRS4.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WR_PREAMBLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CA_PARITY_LATENCY</id>
    <description>C/A Parity Latency Mode. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CA_PARITY_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CRC_ERROR_CLEAR</id>
    <description>CRC Error Clear. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CRC_ERROR_CLEAR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CA_PARITY_ERROR_STATUS</id>
    <description>C/A Parity Error Status. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CA_PARITY_ERROR_STATUS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_ODT_INPUT_BUFF</id>
    <description>ODT Input Buffer during power down. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_ODT_INPUT_BUFF</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RTT_PARK</id>
    <description>RTT_Park value. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2, 2, 4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RTT_PARK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CA_PARITY</id>
    <description>CA Parity Persistance Error. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CA_PARITY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DATA_MASK</id>
    <description>Data Mask. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DATA_MASK</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WRITE_DBI</id>
    <description>Write DBI. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WRITE_DBI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_READ_DBI</id>
    <description>Read DBI. This is for DDR4 MRS5.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_READ_DBI</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VREF_DQ_TRAIN_VALUE</id>
    <description>vrefdq_train value. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VREF_DQ_TRAIN_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VREF_DQ_TRAIN_RANGE</id>
    <description>vrefdq_train range. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VREF_DQ_TRAIN_RANGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>VREF_DQ_TRAIN_ENABLE</id>
    <description>vrefdq_train enable. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
        <array>2,2,4</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_VREF_DQ_TRAIN_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>TCCD_L</id>
    <description>tccd_l. This is for DDR4 MRS6.  Computed in mss_eff_cnfg. Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_TCCD_L</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WRITE_CRC</id>
    <description>Write CRC control for DDR4.  Set in mss_eff_cnfg.  Each memory channel will have a value.
      creator: mss_eff_cnfg
      consumer: various
      firmware notes: none</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WRITE_CRC</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_2N_MODE_ENABLED</id>
    <description>Describes if this MBA is in 2N address mode.  The DIMM attributes associated with this MBA describes if this mode is needed for SI.  The MR Keyword of the VPD gives and indication of the value needed. Set by eff_config and consumed in the mba_def.initfile.</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_2N_MODE_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DIMM_POWER_TEST_REV</id>
    <description>The power test revision number that is saved when data is saved on an ISDIMM.  If the power test changes, then a difference indicates that the power test needs to be rerun.  This attribute needs to stick around between IPLs</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DIMM_POWER_TEST_REV</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>FRU_ID</id>
    <description>FRU ID attribute for chip class</description>
    <simpleType><uint32_t><default>0</default></uint32_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <description>
      Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL
      (not an IPL by steps). This is read by Hostboot to determine if it needs
      to request the attribute overrides from HWSV before starting its IPL.
    </description>
    <simpleType><uint8_t><default>0x00</default></uint8_t></simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>DUMMY_PERSISTENCY</id>
    <description>Cached value to test persistency</description>
    <simpleType>
       <uint8_t>
          <default>0</default>
       </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DUMMY_PERSISTENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>IS_INTER_ENCLOSURE_BUS</id>
    <description>Indicate an inter-enclosure bus at this endpoint target.
                 0 = No, 1 = Yes
    </description>
    <simpleType>
        <uint8_t><default>0</default></uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>PEER_PATH</id>
    <description>Entity path of the peer target of an Abus
    </description>
    <nativeType>
        <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>PROC_HTM_BAR_SIZE</id>
    <description>Desired HTM trace memory size value
      creator: platform
      firmware notes:
        set by platform to request size of per-chip area reserved
        for HTM trace memory
    </description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_HTM_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_OCC_SANDBOX_SIZE</id>
    <description>Desired size of OCC sandbox memory region
      creator: platform
      firmware notes:
        set by platform to request size of per-chip area reserved
        for OCC sandbox function
    </description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_OCC_SANDBOX_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_HTM_BAR_BASE_ADDR</id>
    <description>HTM trace memory base address allocated
    </description>
    <simpleType><uint64_t></uint64_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_HTM_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_OCC_SANDBOX_BASE_ADDR</id>
    <description>OCC sandbox base address allocated
    </description>
    <simpleType><uint64_t></uint64_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_OCC_SANDBOX_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_MIRROR_PLACEMENT_POLICY</id>
    <description>Define placement policy/scheme for non-mirrored/mirrored memory
                 layout
      creator: platform
      consumer: opt_memmap
      firmware notes:
        NORMAL  = non-mirrored start: 0, mirrored start: 512TB
        FLIPPED = mirrored start: 0, non-mirrored start: 512TB
        SELECTIVE = non-mirrored/mirrored start (interleaved): 0
        DRAWER = non-mirrored start: 1TB*drawer, mirrored start: 512TB+(1TB*drawer/2)
    </description>
    <simpleType>
      <uint8_t>
            <!-- Normal -->
            <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEM_MIRROR_PLACEMENT_POLICY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AS_MMIO_BAR_BASE_ADDR</id>
    <description>AS MMIO BAR base address value
      creator: platform
      consumer: proc_setup_bars
      firmware notes:
        64-bit address representing BAR RA
        NOTE: BAR register covers RA 14:51
    </description>
    <simpleType>
       <uint64_t>
           <default>0</default>
       </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AS_MMIO_BAR_BASE_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AS_MMIO_BAR_ENABLE</id>
    <description>AS MMIO BAR enable
      creator: platform
      consumer: proc_setup_bars
      firmware notes: none
    </description>
    <simpleType>
      <uint8_t>
            <!-- Disabled -->
            <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AS_MMIO_BAR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_AS_MMIO_BAR_SIZE</id>
    <description>AS MMIO BAR size value
      creator: platform
      consumer: proc_setup_bars
      firmware notes: none
    </description>
    <simpleType>
       <uint64_t>
           <!-- 2_MB -->
           <default>0x0000000000200000</default>
       </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_AS_MMIO_BAR_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RISK_LEVEL</id>
    <description>
        Defines risk level to consider for initialization values applied during IPL.
        Risk level 0 should contain solutions for all known errata, and may sacrifice performance to avoid data integrity issue/error checking cases.
        Risk level 0x100 may introduce data integrity/error scenarios to provide full performance or visibility to state space/coverage behind known issues.
    </description>
    <simpleType><uint32_t></uint32_t></simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_RISK_LEVEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_FREQ_BIAS_PERCENTAGE</id>
    <description>
        Percentage to increase/decrease MEM frequency. two's complement number.
        Measured in 100's.  So the value of 100 is one percent increase.
        This frequency change comes from changing multipliers and dividers to
        get the desired frequency. The supported frequencies come from
        Tim Diemoz.
        Creator: platform set this to 0.  Users can set this to a valid value.
    </description>
    <simpleType>
        <uint32_t>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_FREQ_BIAS_PERCENTAGE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CDIMM_SENSOR_MAP_PRIMARY</id>
    <description>
        Custom DIMM Sensor Map for Primary I2C Port (1 byte of data):
            0x00 No sensors attached
            0x01 DIMM sensor 0 attached
            0x02 DIMM sensor 1 attached
            0x04 DIMM sensor 2 attached
            0x08 DIMM sensor 3 attached
            0x10 DIMM sensor 4 attached
            0x20 DIMM sensor 5 attached
            0x40 DIMM sensor 6 attached
            0x80 DIMM sensor 7 attached
            Comes from the VPD MW Keyword
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CDIMM_SENSOR_MAP_PRIMARY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CDIMM_SENSOR_MAP_SECONDARY</id>
    <description>
        Custom DIMM Sensor Map for Secondary I2C Port (1 byte of data):
            0x00 No sensors attached
            0x01 DIMM sensor 0 attached
            0x02 DIMM sensor 1 attached
            0x04 DIMM sensor 2 attached
            0x08 DIMM sensor 3 attached
            0x10 DIMM sensor 4 attached
            0x20 DIMM sensor 5 attached
            0x40 DIMM sensor 6 attached
            0x80 DIMM sensor 7 attached
            Comes from the VPD MW Keyword
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CDIMM_SENSOR_MAP_SECONDARY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DRAM_ADDRESS_MIRRORING</id>
    <description>
        Address mirroring on the DIMM by rank, up to 4 ranks.
            0x08 means rank 0 is mirrored
            0x04 means rank 1 is mirrored
            0x02 means rank 2 is mirrored
            0x01 means rank 3 is mirrored
        Comes from EFF config reading the VPD_DRAM_ADDRESS_MIRRORING from the
        AM keyword of the VPD.
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DRAM_ADDRESS_MIRRORING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_BLUEWATERFALL_BROKEN</id>
    <description>
        Set by the platform depending on DD1.0X vs DD1.03 or newer. If true,
        then draminit_train will modify dqs_clk_ps and gate to work around the
        issue. Set in get ecid which determines if we are at 1.03
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_BLUEWATERFALL_BROKEN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CDM_POLICIES</id>
    <description>
        Cec Degraded Mode Policy flags
        Use the CDM_POLICIES enum to decode.
        If the appropriate bit is 1 then the policy mode is enabled,
        and those type of Guard records are disabled.
    </description>
    <simpleType>
        <uint8_t>
            <default>0x00</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <writeable/>
    <readable/>
</attribute>

<enumerationType>
    <id>CDM_POLICIES</id>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
        <description>
        MFG_Guard policy:
        Used in MFG only to prevent and disable the following:
        . Storing or creation of new Guard records from Diagnostic or other
            faults through error logs. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        . Storing or creation of Manual Guard record from user.
            NOTE: this does not stop FCO.
        . Using an already stored System or Manual Guard record from
            deconfiguring resources. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        </description>
        <name>MANUFACTURING_DISABLED</name>
        <value>0x01</value>
    </enumerator>
    <enumerator>
        <description>
        Predictive_Guard policy:
        Used in Field or development to prevent and disable the following:
        . Storing or creation of new Guard records from diagnostics or other
            faults through error logs with the error_type of Predictive.
        . Using an already stored System Guard record with error_type of
            Predictive from deconfiguring resources.
        </description>
        <name>PREDICTIVE_DISABLED</name>
        <value>0x02</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>FIELD_CORE_OVERRIDE</id>
    <description>Field Core Override (FCO) is the override value for the
    number of functional cores allowed on the system.
    FCO is used when customers order a system with N cores but they only want
    to enable less than N cores to lower software license costs. A field in the
    anchor VPD is set by manufacturing to specify the maximum number of cores
    to enable. The number is maintained, even if some cores are garded out due
    to error.
    A value of 0 means all cores allowed;
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>HOSTSVC_PLID</id>
    <description>
        Value of the next PLID that host service should send
    </description>
    <simpleType>
        <uint32_t>
            <default>0x89000000</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <description>
        Policy indicating whether to perform the maximum amount of memory
            pattern testing possible or not.
        Set to 0x01 to perform the maximum amount of memory pattern testing
            possible.
        Set to 0x00 to perform the default amount of memory pattern testing.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>EFF_RLO</id>
    <description>Gives the RLO value to use for this port.  This comes from the MR Keyword of the VPD gives and indication of the value.  It will be writable until it comes from VPD. The value is a positive integer number.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RLO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_WLO</id>
    <description>Read Latency Offset value that is used in the phy.  This value  comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_WLO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_GPO</id>
    <description>Global Phy Offset value that is used in setting up the phy.  This value comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_GPO</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CKE_PRI_MAP</id>
    <description>Contains the CKE MAP for the DIMM being plugged in.  It comes from the MT keyword but is not on a port basis --- meaning this Attribute may be split: with 16 bits associated with port A data and 16 bits with B. This value goes directly into the MBA01 Rank-to-primary-CKE mapping table register bits 0:31 (MBA01_MBAREF1Q) register. This attribute is writeable until it comes from the VPD</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CKE_PRI_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_CKE_PWR_MAP</id>
    <description>Contains the CKE Power Domain mapping tables for the DIMM being plugged in.  It comes from the MT keyword but is not on a port basis --- meaning this Attribute may be split: with 32 bits associated with port A data and 32 bits with B. This value goes directly into the MBA01 Rank-to-CKE power domain mapping table bits 0:33 (MBA01_MBARPC1Q) register. This attribute is writeable until it comes from the VPD</description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_CKE_PWR_MAP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_RDTAG</id>
    <description>Read Tag value that is used in setting up the phy.  It is expected that this value will come from the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_RDTAG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TSYS_ADR</id>
    <description>TSYS for all address blocks in the MBA pair. This value comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TSYS_ADR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_TSYS_DP18</id>
    <description>TSYS for all DP18 blocks in the MBA pair.  This value comes from the MR keyword of the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_TSYS_DP18</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_DQ_WR_OFFSET</id>
    <description>DQ write offset value that is used in setting up the phy's phase rotators before WR_LVL, 0x40 is HW Default.  It is expected that this value will come from the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_DQ_WR_OFFSET</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFF_BUFFER_LATENCY</id>
    <description>Additional buffer latency in the case of RDIMMs and LRDIMMs.    It is expected that this value will come from the VPD</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_EFF_BUFFER_LATENCY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LRDIMM_MR12_REG</id>
    <description>LRDIMM MR1,2 register.
     DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and 1, DRAM driver impedance for all ranks.  Eff config should set this up.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LRDIMM_MR12_REG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LRDIMM_ADDITIONAL_CNTL_WORDS</id>
    <description>LRDIMM additional RCD control words as set by DIMM SPD:
     F[3,4]RC10, F[3,4]RC11, F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
     F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15.
     Eff config should set this up</description>
    <simpleType>
        <uint64_t>
            <default>0</default>
        </uint64_t>
        <array>2,2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LRDIMM_RANK_MULT_MODE</id>
    <description>LRDIMM rank multiplication mode.
     Will be set at an MBA level with one policy to be used</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LRDIMM_RANK_MULT_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SPWUP_IGNORE_XSTOP_FLAG</id>
    <description>Flag storage to have the Special Wakeup procedure ignore a checkstop condition.</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SPWUP_IGNORE_XSTOP_FLAG</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CPM_INFLECTION_POINTS</id>
    <description>Structure to communicate the CPM inflection points from the CPM code to the Pstate code
    Datablock consisting of:
        8 Inflection Point frequency entries (binary in ATTR_FREQ_PROC_REFCLOCK_KHZ / ATTR_PROC_DPLL_DIVIDER units)
        1 ValidRanges entry - the number of valid inflection points in the previous locations (unit origin)
        1 pMax frequency entry - the maximum allowed boosted frequency (binary in ATTR_FREQ_PROC_REFCLOCK_KHZ / ATTR_DPLL_DIVIDER units)
        6 spare entries
    Producer: p8_cpm_cal_load
    Consumer: p8_pstate_datablock
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
        <array>16</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CPM_INFLECTION_POINTS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>LAB_USE_JTAG_MODE</id>
    <description>This attribute controls how the procedures operate in JTAG mode under an environment called cronus flex.  For normal operation, this attribute should be set to FALSE. Platforms should initialize this attribute to FALSE.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_LAB_USE_JTAG_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_CONTROL_SWITCH</id>
    <description>This attribute enables control switches in the memory code.  This is a one hot vector:  Bit 7 controls the Bad Bit Mask function in draminit_training. The platform should initialize this to BBM_ON except if ATTR_LAB_USE_JTAG_MODE == TRUE, then the platform should set this attribute to BBM_ OFF.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_CONTROL_SWITCH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<!--
<attribute>
    <id>MSS_DRAM_ACTIVATE_POWER_PERCENT</id>
    <description>DRAM Activation power percentage to determine the ras and cas weights for throttle controls
        will originates from VPD for custom DIMMs in the MW keyword byte 5 (MSB is on the left(big endian))
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DRAM_ACTIVATE_POWER_PERCENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>
-->

<attribute>
    <id>MSS_THROTTLE_CONTROL_RAS_WEIGHT</id>
    <description>RAS weight to use for memory throttle control</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_THROTTLE_CONTROL_CAS_WEIGHT</id>
    <description>CAS weight to use for memory throttle control</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_BASES_ACK</id>
  <description>Mirrored memory base addresses
      creator: mss_setup_bars
      consumer: consumer: opt_mem_map
      Mem opt map uses this for the bases of the mirror ranges.
        (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_BASES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MIRROR_SIZES_ACK</id>
  <description>Size of mirrored memory region up to a power of 2
      creator: mss_setup_bars
      consumer: opt_mem_map
      Mem opt map uses this to stack mirror ranges.  The real amount of memory behind the mirror group maybe less than the number reported here if there are memory holes
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>4</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MIRROR_SIZES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MEM_BASES_ACK</id>
  <description>Non-mirrored memory base addresses
    creator: mss_setup_bars
    consumer: opt_mem_map
    Mem opt map uses this for the bases of the non-mirror ranges.
      (max number based on Venice design)
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_MEM_SIZES_ACK</id>
  <description>Size of non-mirrored memory regions up to a power of 2
    creator: mss_setup_bars
    consumer: opt_mem_map
    Mem opt map uses this to stack mirror ranges.  The real amount of memory behind the mirror group maybe less than the number reported here if there are memory holes
  </description>
  <simpleType>
      <uint64_t></uint64_t>
      <array>8</array>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_SIZES_ACK</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_RANDOM_SEED_VALUE</id>
    <description>Controls the MCBIST engine in the centaur chip.  The value will be set in mss_eff_config_shmoo.</description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_RANDOM_SEED_VALUE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MCBIST_RANDOM_SEED_TYPE</id>
    <description>Controls the MCBIST engine in the centaur chip.  The value will be set in mss_eff_config_shmoo.</description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MCBIST_RANDOM_SEED_TYPE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_BOOT_VOLTAGE_VID</id>
    <description>
        Proc Boot Voltage
    </description>
    <simpleType>
        <uint32_t>
            <default>0</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_BOOT_VOLTAGE_VID</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DISABLE_I2C_ACCESS</id>
    <description>
      Set to skip physical access to i2c interface in SBE execution.
      Consumed by SBE hooks to permit skipping of selected code when
      running on a test platform (i.e., wafer) which does not have a physical
      SEEPROM connected.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DISABLE_I2C_ACCESS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PCI_REFCLOCK_RCVR_TERM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MEM_FILTER_PLL_SOURCE</id>
    <description>
        Defines source of MEM filter PLL input (FSI GP4 bit 23)
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MEM_FILTER_PLL_SOURCE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE</id>
    <description>To represent different sizes of Multiscom Buffer.
    It can take 11 different values
    MULTI_SCOM_BUFFER_SIZE_1KB   = 0x0000000000000400,
    MULTI_SCOM_BUFFER_SIZE_2KB   = 0x0000000000000800,
    MULTI_SCOM_BUFFER_SIZE_4KB   = 0x0000000000001000,
    MULTI_SCOM_BUFFER_SIZE_8KB   = 0x0000000000002000,
    MULTI_SCOM_BUFFER_SIZE_16KB  = 0x0000000000004000,
    MULTI_SCOM_BUFFER_SIZE_32KB  = 0x0000000000008000,
    MULTI_SCOM_BUFFER_SIZE_64KB  = 0x0000000000010000,
    MULTI_SCOM_BUFFER_SIZE_128KB = 0x0000000000020000,
    MULTI_SCOM_BUFFER_SIZE_256KB = 0x0000000000040000,
    MULTI_SCOM_BUFFER_SIZE_512KB = 0x0000000000080000,
    MULTI_SCOM_BUFFER_SIZE_1MB   = 0x0000000000100000
    </description>
    <simpleType>
      <uint64_t>
            <default>0x0000000000001000</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MULTI_SCOM_BUFFER_MAX_SIZE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
    <description>Enumeration indicating the multi scome
        buffer size. The values can be combined using a
        bitwise 'OR'.  The values will need to be kept
        in sync with the FAPI enumerator values.  Also
        the enumeration type is used by the
        ATTR_MULTI_SCOM_BUFFER_MAX_SIZE.  Should
        note that the MULTI_SCOM_BUFFER_MAX_SIZE values
        are of type uint32_t
    </description>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
        <value>0x00000400</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
        <value>0x00000800</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
        <value>0x00001000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
        <value>0x00002000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
        <value>0x00004000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
        <value>0x00008000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
        <value>0x00010000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
        <value>0x00020000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
        <value>0x00040000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
        <value>0x00080000</value>
    </enumerator>
    <enumerator>
        <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
        <value>0x00100000</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>DMI_DFE_OVERRIDE</id>
    <description>
      Defines where to apply DMI bus DFE override settings for HW244323.
    </description>
    <simpleType>
        <uint8_t>
            <default>0</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DMI_DFE_OVERRIDE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_VRM_VOFFSET_VDD</id>
    <description>
      Offset voltage (binary in microvolts) to apply to the VDD VRM distribution to
      the processor module.  This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per system)

      Consumer: p8_build_gpstate_table.C
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_VRM_VOFFSET_VDD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_VRM_VOFFSET_VCS</id>
    <description>
      Offset voltage (binary in microvolts) to apply to the VCS VRM distribution to
      the processor module.  This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per system)

      Consumer: p8_build_gpstate_table.C
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_VRM_VOFFSET_VCS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>CPM_TURBO_BOOST_PERCENT</id>
    <description>
     Percent of Boost Above Turbo for CPMs - (binary in 0.1 percent steps)

     Used in generating extra Pstate tables beyond those that would result from
     #V data.

     Producer:  DEF file as this is CCIN based

     Consumers: p8_build_gpstate_table.C, p8_cpm_cal_load.C

     Platform default:  0
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_CPM_TURBO_BOOST_PERCENT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_LOADLINE_VDD</id>
    <description>
      Impedance (binary microOhms) of the load line from a processor VDD VRM to the
      Processor Module pins.  This value is applied to each processor instance.

      Consumers: p8_build_gpstate_table.C

      Provided by the Machine Readable Workbook (via the power subsystem design
      per system)
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_LOADLINE_VDD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_LOADLINE_VCS</id>
    <description>
      Impedance (binary microOhms) of the load line from a processor VCS VRM to the
      Processor Module pins.  This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per system)

      Consumer: p8_build_gpstate_table.C
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_LOADLINE_VCS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_DISTLOSS_VDD</id>
    <description>
      Impedance (binary in microOhms) of the VDD distribution loss sense point
      to the circuit. This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per system)

      Consumer: p8_build_gpstate_table.C
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_DISTLOSS_VDD</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PROC_R_DISTLOSS_VCS</id>
    <description>
      Impedance (binary in microOhms) of the VCS distribution loss sense point
      to the circuit. This value is applied to each processor instance.

      Producer:  Machine Readable Workbook (via the power subsystem design per system)

      Consumer: p8_build_gpstate_table.C
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PROC_R_DISTLOSS_VCS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_UNDERVOLTING_FRQ_MINIMUM</id>
    <description>
      Override for Minimum frequency for which undervolting is allowed.

      If value = 0, the value of VPD CPMin data point is passed to OCC FW via
      Pstate SuperStructure.

      If value != 0, this value will be passed to OCC FW via Pstate SuperStructure
      as the floor frequency for enabled CPMs.

      Will be internally rounded to the nearest ATTR_PROC_REFCLK_FREQUENCY / 8 value.

      Consumer: OCC FW; OCC Lab Tools

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_UNDERVOLTING_FRQ_MINIMUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_UNDERVOLTING_FREQ_MAXIMUM</id>
    <description>
      Override for Maximum frequency for which undervolting is allowed.

      If value = 0, the value of VPD Turbo data point is passed to OCC FW via
      Pstate SuperStructure.

      If value != 0, this value will be passed to OCC FW via Pstate SuperStructure
      as the ceiling frequency for enabled CPMs.

      Will be internally rounded to the nearest ATTR_PROC_REFCLK_FREQUENCY / 8 value.

      Consumer: OCC FW; OCC Lab Tools

      Provided by the Machine Readable Workbook.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_UNDERVOLTING_FREQ_MAXIMUM</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_WINKLE_ENTRY</id>
    <description>Setting depends on di/dt charateristics of the system.

        Set Assisted if power off serialization is needed and WINKLE_TYPE=Fast;
        Set to Hardware if the system can handle the unrelated powering off between cores.
        Hardware setting decreases entry latency

        Producer: MRWB

        Consumer:  p8_poreslw_init.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_WINKLE_ENTRY</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_WINKLE_EXIT</id>
    <description>Setting depends on di/dt charateristics of the system and the setting of ATTR_PM_WINKLE_TYPE.

        Set to Assisted if power on serialization is needed and WINKLE_TYPE=Fast;  Set to Hardware if the system
        can handle the unrelated powering off between cores.  Hardware setting decreases entry latency.
        Must be set to Assisted if ATTR_PM_WINKLE_TYPE=Deep as this necessary for restore.

        Setting to Hardware is a test mode for Fast only.

        Producer: MRWB

        Consumer:  p8_poreslw_init.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_WINKLE_EXIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>PROC_MASTER_TYPE</id>
    <description>
        Enumeration indicating the role of proc as master/alt_master/not_master
    </description>
    <enumerator>
        <name>ACTING_MASTER</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>MASTER_CANDIDATE</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>NOT_MASTER</name>
        <value>2</value>
    </enumerator>
    <default>NOT_MASTER</default>
</enumerationType>

<attribute>
    <id>PROC_MASTER_TYPE</id>
    <description>Type of Master, ACTING_MASTER or MASTER_CANDIDATE or
      NOT_MASTER</description>
    <simpleType>
        <uint8_t>
            <default>NOT_MASTER</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
    <writeable/>
</attribute>

<attribute>
  <id>MSS_DATABUS_UTIL_PER_MBA</id>
  <description>MBA DRAM data bus utilization percent to use to determine cfg_nm_n_per_mba</description>
  <simpleType>
      <uint8_t></uint8_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_DATABUS_UTIL_PER_MBA</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>MSS_UTIL_N_PER_MBA</id>
  <description>cfg_nm_n_per_mba throttle N value that was calculated from MSS_DATABUS_UTIL_PER_MBA</description>
  <simpleType>
      <uint32_t></uint32_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_MSS_UTIL_N_PER_MBA</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>EFFECTIVE_EC</id>
    <description>
        Holds the effective EC of the system.  Effective EC is the lowest EC
        among all the functional procs in the system.  Some cards may "downbin"
        the effective ECs of their contained processors, which could lower the
        effective EC of the system beyond what would occur when considering
        processor ECs alone
    </description>
    <simpleType>
        <uint8_t>
            <default>0x00</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
  <id>PROC_PBA_UNTRUSTED_BAR_BASE_ADDR</id>
    <description>PBA Untrusted BAR base address (secure mode)
      creator: platform
      firmware notes:
        64-bit address representing BAR RA
    </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PBA_UNTRUSTED_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PBA_UNTRUSTED_BAR_SIZE</id>
    <description>PBA Untrusted BAR size (secure mode)
      creator: platform
      firmware notes:
        mask applied to RA 23:43
    </description>
  <simpleType>
      <uint64_t></uint64_t>
  </simpleType>
  <persistency>volatile-zeroed</persistency>
  <readable/>
  <writeable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PBA_UNTRUSTED_BAR_SIZE</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>
<attribute>
    <id>MRU_ID</id>
    <description>MRU ID attribute for chip/unit class</description>
    <simpleType>
        <uint32_t>
            <default>0x00</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MSS_INIT_STATE</id>
    <description>How far into the ipl istep the centaur has been brought up</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_INIT_STATE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_FFE_GEN1</id>
    <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe TX FFE (Gen1)
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
    </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_FFE_GEN1</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
  <id>PROC_PCIE_IOP_TX_FFE_GEN2</id>
    <description>
      creator: platform (MRW)
      consumer: proc_pcie_scominit
      notes:
        PCIe TX FFE (Gen2)
        First array index: IOP number (0:1)
        Second array index: Lane number (0:15)
    </description>
  <simpleType>
      <uint32_t></uint32_t>
      <array>2,16</array>
  </simpleType>
  <persistency>non-volatile</persistency>
  <readable/>
  <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_TX_FFE_GEN2</id>
      <macro>DIRECT</macro>
  </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
    <description>Machine Readable Workbook DIMM power curve percent uplift for this system</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_MEM_THROTTLE_DENOMINATOR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_MAX_DRAM_DATABUS_UTIL</id>
    <description>Machine Readable Workbook value for maximum dram data bus utilization in centi percent (c%).  Used to determine memory throttle values.</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_MAX_DRAM_DATABUS_UTIL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>RECONFIGURE_LOOP</id>
    <description>
        Used to inidicate if a reconfigure loop is needed.
        Hostboot clears and sets this during istep dispatching.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_RECONFIGURE_LOOP</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>RECONFIGURE_LOOP</id>
    <description>Enumeration of RECONFIGURE_LOOP flags</description>
    <!-- add enumerators (single bits) for anything that needs a reconfigure loop -->
    <enumerator>
        <description>
            Indicates HW has been deconfigured
        </description>
        <name>DECONFIGURE</name>
        <value>0x01</value>
    </enumerator>
    <enumerator>
        <description>
            Indicates a bad DQ bit was set in the BadDqBitmap
        </description>
        <name>BAD_DQ_BIT_SET</name>
        <value>0x02</value>
    </enumerator>
</enumerationType>

<attribute>
    <id>PM_SYSTEM_IVRMS_ENABLED</id>
    <description>System control to allow (if all other attribute tests yield true values) or categorically disallow IVRM enablement
     Producer: MRWB
     Consumer:  p8_build_pstate_datablock.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SYSTEM_IVRMS_ENABLED</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SYSTEM_IVRM_VPD_MIN_LEVEL</id>
    <description>Version level of #M that represents the minimum for IVRM characterized parts.
     If this value is non-zero and the #M version level is less than this value, IVRMs are disabled.
     If the #M version is greater than or equal to this value, the IVRMs are allowed to be enable from a level of part perspective.
     Producer: MRWB
     Consumer:  p8_build_pstate_datablock.C
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SYSTEM_IVRM_VPD_MIN_LEVEL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLW_DEEP_WINKLE_EXIT_GOOD_HALT_ADDR</id>
    <description>
    Stores the offset in SLW image of the halt point for a good Deep Winkle Exit transition.
    This is value may used by FAPI code to check that the SLW engine achieved an expected state.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLW_DEEP_WINKLE_EXIT_GOOD_HALT_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_SLW_DEEP_SLEEP_EXIT_GOOD_HALT_ADDR</id>
    <description>
    Stores the offset in SLW image of the halt point for a good Deep Sleep Exit transition.
    This is value may used by FAPI code to check that the SLW engine achieved an expected state.
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_SLW_DEEP_SLEEP_EXIT_GOOD_HALT_ADDR</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_EFF_VPD_VERSION</id>
    <description>
        The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in ASCII) of the VINI VZ keyword
    </description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_EFF_VPD_VERSION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DISABLE_SCRUB_AFTER_PATTERN_TEST</id>
    <description>
        1 = disable scrub after memdiags pattern test. 0 = scrub after memdiags pattern test.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_DISABLE_SCRUB_AFTER_PATTERN_TEST</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_PCBS_FSM_TRACE_EN</id>
    <description>
    Overridable attribute to allow for PCBS FSM tracing by Power Management procedures
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_PCBS_FSM_TRACE_EN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_GLOBAL_FIR_TRACE_EN</id>
    <description>
    Overridable attribute to allow for Global checkstop and recoverable FIR tracing by Power Management procedures
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_GLOBAL_FIR_TRACE_EN</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>Value of on or off.  On is 256 bit interleave.  Off, the translation is on 128  bit interleave mode.  See centaur workbook chapter 5.</description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
    <description>
       The MRW for a system should set this to TRUE for systems that must obey plug rules.  Lab environments should default this to off and allow the user to override using normal methods to test.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_STRICT_MBA_PLUG_RULE_CHECKING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_DERIVED_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>This dial sets the Centaur address bits used to interleave addresses between MBA01 and MBA23.  Valid values are 23 through 32.  See Centaur Spec Chapter 5 for details.   Used in the intifile </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_DERIVED_MBA_ADDR_INTERLEAVE_BIT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
    <description>At a system level, this attribute controls if interleaving is required, requested or never.  The MRW.</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>PM_HWP_ATTR_VERSION</id>
    <description>Defines HWP version to be checked inside HWPs to determine if new code should be loaded/skipped/modified/etc.</description>
    <simpleType>
        <uint32_t></uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_PM_HWP_ATTR_VERSION</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>REDUNDANT_CLOCKS</id>
    <description>
    1 = System has redundant clock oscillators
        0 = System does not have redundant clock oscillators
        From the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_REDUNDANT_CLOCKS</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MSS_NEST_CAPABLE_FREQUENCIES</id>
    <description>
        The NEST frequencies the memory chip can run at computed by the mss_freq.  The possibilities are ORed together.  The platform uses these value and the MRW to determine what frequency to boot the fabric (nest) if it can. There are two values: 8G and 9.6G
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MSS_NEST_CAPABLE_FREQUENCIES</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_ENHANCED_GROUPING_NO_MIRRORING</id>
    <description>
       The MRW for a system should set this to TRUE for systems that do not want to suport MCS groupings larget than 2.  Mirroring  also must be disabled and is unusable. IBM systems, such as Tuleta, should set this attribute to FALSE.  Stradale based systems should set this to TRUE.  This instructs the grouping code to group contiguous memory controllers of the same size together.
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_ENHANCED_GROUPING_NO_MIRRORING</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<enumerationType>
    <id>TOD_ROLE</id>
    <description>
        Enumeration indicating what role this chip has in tod topology
    </description>
    <enumerator>
        <name>NON_MASTER</name>
        <value>0</value>
    </enumerator>
    <enumerator>
        <name>PRIMARY</name>
        <value>1</value>
    </enumerator>
    <enumerator>
        <name>SECONDARY</name>
        <value>2</value>
    </enumerator>
    <default>NON_MASTER</default>
</enumerationType>

<attribute>
    <id>TOD_ROLE</id>
    <description>
        Bitmask indicating what role this chip has in tod topology
    </description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
</attribute>

<attribute>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <description>
      System attribute.
      6 bit rx_min_eye_width value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_DMI_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <description>
      System attribute.
      8 bit rx_min_eye_height value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_DMI_MIN_EYE_HEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_ABUS_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <description>
      System attribute
      8 bit rx_min_eye_height value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_ABUS_MIN_EYE_HEIGHT</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for X bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
        <uint8_t>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MNFG_XBUS_MIN_EYE_WIDTH</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <description>
        The amount of mainstore that PHYP needs to preserve per node
        during MPIPL.
    </description>
    <simpleType>
        <uint32_t>
            <default>256</default>
        </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

<attribute>
    <id>MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the master i2c bus</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
    <description>Used for Custom DIMMs to not enable the reading of the dimm temperature sensor on the spare i2c bus</description>
    <simpleType>
        <uint8_t></uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
        <id>ATTR_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE</id>
        <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
</attribute>

<attribute>
    <id>DO_ABUS_DECONFIG</id>
    <description>
        Indicates if system should consider abus logic when deconfiguring in
        _deconfigureAssocProc(), will be overwritten on multi-node system
    </description>
    <simpleType>
        <uint8_t>
            <default>1</default>
        </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
</attribute>

</attributes>
