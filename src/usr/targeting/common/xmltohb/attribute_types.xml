<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types.xml $        -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2012,2023                        -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->
<attributes>
  <attribute>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <id>AFFINITY_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <description>
        System attribute.
        If all MCS chiplets are in an interleaving group (1=true, 0=false).
        - If true the SMP fabric is setup in normal mode and multiple MCSs
          are grouped (disallowing systems with memory only under 1 MCS
          (i.e. systems with a single C-DIMM))
        - If false the SMP fabric is setup in checkerboard mode.
        Provided by the Machine Readable Workbook.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <description>
        The asynchronous nest frequency
    </description>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>ATTN_AREA_1_ADDR</id>
    <description>
    Specifies the "intended" starting memory address for PHYP's ATTN area 1.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 1 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>ATTN_AREA_2_ADDR</id>
    <description>
    Specifies the "intended" starting memory address for PHYP's ATTN area 2.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 2 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory AVDD voltage domain ID.  All memory buffers in the same AVDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Block speculative deconfig in reconfig loop.
        Flags when speculative deconfigurations should not be done for
        predictive gard records on a reconfig loop IPL due to out of
        hardware condition on prior IPL.
        0 = Allow speculative deconfiguration
        1 = Block speculative deconfiguration
        </description>
    <id>BLOCK_SPEC_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels
        to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>DEFAULT_ALL</default>
    <description>Enumeration for the various BPM update behaviors</description>
    <enumerator>
      <name>DEFAULT_ALL</name>
      <value>0x0000</value>
    </enumerator>
    <enumerator>
      <name>SKIP_ALL</name>
      <value>0x1010</value>
    </enumerator>
    <enumerator>
      <name>FORCE_ALL</name>
      <value>0x1111</value>
    </enumerator>
    <enumerator>
      <name>SKIP_FW</name>
      <value>0x1000</value>
    </enumerator>
    <enumerator>
      <name>FORCE_FW</name>
      <value>0x1100</value>
    </enumerator>
    <enumerator>
      <name>SKIP_CONFIG</name>
      <value>0x0010</value>
    </enumerator>
    <enumerator>
      <name>FORCE_CONFIG</name>
      <value>0x0011</value>
    </enumerator>
    <enumerator>
      <name>FORCE_CONFIG_SKIP_FW</name>
      <value>0x1011</value>
    </enumerator>
    <enumerator>
      <name>SKIP_CONFIG_FORCE_FW</name>
      <value>0x1110</value>
    </enumerator>
    <id>BPM_UPDATE_BEHAVIOR</id>
  </enumerationType>

  <attribute>
    <id>BPM_UPDATE_OVERRIDE</id>
    <description>
        If non-zero then use value to determine which portion of BPM updates to
        skip/force/default behavior.
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>BRAZOS_RX_FIFO_OVERRIDE</id>
    <description>
      Defines where to apply Brazos rx_fifo_final_l2u_dly override settings for SW299500.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Specifies a target's CEC degraded mode domain.  For example, all
        DIMMs are part of the DIMM CEC degraded mode domain.
    </description>
    <hasStringConversion/>
    <id>CDM_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CDM_DOMAIN</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration specifying a target's CEC degraded mode domain
    </description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CPU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FABRIC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>IO</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CLOCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>10</value>
    </enumerator>
    <id>CDM_DOMAIN</id>
  </enumerationType>

  <attribute>
    <description>
        Cec Degraded Mode Policy flags
        Use the CDM_POLICIES enum to decode.
        If the appropriate bit is 1 then the policy mode is enabled,
        and those type of Guard records are disabled.
    </description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>
        MFG_Guard policy:
        Used in MFG only to prevent and disable the following:
        . Storing or creation of new Guard records from Diagno`stic or other
            faults through error logs. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        . Storing or creation of Manual Guard record from user.
            NOTE: this does not stop FCO.
        . Using an already stored System or Manual Guard record from
            deconfiguring resources. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        </description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>
        Predictive_Guard policy:
        Used in Field or development to prevent and disable the following:
        . Storing or creation of new Guard records from diagnostics or other
            faults through error logs with the error_type of Predictive.
        . Using an already stored System Guard record with error_type of
            Predictive from deconfiguring resources.
        </description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure which defines a they IPL types
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Perform mainstore dump collection. Only valid for MPIPL
                0b0: Do not collect mainstore dump
                0b1: Perform mainstore dump collection
            </description>
        <name>PostDump</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>7</bits>
        <default>0</default>
        <description>Minor IPL Type</description>
        <name>MinorIPLType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes optional IPL flavors
    </description>
    <id>CEC_IPL_TYPE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to
        report the ECID data to the BMC and make it available for systems which
        have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
   </description>
    <id>CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>The address offset which each Chiplet types pervasive
     address space used to represent the a chiplet.
     0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets
     0x10 to 0x1F =&gt; All Cache Chiplets
     0x20 to 0x37 =&gt; All Core Chiplets
     0x38 to 0x3F =&gt; Multicast Operation
   </description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>CHIP_ID</id>
    <description>attribute indicating the chip's ID</description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>A unit (chiplet) 's  offset number within the chip. </description>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion/>
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ASIC</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>12</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>

  <attribute>
    <description>CPU Attribute</description>
    <id>CPU_ATTR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>CVPD_MAX_SECTIONS</id>
    <description>Max CVPD sections </description>
    <simpleType>
      <uint32_t>
        <default>32</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>CVPD_SIZE</id>
    <description>Size of CDIMM/ISDIMM
                 This is the size of the centaur vpd or memory buffer vpd.
                 It varies based on the type of the DIMM. For ISDIMMs,
                 the size will be 8KB and for CDIMM, it will be 4KB.
    </description>
    <simpleType>
      <uint64_t>
        <default>0x2000</default>
      </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>L1 Data Cache Line Size in bytes</description>
    <id>DATA_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>L1 Data Cache Size in KB</description>
    <id>DATA_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>DCache Associative Sets</description>
    <id>DCACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>DCache Line Size in bytes</description>
    <id>DCACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>If the Target is directly deconfigurable and GARDable; target
    may still be deconfigured in 'by association' processing.</description>
    <id>DECONFIG_GARDABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Used to tell I2C code whether to run
        I2C Engine 2 Port 0 in diag mode or not
        0 = Use Diag Mode
        1 = Disable Diag Mode
    </description>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Setting that determins if the TPM(s) on the system should be disabled
        0x00 - Do NOT Disable TPM
        0x01 - Disable TPM
    </description>
    <id>DISABLE_TPM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <description>
        Indicates if system should consider abus logic when deconfiguring in
        _deconfigureAssocProc(), will be overwritten on multi-node system
    </description>
    <id>DO_ABUS_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Defines a negative percentage value that is applied to
        the ATTR_NOMINAL_FREQ_MHZ determined from MVPD #V.  It
        is used to explicitly raise the value of MIN_FREQ_MHZ above
        what is specified by MVPD #V data.  On FSP systems this
        is sourced from the power_management def file.
        Value must be between 0 and -100.
        A value of zero indicates no override.
    </description>
    <id>DPO_MIN_FREQ_PERCENT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <range>
      <min>-100</min>
      <max>0</max>
    </range>
    <simpleType>
      <int32_t>
        <default>0</default>
      </int32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Dummy attribute on the heap with zero initialization</description>
    <id>DUMMY_HEAP_ZERO_DEFAULT</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read/write permissions</description>
    <id>DUMMY_RW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>1,3,5</array>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_DUMMY_SCRATCH_PLAT_INIT_UINT8</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Dummy attribute with write-only permissions</description>
    <id>DUMMY_WO</id>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>EC</id>
    <description>attribute indicating the chip target's EC level</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_EC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Specifies a target's eeprom content type.</description>
    <hasStringConversion/>
    <id>EEPROM_CONTENT_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>EEPROM_CONTENT_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>RAW</default>
    <description>Enumeration indicating a target's eeprom
        content type.
        RAW - eeprom has no specified layout
        ISDIMM - uses standard JEDEC layout for DDR memory
        IBM_FRUVPD - uses ipz converged vpd layout with records/keywords for
                     generic FRUs
        IBM_MVPD - use ipz converged vpd layout with records/keywords for
                   processor modules
        DDIMM - uses Differential DIMM layout
    </description>
    <enumerator>
      <name>RAW</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>IBM_FRUVPD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>IBM_MVPD</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <id>EEPROM_CONTENT_TYPE</id>
  </enumerationType>

  <attribute>
    <id>EEPROM_NV_INFO</id>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <name>i2cMasterPath</name>
        <description>Entity path to the chip that contains the I2C
                master.
            </description>
        <type>EntityPath</type>
        <default>physical:sys-0</default>
      </field>
      <field>
        <name>port</name>
        <description>Port from the I2C Master device. This is a 6-bit
                value, but then shifted 2 bits left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>devAddr</name>
        <description>Device address on the I2C bus. This is a 7-bit value,
                but then shifted 1 bit left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>engine</name>
        <description>I2C master engine. This is a 2-bit value,
                but then shifted 6 bits left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>byteAddrOffset</name>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. For NV controller it's only
                one byte addressing with no page select (3)
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <type>uint8_t</type>
        <default>0x03</default>
      </field>
      <field>
        <name>maxMemorySizeKB</name>
        <description>The number of kilobytes a device can hold.  'Zero'
                value possible for some devices.
            </description>
        <type>uint64_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>chipCount</name>
        <description>The number of chips making up an eeprom device.
            </description>
        <type>uint8_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>writePageSize</name>
        <description>The maximum number of bytes that can be written to
                a device at one time. 'Zero' value means no maximum value is
                expected or checked.
            </description>
        <type>uint64_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>writeCycleTime</name>
        <description>The amount of time in milliseconds a device requires
                on the completion of a write command to update its internal memory.
            </description>
        <type>uint64_t</type>
        <default>0x05</default>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains secondary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains primary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. DDR4 DIMMs require a special EEPROM
                page switching mechanic denoted here by a value of 1
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Holds the effective EC of the system.  Effective EC is the lowest EC
        among all the functional procs in the system.  Some cards may "downbin"
        the effective ECs of their contained processors, which could lower the
        effective EC of the system beyond what would occur when considering
        processor ECs alone
    </description>
    <id>EFFECTIVE_EC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Bitmask of threads to enable for each processor,
       Zero means enable all architected threads
    </description>
    <id>ENABLED_THREADS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion/>
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric chip id for this chip (position within the fabric).
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric group the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Correlate HDAT node number (physical) to the logical node
        (based on the PIR) that contains the host boot image.
    </description>
    <id>FABRIC_TO_PHYSICAL_NODE_MAP</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <uint8_t>
        <default>0,255,255,255,255,255,255,255</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Common name across FAPI environments
    chip target -&gt; pu:k0:n0:s0:p00
    DIMM target -&gt; dimm:k0:n0:s0:p00
    chip unit target -&gt; pu.core:k0:n0:s0:p00:c0
    cage/system target -&gt; k0

    (chip type).(unit type):k(cage,always zero for us):n(node/drawer)
              :s(slot,always zero for us):p(chip position):c(core/unit position)
    pu  = generic processor
    </description>
    <id>FAPI_NAME</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration defining special FAPI_POS values</description>
    <enumerator>
      <name>NA</name>
      <value>0xFFFFFFFF</value>
    </enumerator>
    <id>FAPI_POS</id>
  </enumerationType>

  <attribute>
    <description>Field Core Override (FCO) is the override value for the
    number of functional cores allowed on the system.
    FCO is used when customers order a system with N cores but they only want
    to enable less than N cores to lower software license costs. A field in the
    anchor VPD is set by manufacturing to specify the maximum number of cores
    to enable. The number is maintained, even if some cores are garded out due
    to error.
    A value of 0 means all cores allowed;
    </description>
    <id>FIELD_CORE_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Column Repairs allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Column Repairs allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>7</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Lab-only trigger to force a factory reset of the NVDIMMs.
      NOTE: This will erase any saved image and encryption keys.
    </description>
    <id>FORCE_NVDIMM_RESET</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>FORCE_SRAM_MMIO_OVER_I2C</id>
    <description>
    Force inband SRAM access to be over I2C instead of MMIO
    This is a way to get data when the MMIO path is not working
    (0x00 = use normal path, 0x01 = force i2c path)
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>FREQ_CORE_CEILING_MHZ</id>
    <description>
    The maximum core frequency in MHz.
    This is the same for all cores in the system.
    Data is provided by MVPD #V and is calculated as
    the minimum of the turbo frequencies.
  </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>FREQ_CORE_MAX</id>
    <description>
      SYSTEM Attribute
      Maximum frequency (binary in MHz) that any processor in the system will
      run. Used to define the top end of the PState range in the frequency space.
      From this, the ATTR_PROCPM_PSTATE0_FREQUENCY is computed using
      ATTR_SYSTEM_REFCLK_FREQUENCY to determine the step size.

      Consumers: proc_build_gpstate_table.C (among others)

      Data is is provided by MVPD #V and is calculated as the minimum
      of the turbo frequencies
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <!-- Required by FSP -->
  <attribute>
    <id>FREQ_PROC_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the processor refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC
        for each fru in the system.</description>
    <global/>
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the default master processor</description>
    <id>FSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the default master processor</description>
    <id>FSI_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Type of Master FSI connection to this slave (MFSI or cMFSI)</description>
    <hasStringConversion/>
    <id>FSI_MASTER_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <default>NO_MASTER</default>
        <id>FSI_MASTER_TYPE</id>
      </enumeration>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NO_MASTER</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>MFSI</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CMFSI</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NO_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>FSI_MASTER_TYPE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
                Set on FSI master chips (procs) if that chip uses slaveB
                to attach to the acting master chip.
            </description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>
        Reserved for any special flags we might need to access FSI
    </description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Slave cascade position</description>
    <id>FSI_SLAVE_CASCADE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of FSP IO Region</description>
    <id>FSP_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003FFE000000000</default>
      </uint64_t>
    </simpleType>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FSP_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <id>FUSED_CORE_MODE_HB</id>
    <description>Enum for FUSED_CORE_MODE_HB</description>
    <enumerator>
      <name>SMT4_DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SMT4_ONLY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SMT8_ONLY</name>
      <value>2</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <id>FUSED_CORE_MODE_HB</id>
    <description>
        Stores the SMT setting used to determine fused mode.
        SMT4_DEFAULT: Nimbus_DD1, boot in SMT4 but can change to SMT8
        SMT4_ONLY: Nimbus_DD2/Cumulus, set based on PVR info
        SMT8_ONLY: Nimbus_DD2/Cumulus, set based on PVR info
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        If not loading PHYP or OPAL, then use this to
        decide whether to use FUSED cores or NOT.
    </description>
    <id>FUSED_CORE_OPTION</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enum for FUSED_CORE_OPTION</description>
    <enumerator>
      <name>USING_DEFAULT_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>USING_NORMAL_CORES</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>USING_FUSED_CORES</name>
      <value>2</value>
    </enumerator>
    <id>FUSED_CORE_OPTION</id>
  </enumerationType>

  <attribute>
    <description>Hostboot HRMOR = (HB_HRMOR_NODAL_BASE * node) + offset. </description>
    <id>HB_HRMOR_NODAL_BASE</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x200000000000</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        The amount of mainstore that PHYP needs to preserve per node
        during MPIPL.
    </description>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>256</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings.
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Enable / Disable continuous trace.
                0b0: Continuous trace is disabled.
                0b1: Continuous trace is enabled.
            </description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for SCAN component.
                0b0: TRACS entries for SCAN have default behavior.
                0b1: TRACS entries for SCAN are enabled.
            </description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for DBG component.
                0b0: TRACS entries for DBG have default behavior.
                0b1: TRACS entries for DBG are enabled.
            </description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes how the SP has configured features in
      Hostboot.
    </description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
       Indicates the chip's EC level, distinct from ATTR_EC to handle
       non-standard mini-ECs, e.g. 1.01, separate from the real
       hardware-defined EC level.  By default, ATTR_HDAT_EC==ATTR_EC
       unless the chip has a mini-EC.
    </description>
    <id>HDAT_EC</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot runtime data section.
    </description>
    <id>HDAT_HBRT_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Biggest size for any of the hostboot
        runtime data sections.
    </description>
    <id>HDAT_HBRT_SECTION_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>9</array>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            purpose to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <!-- deprecated -->
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            type to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <!-- deprecated -->
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <!-- deprecated -->
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <!-- deprecated -->
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>THERMAL_SENSOR</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c04</name>
      <value>0x0D</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c412</name>
      <value>0x0E</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c32</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c64</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c16</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>NVDIA_GPU</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>NXP_LPC_Microcontroller_LPC11U35</name>
      <value>0x13</value>
    </enumerator>
    <enumerator>
      <name>9550</name>
      <value>0x14</value>
    </enumerator>
    <enumerator>
      <name>TCG_I2C_TPM</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot reserved memory section.
    </description>
    <id>HDAT_RSV_MEM_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>HDDW_ORDER</id>
    <description>PCIe slot HDDW order definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>HOMER_PHYS_ADDR</id>
    <description>
        Physical address where HOMER image is placed in mainstore.
    </description>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_HOMER_PHYS_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Value of the next EID that host service should send.
        (Note - EID is more accurate, PLID being kept to handle legacy code.)
    </description>
    <id>HOSTSVC_PLID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x89000000</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <description>Hot Plug Controller values for a specific processor.
        Purpose: Holds information about the hot plug controllers so that a
            Hardware procedure is able to turn them on and off.
        Data Format: up to 8 Hot Plug Controllers x 7 variables of information
            This data is at the processor level.
            The needed information and their individual sizes are as follows:
            (1) I2C Master processor engine (uint8_t)
            (2) I2C Master processor port (uint8_t)
            (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB)
            (4) Slave address (uint8_t)
            (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum)
            (6) I2C Master processor node (uint8_t)
            (7) I2C Master processor position (uint8_t)
            Thus, the information will be 8 bytes.
    </description>
    <simpleType>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            </default>
      </uint8_t>
      <array>8,8</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Hardware Unit ID
        SSSSNNNNTTTTTTTTiiiiiiiiiiiiiiii
        S=System
        N=Node Number
        T=Target Type (matches TYPE attribute)
        i=Instance/Sequence number of target, relative to node
    </description>
    <id>HUID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <default>0xFFFFFFFF</default>
      <uint32_t/>
    </simpleType>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the services that are concerned
        with target changes (ie, via HCDB change).
        The values can be combined using a bitwise 'OR'.
    </description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>struct - 4 booleans and a PLID</description>
      <field>
        <default>0</default>
        <description>if this target was deconfigured,
                this will be a special DECONFIGURED_BY_ enum,
                OR it will be the errlog EID that caused it,
                either directly or by association,
            </description>
        <name>deconfiguredByEid</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
            </description>
        <name>poweredOn</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
            </description>
        <name>present</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not functional;
             0b1: Target is functional
            </description>
        <name>functional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
            </description>
        <name>dumpfunctional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set for speculative deconfig;
             0b0: target not speculative deconfig;
             0b1: target is speculatively deconfigured;
            </description>
        <name>specdeconfig</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>HardWare Availability Service State Attribute.
        Keeps track of Target values poweredOn, present, functional</description>
    <id>HWAS_STATE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Attribute.
        Keeps track of changedSinceChecked state, indicates if the
        target has changed since last checked by the appropriate service.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Mask.
        Used when a target changes (ie, via HCDB change) to set the
        HWAS_STATE_CHANGED_FLAG, so that the appropriate services will
        all handle the change.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Designates the speed at which a given I2C bus should run.
        Creator: MRW
        Purpose: Used by FW to know the fastest possible bus speed that all of
            the devices on a given bus are able to use.
        Data Format: 4x13 array of uint16_t values.  The first index indicates
            the engine number of the bus.  The second index indicates the port
            number of the bus.  The value in the array is the I2C bus speed
            used for that engine/port combination in KHz.
    </description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,13</array>
      <uint16_t>
        <default>
            0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>I2C_CONTROL_INFO</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the I2C mux for
            this device
                     must enable to connect this device to its I2C master, if applicable.
                     0xFF indicates no I2C mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path of the I2C mux for this device, if any.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which I2C access method to use at
        a point in time.  Only applicable if target supports one or more I2C
        types.  Only one bit (of the first two) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI I2C at this time.  0b1: Use FSI
            I2C at this time</description>
        <name>useFsiI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use Host I2C at this time.  0b1: Use
            Host I2C at this time</description>
        <name>useHostI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which I2C method to use</description>
    <id>I2C_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>MCS Inband Scom base address</description>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Assoc Sets</description>
    <id>ICACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Block Size in bytes</description>
    <id>ICACHE_BLOCK_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Icache Line Size in bytes</description>
    <id>ICACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Size in KB</description>
    <id>ICACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Size of IMT IO Region
        Set by FSP-based tooling
    </description>
    <id>IMT_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0000000000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of In-Memory Trace Region
        Set by FSP-based tooling
    </description>
    <id>IMT_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      Controls whether target discovery code should assume the target is
      initially present, functional, and powered on (even though later
      operations may change this).  Commonly used to avoid having to do presence
      detect on certain targets.
          0x00: Do not assume target is initially available
          0x01: Assume target is initially available
    </description>
    <id>INIT_TO_AVAILABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <no_export/>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <description>Base Address of Interrupt Presenter</description>
    <id>INTP_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>ISTEP_MODE</id>
    <description>If True, puts HostBoot into SPLess SingleStep mode.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_ISTEP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      Used to configure the parameters for enabling pause/stop between
      isteps. This attribute is set via attribute override.
    </description>
    <id>ISTEP_PAUSE_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Used to enable pause/stop in between isteps. This attribute is set via
      attribute override.
    </description>
    <id>ISTEP_PAUSE_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Indicate an inter-enclosure bus at this endpoint target.
                 0 = No, 1 = Yes
    </description>
    <id>IS_INTER_ENCLOSURE_BUS</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>KEY_CLEAR_REQUEST</id>
    <description>
        Indicates types of Key Clear Requests are being made
    </description>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>KEY_CLEAR_REQUEST</id>
        <default>NONE</default>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <id>KEY_CLEAR_REQUEST</id>
    <description>
        Enum indicating the different possible Key Clear Request values
        NOTE: See "Host FW key clear requests" in HDAT spec
    </description>
    <enumerator>
      <description>
          (Default) Key Clear not requested
      </description>
      <name>NONE</name>
      <value>0x0000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear All" : Clear/reset all sensitive data controlled by platform
          firmware from the system
      </description>
      <name>ALL</name>
      <value>0x8000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear OS Keys" : This indicates OPAL to clear the OS secureboot keys
      </description>
      <name>OS_KEYS</name>
      <value>0x4000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear PowerVM System Key" : This indicates to PowerVM to clear the
          system key to the default state
      </description>
      <name>POWERVM_SYSKEY</name>
      <value>0x1000</value>
    </enumerator>
    <enumerator>
      <description>
          Reserved bits
      </description>
      <name>RESERVED_1</name>
      <value>0x2E00</value>
    </enumerator>
    <enumerator>
      <description>
          MFG mode and imprint driver only : Clear all sensitive data and
          leave storage empty
      </description>
      <name>MFG</name>
      <value>0x0100</value>
    </enumerator>
    <enumerator>
      <description>
          Reserved bits
      </description>
      <name>RESERVED_2</name>
      <value>0x00FF</value>
    </enumerator>
  </enumerationType>

  <enumerationType>
    <id>KEY_TRANSITION_STATE</id>
    <description>
        Enum indicating the current Secure Boot key transition state for the
        node.
    </description>
    <enumerator>
      <description>
            Secure Boot key transition not yet requested for the node
        </description>
      <name>KEY_TRANSITION_NOT_REQUESTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <description>
            About to write new system Secure Boot key to first SBE SEEPROM
            side in the node
        </description>
      <name>KEY_TRANSITION_STARTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <description>
            Failed to apply new system Secure Boot key to one or more functional
            SBE SEEPROM sides in the node
        </description>
      <name>KEY_TRANSITION_FAILED</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <description>
            Successfully applied new system Secure Boot key to every functional
            SBE SEEPROM side in the node
        </description>
      <name>KEY_TRANSITION_SUCCEEDED</name>
      <value>3</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <description>
    Attribute indicating the status of the Secure Boot key transition for
    the node
  </description>
    <hasStringConversion/>
    <id>KEY_TRANSITION_STATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <enumeration>
        <id>KEY_TRANSITION_STATE</id>
        <default>KEY_TRANSITION_NOT_REQUESTED</default>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Assoc Sets</description>
    <id>L2_CACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Line Size in bytes</description>
    <id>L2_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Size in KB</description>
    <id>L2_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>L3 Cache Line Size in bytes</description>
    <id>L3_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>L3 Cache Size in KB</description>
    <id>L3_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>LPC Bus address - MMIO consumed by PHYP</description>
    <id>LPC_BUS_ADDR</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max chiplets per proc available in the system.
    </description>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>MAX_COMPUTE_NODES_PER_SYSTEM</id>
    <description>
        The max compute nodes available in the system.
        Computed value based on CEC enclosures.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max DIMMs per MBA Port available in the system.
    </description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <!-- End Required by FSP -->
  <attribute>
    <id>MAX_DMI_PER_PROC</id>
    <description>
        System attribute.
        The max DMI units per proc available in the system.
    </description>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max EX units per proc chip available in the system.
    </description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBAS per membuf available in the system.
    </description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBA ports per MBA available in the system.
    </description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MCS units available in the system.
    </description>
    <id>MAX_MCS_PER_SYSTEM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>4</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MAX_POWER</id>
    <description>Defines the maximum power consumption for a PCIe slot</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max proc chips per node available in the system.
    </description>
    <id>MAX_PROC_CHIPS_PER_NODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MAX_SBE_SEEPROM_SIZE</id>
    <description>
      Defines the maximum Seeprom storage size for the fully-customized SBE image
      permitted by the platform.
      For platforms (FSP/HB FW) which require the image to be constrained into a
      physical storage device (SEEPROM), this should reflect the maximum size of that
      memory (e.g., 256KB).
      For platforms (Cronus) which may use a customized image in a virtual
      envrionment with no physical storage constraints, this size may be
      larger than the physical SEEPROM size.
    </description>
    <simpleType>
      <uint32_t>
        <default>0x40000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MAX_SBE_SEEPROM_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MBA_DIMM</id>
    <description>
       MBA port DIMM number of this DIMM
       (deprecated in favor of POS_ON_MEM_PORT)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MBA_PORT</id>
    <description>
       MBA port this DIMM is connected to
       (deprecated in favor of MEM_PORT)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MC_PLL_BUCKET</id>
    <description>
        MC pll bucket selection in async mode for Cumulus
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MC_PLL_BUCKET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory AVDD voltage domain offset in mV.</description>
    <id>MEM_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Base Address for all mainstore behind this processor</description>
    <id>MEM_BASE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MEM_PORT</id>
    <description>
       Memory port this DIMM is connected to
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Memory VCS voltage domain offset in mV.</description>
    <id>MEM_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VCS_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VDDR voltage domain offset in mV.</description>
    <id>MEM_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VDD voltage domain offset in mV.</description>
    <id>MEM_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VPP voltage domain offset in mV.</description>
    <id>MEM_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPP_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MFG_TRACE_ENABLE</id>
    <description>
        Override this to a non-zero value to have the FAPI manufacturing
        traces output to the console or go to a fsp trace buffer when
        console not enabled.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
    <description>Enum for MFG_WRAP_TEST_ABUS_LINKS_SET</description>
    <enumerator>
      <name>SET_NONE</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>SET_1</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SET_2</name>
      <value>0x2</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
    <description>
      Due to fabric limitations, we can only enable 2 links
      at a time during wrap testing. This attribute defines
      which set this ABUS link belong to. This attribute
      will live on the OBUS target. The value will come
      from MRW. When the value for this attribute matches
      MFG_WRAP_TEST_ABUS_LINKS_SET_ENABLE, then we leave the
      OBUSes configured. Otherwise, we deconfigure them.
    </description>
    <simpleType>
      <enumeration>
        <default>SET_NONE</default>
        <id>MFG_WRAP_TEST_ABUS_LINKS_SET</id>
      </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MFG_WRAP_TEST_ABUS_LINKS_SET_ENABLE</id>
    <description>
      This attribute defines which set of ABUS links to enable
      during MST wrap testing. This attribute will live on
      the system target. The value will be overriden during
      MST testing. When the value of MFG_WRAP_TEST_ABUS_LINKS_SET
      on each of the OBUS matches with this value, then we leave the
      OBUSes configured. Otherwise, we deconfigure them.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MGC_LOAD_SOURCE</id>
    <description>defines MGC load source</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The lowest frequency that a core can be set to in MHz.
        This is the same for all cores in the system.
        Data is provided by MVPD #V and is calculated as the
        Maximum of the power save frequencies.
    </description>
    <id>MIN_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>4800</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_FLOOR_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MIRROR_BASE_ADDRESS</id>
    <description>System Mirrorable Base Address
       Bits8-12 Specifies System Selects
       Bits13-14 Memory select
       Bits15-18 Group ID (within an SMP)
       Bits19-21 Chip ID (8 Max)
       Bits22-63 Chip internal address (42 bits, 4TB)
       Mirroring uses memory select
    </description>
    <simpleType>
      <uint64_t>
        <default>0x4000000000000</default>
      </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_MIRROR_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <description>
      System attribute
      8 bit rx_min_eye_height value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <description>
      System attribute.
      8 bit rx_min_eye_height value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <description>
      System attribute.
      6 bit rx_min_eye_width value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <id>MNFG_FLAG</id>
    <description>Enumeration indicating the mnfg flags
        that are set by the user.  The values can be
        combined using a bitwise 'OR'.  The values will
        need to be kept in sync with the FAPI
        enumerator values.  Also the enumeration type
        is used by the ATTR_MNFG_FLAGS attribute.  Should
        note that the MNFG_FLAG values are of type uint32_t
    </description>
    <enumerator>
      <!-- Use default mfg error thresholds and reporting values -->
      <name>THRESHOLDS</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <!-- Enable AVP execution -->
      <name>AVP_ENABLE</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <!-- Enable HDAT AVPs** -->
      <name>HDAT_AVP_ENABLE</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <!-- All SRCs are terminating (CEC hardware/procedural) -->
      <name>SRC_TERM</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <!-- Enable IPL memory diagnostics to report memory CE -->
      <name>IPL_MEMORY_CE_CHECKING</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <!-- Enable Fast Background Scrub -->
      <name>FAST_BACKGROUND_SCRUB</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <!-- Test DRAM Repairs -->
      <name>TEST_DRAM_REPAIRS</name>
      <value>0x00000040</value>
    </enumerator>
    <enumerator>
      <!-- Disable Dram Repairs -->
      <name>DISABLE_DRAM_REPAIRS</name>
      <value>0x00000080</value>
    </enumerator>
    <enumerator>
      <!-- Enable exhaustive pattern test -->
      <name>ENABLE_EXHAUSTIVE_PATTERN_TEST</name>
      <value>0x00000100</value>
    </enumerator>
    <enumerator>
      <!-- Enable standard pattern test -->
      <name>ENABLE_STANDARD_PATTERN_TEST</name>
      <value>0x00000200</value>
    </enumerator>
    <enumerator>
      <!-- Enable minimum pattern test -->
      <name>ENABLE_MINIMUM_PATTERN_TEST</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <!-- Disable Fabric eRepair -->
      <name>DISABLE_FABRIC_eREPAIR</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <!-- Disable Memory eRepair -->
      <name>DISABLE_MEMORY_eREPAIR</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <!-- Fabric deploy lane spares -->
      <name>FABRIC_DEPLOY_LANE_SPARES</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <!-- DMI deploy lane spares -->
      <name>DMI_DEPLOY_LANE_SPARES</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <!-- Forcibly run PSI diagnostics -->
      <name>PSI_DIAGNOSTIC</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <!-- Brazos Wrap Config -->
      <name>BRAZOS_WRAP_CONFIG</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <!-- FSP is responsible for updating Processor SBE Image -->
      <name>FSP_UPDATE_SBE_IMAGE</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <!-- Update both sides of SBE Image if update is needed -->
      <name>UPDATE_BOTH_SIDES_OF_SBE</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <!-- Update both sides of SBE Image if update is needed -->
      <name>IMMEDIATE_HALT</name>
      <value>0x00080000</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <description>
      This attribute represents the maximum number of L4 Cache CEs allowed.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_L4_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during IPL.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_MBA_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the maximum number of Memory RCEs
      allowed per Rank during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_MBA_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_CEN_MBA_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent MPE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent UE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Column Repairs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Column Repairs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_COL_REPAIRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_P8EX_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when an
      RCD parity error (recovery enabled) attention count is equal to this
      value. A value of 0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for X bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion/>
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OCMB</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <enumerator>
      <name>UCD9090</name>
    </enumerator>
    <enumerator>
      <name>UCD90120A</name>
    </enumerator>
    <enumerator>
      <name>UCD9090A</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>

  <attribute>
    <description>MRU ID attribute for chip/unit class</description>
    <id>MRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Attribute indicating the default risk level for the system. Applied if
        scratch registers are not overriden
    </description>
    <id>MRW_DEFAULT_RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <!--attribute>
    <id>MRW_REQUIRED_TEST</id>
    <description>An attribute to test the mrwRequired keyword</description>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <mrwRequired/>
  </attribute-->
  <attribute>
    <description>AVDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>MBA DRAM data bus utilization percent to use to determine cfg_nm_n_per_mba</description>
    <id>MSS_DATABUS_UTIL_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>STR</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <default>OFF</default>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>STR</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration for Temperature refresh mode</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>

  <attribute>
    <id>MSS_PHY_SEQ_REFRESH</id>
    <description>
      Controls ENABLE/DISABLE of workaround that sets
      the PHY sequencer to trigger refresh after draminit.
    </description>
    <simpleType>
      <uint8_t/>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_PHY_SEQ_REFRESH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>VCS memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDDR memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic,
    3 = DEFAULT  - domain needs to be programmed, pgm values in sys xml file
    </description>
    <hasStringConversion/>
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VDDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>VPP memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the multi scome
        buffer size. The values can be combined using a
        bitwise 'OR'.  The values will need to be kept
        in sync with the FAPI enumerator values.  Also
        the enumeration type is used by the
        ATTR_MULTI_SCOM_BUFFER_MAX_SIZE.  Should
        note that the MULTI_SCOM_BUFFER_MAX_SIZE values
        are of type uint32_t
    </description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>

  <attribute>
    <id>NEST_PLL_FREQ_BUCKETS</id>
    <description>
      Constant defining number of NEST PLL frequency options ('buckets')
      to be built into unsigned HW image.
  </description>
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>NEST_PLL_FREQ_I2CDIV_LIST</id>
    <description>
      I2C bus divisor
      index is bucket number
      The values in this list will be factor of 1:64 to the NEST_PLL_FREQ_LIST
  </description>
    <simpleType>
      <uint32_t>
        <default>25,29,31,33,37</default>
      </uint32_t>
      <array>5</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>NEST_PLL_FREQ_LIST</id>
    <description>
      Nest PLL frequency in MHZ
      index is bucket number
  </description>
    <simpleType>
      <uint32_t>
        <default>1600,1866,2000,2133,2400</default>
      </uint32_t>
      <array>5</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        genHwsvMrwXml.pl
    </description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      The nominal core frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <id>NOMINAL_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_NOMINAL_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR base address values
        creator: platform
        consumer: proc_setup_bars
        firmware notes:
            64-bit address representing BAR RA
            NOTE: BAR register covers RA 14:51
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR size values
        creator: platform
        consumer: proc_setup_bars
        firmware notes: none
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the BAR size
        used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      NVDIMM(s) are armed for backup incase of power loss (DDR Reset_n goes low)
      This keeps track of the armed state
    </description>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <complexType>
      <description>Armed State</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Is NVDIMM armed</description>
        <name>armed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Is OCC active</description>
        <name>occ_active</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>NVDIMM controller fatal error detected</description>
        <name>fatal_error_detected</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>NVDIMM controller risky error detected</description>
        <name>risky_error_detected</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>NVDIMM encryption error detected</description>
        <name>encryption_error_detected</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>1</default>
        <description>Is SBE active</description>
        <name>sbe_active</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>2</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <id>NVDIMM_ARMED</id>
  </attribute>

  <attribute>
    <id>NVDIMM_AUTO_ARM</id>
    <description>
        0 - Do not automatically arm all NVDIMMS in the system at runtime
        1 - Automatically arm all NVDIMMS in the system at runtime
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NVDIMM_ENCRYPTION_ENABLE</id>
    <description>
        0 - Encryption is not enabled on all NVDIMMS in the system
        1 - Encryption is enabled on all NVDIMMS in the system
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NVDIMM_ENCRYPTION_KEYS_ANCHOR</id>
    <description>
        NVDIMM Encryption keys
          Bytes  0..31  Random String (RS)
          Bytes 32..63  Erase Key     (EK)
          Bytes 64..95  Access Key    (AK)
        Set by HWSV, stored in anchor card
        Should match NVDIMM_ENCRYPTION_KEYS_FW
    </description>
    <simpleType>
      <array>96</array>
      <uint8_t>
        <default>
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        </default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NVDIMM_ENCRYPTION_KEYS_FW</id>
    <description>
        NVDIMM Encryption keys
          Bytes  0..31  Random String (RS)
          Bytes 32..63  Erase Key     (EK)
          Bytes 64..95  Access Key    (AK)
        Set by Hostboot, stored in FSP flash
        Should match NVDIMM_ENCRYPTION_KEYS_ANCHOR
    </description>
    <simpleType>
      <array>96</array>
      <uint8_t>
        <default>
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        </default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NVDIMM_FORCE_FW_UPDATE</id>
    <description>
        If non-zero then just update FW level on all NVDIMMs
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>NVDIMM_UPDATE_I2C_BLOCK_SIZE</id>
    <description>
        If non-zero, use this block size when updating FPGA code of NVDIMM
        Valid sizes are 0, 2, 32
      </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>NV_OPS_TIMEOUT_MSEC</id>
    <description>
        NVDIMM timeout value for 6 main operations
        0 - CSAVE
        1 - Page Switch
        2 - Restore
        3 - ERASE
        4 - ARM
        5 - CHARGE

        This attribute is set to volatile because the timeout values vary
        depending on the vendor and capacity. The timeout values will be
        determined during init by reading the i2c registers on the NV
        controller.
        The indices are defined in src/usr/isteps/nvdimm.H and the attribute
        is consumed in nvdimm.C
    </description>
    <simpleType>
      <array>6</array>
      <uint32_t>
        <default>0,0,0,0,0,0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NV_STATUS_FLAG</id>
    <description>
        NVDIMM status flag. This is used to record the status and
        later report to OPAL/PHYP. Possible values:

        0x01: Unable to preserve future contents
        0x02: Failed to preserve contents
        0x04: Contents preserved
        0x08: Contents not preserved
        0x10: Contents are encrypted
        0x20: Secure erase verify complete
        0x40: Error detected, but save/restore might work
        0x80: Reserved
        0xFF: Memory is invalid
            NOTE: set for virtual SCM devices, does not persist across reboot
    </description>
    <simpleType>
      <uint8_t>
        <default>0x08</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>OBUS_BRICK_LANE_MASK</id>
    <description>
      Lane mask for which 8 lanes belong to this brick
      This is a right justified 24-bit value. Only 8 of the
      24 bits will be set representing the lanes belonging to
      the associated brick.
      Provided by the MRW.
  </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>OBUS_SLOT_INDEX</id>
    <description>
      Position of the obus slot that the Obus brick is connected to
      (represented in decimal). There is only one slot that a given
      brick connects to and there are only 6 slots per proc,
      so, we just need a single uint8_t representing the position
      of the slot.
      Provided by the MRW.
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        This attribute is to determine whether an occ is master capable.
        An OCC is master capable if it's parent processor is wired to the
        APSS.
    </description>
    <id>OCC_MASTER_CAPABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>DEFAULT_ALL</default>
    <description>Enumeration for the various OCMB Firmware update behaviors</description>
    <enumerator>
      <!-- Compare actual and desired versions, update if they do not match -->
      <name>CHECK_VERSIONS</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <!-- Force an update regardless of the current version in the hardware -->
      <name>FORCE_UPDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <!-- Do not update the firwmare, do not even check the versions -->
      <name>PREVENT_UPDATE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <!-- Compare actual and desired versions, but do not do any updates -->
      <name>CHECK_BUT_NO_UPDATE</name>
      <value>3</value>
    </enumerator>
    <id>OCMB_FW_UPDATE_BEHAVIOR</id>
  </enumerationType>

  <attribute>
    <description>
       Force specific behavior for the OCMB Firmware update function.
    </description>
    <id>OCMB_FW_UPDATE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path an OMI's associated OMIC parent target
    </description>
    <id>OMIC_PARENT</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Ordinal ID of a target</description>
    <id>ORDINAL_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <description>
      Rules on how to handle a deconfigure to parent level
    </description>
    <id>PARENT_DECONFIG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <complexType>
      <description>Structure which defines a target's deconfigure rules.
        Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Are the rule bits set correctly?
        </description>
        <name>valid</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT be deconfigured by child rollup
            0b1: Target allowed to be deconfigured by child rollup
            </description>
        <name>childRollupAllowed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT rollup its deconfigure to its parent
            0b1: Target should deconfigure its parent if no more functioning
                 children of same type exist for its parent
        </description>
        <name>deconfigureParent</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path of the target's associated pervasive target
    </description>
    <id>PARENT_PERVASIVE</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Base address (target HRMOR) of the payload.  Value is in MB.</description>
    <id>PAYLOAD_BASE</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>256</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>The offset from base address of the payload entry-point.
        Current default is 0x180</description>
    <id>PAYLOAD_ENTRY</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x180</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Indicate that payload should be placed in mirrored memory.
        Set by the FSP based on the value of the registry key indicating
        the memory mirroring mode.
    </description>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Attribute indicating what kind of payload is to be started.
    </description>
    <hasStringConversion/>
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PAYLOAD_KIND</id>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>UNKNOWN</default>
    <description>
        Enumeration indicating what kind of payload is to be started
    </description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>

  <attribute>
    <id>PCIE_32BIT_DMA_SIZE</id>
    <description>PCIe slot 32bit DMA size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_32BIT_MMIO_SIZE</id>
    <description>PCIe slot 32bit MMIO size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_64BIT_DMA_SIZE</id>
    <description>PCIe slot 64bit DMA size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_64BIT_MMIO_SIZE</id>
    <description>PCIe slot 64bit MMIO size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_CAPABILITES</id>
    <description>Denotes the capabilites of this pcie slot</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Base Address of PCI 32 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_32</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of PCI 64 bit Memory Space</description>
    <id>PCI_BASE_ADDRS_64</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
  </attribute>

  <attribute>
    <description>
        This attribute indicates if the PEC can be bifurcated. The value is determined from the workbook.
        0 - PEC is not bifurcateable
        1 - PEC can be bifurcated
        Note: Altering the lane map can be done using the HX keyword.
    </description>
    <id>PEC_IS_BIFURCATABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
          This attribute holds the contents of the HX keyword read by the FSP
          from a PCIe card. The keyword data is used to determine the PHB
          bifurcation settings.
          byte    0 = Keyword Version
                        0x00 - Keyword not used, ignore remaining data
                        0x01 - Data describes this enitity's logical PCIe device
                               to physical PCIe lane mapping as one or more
                               logical devices, each connected to a set of PCIe
                               lanes (always an integral multiple of 8 lanes)
          byte    1 = Number of x8 lane set entries X (0 to 7)
                      Each lane set entry is a one-byte value which indicates
                      whether the lane set is used by any logical device, and if
                      used, the logical device ID to which the lane set
                      is assigned, if this byte is zero the remaining keyword
                      data should be ignored.
          bytes 2+N = Lane set entry N
                      where N={0,1..X-1}
                      Each lane set entry maps a set of physical lanes
                      (8*N through N*8+7) to a logical device. Bit 0 indicates
                      whether the lane set is used by a logical device. If used,
                      the next three bits indicate which logical device ID
                      uses those lanes.

                      Bit0:
                         0b0 = Lanes not used by a logical device; ignore
                         0b1 = Lanes used by a logical device; logical device
                               id below is valid
                      Bit 1-3:
                         0b000 = reserved (when bit 0 = 0b0)
                         0b001 -&gt; 0b111
                      Bit 4-7
                      reserved

          Example: bifurcate PEC into 2-x8 devices PHB3 and PHB4
          HX keyword data  kw = { 01 02 B0 C0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = C0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 100 - lane set is assigned to device ID4
              kw[4:8]   - remaining data is ignored


         Example: un-bifurcate a slot which is by default bifurcated
          HX keyword data  kw = { 01 02 B0 B0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = B0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[4:8]   - remaining data is ignored

         HX keyword data must map to a valid slot configuration as defined by
         the system workbook.
    </description>
    <id>PEC_PCIE_HX_KEYWORD_DATA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <array>9</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Effective PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the effective PCIE IOP reversal value after taking into
            account any IOP bifurcations.  If no IOP bifurcations present, this
            is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED
            attribute.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given PEC/lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the PCIE IOP reversal value for cases where the IOP
            is bifurcated
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. The given index in
            the array is a mask which specifies which bit to invert in the lane
            swap settings for the given lane set
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the base PCIE IOP reversal value without considering IOP
            bifurcation.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value for the IOPs in the
            case where they are bifurcated.  The swap value controls how PCIE
            lanes are recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value without considering
            IOP bifurcation.  The swap value controls how PCIE lanes are
            recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask bifurcated configuration
        Creator: MRW
        Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP. For
            instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF
             means the IOP is bifurcated into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask base configuration
        Creator: MRW
        Purpose: Holds the base PCIE lane mask assuming no dynamic IOP
            bifurcations.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP.  For
            instance, lane set 0 value of 0xFFFF and lane set 1 value of 0x0000
            means the PEC is a x16. Lane set 0 value of 0xFF00 and lane
            set 1 value of 0x00FF, means the PEC is split into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Entity path of the peer target of a bus target
    </description>
    <id>PEER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
      <default>physical:na</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Peer target's address of a A/X-bus connection.
                 NULL means address 0 for no peer target. If a
                 target instance overrides the default with the
                 peer target's PHYS_PATH. The target compiler will
                 convert the valid PHYS_PATH string into the runtime
                 virtual address of the peer target instance.
    </description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        VCS PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        DD PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>

  <attribute>
    <id>PG</id>
    <description>
    Chiplet Partial good info attribute. Provided by Ring scans
  </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF
            </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <id>PIB_I2C_NEST_PLL</id>
    <description>
    i2c pll for the system
    default is 0x26 (For PIB @500 MHz (2 GHz nest)) for
    I2C speed = ~1Mhz per Andreas Koenig.
</description>
    <simpleType>
      <uint32_t>
        <default>0x026</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PIB_I2C_REFCLOCK</id>
    <description>
    i2c reference clock for the system.
    default is 0x4 =&gt; I2C speed = ~1Mhz per Andreas Koenig
</description>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL
      (not an IPL by steps). This is read by Hostboot to determine if it needs
      to request the attribute overrides from HWSV before starting its IPL.
    </description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Save state of the sfc driver flash workarounds for runtime</description>
    <id>PNOR_FLASH_WORKAROUNDS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>POS_ON_MEM_PORT</id>
    <description>
       Position of this DIMM on its memory port
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PRD_HWP_PLID</id>
    <description>
      PRD will perform error isolation for certain errors that may cause a HWP
      to fail. This attribute will be used by the HWP to store the PLID so that
      PRD can subsequently check it for a non-zero value and link the HWP PLID
      to the PRD error log.
    </description>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
       Tracks if a specific core has previously experienced a timeout during
       initial activation.
          0 = No previous errors reported;
          1 = Core failed on the last attempt to be started
    </description>
    <id>PREVIOUS_WAKEUP_FAIL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a target's primary capabilities.
        A target can only support at most FSI SCOM and one of the other two SCOM
        types.  Applicable for all targets.  Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support FSI SCOM;
            0b1: Target supports FSI SCOM
            </description>
        <name>supportsFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support XSCOM;
            0b1: Target supports FSI XSCOM</description>
        <name>supportsXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support inband SCOM</description>
        <name>supportsInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes capabilities of a target</description>
    <id>PRIMARY_CAPABILITIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Required Processor Compatibility Setting</description>
    <id>PROC_COMPATIBILITY_REQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PROC_COMPATIBILITY_REQ</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>ALLOW_COMPATIBILITY</default>
    <description>
        Enumeration specifying the compatibility setting for Processor ECs
        ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed
        FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level
        FORCED_NATIVE = set RISK_LEVEL to ECs native setting
    </description>
    <enumerator>
      <name>ALLOW_COMPATIBILITY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCED_COMPATIBILITY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCED_NATIVE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_COMPATIBILITY_REQ</id>
  </enumerationType>

  <attribute>
    <id>PROC_DCM_INSTALLED</id>
    <description>
      PROC_CHIP Attribute
        If true, the chip is installed on a Dual Chip Module
        Provided by the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the PROC_EPS_TABLE_TYPE</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_CAPI_MODE
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating the PROC_FABRIC_PUMP_MODE</description>
    <enumerator>
      <name>MODE1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>MODE2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_PUMP_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE
    </description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>

  <attribute>
    <description>Type of Master, ACTING_MASTER or MASTER_CANDIDATE or
      NOT_MASTER</description>
    <hasStringConversion/>
    <id>PROC_MASTER_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NOT_MASTER</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NOT_MASTER</default>
    <description>
        Enumeration indicating the role of proc as master/alt_master/not_master
    </description>
    <enumerator>
      <name>ACTING_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MASTER_CANDIDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NOT_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>PROC_MASTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>

  <attribute>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <description>PCIE IOP lane configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP lane configuration
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_PCIE_IOVALID_ENABLE</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCIE iovalid enable valid mask
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOVALID_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot
        Creator: MRW
        Purpose: Used by FW to know whether the given PCIE lanes terminate at a
            pluggable slot or not.  If this is the case, and the platform
            supports bifurcation, the card's VPD should be interrogated to
            determine whether to bifurcate the IOP or not.
        Data Format: x4 array of uint8_t values.  The first value indicates
            whether lane set 0 terminates at a pluggable slot.  The
            next three values indicate the same for lane sets 1-3. A value of
            1 at a given array index indicates the lanes terminate at a
            pluggable slot, 0 otherwise.
    </description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen3 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen4 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Effective PCIE Lane Mask
        Creator: Firmware
        Purpose: Holds the effective PCIE lane mask of each PEC after taking
            into account any IOP bifurcations. If no IOP bifurcations present,
            this is just the value of the PEC_PCIE_LANE_MASK_NON_BIFURCATED
            attribute
        Data Format: x4 array of uint16_t values.  The uint16_t value is a
            mask for lane 0, the next for lane 1 and so on until lane 3.
            A lane set mask indicates which groups of lanes are assigned to an
            IOP.  For instance, lane set 0 value of 0xFFFF and lane set 1 value
            of 0x0000 for PEC0 means PEC0 is a x16. Lane set 0 value of 0xFF00
            and lane set 2 value of 0x00FF for PEC0, means the IOP is bifurcated
            into two x8s.
    </description>
    <id>PROC_PCIE_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_NUM_PEC</id>
    <description>
      creator: platform
        Number of PCIe PEC units present on target
        Nimbus: 3
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx loff control
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx loff control for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
      <uint16_t/>
      <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx phase rotator control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx sigdet control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx vga control register3
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx vga control register3.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
      <uint16_t/>
      <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <description>
        Value of PCS system control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <!-- @fixme -->
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx fifo config offset
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PHB_ACTIVE</id>
    <description>PCIE PHB valid mask
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Bit mask defining set of active/valid PHBs
        bit0=PHB0, bit1=PHB1, bit2=PHB2, bit3=PHB3
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_REFCLOCK_ENABLE</id>
    <description>PCIE refclock enable valid mask
      PCIE refclock enable valid mask
      creator: platform
      consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REFCLOCK_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used to boot a processor</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
  </enumerationType>

  <attribute>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
    <description>
    Specifies which SEEPROM image should be used to boot a processor
      FIRST  - the first image was selected
      SECOND - the second image was selected
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used for the boot master</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
  </enumerationType>

  <attribute>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
    <description>
    Specifies which SEEPROM image should be used for the boot master.
      FIRST  - the first image was selected
      SECOND - the second image was selected
      Platforms are expected to set this to FIRST in normal operation
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base Address of PSI Bridge Logic</description>
    <id>PSI_BRIDGE_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PSI_BRIDGE_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PSIHB - ESB space address - MMIO consumed by PHYP
    </description>
    <id>PSI_HB_ESB_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Raw value of system MTM
    </description>
    <id>RAW_MTM</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      The number of reconfig loops allowed due to RCD parity errors when
      recovery is disabled. PRD will make a predictive callout and stop issuing
      reconfigs due to RCD parity errors when RCD_PARITY_RECONFIG_LOOP_COUNT is
      greater than this value. A value of 0 indicates that no reconfig loops are
      allowed due to RCD parity errors.
    </description>
    <id>RCD_PARITY_RECONFIG_LOOPS_ALLOWED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      PRD will increment this count and issue a reconfig loop each time an RCD
      parity error (recovery disabled) is detected during Memory Diagnostics.
      This value will be cleared at the end of Memory Diagnostics if it is able
      to complete without the need to issue a reconfig loop.
    </description>
    <id>RCD_PARITY_RECONFIG_LOOP_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <description>Enumeration of RECONFIGURE_LOOP flags</description>
    <enumerator>
      <description>
            Indicates HW has been deconfigured
        </description>
      <name>DECONFIGURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>
            Indicates a bad DQ bit was set in the BadDqBitmap
        </description>
      <name>BAD_DQ_BIT_SET</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <description>
            An RCD parity error has been detected
        </description>
      <name>RCD_PARITY_ERROR</name>
      <value>0x04</value>
    </enumerator>
    <id>RECONFIGURE_LOOP</id>
  </enumerationType>

  <attribute>
    <description> System attribute array that defines the reconfig loop test cases
      consumer: istep dispatcher reconfigLoopTestRunner function
      This array is loaded with data via attribute override. The attribute is
      then read  and then overlayed onto a test case structure.
  </description>
    <id>RECONFIG_LOOP_TESTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>5</array>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Indicates whether reconfigure loop tests are enabled.
        This attribute is set via attribute override
    </description>
    <id>RECONFIG_LOOP_TESTS_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>REDUNDANT_CLOCKS</id>
    <description>
        1 = System has redundant clock oscillators
        0 = System does not have redundant clock oscillators
        From the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>REL_POS</id>
    <description>
        Logical position of this unit/dimm relative to its immediate parent
    </description>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_REL_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Used to tell if a resource is critical to perform an IPL. If this
        attribute is set to 1 and the target is deconfigured, the IPL MUST
        terminate.
    </description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Where did the RISK_LEVEL setting originate?
    This is used to make sure the MRW isn't setting an invalid level
    for FORCED_COMPATIBILITY.
    </description>
    <id>RISK_LEVEL_ORIGIN</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>RISK_LEVEL_ORIGIN</id>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>USER</default>
    <description>
        Enumeration specifying what was used to setup the RISK_LEVEL
    </description>
    <enumerator>
      <name>USER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MRW</name>
      <value>1</value>
    </enumerator>
    <id>RISK_LEVEL_ORIGIN</id>
  </enumerationType>

  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of RNG IO Region</description>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Policy indicating whether to perform the maximum amount of memory
            pattern testing possible or not.
        Set to 0x01 to perform the maximum amount of memory pattern testing
            possible.
        Set to 0x00 to perform the default amount of memory pattern testing.
    </description>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
            uint8_t attribute to be used for storing functional state of a target during
            test cases.
        </description>
    <id>SAVED_STATE_UINT8</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SBE_COMMIT_ID</id>
    <description>
        A hexadecimal value of the commit ID associated
        with the SBE.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_IS_STARTED</id>
    <description>
        If 0, SBE for the processor has not been started.
        Otherwise, SBE for the processor has been started.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_RELEASE_TAG</id>
    <description>
        An ascii value of the SBE release tag
    </description>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>21</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_UPDATE_DISABLE</id>
    <description>
      Control execution of updateProcessorSbeSeeproms()

      if 0, enable SBE update of processor SEEPROM
      if 1, disable SBE update of processor SEEPROM

      Consumer:  sbe_update.C

      Default:  0
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>SBE_VERSION_INFO</id>
    <description>
        A hexadecimal value of the major and minor
        version of the SBE.  The major info is in the
        first 16 bits followed by the minor.
        0:15: Major Version
        16:31: Minor Version
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which SCOM to use at a point in
        time.  Only applicable if target supports one or more SCOM types.  Only
        one bit (of the first three) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI SCOM at this time.  0b1: Use FSI
            SCOM at this time</description>
        <name>useFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use XSCOM at this time.  0b1: Use XSCOM at
            this time</description>
        <name>useXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use inband SCOM at this time.  0b1: Use
            inband SCOM at this time</description>
        <name>useInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use SBE SCOM at this time.  0b1: Use
            SBE SCOM at this time</description>
        <name>useSbeScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
          0b0: Do not use I2C SCOM at this time.
          0b1: Use I2C SCOM at this time
        </description>
        <name>useI2cScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>3</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which SCOM path to use</description>
    <id>SCOM_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
    <description>
        To deconfigure a TPM in a secure system - 01 to set TDP bit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>SECURE_VERSION_LOCKIN_POLICY</id>
    <description>
        This policy determines if a new FW Secure Version will be locked into
        the SBE Seeproms during the SBE Update process such that previous
        versions will no longer be supported.
        - 0b0 - (Default) Policy Disabled - Do NOT Lock In Secure Version
        - 0b1 - Policy Enabled - Do Lock In Secure Version
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SECURE_VERSION_SEEPROM</id>
    <description>
        The value of the FW Secure Version found in the SBE Seeprom
        of the master processor used to boot this node. It will get
        updated, if necessary, by Hostboot on each IPL.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SLOT_INDEX</id>
    <description>PCIe slot index definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SLOT_NAME</id>
    <description>PCIe slot name definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>The amount of SMF memory requested
                 by the user, in bytes (read from NVRAM).
    </description>
    <id>SMF_MEM_AMT_REQUESTED</id>
    <persistency>volatile-zeroed</persistency>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SOCKET_POWER_NOMINAL</id>
    <description>
      The socket power in nominal mode.
      Controls how much power can be used.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SOCKET_POWER_TURBO</id>
    <description>
      The socket power in turbo mode.
      Controls how much power can be used.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>
         Structure which defines a system's SP functions.
         Applicable for System target only.  Structure is read-only.
         Default values match OpenBMC implementation.
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             If this flag is set then mailboxEnabled MUST also be set

             0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD;
             0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD
            </description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI slave logic, Hostboot must;
             0b1: SP does initialize FSI slave logic so Hostboot should not
            </description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: There is no SP mailbox support;
             0b1: There is SP mailbox support
            </description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI master logic, Hostboot must;
             0b1: SP does initialize FSI master logic so Hostboot should not
            </description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform hardware change detection, Hostboot must;
             0b1: SP does perform hardware change detection (HCDB) so Hostboot should not
            </description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must;
             0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not
            </description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes what the SP is or is not doing in this system
    </description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN</id>
    <description>
      Specifies the starting memory address that corresponds to the TCE Token
      used by the FSP to transfer the PAYLOAD into system memory.
      If 0xFFFFFFFFFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>STOP5_DISABLE</id>
    <description> Control CME response to execution of PowerPC STOP instruction
    if OFF, treat STOP5 as STOP5
    if ON,  treat STOP5 as STOP4

    Producer: ???

    Consumer:  p8_hcode_image_build.C

    Platform default: OFF
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>
        Enumeration indication which Hot Plug Controllers are supported by
        the current system.
    </description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>

  <attribute>
    <description>
      STOP levels supported at runtime (sent to Host via HDAT):
        Bit 0: STOP0 Supported - Quiesce thread only
        Bit 1: STOP1 Supported - P8 Nap
        Bit 2: STOP2 Supported - P8 Fast Sleep
        Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs
        Bit 4: STOP4 supported - P8 Deep Sleep
        Bit 5: STOP5 Supported - WOF-friendly "Instant on"
        Bit 6,7: Reserved
        Bit 8: STOP8 supported - Half Quad Sleep
        Bit 9: STOP9 supported - P8 Fast Winkle
        Bit 10: Reserved
        Bit 11: STOP11 supported - P8 Deep Winkle
        Bit 12-15 : Reserved
        Bits 16..31 - Reserved
  </description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Do we support dynamically updating memory voltages?
        0 = no, 1 = yes
    </description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>SYNC_BETWEEN_STEPS</id>
    <description>
        Attribute to enable targetting attribute sync when in istep mode.
        1 = sync will occur following each substep when ipl'ing in single step mode
        0 = sync will not be done after each step
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        This field is of the form "vendor,name" where the name indicates
        the family of the systems.  The textual portion of the string has
        a maximum length of 63 characters to accommodate a terminating NULL.
        Both vendor and name fields are lower case US ASCII. No special
        characters other than ",", "-", and "+" as described below should
        be used in the string.
    </description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,p9</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This field is of the form ?vendor,type? where the type indicates
        a type of system within the System Family. The textual portion of
        the string has a maximum length of 63 characters to accommodate a
        terminating NULL. Both vendor and name fields are lower case US
        ASCII. No special characters other than ",", "-", and "+" as described
        below should be used in the string.  If identification of specific
        models within a system type is desired, "-model" should be appended
        to the end of the name. The "-model" portion is optional and could be
        used to identify the packaging, specific model numbers, etc.
        NOTE: No Hostboot code should ever key off of this value.
    </description>
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,miscopenpower</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <id>TCE_START_TOKEN_FOR_HDAT</id>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      HDAT section into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>TCE_START_TOKEN_FOR_PAYLOAD</id>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      PAYLOAD into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Test attribute; largest string possible given size</description>
    <id>TEST_MAX_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>abc</default>
        <sizeInclNull>4</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Test attribute; smallest string possible given size</description>
    <id>TEST_MIN_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>a</default>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute to test signed attribute
        functionality in the system</description>
    <id>TEST_NEGATIVE_FCN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>-6</default>
      </int8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Test attribute; string with no default supplied</description>
    <id>TEST_NO_DEFAULT_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Test attribute; string with empty default value</description>
    <id>TEST_NULL_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Thread Count</description>
    <id>THREAD_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Time Base frequency in MHZ</description>
    <id>TIME_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x800000</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Data Associative Sets</description>
    <id>TLB_DATA_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Data Entries</description>
    <id>TLB_DATA_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Instruction Associative Sets</description>
    <id>TLB_INSTR_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Instruction Entries</description>
    <id>TLB_INSTR_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Reserve Size in bytes</description>
    <id>TLB_RESERVE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TOD CHIP DATA for each CHIP
        The size of the TOD CHIP DATA must be equal to the sizeof(TodChipData)
    </description>
    <id>TOD_CPU_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>44</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Bitmask indicating what role this chip has in tod topology
    </description>
    <id>TOD_ROLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NON_MASTER</default>
    <description>
        Enumeration indicating what role this chip has in tod topology
    </description>
    <enumerator>
      <name>NON_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>TOD_ROLE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     TPM.</description>
      <field>
        <default>0x0</default>
        <description>Boolean indicating whether this TPM is available
              in the system</description>
        <name>tpmEnabled</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x01</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAE</default>
        <description>Device address on the I2C bus for Locality 0.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality0</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA8</default>
        <description>Device address on the I2C bus for Locality 1.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality1</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xAA</default>
        <description>Device address on the I2C bus for Locality 2.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality2</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA4</default>
        <description>Device address on the I2C bus for Locality 3.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality3</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xA6</default>
        <description>Device address on the I2C bus for Locality 4.
                         This is a 7-bit value, but then shifted 1
                         bit left.</description>
        <name>devAddrLocality4</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x00</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x01</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM slaves</description>
    <id>TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>TPM_POISONED</id>
    <description>
        A flag indicating whether the TPM has been poisoned. A poisoned TPM
        has a random number extended into its PCR but not mirrorred to its
        log. That creates a disconnection between the TPM and its log, which
        in turn makes it impossible to perform remote attestation on the TPM.
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Setting to require(0x1) or not require(0x0) a functional TPM to
        boot the system.
    </description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <id>TPM_UNUSABLE</id>
    <description>
        Indicates whether the TPM is unusable. Hostboot should not read this
        value for any purpose other than tracing. This value should only be
        written to when there is a certainty that the TPM is not usable.
        This attribute is consumed by FSP during alignment check to determine
        the optimal boot configuration. This attribute can be removed if TPM
        gard is ever supported.
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion/>
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>PMIC</name>
      <value>78</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>79</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>

  <attribute>
    <id>UCD_MFR_REVISION_OVERRIDE</id>
    <description>
        If non-zero then use value as the discovered MFR_REVISION value from
        the UCD device rather than the actual value from the device.
    </description>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      The ultra turbo frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V and is calculated as
      the minimum of the ultra turbo frequencies.
    </description>
    <id>ULTRA_TURBO_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_ULTRA_TURBO_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>USE_TCES_FOR_DMAS</id>
    <description>
      Specifies whether or not the FSP is ready for Hostboot to enable TCEs
      for DMAs for the given IPL.  This is a temporary attribute which will
      be used to phase-in TCE support.
      If 0, DO NOT use TCEs;
      If 1, use TCEs
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Memory VCS voltage domain ID.  All memory buffers in the same VCS
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Voltage Memory Rail Manager ID.  Currently HB only needs
        to configured the Vddr voltage rail manager during the IPL.  The ID
        is an arbitary value and needed as correlation token between HB and
        HWSV.  It will be generated by the genHwsvMrwXml.pl.
    </description>
    <id>VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory VDD voltage domain ID.  All memory buffers in the same VDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>

  <attribute>
    <id>VENDOR_ID</id>
    <description>PCIe vendor ID definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Record offset for this target's VPD</description>
    <id>VPD_REC_NUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0xFFFF</default>
      </uint16_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory VPP voltage domain ID.  All memory buffers in the same VPP
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        genHwsvMrwXml.pl
    </description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System control to set the power limit for Workload Optimized
      Frequency (WOF) algorithms.  This is used to select the
      proper VFRT tables.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>

  <attribute>
    <id>WOF_TABLE_LID_NUMBER</id>
    <description>
      LID id used to load tables for Workload Optimized
      Frequency (WOF) algorithms.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <simpleType>
      <uint32_t>
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>XIVE - Controller Bar address
        MMIO consumed by PHYP
    </description>
    <id>XIVE_CONTROLLER_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>XIVE - Thread Management Bar address register 1
         MMIO consumed by HB/PHYP
    </description>
    <id>XIVE_THREAD_MGMT1_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>XSCOM base address</description>
    <id>XSCOM_BASE_ADDRESS</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <no_export/>
  </attribute>

</attributes>
