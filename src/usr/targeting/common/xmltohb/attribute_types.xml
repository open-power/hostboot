<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/usr/targeting/common/xmltohb/attribute_types.xml $        -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2012,2021                        -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->
<attributes>
  <attribute>
    <description>Hierarchical path to the target with respect to logical affinity</description>
    <id>AFFINITY_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <description>Set to non-zero to enable EEPROM writes to Hardware</description>
    <id>ALLOW_EEPROM_WRITES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>ALL_MCS_IN_INTERLEAVING_GROUP</id>
    <description>
        System attribute.
        If all MCS chiplets are in an interleaving group (1=true, 0=false).
        - If true the SMP fabric is setup in normal mode and multiple MCSs
          are grouped (disallowing systems with memory only under 1 MCS
          (i.e. systems with a single C-DIMM))
        - If false the SMP fabric is setup in checkerboard mode.
        Provided by the Machine Readable Workbook.
        This attribute is based on Machine-Type-Model (MTM) and is setup by
          the service processor.
    </description>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the alternate master processor</description>
    <id>ALTFSI_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>ASYNC_NEST_FREQ_MHZ</id>
    <description>
        The asynchronous nest frequency
    </description>
    <simpleType>
      <uint32_t>
        <default>2000</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>ATTN_AREA_1_ADDR</id>
    <description>
    Specifies the "intended" starting memory address for PHYP's ATTN area 1.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 1 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>ATTN_AREA_2_ADDR</id>
    <description>
    Specifies the "intended" starting memory address for PHYP's ATTN area 2.
    This is written to by Hostboot and read by FSP as a means for Hostboot to
    communicate its intentions of where the ATTN 2 area will be. Hostboot can
    then later open up an SBE window for PHYP to dump its debugging info. An
    address of 0xFFFFFFFFFFFFFFFF is considered N/A.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory AVDD voltage domain ID.  All memory buffers in the same AVDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>AVDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Block speculative deconfig in reconfig loop.
        Flags when speculative deconfigurations should not be done for
        predictive gard records on a reconfig loop IPL due to out of
        hardware condition on prior IPL.
        0 = Allow speculative deconfiguration
        1 = Block speculative deconfiguration
        </description>
    <id>BLOCK_SPEC_DECONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>BMC FRU ID attribute to report the system firmware levels
        to the BMC.</description>
    <id>BMC_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Specifies a target's CEC degraded mode domain.  For example, all
        DIMMs are part of the DIMM CEC degraded mode domain.
    </description>
    <hasStringConversion/>
    <id>CDM_DOMAIN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CDM_DOMAIN</id>
      </enumeration>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration specifying a target's CEC degraded mode domain
    </description>
    <enumerator>
      <name>NONE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CPU</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>FABRIC</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>IO</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CLOCK</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SECURITY</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ALL</name>
      <value>11</value>
    </enumerator>
    <id>CDM_DOMAIN</id>
  </enumerationType>

  <attribute>
    <description>
        Cec Degraded Mode Policy flags
        Use the CDM_POLICIES enum to decode.
        If the appropriate bit is 1 then the policy mode is enabled,
        and those type of Guard records are disabled.
    </description>
    <id>CDM_POLICIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration of CDM_POLICIES flags</description>
    <enumerator>
      <description>
        MFG_Guard policy:
        Used in MFG only to prevent and disable the following:
        . Storing or creation of new Guard records from Diagno`stic or other
            faults through error logs. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        . Storing or creation of Manual Guard record from user.
            NOTE: this does not stop FCO.
        . Using an already stored System or Manual Guard record from
            deconfiguring resources. This is all domains, CEC
            processor/memory, VPD, FSP, etc.
        </description>
      <name>MANUFACTURING_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>
        Predictive_Guard policy:
        Used in Field or development to prevent and disable the following:
        . Storing or creation of new Guard records from diagnostics or other
            faults through error logs with the error_type of Predictive.
        . Using an already stored System Guard record with error_type of
            Predictive from deconfiguring resources.
        </description>
      <name>PREDICTIVE_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <id>CDM_POLICIES</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure which defines a they IPL types
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Perform mainstore dump collection. Only valid for MPIPL
                0b0: Do not collect mainstore dump
                0b1: Perform mainstore dump collection
            </description>
        <name>PostDump</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>7</bits>
        <default>0</default>
        <description>Minor IPL Type</description>
        <name>MinorIPLType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes optional IPL flavors
    </description>
    <id>CEC_IPL_TYPE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>FRU ID attribute for centaur ECID data. This fru ID is used to
        report the ECID data to the BMC and make it available for systems which
        have then centaur chips soldered to the backplane.</description>
    <id>CENTAUR_ECID_FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
   </description>
    <id>CEN_MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_CEN_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>CEN_MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>CHASSIS_LOCATION_CODE</id>
    <description>
      Location code of the chassis
    </description>
    <persistency>volatile</persistency>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <no_export/>
    <writeable/>
    <readable/>
  </attribute>

  <attribute>
    <description>The address offset which each Chiplet types pervasive
     address space used to represent the a chiplet.
     0x00 to 0x0F =&gt; For P9 all non-core and non-cache chiplets
     0x10 to 0x1F =&gt; All Cache Chiplets
     0x20 to 0x37 =&gt; All Core Chiplets
     0x38 to 0x3F =&gt; Multicast Operation
   </description>
    <id>CHIPLET_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>CHIP_ID</id>
    <description>attribute indicating the chip's ID</description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>A unit (chiplet) 's  offset number within the chip. </description>
    <id>CHIP_UNIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_CHIP_UNIT_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's class</description>
    <hasStringConversion/>
    <id>CLASS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>CLASS</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's class</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CARD</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENC</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>CHIP</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>UNIT</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>DEV</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>LOGICAL_CARD</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>BATTERY</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>LED</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>ASIC</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MAX</name>
      <value>12</value>
    </enumerator>
    <id>CLASS</id>
  </enumerationType>

  <attribute>
    <description>CPU Attribute</description>
    <id>CPU_ATTR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L1 Data Cache Line Size in bytes</description>
    <id>DATA_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L1 Data Cache Size in KB</description>
    <id>DATA_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>DCache Associative Sets</description>
    <id>DCACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>DCache Line Size in bytes</description>
    <id>DCACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines what Explorer logs to grab
        Prefixes:
        early = early in the IPL
        late  = later in the IPL
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image A side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>earlySavedLogA</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image B side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>earlySavedLogB</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Active log (RAM data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>earlyActiveLog</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>earlyReserved</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image A side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>lateSavedLogA</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Saved Log from Image B side (SPI flash data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>lateSavedLogB</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Grab Active log (RAM data)
          0b0: Do not collect log
          0b1: Collect the log
        </description>
        <name>lateActiveLog</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>lateReserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Explorer logs to grab and report in the IPL</description>
    <id>DEBUG_OCMB_LOGS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>If the Target is directly deconfigurable and GARDable; target
    may still be deconfigured in 'by association' processing.</description>
    <id>DECONFIG_GARDABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Used to tell I2C code whether to run
        I2C Engine 2 Port 0 in diag mode or not
        0 = Use Diag Mode
        1 = Disable Diag Mode
    </description>
    <id>DISABLE_I2C_ENGINE2_PORT0_DIAG_MODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute on the heap with zero initialization</description>
    <id>DUMMY_HEAP_ZERO_DEFAULT</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read-only permissions</description>
    <id>DUMMY_RO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Dummy attribute with read/write permissions</description>
    <id>DUMMY_RW</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>1,3,5</array>
      <uint8_t>
        <default>5</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <ignoreEkb/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Dummy attribute with write-only permissions</description>
    <id>DUMMY_WO</id>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>EC</id>
    <description>attribute indicating the chip target's EC level</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_EC</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>EECACHE_DISABLE_AUTO_RESET</id>
    <description>
      Disable the ability to auto reset the EECACHE

      0 = Automatically clear the EECACHE on correctable errors
      1 = Disables the automatic EECACHE clearing to allow for debug

      Default:  0
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>State of the VPD synchronization
    between the in memory eecache, the SEEPROM and
    the EECACHE partition.  This will be used to
    track the modification of the VPD information
    and then used to trigger a refresh of the EECACHE
    partition during the IPL flow(s).
    </description>
    <id>EECACHE_VPD_STATE</id>
    <simpleType>
      <enumeration>
        <id>EECACHE_VPD_STATE</id>
        <default>VPD_GOOD</default>
      </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>VPD_GOOD</default>
    <description>
        Enumeration specifying status of VPD data
    </description>
    <enumerator>
      <name>VPD_GOOD</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>VPD_NEEDS_REFRESH</name>
      <value>0x1</value>
    </enumerator>
    <id>EECACHE_VPD_STATE</id>
  </enumerationType>

  <attribute>
    <description>Specifies a target's eeprom content type.</description>
    <hasStringConversion/>
    <id>EEPROM_CONTENT_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>EEPROM_CONTENT_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>RAW</default>
    <description>Enumeration indicating a target's eeprom
        content type.
        RAW - eeprom has no specified layout
        ISDIMM - uses standard JEDEC layout for DDR memory
        IBM_FRUVPD - uses ipz converged vpd layout with records/keywords for
                     generic FRUs
        IBM_MVPD - use ipz converged vpd layout with records/keywords for
                   processor modules
        DDIMM - uses Differential DIMM layout
        SBE_BOOT_CODE - SBE code
        SBE_MEASUREMENT_CODE - Measurement code
        WOF_DATA - WOF data
        KEYSTORE - Keystore data
    </description>
    <enumerator>
      <name>RAW</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ISDIMM</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>IBM_FRUVPD</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>IBM_MVPD</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>DDIMM</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SBE_BOOT_CODE</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>SBE_MEASUREMENT_CODE</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>WOF_DATA</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>KEYSTORE</name>
      <value>8</value>
    </enumerator>
    <id>EEPROM_CONTENT_TYPE</id>
  </enumerationType>

  <attribute>
    <id>EEPROM_NV_INFO</id>
    <description>Information needed to address the NV controller on the NVDIMM</description>
    <complexType>
      <description>Structure to define the addressing for NV controller.</description>
      <field>
        <name>i2cMasterPath</name>
        <description>Entity path to the chip that contains the I2C
                master.
            </description>
        <type>EntityPath</type>
        <default>physical:sys-0</default>
      </field>
      <field>
        <name>port</name>
        <description>Port from the I2C Master device. This is a 6-bit
                value, but then shifted 2 bits left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>devAddr</name>
        <description>Device address on the I2C bus. This is a 7-bit value,
                but then shifted 1 bit left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>engine</name>
        <description>I2C master engine. This is a 2-bit value,
                but then shifted 6 bits left.
            </description>
        <type>uint8_t</type>
        <default>0x80</default>
      </field>
      <field>
        <name>byteAddrOffset</name>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. For NV controller it's only
                one byte addressing with no page select (3)
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <type>uint8_t</type>
        <default>0x03</default>
      </field>
      <field>
        <name>maxMemorySizeKB</name>
        <description>The number of kilobytes a device can hold.  'Zero'
                value possible for some devices.
            </description>
        <type>uint64_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>chipCount</name>
        <description>The number of chips making up an eeprom device.
            </description>
        <type>uint8_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>writePageSize</name>
        <description>The maximum number of bytes that can be written to
                a device at one time. 'Zero' value means no maximum value is
                expected or checked.
            </description>
        <type>uint64_t</type>
        <default>0x01</default>
      </field>
      <field>
        <name>writeCycleTime</name>
        <description>The amount of time in milliseconds a device requires
                on the completion of a write command to update its internal memory.
            </description>
        <type>uint64_t</type>
        <default>0x05</default>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x02</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x100</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x04</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0x0</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_SBE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>EEPROM_VPD_ACCESSIBILITY</id>
    <description>
      A bitmask value indicating whether an error has previously
      occurred on an access to the primary or secondary VPDs for this
      target. Adding this attribute to a target indicates the
      existence of redundant VPD for this target.
    </description>
    <simpleType>
      <enumeration>
        <id>EEPROM_VPD_ACCESSIBILITY</id>
        <default>NONE_DISABLED</default>
      </enumeration>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NONE_DISABLED</default>
    <description>
      Enumeration indicating which VPDs are disabled on a
      target. These values can be OR-ed together to make a bitmask.
    </description>
    <!-- Real values for the attribute -->
    <enumerator>
      <name>NONE_DISABLED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CACHE_DISABLED</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PRIMARY_DISABLED</name>
      <value>0x02</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY_DISABLED</name>
      <value>0x04</value>
    </enumerator>
    <!-- Special values which are combinations of other flags -->
    <enumerator>
      <name>LAST_DISABLED</name>
      <value>0x08</value>
    </enumerator>
    <id>EEPROM_VPD_ACCESSIBILITY</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains secondary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of bytes a device requires to set its
                         internal address/offset.</description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EERPROM slaves</description>
    <id>EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached I2C
          eeprom device that contains primary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>
                The number of bytes a device requires to set its
                internal address/offset. DDR4 DIMMs require a special EEPROM
                page switching mechanic denoted here by a value of 1
                0 = Zero Byte Addressing
                1 = One Byte Addressing with page select
                2 = Two Byte Addressing
                3 = OneByte Addressing with no page select
            </description>
        <name>byteAddrOffset</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes a device can hold.  'Zero'
                         value possible for some devices.</description>
        <name>maxMemorySizeKB</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>The number of chips making up an eeprom device.
            </description>
        <name>chipCount</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The maximum number of bytes that can be written to
                         a device at one time. 'Zero' value means no maximum
                         value is expected or checked.</description>
        <name>writePageSize</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The amount of time in milliseconds a device requires
                         on the completion of a write command to update its
                         internal memory.</description>
        <name>writeCycleTime</name>
        <type>uint64_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM slaves</description>
    <id>EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Holds the effective EC of the system.  Effective EC is the lowest EC
        among all the functional procs in the system.  Some cards may "downbin"
        the effective ECs of their contained processors, which could lower the
        effective EC of the system beyond what would occur when considering
        processor ECs alone
    </description>
    <id>EFFECTIVE_EC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Bitmask of threads to enable for each processor,
       Zero means enable all architected threads
    </description>
    <id>ENABLED_THREADS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's engine type</description>
    <hasStringConversion/>
    <id>ENGINE_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>ENGINE_TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's engine type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_IIC</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ENGINE_SCOM</name>
      <value>2</value>
    </enumerator>
    <id>ENGINE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric chip id for this chip (position within the fabric).
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <id>FABRIC_CHIP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_CHIP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Chip attribute.
        Logical fabric group the chip belongs to.
        Provided by the Machine Readable Workbook.
        Can vary across drawers.
    </description>
    <id>FABRIC_GROUP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_FABRIC_GROUP_ID</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <!--
  @todo CQ:SW497175 Attribute FABRIC_PRESENT_GROUPS is now PROC_FABRIC_PRESENT_GROUPS
        Remove this attribute after HWSV is updated with new name
        The new attribute is made writeable in hb_customized_attrs.xml
  -->
  <attribute>
    <description>Temp attr until hwsv is updated with new name</description>
    <id>FABRIC_PRESENT_GROUPS</id>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile</persistency>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Correlate HDAT node number (physical) to the logical node
        (based on the PIR) that contains the host boot image.
    </description>
    <id>FABRIC_TO_PHYSICAL_NODE_MAP</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <array>8</array>
      <uint8_t>
        <default>0,255,255,255,255,255,255,255</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>FAPI_I2C_CONTROL_INFO</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Common name across FAPI environments
    chip target -&gt; pu:k0:n0:s0:p00
    DIMM target -&gt; dimm:k0:n0:s0:p00
    chip unit target -&gt; pu.core:k0:n0:s0:p00:c0
    cage/system target -&gt; k0

    (chip type).(unit type):k(cage,always zero for us):n(node/drawer)
              :s(slot,always zero for us):p(chip position):c(core/unit position)
    pu  = generic processor
    </description>
    <id>FAPI_NAME</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>unknown</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration defining special FAPI_POS values</description>
    <enumerator>
      <name>NA</name>
      <value>0xFFFFFFFF</value>
    </enumerator>
    <id>FAPI_POS</id>
  </enumerationType>

  <attribute>
    <description>Field Core Override (FCO) is the override value for the
    number of functional cores allowed on the system.
    FCO is used when customers order a system with N cores but they only want
    to enable less than N cores to lower software license costs. A field in the
    anchor VPD is set by manufacturing to specify the maximum number of cores
    to enable. The number is maintained, even if some cores are garded out due
    to error.
    A value of 0 means all cores allowed;
    </description>
    <id>FIELD_CORE_OVERRIDE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      in the Field.
      creator: platform (generated based on MRW data)
    </description>
    <id>FIELD_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>6</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>FORCE_SERIAL_ISTEPS</id>
    <description>
    Forces all isteps to run hardware procedures serially, rather than
    in parallel.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>FORCE_SRAM_MMIO_OVER_I2C</id>
    <description>
    Force inband SRAM access to be over I2C instead of MMIO
    This is a way to get data when the MMIO path is not working
    (0x00 = use normal path, 0x01 = force i2c path)
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Defines presence detection states</description>
    <enumerator>
      <!-- SP did not attempt to discover this part -->
      <name>NO_ATTEMPT</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <!-- Part was detected -->
      <name>FOUND</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <!-- Discovery was attempted and found nothing -->
      <name>MISSING</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <!-- Part cannot be crosschecked -->
      <name>SKIP</name>
      <value>0x3</value>
    </enumerator>
    <id>FOUND_PRESENT_BY_SP</id>
  </enumerationType>

  <attribute>
    <description>
       Target (FRU) was detected as present by the service processor.
       This is used by Hostboot as a cross-check with its own internal
        detection code to ensure a consistent picture.
    </description>
    <id>FOUND_PRESENT_BY_SP</id>
    <readable/>
    <writeable/>
    <simpleType>
      <enumeration>
        <id>FOUND_PRESENT_BY_SP</id>
        <default>NO_ATTEMPT</default>
      </enumeration>
    </simpleType>
    <no_export/>
    <persistency>non-volatile</persistency>
  </attribute>

  <attribute>
    <id>FREQ_CORE_CEILING_MHZ</id>
    <description>
    The maximum core frequency in MHz.
    This is the same for all cores in the system.
    Data is provided by MVPD #V and is calculated as
    the minimum of the turbo frequencies.
  </description>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_FREQ_CORE_CEILING_MHZ</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <!-- Required by FSP -->
  <attribute>
    <id>FREQ_PROC_REFCLOCK</id>
    <description>
        System attribute.
        The frequency of the processor refclock in MHz.
        Provided by the MRW.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>FRU ID attribute used to report FRU information to the BMC
        for each fru in the system.</description>
    <global/>
    <id>FRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Chip which contains the FSI master logic that drives this slave when booting from the default master processor</description>
    <id>FSI_MASTER_CHIP</id>
    <nativeType>
      <default>physical:sys-0</default>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Which port is this chip hanging off of when booting from the default master processor</description>
    <id>FSI_MASTER_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Type of Master FSI connection to this slave (MFSI or cMFSI)</description>
    <hasStringConversion/>
    <id>FSI_MASTER_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <default>NO_MASTER</default>
        <id>FSI_MASTER_TYPE</id>
      </enumeration>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NO_MASTER</default>
    <description>Enumeration indicating the master's FSI type</description>
    <enumerator>
      <name>MFSI</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>CMFSI</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NO_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>FSI_MASTER_TYPE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>FSI flags</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
                Set on FSI master chips (procs) if that chip uses slaveB
                to attach to the acting master chip.
            </description>
        <name>flipPort</name>
        <type>uint16_t</type>
      </field>
      <field>
        <bits>15</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint16_t</type>
      </field>
    </complexType>
    <description>
        Reserved for any special flags we might need to access FSI
    </description>
    <id>FSI_OPTION_FLAGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Slave cascade position</description>
    <id>FSI_SLAVE_CASCADE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Size of FSP IO Region</description>
    <id>FSP_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0000000100000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of FSP IO Region</description>
    <id>FSP_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <enumerationType>
    <id>FUSED_CORE_MODE_HB</id>
    <description>Enum for FUSED_CORE_MODE_HB</description>
    <enumerator>
      <name>SMT4_DEFAULT</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SMT4_ONLY</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>SMT8_ONLY</name>
      <value>8</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <id>FUSED_CORE_MODE_HB</id>
    <description>
        Stores the SMT setting read from the PVR that defines the fused mode.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Force a fused-core mode.  Note this will not match the true hardware
        state if using a part with fuses blown..
    </description>
    <id>FUSED_CORE_OPTION</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enum for FUSED_CORE_OPTION</description>
    <enumerator>
      <name>USING_DEFAULT_CORES</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>USING_NORMAL_CORES</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>USING_FUSED_CORES</name>
      <value>2</value>
    </enumerator>
    <id>FUSED_CORE_OPTION</id>
  </enumerationType>

  <attribute>
    <id>HBRT_HYP_ID</id>
    <description>
      Effective ID used by the hypervisor to specify a given target. A value
      of 0xFFFFFFFFFFFFFFFF means invalid/unknown.
  </description>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Hostboot HRMOR = (HB_HRMOR_NODAL_BASE * node) + offset. </description>
    <id>HB_HRMOR_NODAL_BASE</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x200000000000</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        The amount of mainstore that PHYP needs to preserve per node
        during MPIPL.
    </description>
    <id>HB_RSV_MEM_SIZE_MB</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>256</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a system's HB settings.
         Applicable for System target only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Enable / Disable continuous trace.
                0b0: Continuous trace is disabled.
                0b1: Continuous trace is enabled.
            </description>
        <name>traceContinuous</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for SCAN component.
                0b0: TRACS entries for SCAN have default behavior.
                0b1: TRACS entries for SCAN are enabled.
            </description>
        <name>traceScanDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            Override trace debug selection for DBG component.
                0b0: TRACS entries for DBG have default behavior.
                0b1: TRACS entries for DBG are enabled.
            </description>
        <name>traceFapiDebug</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes how the SP has configured features in
      Hostboot.
    </description>
    <id>HB_SETTINGS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
       Indicates the chip's EC level, distinct from ATTR_EC to handle
       non-standard mini-ECs, e.g. 1.01, separate from the real
       hardware-defined EC level.  By default, ATTR_HDAT_EC==ATTR_EC
       unless the chip has a mini-EC.
    </description>
    <id>HDAT_EC</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot runtime data section.
    </description>
    <id>HDAT_HBRT_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Biggest size for any of the hostboot
        runtime data sections.
    </description>
    <id>HDAT_HBRT_SECTION_SIZE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>9</array>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            purpose to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>CABLE_CARD_PRES</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_PGOOD</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>PCI_HOTPLUG_CONTROL</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>MODULE_VPD</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>DIMM_SPD</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>PROC_MODULE_VPD</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>SBE_SEEPROM</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>PLANAR_VPD</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_TOPOLOGY_VERIFICATION</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <!-- deprecated -->
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>NVLINK_CABLE_MICRO_RESET</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>I2C_ASSOC_WITH_NVLINK_CABLE</name>
      <value>0xC</value>
    </enumerator>
    <enumerator>
      <name>WINDOW_OPEN</name>
      <value>0xD</value>
    </enumerator>
    <enumerator>
      <name>PHYSICAL_PRESENCE</name>
      <value>0xE</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0xF</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_PURPOSE</id>
  </enumerationType>

  <enumerationType>
    <description>Pulled from the MRW, this describes the device
            type to the HDAT.  This is for I2C devices only.
    </description>
    <enumerator>
      <name>9551</name>
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>955X</name>
      <!-- deprecated -->
      <value>0x1</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <!-- deprecated -->
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c128</name>
      <value>0x2</value>
    </enumerator>
    <enumerator>
      <name>NUVOTON_TPM</name>
      <value>0x3</value>
    </enumerator>
    <enumerator>
      <name>MEX_FPGA</name>
      <value>0x4</value>
    </enumerator>
    <enumerator>
      <name>UCX90XX</name>
      <value>0x5</value>
    </enumerator>
    <enumerator>
      <name>NVLINK</name>
      <!-- deprecated -->
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9552</name>
      <value>0x6</value>
    </enumerator>
    <enumerator>
      <name>9553</name>
      <value>0x7</value>
    </enumerator>
    <enumerator>
      <name>9554</name>
      <value>0x8</value>
    </enumerator>
    <enumerator>
      <name>9555</name>
      <value>0x9</value>
    </enumerator>
    <enumerator>
      <name>SMP_or_OpenCAPI_Cable</name>
      <value>0xA</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel28c256</name>
      <value>0xB</value>
    </enumerator>
    <enumerator>
      <name>THERMAL_SENSOR</name>
      <value>0x0C</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c04</name>
      <value>0x0D</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c412</name>
      <value>0x0E</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c32</name>
      <value>0x0F</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c64</name>
      <value>0x10</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM_Atmel24c16</name>
      <value>0x11</value>
    </enumerator>
    <enumerator>
      <name>NVDIA_GPU</name>
      <value>0x12</value>
    </enumerator>
    <enumerator>
      <name>NXP_LPC_Microcontroller_LPC11U35</name>
      <value>0x13</value>
    </enumerator>
    <enumerator>
      <name>9550</name>
      <value>0x14</value>
    </enumerator>
    <enumerator>
      <name>TCG_I2C_TPM</name>
      <value>0x15</value>
    </enumerator>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0xFF</value>
    </enumerator>
    <id>HDAT_I2C_DEVICE_TYPE</id>
  </enumerationType>

  <attribute>
    <description>
        Number of internal data pointers we have in
        the hostboot reserved memory section.
    </description>
    <id>HDAT_RSV_MEM_NUM_SECTIONS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>HDDW_ORDER</id>
    <description>PCIe slot HDDW order definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>HOMER_PHYS_ADDR</id>
    <description>
        Physical address where HOMER image is placed in mainstore.
    </description>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_HOMER_PHYS_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Value of the next EID that host service should send.
        (Note - EID is more accurate, PLID being kept to handle legacy code.)
    </description>
    <id>HOSTSVC_PLID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x89000000</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>HOT_PLUG_POWER_CONTROLLER_INFO</id>
    <description>Hot Plug Controller values for a specific processor.
        Purpose: Holds information about the hot plug controllers so that a
            Hardware procedure is able to turn them on and off.
        Data Format: up to 8 Hot Plug Controllers x 7 variables of information
            This data is at the processor level.
            The needed information and their individual sizes are as follows:
            (1) I2C Master processor engine (uint8_t)
            (2) I2C Master processor port (uint8_t)
            (3) Bus Speed (uint16_t value: 2 uint8_t values: MSB, LSB)
            (4) Slave address (uint8_t)
            (5) Device type (uint8_t: see SUPPORTED_HOT_PLUG enum)
            (6) I2C Master processor node (uint8_t)
            (7) I2C Master processor position (uint8_t)
            Thus, the information will be 8 bytes.
    </description>
    <simpleType>
      <uint8_t>
        <default>0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
                     0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
            </default>
      </uint8_t>
      <array>8,8</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Hardware Unit ID
        SSSSNNNNTTTTTTTTiiiiiiiiiiiiiiii
        S=System
        N=Node Number
        T=Target Type (matches TYPE attribute)
        i=Instance/Sequence number of target, relative to node
    </description>
    <id>HUID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <default>0xFFFFFFFF</default>
      <uint32_t/>
    </simpleType>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the services that are concerned
        with target changes (ie, via HCDB change).
        The values can be combined using a bitwise 'OR'.
    </description>
    <enumerator>
      <name>GARD</name>
      <value>0x00000001</value>
    </enumerator>
    <enumerator>
      <name>MEMDIAG</name>
      <value>0x00000002</value>
    </enumerator>
    <enumerator>
      <name>PSIDIAG</name>
      <value>0x00000004</value>
    </enumerator>
    <enumerator>
      <name>DIAG_MASK</name>
      <value>0x00000006</value>
    </enumerator>
    <enumerator>
      <name>HOSTSVC_HBEL</name>
      <value>0x00000008</value>
    </enumerator>
    <enumerator>
      <name>RESRC_RECOV</name>
      <value>0x00000010</value>
    </enumerator>
    <enumerator>
      <name>GARD_APPLIED</name>
      <value>0x00000020</value>
    </enumerator>
    <enumerator>
      <name>DEVTREE_SYNC</name>
      <value>0x00000040</value>
    </enumerator>
    <id>HWAS_CHANGED_BIT</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>
        Structure consisting of an EID (or reason), 5 booleans, and 3 reserved
        bits
      </description>
      <field>
        <default>0</default>
        <description>if this target was deconfigured,
                this will be a special DECONFIGURED_BY_ enum,
                OR it will be the errlog EID that caused it,
                either directly or by association,
            </description>
        <name>deconfiguredByEid</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
            </description>
        <name>poweredOn</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
            </description>
        <name>present</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not functional;
             0b1: Target is functional
            </description>
        <name>functional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
            </description>
        <name>dumpfunctional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set for speculative deconfig;
             0b0: target not speculative deconfig;
             0b1: target is speculatively deconfigured;
            </description>
        <name>specdeconfig</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>3</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      HardWare Availability Service state attribute which keeps track of whether
      a given target is powered on (or not), present (or not), functional (or
      not), functional in terms of dump (or not), speculatively deconfigured (or
      not), and if deconfigured, the reason or EID associated with the
      deconfiguration.
    </description>
    <id>HWAS_STATE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Attribute.
        Keeps track of changedSinceChecked state, indicates if the
        target has changed since last checked by the appropriate service.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_FLAG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>HardWare Availability Service State Changed Mask.
        Used when a target changes (ie, via HCDB change) to set the
        HWAS_STATE_CHANGED_FLAG, so that the appropriate services will
        all handle the change.
        This is a bit field of flags (see HWAS_CHANGED_BIT enumeration
        that follows).
        </description>
    <id>HWAS_STATE_CHANGED_SUBSCRIPTION_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>
        Structure consisting of 5 booleans, and 3 reserved
        bits
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not powered on (is off);
             0b1: Target is powered on;
            </description>
        <name>poweredOn</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not present in the system;
             0b1: Target is present in the system
            </description>
        <name>present</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: Target is not functional;
             0b1: Target is functional
            </description>
        <name>functional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>FSP Only, used by DUMP applet;
             0b0: target is dump capabile;
             0b1: target is not dump capabile;
            </description>
        <name>dumpfunctional</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Set for speculative deconfig;
             0b0: target not speculative deconfig;
             0b1: target is speculatively deconfigured;
            </description>
        <name>specdeconfig</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>3</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>
      Copy of HWAS_STATE that is used for save/restore operations
      during testcase execution.
    </description>
    <id>HWAS_STATE_TESTSAVE</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Designates the speed at which a given I2C bus should run.
        Creator: MRW
        Purpose: Used by FW to know the fastest possible bus speed that all of
            the devices on a given bus are able to use.
        Data Format: 4x16 array of uint16_t values.  The first index indicates
            the engine number of the bus.  The second index indicates the port
            number of the bus.  The value in the array is the I2C bus speed
            used for that engine/port combination in KHz.
    </description>
    <id>I2C_BUS_SPEED_ARRAY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,16</array>
      <uint16_t>
        <default>
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,
            0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>I2C_CONTROL_INFO</id>
    <description>Information needed to address an I2C slave device</description>
    <complexType>
      <description>Structure to define addressing this I2C slave device.
    </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C master
      </description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit value.
      </description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
          but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the I2C mux for
            this device
                     must enable to connect this device to its I2C master, if applicable.
                     0xFF indicates no I2C mux present or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path of the I2C mux for this device, if any.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which I2C access method to use at
        a point in time.  Only applicable if target supports one or more I2C
        types.  Only one bit (of the first two) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI I2C at this time.  0b1: Use FSI
            I2C at this time</description>
        <name>useFsiI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use Host I2C at this time.  0b1: Use
            Host I2C at this time</description>
        <name>useHostI2C</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which I2C method to use</description>
    <id>I2C_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>MCS Inband Scom base address</description>
    <id>IBSCOM_MCS_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MCS_INBAND_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>PROC Inband Scom base address</description>
    <id>IBSCOM_PROC_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x0003E00000000000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>ICache Assoc Sets</description>
    <id>ICACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>ICache Block Size in bytes</description>
    <id>ICACHE_BLOCK_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Icache Line Size in bytes</description>
    <id>ICACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>ICache Size in KB</description>
    <id>ICACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      Controls whether target discovery code should assume the target is
      initially present, functional, and powered on (even though later
      operations may change this).  Commonly used to avoid having to do presence
      detect on certain targets.
          0x00: Do not assume target is initially available
          0x01: Assume target is initially available
    </description>
    <id>INIT_TO_AVAILABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <no_export/>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <description>INT - Thread Management Bar address
         MMIO consumed by HB/PHYP
    </description>
    <id>INT_CQ_TM_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <id>ISTEP_MODE</id>
    <description>If True, puts HostBoot into SPLess SingleStep mode.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_ISTEP_MODE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      Used to configure the parameters for enabling pause/stop between
      isteps. This attribute is set via attribute override.
    </description>
    <id>ISTEP_PAUSE_CONFIG</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Used to enable pause/stop in between isteps. This attribute is set via
      attribute override.
    </description>
    <id>ISTEP_PAUSE_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Indicate an inter-enclosure bus at this endpoint target.
                 0 = No, 1 = Yes
    </description>
    <id>IS_INTER_ENCLOSURE_BUS</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>KEY_CLEAR_REQUEST</id>
    <description>
        Indicates types of Key Clear Requests are being made
    </description>
    <no_export/>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>KEY_CLEAR_REQUEST</id>
        <default>NONE</default>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <id>KEY_CLEAR_REQUEST</id>
    <description>
        Enum indicating the different possible Key Clear Request values
        NOTE: See "Host FW key clear requests" in HDAT spec
    </description>
    <enumerator>
      <description>
          (Default) Key Clear not requested
      </description>
      <name>NONE</name>
      <value>0x0000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear All" : Clear/reset all sensitive data controlled by platform
          firmware from the system
      </description>
      <name>ALL</name>
      <value>0x8000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear OS Keys" : This indicates OPAL to clear the OS secureboot keys
      </description>
      <name>OS_KEYS</name>
      <value>0x4000</value>
    </enumerator>
    <enumerator>
      <description>
          "Clear PowerVM System Key" : This indicates to PowerVM to clear the
          system key to the default state
      </description>
      <name>POWERVM_SYSKEY</name>
      <value>0x1000</value>
    </enumerator>
    <enumerator>
      <description>
          Reserved bits
      </description>
      <name>RESERVED_1</name>
      <value>0x2C00</value>
    </enumerator>
    <enumerator>
      <description>
          MFG mode and imprint driver only : Clear all latent sensitive data
          and treat as genesis IPL for MFG processing. Same behavior as
          KEY_CLEAR_ALL as well as clear/reset of any IBM sensitive data.
      </description>
      <name>MFG_ALL</name>
      <value>0x0200</value>
    </enumerator>
    <enumerator>
      <description>
          MFG mode and imprint driver only : Clear all sensitive data and
          leave storage empty
      </description>
      <name>MFG</name>
      <value>0x0100</value>
    </enumerator>
    <enumerator>
      <description>
          Reserved bits
      </description>
      <name>RESERVED_2</name>
      <value>0x00FF</value>
    </enumerator>
  </enumerationType>

  <enumerationType>
    <id>KEY_TRANSITION_STATE</id>
    <description>
        Enum indicating the current Secure Boot key transition state for the
        node.
    </description>
    <enumerator>
      <description>
            Secure Boot key transition not yet requested for the node
        </description>
      <name>KEY_TRANSITION_NOT_REQUESTED</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <description>
            About to write new system Secure Boot key to first SBE SEEPROM
            side in the node
        </description>
      <name>KEY_TRANSITION_STARTED</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <description>
            Failed to apply new system Secure Boot key to one or more functional
            SBE SEEPROM sides in the node
        </description>
      <name>KEY_TRANSITION_FAILED</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <description>
            Successfully applied new system Secure Boot key to every functional
            SBE SEEPROM side in the node
        </description>
      <name>KEY_TRANSITION_SUCCEEDED</name>
      <value>3</value>
    </enumerator>
  </enumerationType>

  <attribute>
    <description>
    Attribute indicating the status of the Secure Boot key transition for
    the node
  </description>
    <hasStringConversion/>
    <id>KEY_TRANSITION_STATE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <enumeration>
        <id>KEY_TRANSITION_STATE</id>
        <default>KEY_TRANSITION_NOT_REQUESTED</default>
      </enumeration>
    </simpleType>
  </attribute>

  <attribute>
    <description>L2 Cache Assoc Sets</description>
    <id>L2_CACHE_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L2 Cache Line Size in bytes</description>
    <id>L2_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L2 Cache Size in KB</description>
    <id>L2_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L3 Cache Line Size in bytes</description>
    <id>L3_CACHE_LINE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>L3 Cache Size in KB</description>
    <id>L3_CACHE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Location code of the Fru target</description>
    <id>LOCATION_CODE</id>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>LPC Bus address - MMIO consumed by PHYP</description>
    <id>LPC_BUS_ADDR</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max chiplets per proc available in the system.
    </description>
    <id>MAX_CHIPLETS_PER_PROC</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MAX_COMPUTE_NODES_PER_SYSTEM</id>
    <description>
        The max compute nodes available in the system.
        Computed value based on CEC enclosures.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max DIMMs per MBA Port available in the system.
    </description>
    <id>MAX_DIMMS_PER_MBA_PORT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <!-- End Required by FSP -->
  <attribute>
    <id>MAX_DMI_PER_PROC</id>
    <description>
        System attribute.
        The max DMI units per proc available in the system.
    </description>
    <simpleType>
      <uint8_t>
        <default>8</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max EX units per proc chip available in the system.
    </description>
    <id>MAX_EXS_PER_PROC_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBAS per membuf available in the system.
    </description>
    <id>MAX_MBAS_PER_MEMBUF_CHIP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MBA ports per MBA available in the system.
    </description>
    <id>MAX_MBA_PORTS_PER_MBA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max MCS units available in the system.
    </description>
    <id>MAX_MCS_PER_SYSTEM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>4</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MAX_POWER</id>
    <description>Defines the maximum power consumption for a PCIe slot</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The max proc chips per node available in the system.
    </description>
    <id>MAX_PROC_CHIPS_PER_NODE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <id>MBA_DIMM</id>
    <description>
       MBA port DIMM number of this DIMM
       (deprecated in favor of POS_ON_MEM_PORT)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MBA_PORT</id>
    <description>
       MBA port this DIMM is connected to
       (deprecated in favor of MEM_PORT)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Memory AVDD voltage domain offset in mV.</description>
    <id>MEM_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Base Address for all mainstore behind this processor</description>
    <id>MEM_BASE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_MEM_BASE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MEM_PORT</id>
    <description>
       Memory port this DIMM is connected to
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Memory VCS voltage domain offset in mV.</description>
    <id>MEM_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VCS_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VDDR voltage domain offset in mV.</description>
    <id>MEM_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDDR_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VDD voltage domain offset in mV.</description>
    <id>MEM_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VDD_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Memory VPP voltage domain offset in mV.</description>
    <id>MEM_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VPP_OFFSET</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MFG_TRACE_ENABLE</id>
    <description>
        Override this to a non-zero value to have the FAPI manufacturing
        traces output to the console or go to a fsp trace buffer when
        console not enabled.
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MGC_LOAD_SOURCE</id>
    <description>defines MGC load source</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        System attribute.
        The lowest frequency that a core can be set to in MHz.
        This is the same for all cores in the system.
        Data is provided by MVPD #V and is calculated as the
        Maximum of the power save frequencies.
    </description>
    <id>MIN_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>4800</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>MIRROR_BASE_ADDRESS</id>
    <description>System Mirrorable Base Address
       Bits8-12 Specifies System Selects
       Bits13-14 Memory select
       Bits15-18 Group ID (within an SMP)
       Bits19-21 Chip ID (8 Max)
       Bits22-63 Chip internal address (42 bits, 4TB)
       Mirroring uses memory select
    </description>
    <simpleType>
      <uint64_t>
        <default>0x4000000000000</default>
      </uint64_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_MIRROR_BASE_ADDRESS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>MMIO_PHYS_ADDR</id>
    <description>
            Physical memory address this device has been mapped to.
    </description>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>MNFG_ABUS_MIN_EYE_HEIGHT</id>
    <description>
      System attribute
      8 bit rx_min_eye_height value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_ABUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for A bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_DMI_MIN_EYE_HEIGHT</id>
    <description>
      System attribute.
      8 bit rx_min_eye_height value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MNFG_DMI_MIN_EYE_WIDTH</id>
    <description>
      System attribute.
      6 bit rx_min_eye_width value for DMI bus interfaces during system
      manufacturing; used for both centaur and p8
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L2_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L2_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L2 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L2_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Cache CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L3_CACHE_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>3</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Directory CEs allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L3_DIR_CES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Maximum number of L3 Line Deletes allowed
      during Manufacturing.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_L3_LINE_DELETES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent MPE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IMPES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during IPL.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_MEMORY_IPL_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when a
      memory intermittent UE attention count is equal to this value. A value of
      0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_IUES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      With MNFG thresholds enabled, PRD will make a predictive callout when an
      RCD parity error (recovery enabled) attention count is equal to this
      value. A value of 0 defaults to the max threshold of 0xff.
    </description>
    <id>MNFG_TH_MEMORY_RCD_PARITY_ERRORS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the maximum number of Memory RCEs
      allowed per Rank during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_MEMORY_RT_RCE_PER_RANK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      This attribute represents the Base threshold (for 2GB DRAM ) of
      Memory CEs allowed during runtime.
      creator: platform (generated based on MRW data)
    </description>
    <id>MNFG_TH_MEMORY_RT_SOFT_CE_TH_ALGO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>2</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>MNFG_XBUS_MIN_EYE_WIDTH</id>
    <description>
      System attribute
      6 bit rx_min_eye_width value for X bus interfaces during system
      manufacturing
      creator: platform
      firmware notes: Attribute value is in the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's model</description>
    <hasStringConversion/>
    <id>MODEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>MODEL</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's model</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>RESERVED</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>VENICE</name>
    </enumerator>
    <enumerator>
      <name>MURANO</name>
    </enumerator>
    <enumerator>
      <name>NAPLES</name>
    </enumerator>
    <enumerator>
      <name>NIMBUS</name>
    </enumerator>
    <enumerator>
      <name>CUMULUS</name>
    </enumerator>
    <enumerator>
      <name>AXONE</name>
    </enumerator>
    <enumerator>
      <name>CENTAUR</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>OCMB</name>
    </enumerator>
    <enumerator>
      <name>JEDEC</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>CDIMM</name>
    </enumerator>
    <enumerator>
      <name>POWER8</name>
      <value>112</value>
    </enumerator>
    <enumerator>
      <name>POWER9</name>
      <value>144</value>
    </enumerator>
    <enumerator>
      <name>POWER10</name>
      <value>145</value>
    </enumerator>
    <enumerator>
      <name>CECTPM</name>
    </enumerator>
    <enumerator>
      <name>BMC</name>
    </enumerator>
    <enumerator>
      <name>AST2500</name>
    </enumerator>
    <enumerator>
      <name>AST2600</name>
    </enumerator>
    <enumerator>
      <name>PCA9847</name>
    </enumerator>
    <enumerator>
      <name>UCD9090</name>
    </enumerator>
    <enumerator>
      <name>UCD90120A</name>
    </enumerator>
    <enumerator>
      <name>UCD90320</name>
    </enumerator>
    <id>MODEL</id>
  </enumerationType>

  <attribute>
    <description>MRU ID attribute for chip/unit class</description>
    <id>MRU_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x00</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR3 VDDR
        voltage setpoint. In mV.
    </description>
    <id>MRW_DDR3_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Maximum voltage limit for the dynamic VID DDR4 VDDR voltage
        setpoint. In mV.
    </description>
    <id>MRW_DDR4_VDDR_MAX_LIMIT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Attribute indicating the default risk level for the system. Applied if
        scratch registers are not overriden
    </description>
    <id>MRW_DEFAULT_RISK_LEVEL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>MRW_MEM_THROTTLE_DENOMINATOR</id>
    <description>Machine Readable Workbook throttle value for denominator cfg_nm_m</description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <!--attribute>
    <id>MRW_REQUIRED_TEST</id>
    <description>An attribute to test the mrwRequired keyword</description>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <mrwRequired/>
  </attribute-->
  <attribute>
    <description>AVDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_AVDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_AVDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INTERCEPT</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_AVDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_ACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_AVDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_AVDD_SLOPE_INACTIVE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VCS_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VCS_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_CENT_VDD_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_ACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/Membuf
    </description>
    <id>MSS_CENT_VDD_SLOPE_INACTIVE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>MBA DRAM data bus utilization percent to use to determine cfg_nm_n_per_mba</description>
    <id>MSS_DATABUS_UTIL_PER_MBA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>MSS_MBA_ADDR_INTERLEAVE_BIT</id>
    <description>sets the Centaur address bits used to interleave addresses between MBA01 and MBA23. valid values are 23 through 32.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>MSS_MBA_CACHELINE_INTERLEAVE_MODE</id>
    <description>centaur interleave mode. 1 = 256-BIT, 0 = 128-BIT.</description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <default>NONE</default>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>STR</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_IDLE_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <default>OFF</default>
    <description>
        Enumeration defining the type of power control requested
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>POWER_DOWN</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>STR</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>PD_AND_STR</name>
      <value>3</value>
    </enumerator>
    <id>MSS_MRW_POWER_CONTROL_REQUESTED</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration for Temperature refresh mode</description>
    <enumerator>
      <name>DISABLE</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ENABLE</name>
      <value>1</value>
    </enumerator>
    <id>MSS_MRW_TEMP_REFRESH_MODE</id>
  </enumerationType>

  <attribute>
    <id>MSS_PHY_SEQ_REFRESH</id>
    <description>
      Controls ENABLE/DISABLE of workaround that sets
      the PHY sequencer to trigger refresh after draminit.
    </description>
    <simpleType>
      <uint8_t/>
      <array>2</array>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_PHY_SEQ_REFRESH</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>VCS memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VCS_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDDR memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic,
    3 = DEFAULT  - domain needs to be programmed, pgm values in sys xml file
    </description>
    <hasStringConversion/>
    <id>MSS_VDDR_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>VDD memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VDD_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_AVDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR3_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR3_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_DDR4_VDDR_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: 1/Amps
    </description>
    <id>MSS_VOLT_DDR4_VDDR_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VCS_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VDDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDDR_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      DRAM Voltage, each voltage rail would need to have a value.
      Computed in mss_volt C code - in millivolts
      creator: mss_volt
      consumer: mss_eff_cnfg, others
      firmware notes: none
    </description>
    <id>MSS_VOLT_VDD_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: mV
    </description>
    <id>MSS_VOLT_VPP_INTERCEPT_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_MSS_VOLT_VPP</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
          DRAM VPP Voltage, each voltage rail would need to have a value.
          Computed in mss_volt C code - in millivolts.  0V - DDR3, 2.5V - DDR4
          creator: mss_volt
          consumer: mss_eff_cnfg, others
          firmware notes: none
    </description>
    <id>MSS_VOLT_VPP_OFFSET_MILLIVOLTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Units: uV/DRAM
    </description>
    <id>MSS_VOLT_VPP_SLOPE_POST_DRAM_INIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>VPP memory programming type
    0 = POWERON  - domain is programmed as part of regular power on sequence,
    1 = STATIC   - domain needs to be programmed, no special computation needed,
    2 = DYNAMIC  - domain needs to be programmed, uses dynamic vid logic
    </description>
    <hasStringConversion/>
    <id>MSS_VPP_PROGRAM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the multi scome
        buffer size. The values can be combined using a
        bitwise 'OR'.  The values will need to be kept
        in sync with the FAPI enumerator values.  Also
        the enumeration type is used by the
        ATTR_MULTI_SCOM_BUFFER_MAX_SIZE.  Should
        note that the MULTI_SCOM_BUFFER_MAX_SIZE values
        are of type uint32_t
    </description>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1KB</name>
      <value>0x00000400</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_2KB</name>
      <value>0x00000800</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_4KB</name>
      <value>0x00001000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_8KB</name>
      <value>0x00002000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_16KB</name>
      <value>0x00004000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_32KB</name>
      <value>0x00008000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_64KB</name>
      <value>0x00010000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_128KB</name>
      <value>0x00020000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_256KB</name>
      <value>0x00040000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_512KB</name>
      <value>0x00080000</value>
    </enumerator>
    <enumerator>
      <name>MULTI_SCOM_BUFFER_SIZE_1MB</name>
      <value>0x00100000</value>
    </enumerator>
    <id>MULTI_SCOM_BUFFER_MAX_SIZE_BIT</id>
  </enumerationType>

  <attribute>
    <id>NEST_PLL_FREQ_BUCKETS</id>
    <description>
      Constant defining number of NEST PLL frequency options ('buckets')
      to be built into unsigned HW image.
  </description>
    <simpleType>
      <uint8_t>
        <default>0x05</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>NEST_PLL_FREQ_I2CDIV_LIST</id>
    <description>
      I2C bus divisor
      index is bucket number
      The values in this list will be factor of 1:64 to the NEST_PLL_FREQ_LIST
  </description>
    <simpleType>
      <uint32_t>
        <default>25,29,31,33,37</default>
      </uint32_t>
      <array>5</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>NEST_PLL_FREQ_LIST</id>
    <description>
      Nest PLL frequency in MHZ
      index is bucket number
  </description>
    <simpleType>
      <uint32_t>
        <default>1600,1866,2000,2133,2400</default>
      </uint32_t>
      <array>5</array>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Nest VCS Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDDR Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDD Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VDN Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VDN_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Nest VIO Voltage Rail ID. The ID is an arbitrary value and is needed as
        correlation token between HB and HWSV. It will be generated by the
        MRW processing scripts.
    </description>
    <id>NEST_VIO_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR base address values
        creator: platform
        consumer: proc_setup_bars
        firmware notes:
            64-bit address representing BAR RA
            NOTE: BAR register covers RA 14:51
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <id>NPU_MMIO_BAR_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>NPU MMIO BAR size values
        creator: platform
        consumer: proc_setup_bars
        firmware notes: none
            first dimension: unit number (0:3)
            second dimension: BAR number (0:1)
    </description>
    <id>NPU_MMIO_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4,2</array>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NPU_MMIO_BAR_SIZE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the BAR size
        used with ATTR_PROC_NPU_MMIO_BAR_SIZE</description>
    <enumerator>
      <name>2_MB</name>
      <value>0x0000000000200000</value>
    </enumerator>
    <enumerator>
      <name>1_MB</name>
      <value>0x0000000000100000</value>
    </enumerator>
    <enumerator>
      <name>512_KB</name>
      <value>0x0000000000080000</value>
    </enumerator>
    <enumerator>
      <name>256_KB</name>
      <value>0x0000000000040000</value>
    </enumerator>
    <enumerator>
      <name>128_KB</name>
      <value>0x0000000000020000</value>
    </enumerator>
    <enumerator>
      <name>64_KB</name>
      <value>0x0000000000010000</value>
    </enumerator>
    <id>NPU_MMIO_BAR_SIZE</id>
  </enumerationType>

  <attribute>
    <complexType>
      <description>Numeric POD type test structure</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path for testing purposes</description>
        <name>fsiPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>CHIP</default>
        <description>Class for testing purposes</description>
        <name>className</name>
        <type>CLASS</type>
      </field>
      <field>
        <default>0xAB</default>
        <description>Test uint8</description>
        <name>uint8</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xABCD</default>
        <description>Test uint16</description>
        <name>uint16</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xABCDEF01</default>
        <description>Test uint32</description>
        <name>uint32</name>
        <type>uint32_t</type>
      </field>
      <field>
        <default>0xABCDEF0123456789</default>
        <description>Test uint64</description>
        <name>uint64</name>
        <type>uint64_t</type>
      </field>
      <field>
        <default>-124</default>
        <description>Test int8</description>
        <name>int8</name>
        <type>int8_t</type>
      </field>
      <field>
        <default>-32764</default>
        <description>Test int16</description>
        <name>int16</name>
        <type>int16_t</type>
      </field>
      <field>
        <default>-2147483644</default>
        <description>Test int32</description>
        <name>int32</name>
        <type>int32_t</type>
      </field>
      <field>
        <default>-9223372036854775804</default>
        <description>Test int64</description>
        <name>int64</name>
        <type>int64_t</type>
      </field>
    </complexType>
    <description>Attribute which tests numeric POD types</description>
    <id>NUMERIC_POD_TYPE_TEST</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      NVDIMM(s) are armed for backup incase of power loss (DDR Reset_n goes low)
      This keeps track of the armed state
    </description>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <complexType>
      <description>Armed State</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Is NVDIMM armed</description>
        <name>armed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>NVDIMM controller error detected</description>
        <name>error_detected</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <id>NVDIMM_ARMED</id>
  </attribute>

  <attribute>
    <id>NV_OPS_TIMEOUT_MSEC</id>
    <description>
        NVDIMM timeout value for 6 main operations
        0 - CSAVE
        1 - Page Switch
        2 - Restore
        3 - ERASE
        4 - ARM
        5 - CHARGE

        This attribute is set to volatile because the timeout values vary
        depending on the vendor and capacity. The timeout values will be
        determined during init by reading the i2c registers on the NV
        controller.
        The indices are defined in src/usr/isteps/nvdimm.H and the attribute
        is consumed in nvdimm.C
    </description>
    <simpleType>
      <array>6</array>
      <uint32_t>
        <default>0,0,0,0,0,0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>NV_STATUS_FLAG</id>
    <description>
        NVDIMM status flag. This is used to record the status and
        later report to OPAL/PHYP. Possible values:

        0x08 - contents not preserved (genesis)
        0x04 - contents preserved
        0x02 - failed to preserve contents
        0x01 - unable to preserve future contents
    </description>
    <simpleType>
      <uint8_t>
        <default>0x08</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>OBUS_BRICK_LANE_MASK</id>
    <description>
      Lane mask for which 8 lanes belong to this brick
      This is a right justified 24-bit value. Only 8 of the
      24 bits will be set representing the lanes belonging to
      the associated brick.
      Provided by the MRW.
  </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>OBUS_SLOT_INDEX</id>
    <description>
      Position of the obus slot that the Obus brick is connected to
      (represented in decimal). There is only one slot that a given
      brick connects to and there are only 6 slots per proc,
      so, we just need a single uint8_t representing the position
      of the slot.
      Provided by the MRW.
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        This attribute is to determine whether an occ is master capable.
        An OCC is master capable if it's parent processor is wired to the
        APSS.
    </description>
    <id>OCC_MASTER_CAPABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>DEFAULT_ALL</default>
    <description>Enumeration for the various OCMB Firmware update behaviors</description>
    <enumerator>
      <!-- Compare actual and desired versions, update if they do not match -->
      <name>CHECK_VERSIONS</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <!-- Force an update regardless of the current version in the hardware -->
      <name>FORCE_UPDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <!-- Do not update the firwmare, do not even check the versions -->
      <name>PREVENT_UPDATE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <!-- Compare actual and desired versions, but do not do any updates -->
      <name>CHECK_BUT_NO_UPDATE</name>
      <value>3</value>
    </enumerator>
    <id>OCMB_FW_UPDATE_BEHAVIOR</id>
  </enumerationType>

  <attribute>
    <description>
       Force specific behavior for the OCMB Firmware update function.
    </description>
    <id>OCMB_FW_UPDATE_OVERRIDE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
       Status for OCMB Firmware update
       - update is needed
       - method of update (I2C vs MMIO) to try
       - i2c update has been tried
       - hard failure hit (failure after i2c update tried)
    </description>
    <id>OCMB_FW_UPDATE_STATUS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <complexType>
      <description>Structure which defines update status</description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
              0b0: No update necessary
              0b1: At least one explorer needs update
          </description>
        <name>updateRequired</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Update via I2C
              0b0:  Next update via MMIO (default)
              0b1:  Next update via I2C
          </description>
        <name>updateI2c</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
              0b0: I2C update not done
              0b1: I2C update has been attempted
          </description>
        <name>i2cUpdateAttempted</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
              0b0: I2C update still available to try
              0b1: Hard failure (failure after I2C update)
          </description>
        <name>hardFailure</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>4</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path an OMI's associated OMIC parent target
    </description>
    <id>OMIC_PARENT</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Ordinal ID of a target</description>
    <id>ORDINAL_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <writeable/>
    <no_export/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <description>
      Rules on how to handle a deconfigure to parent level
    </description>
    <id>PARENT_DECONFIG_RULES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <complexType>
      <description>Structure which defines a target's deconfigure rules.
        Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>Are the rule bits set correctly?
        </description>
        <name>valid</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT be deconfigured by child rollup
            0b1: Target allowed to be deconfigured by child rollup
            </description>
        <name>childRollupAllowed</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
            0b0: Target should NOT rollup its deconfigure to its parent
            0b1: Target should deconfigure its parent if no more functioning
                 children of same type exist for its parent
        </description>
        <name>deconfigureParent</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path of the target's associated pervasive target
    </description>
    <id>PARENT_PERVASIVE</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Physical entity path of an OMIC's associated PAUC parent target
    </description>
    <id>PAUC_PARENT</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <virtual/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Base address (target HRMOR) of the payload.  Value is in MB.</description>
    <id>PAYLOAD_BASE</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>The offset from base address of the payload entry-point.
        Current default is 0x180</description>
    <id>PAYLOAD_ENTRY</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x180</default>
      </uint64_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Indicate that payload should be placed in mirrored memory.
        Set by the FSP based on the value of the registry key indicating
        the memory mirroring mode.
    </description>
    <id>PAYLOAD_IN_MIRROR_MEM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Attribute indicating what kind of payload is to be started.
    </description>
    <hasStringConversion/>
    <id>PAYLOAD_KIND</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PAYLOAD_KIND</id>
        <default>PHYP</default>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>UNKNOWN</default>
    <description>
        Enumeration indicating what kind of payload is to be started
    </description>
    <enumerator>
      <name>UNKNOWN</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PHYP</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SAPPHIRE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>NONE</name>
      <value>3</value>
    </enumerator>
    <id>PAYLOAD_KIND</id>
  </enumerationType>

  <attribute>
    <id>PCIE_32BIT_DMA_SIZE</id>
    <description>PCIe slot 32bit DMA size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_32BIT_MMIO_SIZE</id>
    <description>PCIe slot 32bit MMIO size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_64BIT_DMA_SIZE</id>
    <description>PCIe slot 64bit DMA size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_64BIT_MMIO_SIZE</id>
    <description>PCIe slot 64bit MMIO size definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PCIE_CAPABILITES</id>
    <description>Denotes the capabilities of this pcie slot</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Custom Card Identification Number (CCIN) of the NVME Backplane</description>
    <id>PCIE_NVME_CCIN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Designates the System PHB Configuration for NVME Backplanes
        Creator: MRW
        Purpose: Used by FW to know which PHBs to deconfigure based on NVME Backplane
        Data Format: 2x2 array of uint64_t values. The first entry in each array
            is the CCIN of the NVME backplane. The 2nd entry is a bit definition
            to show which PHBs on which Procs are disabled. This is also going to
            emulate the ATTR_PROC_PCIE_PHB_ACTIVE_BASE format. The bit set to 1
            signals the particular PHB is disabled.
                bit 0,1,2: Proc0 Pec0 PHB0/1/2
                bit 3: reserved
                bit 4,5,6: Proc0 Pec1 PHB0/1/2
                bit 7: reserved

                bit 8,9,10: Proc1 Pec0 PHB0/1/2
                bit 11: reserved
                bit 12,13,14: Proc1 Pec1 PHB0/1/2
                bit 15: reserved

                bit 16,17,18: Proc2 Pec0 PHB0/1/2
                bit 19: reserved
                bit 20,21,22: Proc2 Pec1 PHB0/1/2
                bit 23: reserved

                bit 24,25,26: Proc3 Pec0 PHB0/1/2
                bit 27: reserved
                bit 28,29,30: Proc3 Pec1 PHB0/1/2
                bit 31: reserved

                bit 32,33,34: Proc4 Pec0 PHB0/1/2
                bit 35: reserved
                bit 36,37,38: Proc4 Pec1 PHB0/1/2
                bit 39: reserved

                bit 40,41,42: Proc5 Pec0 PHB0/1/2
                bit 43: reserved
                bit 44,45,46: Proc5 Pec1 PHB0/1/2
                bit 47: reserved

                bit 48,49,50: Proc6 Pec0 PHB0/1/2
                bit 52: reserved
                bit 52,53,54: Proc6 Pec1 PHB0/1/2
                bit 55: reserved

                bit 56,57,58: Proc7 Pec0 PHB0/1/2
                bit 59: reserved
                bit 60,61,62: Proc7 Pec1 PHB0/1/2
                bit 63: reserved

           Example: [0x1234, 0x0000, 0x4567, 0x0040080000000000]
                [0x1234, 0x00000000] -- For NVME Backplane with CCIN 0x1234:
                           Do not deconfigure any PHBs on any Procs

                [0x4567, 0x0040080000000000) -- For NVME Backplane with CCIN 0x4567:
                       00 - Do not deconfigure any PHBs on Proc0
                       40 - Deconfigure PHB1 on Proc1 Pec0
                       08 - Deconfigure PHB0 on Proc2 Pec1
                       00 - Do not deconfigure any PHBs on Proc3
                       00 - Do not deconfigure any PHBs on Proc4
                       00 - Do not deconfigure any PHBs on Proc5
                       00 - Do not deconfigure any PHBs on Proc6
                       00 - Do not deconfigure any PHBs on Proc7
    </description>
    <id>PCIE_NVME_PHB_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>2,2</array>
      <uint64_t>
        <default>
            0,0,
            0,0
        </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>PCI_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of PCI refclock receiver termination (FSI GP4 bits 10:11)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
  </attribute>

  <attribute>
    <description>
        This attribute indicates if the PEC can be bifurcated. The value is determined from the workbook.
        0 - PEC is not bifurcateable
        1 - PEC can be bifurcated
        Note: Altering the lane map can be done using the HX keyword.
    </description>
    <id>PEC_IS_BIFURCATABLE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
          This attribute holds the contents of the HX keyword read by the FSP
          from a PCIe card. The keyword data is used to determine the PHB
          bifurcation settings.
          byte    0 = Keyword Version
                        0x00 - Keyword not used, ignore remaining data
                        0x01 - Data describes this enitity's logical PCIe device
                               to physical PCIe lane mapping as one or more
                               logical devices, each connected to a set of PCIe
                               lanes (always an integral multiple of 8 lanes)
          byte    1 = Number of x8 lane set entries X (0 to 7)
                      Each lane set entry is a one-byte value which indicates
                      whether the lane set is used by any logical device, and if
                      used, the logical device ID to which the lane set
                      is assigned, if this byte is zero the remaining keyword
                      data should be ignored.
          bytes 2+N = Lane set entry N
                      where N={0,1..X-1}
                      Each lane set entry maps a set of physical lanes
                      (8*N through N*8+7) to a logical device. Bit 0 indicates
                      whether the lane set is used by a logical device. If used,
                      the next three bits indicate which logical device ID
                      uses those lanes.

                      Bit0:
                         0b0 = Lanes not used by a logical device; ignore
                         0b1 = Lanes used by a logical device; logical device
                               id below is valid
                      Bit 1-3:
                         0b000 = reserved (when bit 0 = 0b0)
                         0b001 -&gt; 0b111
                      Bit 4-7
                      reserved

          Example: bifurcate PEC into 2-x8 devices PHB3 and PHB4
          HX keyword data  kw = { 01 02 B0 C0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = C0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 100 - lane set is assigned to device ID4
              kw[4:8]   - remaining data is ignored


         Example: un-bifurcate a slot which is by default bifurcated
          HX keyword data  kw = { 01 02 B0 B0 xx xx xx xx xx }
              kw[0] = 01 - data is valid
              kw[1] = 02 - there are two lane sets defined
              kw[2] = B0 - b0   = 1 lane set 0xFF00 is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[3] = B0 - b0   = 1 lane set 0x00FF is used
                           b1:3 = 011 - lane set is assigned to device ID3
              kw[4:8]   - remaining data is ignored

         HX keyword data must map to a valid slot configuration as defined by
         the system workbook.
    </description>
    <id>PEC_PCIE_HX_KEYWORD_DATA</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <array>9</array>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Effective PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the effective PCIE IOP reversal value after taking into
            account any IOP bifurcations.  If no IOP bifurcations present, this
            is just the value of the PROC_PCIE_IOP_REVERSAL_NON_BIFURCATED
            attribute.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given PEC/lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the PCIE IOP reversal value for cases where the IOP
            is bifurcated
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. The given index in
            the array is a mask which specifies which bit to invert in the lane
            swap settings for the given lane set
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP reversal configuration
        Creator: Firmware
        Purpose: Holds the base PCIE IOP reversal value without considering IOP
            bifurcation.
        Data Format: x4 array of uint8_t values. The first uint8_t value is
            for lane set 0, the second for lane set 1 and so on. The given
            index in the array is a mask which specifies which bit to invert
            in the lane swap settings for the given lane set.
    </description>
    <id>PEC_PCIE_IOP_REVERSAL_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Bifurcated PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value for the IOPs in the
            case where they are bifurcated.  The swap value controls how PCIE
            lanes are recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base PCIE IOP swap configuration value
        Creator: MRW
        Purpose: Holds the base IOP swap configuration value without considering
            IOP bifurcation.  The swap value controls how PCIE lanes are
            recordered when the leave the IOP, to provide lane routing
            flexibility.
        Data Format: A uint8_t value. The value specifices for the hardware how
            to swap the PCIE lanes for the given PEC.
    </description>
    <id>PEC_PCIE_IOP_SWAP_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask bifurcated configuration
        Creator: MRW
        Purpose: Holds the PCIE lane mask assuming IOPs are bifurcated.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP. For
            instance, lane set 0 value of 0xFF00 and lane set 1 value of 0x00FF
             means the IOP is bifurcated into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Mask base configuration
        Creator: MRW
        Purpose: Holds the base PCIE lane mask assuming no dynamic IOP
            bifurcations.
        Data Format: x4 array of uint16_t values. The first uint8_t value is
            lane set 0, the second for lane set 2 and so on. A lane set mask
            indicates which groups of lanes are assigned to an IOP.  For
            instance, lane set 0 value of 0xFFFF and lane set 1 value of 0x0000
            means the PEC is a x16. Lane set 0 value of 0xFF00 and lane
            set 1 value of 0x00FF, means the PEC is split into two x8s.
    </description>
    <id>PEC_PCIE_LANE_MASK_NON_BIFURCATED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <description>Entity path of the peer target of a bus target
    </description>
    <id>PEER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
      <default>physical:na</default>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Peer target's address of a bus (IOHS) connection.
                 NULL means address 0 for no peer target. If a
                 target instance overrides the default with the
                 peer target's PHYS_PATH. The target compiler will
                 convert the valid PHYS_PATH string into the runtime
                 virtual address of the peer target instance.
    </description>
    <id>PEER_TARGET</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <Target_t>
        <default>NULL</default>
      </Target_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        VCS PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VCS_VOFF_SEL</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the OFF setting for the core and cache chiplet
        DD PFET controllers
    </description>
    <enumerator>
      <name>NOOFF</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT1TO7OFF</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT2TO7OFF</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT3TO7OFF</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT4TO7OFF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT5TO7OFF</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT6TO7OFF</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>ALLBUT7TO7OFF</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>ALLOFF</name>
      <value>8</value>
    </enumerator>
    <id>PFET_VDD_VOFF_SEL</id>
  </enumerationType>

  <attribute>
    <id>PG</id>
    <description>
    Chiplet Partial good info attribute. Provided by Ring scans
  </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
      uint32_t attribute to be used for storing PG state of a PERV
      target during test cases. A 1 bit means the corresponding part
      is deconfigured; a 0 means it is not deconfigured.
    </description>
    <id>PG_SAVED</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Base Address of PHB Register Space</description>
    <id>PHB_BASE_ADDRS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint64_t>
        <default>
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF,
                0xFFFFFFFFFFFFFFFF
            </default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Physical hierarchical path to the target</description>
    <id>PHYS_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <attribute>
    <id>PIB_I2C_NEST_PLL</id>
    <description>
    i2c pll for the system
    default is 0x26 (For PIB @500 MHz (2 GHz nest)) for
    I2C speed = ~1Mhz per Andreas Koenig.
</description>
    <simpleType>
      <uint32_t>
        <default>0x026</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PIB_I2C_REFCLOCK</id>
    <description>
    i2c reference clock for the system.
    default is 0x4 =&gt; I2C speed = ~1Mhz per Andreas Koenig
</description>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
      Set to 1 by HWSV to indicate that attribute overrides exist in a PLCK IPL
      (not an IPL by steps). This is read by Hostboot to determine if it needs
      to request the attribute overrides from HWSV before starting its IPL.
    </description>
    <id>PLCK_IPL_ATTR_OVERRIDES_EXIST</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0x00</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Save state of the sfc driver flash workarounds for runtime</description>
    <id>PNOR_FLASH_WORKAROUNDS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Position of target relative to node</description>
    <id>POSITION</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>POS_ON_MEM_PORT</id>
    <description>
       Position of this DIMM on its memory port
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Hierarchical path to the target with respect to power</description>
    <id>POWER_PATH</id>
    <nativeType>
      <name>EntityPath</name>
    </nativeType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
      Used to tell PRD to make DD1 OMI x4 degrade logs predictive.
    </description>
    <id>PRD_DD1_OMI_DEGRADE_PREDICTIVE</id>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>PRD_HWP_PLID</id>
    <description>
      PRD will perform error isolation for certain errors that may cause a HWP
      to fail. This attribute will be used by the HWP to store the PLID so that
      PRD can subsequently check it for a non-zero value and link the HWP PLID
      to the PRD error log.
    </description>
    <simpleType>
      <uint32_t>
        <default>0</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines a target's primary capabilities.
        A target can only support at most FSI SCOM and one of the other two SCOM
        types.  Applicable for all targets.  Structure is read-only.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support FSI SCOM;
            0b1: Target supports FSI SCOM
            </description>
        <name>supportsFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support XSCOM;
            0b1: Target supports FSI XSCOM</description>
        <name>supportsXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Target does not support inband SCOM</description>
        <name>supportsInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>5</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute which describes capabilities of a target</description>
    <id>PRIMARY_CAPABILITIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Required Processor Compatibility Setting</description>
    <id>PROC_COMPATIBILITY_REQ</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>PROC_COMPATIBILITY_REQ</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>ALLOW_COMPATIBILITY</default>
    <description>
        Enumeration specifying the compatibility setting for Processor ECs
        ALLOW_COMPATIBILITY = set RISK_LEVEL to best allowed
        FORCED_COMPATIBILITY = set RISK_LEVEL to a compatible level
        FORCED_NATIVE = set RISK_LEVEL to ECs native setting
    </description>
    <enumerator>
      <name>ALLOW_COMPATIBILITY</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>FORCED_COMPATIBILITY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>FORCED_NATIVE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_COMPATIBILITY_REQ</id>
  </enumerationType>

  <attribute>
    <id>PROC_DCM_INSTALLED</id>
    <description>
      PROC_CHIP Attribute
        If true, the chip is installed on a Dual Chip Module
        Provided by the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating the PROC_EPS_TABLE_TYPE</description>
    <enumerator>
      <name>EPS_TYPE_LE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>EPS_TYPE_HE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_EPS_TABLE_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_A_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_A_BUS_WIDTH</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_CAPI_MODE
    </description>
    <enumerator>
      <name>OFF</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_CAPI_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_SMP_OPTICS_MODE
    </description>
    <enumerator>
      <name>OPTICS_IS_X_BUS</name>
      <value>0x0</value>
    </enumerator>
    <enumerator>
      <name>OPTICS_IS_A_BUS</name>
      <value>0x1</value>
    </enumerator>
    <id>PROC_FABRIC_SMP_OPTICS_MODE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration indicating the PROC_FABRIC_X_BUS_WIDTH
    </description>
    <enumerator>
      <name>2_BYTE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>4_BYTE</name>
      <value>2</value>
    </enumerator>
    <id>PROC_FABRIC_X_BUS_WIDTH</id>
  </enumerationType>

  <attribute>
    <description>Type of Master, ACTING_MASTER or MASTER_CANDIDATE or
      NOT_MASTER</description>
    <hasStringConversion/>
    <id>PROC_MASTER_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>NOT_MASTER</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <default>NOT_MASTER</default>
    <description>
        Enumeration indicating the role of proc as master/alt_master/not_master
    </description>
    <enumerator>
      <name>ACTING_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MASTER_CANDIDATE</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NOT_MASTER</name>
      <value>2</value>
    </enumerator>
    <id>PROC_MASTER_TYPE</id>
  </enumerationType>

  <enumerationType>
    <description>
        Enumeration for processor module type that come from HDAT spec
        0x50 = DCM
        0x51 = SCM
    </description>
    <enumerator>
      <name>GODEL</name>
      <value>0x50</value>
    </enumerator>
    <enumerator>
      <name>BLAISE</name>
      <value>0x51</value>
    </enumerator>
    <id>PROC_MODULE_TYPE</id>
  </enumerationType>

  <attribute>
    <id>PROC_MODULE_TYPE</id>
    <description>
      Enumeration of the type of processor module used in the system.
      Expected to be filled out by the MRW and expected to be the same
      for every processor module in the system
    </description>
    <simpleType>
      <enumeration>
        <id>PROC_MODULE_TYPE</id>
      </enumeration>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <mrwRequired/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which _PBIEX_ASYNC_SEL should be use</description>
    <enumerator>
      <name>SEL0</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SEL1</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SEL2</name>
      <value>2</value>
    </enumerator>
    <id>PROC_PBIEX_ASYNC_SEL</id>
  </enumerationType>

  <attribute>
    <id>PROC_PCIE_IOP_CONFIG</id>
    <description>PCIE IOP lane configuration
      creator: platform
      consumer: proc_pcie_scominit
      firmware notes:
        Encoded PCIE IOP lane configuration
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOP_CONFIG</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_PCIE_IOVALID_ENABLE</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCIE iovalid enable valid mask
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_IOVALID_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>Indicates whether PCIE lanes terminate at a pluggable slot
        Creator: MRW
        Purpose: Used by FW to know whether the given PCIE lanes terminate at a
            pluggable slot or not.  If this is the case, and the platform
            supports bifurcation, the card's VPD should be interrogated to
            determine whether to bifurcate the IOP or not.
        Data Format: x4 array of uint8_t values.  The first value indicates
            whether lane set 0 terminates at a pluggable slot.  The
            next three values indicate the same for lane sets 1-3. A value of
            1 at a given array index indicates the lanes terminate at a
            pluggable slot, 0 otherwise.
    </description>
    <id>PROC_PCIE_IS_SLOT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint8_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen3 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN3</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x5454,0x5454,0x5454,0x5454,
            0x5454,0x5454,0x5454,0x5454,
            0x5454,0x5454,0x5454,0x5454,
            0x5454,0x5454,0x5454,0x5454,
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen4 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN4</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>PCIE Lane Equalization values for each PHB
        Creator: MRW
        Purpose: Holds settings which are loaded into the HW to optimize the
            PCIE lane signal eye between the chips + PCIE Gen5 endpoints
        Data Format: 16 entries of 16 bytes of EQ data per PHB.  Each PHB has an EQ
            value for each of its 16 lanes.  Each value is a uint16 formatted as
            follows:
                Bit 0:3   - up_rx_hint (bit 0 reserved)
                Bit 4:7   - up_tx_preset
                Bit 8:11  - dn_rx_hint (bit 0 reserved)
                Bit 12:15 - dn_tx_preset
    </description>
    <id>PROC_PCIE_LANE_EQUALIZATION_GEN5</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>16</array>
      <uint16_t>
        <default>
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777,
            0x7777,0x7777,0x7777,0x7777
        </default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Effective PCIE Lane Mask
        Creator: Firmware
        Purpose: Holds the effective PCIE lane mask of each PEC after taking
            into account any IOP bifurcations. If no IOP bifurcations present,
            this is just the value of the PEC_PCIE_LANE_MASK_NON_BIFURCATED
            attribute
        Data Format: x4 array of uint16_t values.  The uint16_t value is a
            mask for lane 0, the next for lane 1 and so on until lane 3.
            A lane set mask indicates which groups of lanes are assigned to an
            IOP.  For instance, lane set 0 value of 0xFFFF and lane set 1 value
            of 0x0000 for PEC0 means PEC0 is a x16. Lane set 0 value of 0xFF00
            and lane set 2 value of 0x00FF for PEC0, means the IOP is bifurcated
            into two x8s.
    </description>
    <id>PROC_PCIE_LANE_MASK</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>4</array>
      <uint16_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <description>
      This attribute holds the base MRW values that controls the latches required to configure the
      PHBs to swap its lanes if wiring to the connector/device is straight or reverse. On some
      systems Dynamic Bifurcation can occur (based on VPD values or some other indicator) which may
      tweak the value provided in this _BASE attribute and the ATTR_PROC_PCIE_LANE_REVERSAL used by
      the HWP directly. If no dynamic bifurcation occurs the _BASE attribute value and
      ATTR_PROC_PCIE_LANE_REVERSAL will be identical.

      creator: platform
      consumer: p10_pcie_scominit
      firmware notes:
        These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached.

       Attribute Name                     Definition                 Example    Comments                        Targeted HWP Attributes
       ATTR_PROC_PCIE_LANE_REVERSAL_BASE  (Stack0, Stack1, Stack2)   (1, 0, 0)  Reverse lanes on PHB0.          TC_PCI_LANE_CFG_DC_2H
                                                                                Do not reverse lanes on PHB1.   TC_PCI_LANE_CFG_DC_3H
                                                                                Do not reverse lanes on PHB2.   TC_PCI_LANE_CFG_DC_4H

       Register Address      Register Name             Bit    Signal Name                Bit Description
       8000009 / 9000009     TPPCI.PCI.CPLT_CONF1      0      TC_PCI_LANE_CFG_DC_0H      MSB for  LANE CFG  in the logic that configures x16, x8x8, x8x4x4
                                                       1      TC_PCI_LANE_CFG_DC_1H      LSB for LANE CFG  in the logic that configures x16, x8x8, x8x4x4

                                                       2      TC_PCI_SWAP_DC_2H          LANE SWAP control for Stack0
                                                       3      TC_PCI_SWAP_DC_3H          LANE SWAP control for Stack0
                                                       4      TC_PCI_SWAP_DC_4H          LANE SWAP control for Stack0

                                                       8      TC_PCI_IOVALID_DC_8H       IOVALID control for Stack0
                                                       9      TC_PCI_IOVALID_DC_9H       IOVALID control for Stack1
                                                       10     TC_PCI_IOVALID_DC_10H      IOVALID control for Stack2

    </description>
    <global/>
    <id>PROC_PCIE_LANE_REVERSAL_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>
              0x0,0x0,0x0
          </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>PROC_PCIE_NUM_PEC</id>
    <description>
      creator: platform
        Number of PCIe PEC units present on target
        Nimbus: 3
  </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_LOFF_CONTROL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx loff control
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx loff control for PCS.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
      <uint16_t/>
      <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_PHASE_ROTATOR_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx phase rotator control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_SIGDET_CNTL</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS rx sigdet control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_RX_VGA_CONTRL_REGISTER3</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        PCS rx vga control register3
        creator: platform
        consumer: p9_pcie_scominit
        firmware notes:
        The value of rx vga control register3.
        Array index: Configuration number
        index 0~3 for CONFIG0~3
    </description>
    <simpleType>
      <uint16_t/>
      <array>4</array>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_SYSTEM_CNTL</id>
    <description>
        Value of PCS system control
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint16_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <!-- @fixme -->
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_PCS_SYSTEM_CNTL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_PCIE_PCS_TX_FIFO_CONFIG_OFFSET</id>
    <!-- TARGET_TYPE_PEC -->
    <description>
        Value of PCS tx fifo config offset
        creator: platform
        consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <description>
      This attribute holds the base values from the MRW to define how to configure the PEC as a x16,
      x8x8, or x8x4x4 based on what PHBs are active defined from the MRW. On some systems Dynamic
      Bifurcation can occur (based on VPD values or some other indicator) which may tweak the value
      provided in this _BASE attribute and the ATTR_PROC_PCIE_PHB_ACTIVE used by the HWP directly.
      If no dynamic bifurcation occurs the _BASE attribute value and ATTR_PROC_PCIE_PHB_ACTIVE will
      be identical.

      creator: platform
      consumer: p10_pcie_scominit
      firmware notes:
        These are config dependent attributes based on PCIe Lane/sideband signal routing and PCIe endpoints attached.

       Attribute Name                  Definition                Example      Comments       Targeted Register Latches
       ATTR_PROC_PCIE_PHB_ACTIVE_BASE  (Stack0, Stack1, Stack2)  (1, 0, 0)    PHB0 enabled   TC_PCI_LANE_CFG_DC_0H, TC_PCI_LANE_CFG_DC_1H
                                                                              PHB1 disabled
                                                                              PHB2 disabled

       Register Latch Definition:
       PCI0 / PCI1
       Register Address      Register Name             Bit    Signal Name                Bit Description
       8000009 / 9000009     TPPCI.PCI.CPLT_CONF1      0      TC_PCI_LANE_CFG_DC_0H      MSB for  LANE CFG  in the logic that configures x16, x8x8, x8x4x4
                                                       1      TC_PCI_LANE_CFG_DC_1H      LSB for LANE CFG  in the logic that configures x16, x8x8, x8x4x4

                                                       2      TC_PCI_SWAP_DC_2H          LANE SWAP control for Stack0
                                                       3      TC_PCI_SWAP_DC_3H          LANE SWAP control for Stack0
                                                       4      TC_PCI_SWAP_DC_4H          LANE SWAP control for Stack0

                                                       8      TC_PCI_IOVALID_DC_8H       IOVALID control for Stack0
                                                       9      TC_PCI_IOVALID_DC_9H       IOVALID control for Stack1
                                                       10     TC_PCI_IOVALID_DC_10H      IOVALID control for Stack2

    </description>
    <global/>
    <id>PROC_PCIE_PHB_ACTIVE_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <array>3</array>
      <uint8_t>
        <default>
              0x1,0x1,0x1
          </default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>PROC_PCIE_REFCLOCK_ENABLE</id>
    <description>PCIE refclock enable valid mask
      PCIE refclock enable valid mask
      creator: platform
      consumer: p9_pcie_scominit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_PCIE_REFCLOCK_ENABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>PROC_REFCLOCK_RCVR_TERM</id>
    <description>
        Defines system specific value of processor refclock receiver termination (FSI GP4 bits 8:9)
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <hasStringConversion/>
    <readable/>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which chip should be used as the PROC_SELECT_BOOT_MASTER</description>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_MASTER</id>
  </enumerationType>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used to boot a processor</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
  </enumerationType>

  <attribute>
    <id>PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
    <description>
    Specifies which SEEPROM image should be used to boot a processor
      FIRST  - the first image was selected
      SECOND - the second image was selected
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_SELECT_BOOT_SEEPROM_IMAGE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <description>Enumeration indicating which SEEPROM image should be used for the boot master</description>
    <enumerator>
      <name>FIRST</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECOND</name>
      <value>2</value>
    </enumerator>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
  </enumerationType>

  <attribute>
    <id>PROC_SELECT_SEEPROM_IMAGE</id>
    <description>
    Specifies which SEEPROM image should be used for the boot master.
      FIRST  - the first image was selected
      SECOND - the second image was selected
      Platforms are expected to set this to FIRST in normal operation
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>Base Address of PSI Bridge Logic</description>
    <id>PSI_BRIDGE_BASE_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>PSIHB - ESB space address - MMIO consumed by PHYP
    </description>
    <id>PSI_HB_ESB_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>
       Raw value of system MTM
    </description>
    <id>RAW_MTM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <enumerationType>
    <description>Enumeration of RECONFIGURE_LOOP flags</description>
    <enumerator>
      <description>
            Indicates HW has been deconfigured
        </description>
      <name>DECONFIGURE</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <description>
            Indicates a bad DQ bit was set in the BadDqBitmap
        </description>
      <name>BAD_DQ_BIT_SET</name>
      <value>0x02</value>
    </enumerator>
    <id>RECONFIGURE_LOOP</id>
  </enumerationType>

  <attribute>
    <description> System attribute array that defines the reconfig loop test cases
      consumer: istep dispatcher reconfigLoopTestRunner function
      This array is loaded with data via attribute override. The attribute is
      then read  and then overlayed onto a test case structure.
  </description>
    <id>RECONFIG_LOOP_TESTS</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>5</array>
      <uint64_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Indicates whether reconfigure loop tests are enabled.
        This attribute is set via attribute override
    </description>
    <id>RECONFIG_LOOP_TESTS_ENABLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <id>REDUNDANT_CLOCKS</id>
    <description>
        1 = System has redundant clock oscillators
        0 = System does not have redundant clock oscillators
        From the Machine Readable Workbook
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>REL_POS</id>
    <description>
        Logical position of this unit/dimm relative to its immediate parent
    </description>
    <simpleType>
      <uint8_t>
        <default>0xFF</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <ignoreEkb/>
    <no_export/>
    <hwpfToHbAttrMap>
      <id>ATTR_REL_POS</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Used to tell if a resource is critical to perform an IPL. If this
        attribute is set to 1 and the target is deconfigured, the IPL MUST
        terminate.
    </description>
    <id>RESOURCE_IS_CRITICAL</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Where did the RISK_LEVEL setting originate?
    This is used to make sure the MRW isn't setting an invalid level
    for FORCED_COMPATIBILITY.
    </description>
    <id>RISK_LEVEL_ORIGIN</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>RISK_LEVEL_ORIGIN</id>
      </enumeration>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>USER</default>
    <description>
        Enumeration specifying what was used to setup the RISK_LEVEL
    </description>
    <enumerator>
      <name>USER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MRW</name>
      <value>1</value>
    </enumerator>
    <id>RISK_LEVEL_ORIGIN</id>
  </enumerationType>

  <attribute>
    <description>Size of RNG IO Region</description>
    <id>RNG_BAR_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0x000000000001000</default>
      </uint64_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Base Address of RNG IO Region</description>
    <id>RNG_BASE_ADDR</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <hwpfToHbAttrMap>
      <id>ATTR_PROC_NX_MMIO_BAR_BASE_ADDR</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Policy indicating whether to perform the maximum amount of memory
            pattern testing possible or not.
        Set to 0x01 to perform the maximum amount of memory pattern testing
            possible.
        Set to 0x00 to perform the default amount of memory pattern testing.
    </description>
    <id>RUN_MAX_MEM_PATTERNS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
            uint8_t attribute to be used for storing functional state of a target during
            test cases.
        </description>
    <id>SAVED_STATE_UINT8</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SBE_COMMIT_ID</id>
    <description>
        A hexadecimal value of the commit ID associated
        with the SBE.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_FIFO_CAPABILITIES</id>
    <description>
        SBE capabilities based on Host_SBE_Interface_Specification
        (Allows for more capabilities than currently supported)
    </description>
    <simpleType>
      <array>40</array>
      <uint32_t>
        <default>
          0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0,
          0,0,0,0,0,0,0,0,0,0
        </default>
      </uint32_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_IS_STARTED</id>
    <description>
        If 0, SBE for the processor has not been started.
        Otherwise, SBE for the processor has been started.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_RELEASE_TAG</id>
    <description>
        An ascii value of the SBE release tag
    </description>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>21</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>SBE_UPDATE_DISABLE</id>
    <description>
      Control execution of updateProcessorSbeSeeproms()

      if 0, enable SBE update of processor SEEPROM
      if 1, disable SBE update of processor SEEPROM

      Consumer:  sbe_update.C

      Default:  0
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>SBE_VERSION_INFO</id>
    <description>
        A hexadecimal value of the major and minor
        version of the SBE.  The major info is in the
        first 16 bits followed by the minor.
        0:15: Major Version
        16:31: Minor Version
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which SCOM to use at a point in
        time.  Only applicable if target supports one or more SCOM types.  Only
        one bit (of the first three) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI SCOM at this time.  0b1: Use FSI
            SCOM at this time</description>
        <name>useFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use XSCOM at this time.  0b1: Use XSCOM at
            this time</description>
        <name>useXscom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use inband SCOM at this time.  0b1: Use
            inband SCOM at this time</description>
        <name>useInbandScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use SBE SCOM at this time.  0b1: Use
            SBE SCOM at this time</description>
        <name>useSbeScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
          0b0: Do not use I2C SCOM at this time.
          0b1: Use I2C SCOM at this time
        </description>
        <name>useI2cScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use SPI FSI SCOM at this time.  0b1: Use SPI FSI
            SCOM at this time</description>
        <name>useSpiFsiScom</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>2</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which SCOM path to use</description>
    <id>SCOM_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT32_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint32_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT32_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT32_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT64_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint64_t attribute
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT64_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT64_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT8_1</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_1</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Scratch uint8_t attribute.
        Can be used by HWPs for testing.
    </description>
    <id>SCRATCH_UINT8_2</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_SCRATCH_UINT8_2</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
    <description>
        To deconfigure a TPM in a secure system - 01 to set TDP bit
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <ignoreEkb/>
    <hwpfToHbAttrMap>
      <id>ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <id>SECURE_VERSION_LOCKIN_POLICY</id>
    <description>
        This policy determines if a new FW Secure Version will be locked into
        the SBE Seeproms during the SBE Update process such that previous
        versions will no longer be supported.
        - 0b0 - (Default) Policy Disabled - Do NOT Lock In Secure Version
        - 0b1 - Policy Enabled - Do Lock In Secure Version
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SECURE_VERSION_SEEPROM</id>
    <description>
        The value of the FW Secure Version found in the SBE Seeprom
        of the master processor used to boot this node. It will get
        updated, if necessary, by Hostboot on each IPL.
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SLOT_INDEX</id>
    <description>PCIe slot index definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SLOT_NAME</id>
    <description>PCIe slot name definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>The amount of SMF memory requested
                 by the user, in bytes (read from NVRAM).
                 The minimum non-zero amount is 256MB.
    </description>
    <id>SMF_MEM_AMT_REQUESTED</id>
    <persistency>non-volatile</persistency>
    <simpleType>
      <uint64_t>
        <default>0x0</default>
      </uint64_t>
    </simpleType>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <id>SOCKET_POWER_TURBO</id>
    <description>
      The socket power in turbo mode.
      Controls how much power can be used.
      This is the same for all cores in the system.
      Data is provided by MVPD #V.
    </description>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains SPARE info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of SPARE data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFFFFFFFFFFFFFF</default>
        <description>The number of kilobytes of SPARE data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFFFFFF</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM SPARE info via SPI</description>
    <id>SPI_EEPROM_SPARE_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup VPD info, SBE measurement code, and Keystore.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Offset of the section (always 0 for hardware device)</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The size of the EEPROM in kilobytes</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the RAW value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>0</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the BACKUP MEASUREMENT/MVPD/WOF/SPARSE EEPROM via SPI</description>
    <id>SPI_EEPROM_VPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup VPD info, SBE measurement code, and WOF data.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Offset of the section (always 0 for hardware device)</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The size of the EEPROM in kilobytes</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the RAW value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>0</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the PRIMARY MEASUREMENT/MVPD/KEYSTORE EEPROM via SPI</description>
    <id>SPI_EEPROM_VPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains keystore info for HOSTBOOT.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_HOSTBOOT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the first partition of keystore info for OPAL.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_OPAL_0</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the second partition of keystore info for OPAL.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_OPAL_1</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the third partition of keystore info for OPAL.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_OPAL_2</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains keystore info for PHYP.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>Starting offset (in KB) of keystore data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of keystore data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the KEYSTORE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>8</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the keystore EEPROM via SPI</description>
    <id>SPI_KEYSTORE_INFO_PHYP</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of VPD data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of BACKUP VPD data in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the IBM_MVPD value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>3</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM BACKUP MVPD data via SPI</description>
    <id>SPI_MVPD_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains primary VPD info.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of VPD data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of PRIMARY VPD in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the IBM_MVPD value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>3</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the EEPROM PRIMARY MVPD via SPI</description>
    <id>SPI_MVPD_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains backup SBE boot code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of backup SBE boot code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of backup SBE boot code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_BOOT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>5</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the SBE backup boot code EEPROM via SPI</description>
    <id>SPI_SBE_BOOT_CODE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains primary SBE boot code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of primary SBE boot code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of primary SBE boot code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_BOOT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>5</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the primary SBE boot code EEPROM via SPI</description>
    <id>SPI_SBE_BOOT_CODE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the backup SBE measurement code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of SBE measurement code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of SBE measurement code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_MEASUREMENT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>6</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the backup SBE measurement code EEPROM via SPI</description>
    <id>SPI_SBE_MEASUREMENT_CODE_BACKUP_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains the primary SBE measurement code.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of SBE measurement code in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of SBE measurement code in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the SBE_MEASUREMENT_CODE value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>6</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the SBE primary measurement code EEPROM via SPI</description>
    <id>SPI_SBE_MEASUREMENT_CODE_PRIMARY_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure which defines which SPI access method to use at
        a point in time.  Only one bit (of the first two) can ever be set at any one time.
        </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use FSI SPI at this time.  0b1: Use FSI
            SPI at this time</description>
        <name>useFsiSPI</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>0b0: Do not use PIB SPI at this time.  0b1: Use
            PIB SPI at this time</description>
        <name>usePibSPI</name>
        <type>uint8_t</type>
      </field>
      <field>
        <bits>6</bits>
        <default>0</default>
        <description>Reserved for future expansion</description>
        <name>reserved</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Attribute storing information about which SPI access method to use</description>
    <id>SPI_SWITCHES</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing of an attached TPM chip via SPI.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI engine that drives the TPM. When
          the SPI_TPM_INFO object is being used, only this field should be edited. All the other
          fields do not change regardless of P10 system.</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x04</default>
        <description>SPI engine for TPM</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the TPM chip via SPI</description>
    <id>SPI_TPM_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an attached SPI
          eeprom device that contains WOF data.
      </description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the SPI master</description>
        <name>spiMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0xFF</default>
        <description>SPI master engine</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0</default>
        <description>Starting offset (in KB) of WOF data in EEPROM</description>
        <name>dataOffsetKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <default>0xFFFF</default>
        <description>The number of kilobytes of WOF data + ECC in EEPROM</description>
        <name>dataSizeKB</name>
        <type>uint16_t</type>
      </field>
      <field>
        <!-- Corresponds to the WOF_DATA value of the EEPROM_CONTENT_TYPE enumeration -->
        <default>7</default>
        <description>Indicates the target's eeprom content type</description>
        <name>eepromContentType</name>
        <type>uint8_t</type>
      </field>
    </complexType>
    <description>Information needed to address the WOF data via SPI</description>
    <id>SPI_WOF_DATA_INFO</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <complexType>
      <description>
         Structure which defines a system's SP functions.
         Applicable for System target only.  Structure is read-only.
         Default values match OpenBMC implementation.
      </description>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             If this flag is set then mailboxEnabled MUST also be set

             0b0: SP does not support for VPD, payload, ATTR sync, VDDR, TOD;
             0b1: SP supports VPD, payload, ATTR sync, VDDR, TOD
            </description>
        <name>baseServices</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI slave logic, Hostboot must;
             0b1: SP does initialize FSI slave logic so Hostboot should not
            </description>
        <name>fsiSlaveInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: There is no SP mailbox support;
             0b1: There is SP mailbox support
            </description>
        <name>mailboxEnabled</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not initialize FSI master logic, Hostboot must;
             0b1: SP does initialize FSI master logic so Hostboot should not
            </description>
        <name>fsiMasterInit</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform hardware change detection, Hostboot must;
             0b1: SP does perform hardware change detection (HCDB) so Hostboot should not
            </description>
        <name>hardwareChangeDetection</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>1</bits>
        <default>0</default>
        <description>
             0b0: SP does not perform Power Line Disturbance (PLD) detection, Hostboot must;
             0b1: SP does perform Power Line Disturbance (PLD) detection so Hostboot should not
            </description>
        <name>powerLineDisturbance</name>
        <type>uint32_t</type>
      </field>
      <field>
        <bits>26</bits>
        <default>0</default>
        <description>Reserved for future use</description>
        <name>reserved</name>
        <type>uint32_t</type>
      </field>
    </complexType>
    <description>
      Attribute which describes what the SP is or is not doing in this system
    </description>
    <id>SP_FUNCTIONS</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>START_MEM_ADDRESS_FOR_PAYLOAD_TCE_TOKEN</id>
    <description>
      Specifies the starting memory address that corresponds to the TCE Token
      used by the FSP to transfer the PAYLOAD into system memory.
      If 0xFFFFFFFFFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint64_t>
        <default>0xFFFFFFFFFFFFFFFF</default>
      </uint64_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>STOP5_DISABLE</id>
    <description> Control CME response to execution of PowerPC STOP instruction
    if OFF, treat STOP5 as STOP5
    if ON,  treat STOP5 as STOP4

    Producer: ???

    Consumer:  p8_hcode_image_build.C

    Platform default: OFF
    </description>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <hwpfToHbAttrMap>
      <id>ATTR_STOP5_DISABLE</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>
        Enumeration indication which Hot Plug Controllers are supported by
        the current system.
    </description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>MAX5961</name>
      <value>0x01</value>
    </enumerator>
    <enumerator>
      <name>PCA9551</name>
      <value>0x02</value>
    </enumerator>
    <id>SUPPORTED_HOT_PLUG</id>
  </enumerationType>

  <attribute>
    <description>
      STOP levels supported at runtime (sent to Host via HDAT):
        Bit 0: STOP0 Supported - Quiesce thread only
        Bit 1: STOP1 Supported - P8 Nap
        Bit 2: STOP2 Supported - P8 Fast Sleep
        Bit 3: STOP3 Supported - P8 Fast Sleep using iVRMs
        Bit 4: STOP4 supported - P8 Deep Sleep
        Bit 5: STOP5 Supported - WOF-friendly "Instant on"
        Bit 6,7: Reserved
        Bit 8: STOP8 supported - Half Quad Sleep
        Bit 9: STOP9 supported - P8 Fast Winkle
        Bit 10: Reserved
        Bit 11: STOP11 supported - P8 Deep Winkle
        Bit 12-15 : Reserved
        Bits 16..31 - Reserved
  </description>
    <id>SUPPORTED_STOP_STATES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0xEC100000</default>
      </uint32_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        Do we support dynamically updating memory voltages?
        0 = no, 1 = yes
    </description>
    <id>SUPPORTS_DYNAMIC_MEM_VOLT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>SYNC_BETWEEN_STEPS</id>
    <description>
        Attribute to enable targetting attribute sync when in istep mode.
        1 = sync will occur following each substep when ipl'ing in single step mode
        0 = sync will not be done after each step
    </description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        This field is of the form "vendor,name" where the name indicates
        the family of the systems.  The textual portion of the string has
        a maximum length of 63 characters to accommodate a terminating NULL.
        Both vendor and name fields are lower case US ASCII. No special
        characters other than ",", "-", and "+" as described below should
        be used in the string.
    </description>
    <id>SYSTEM_FAMILY</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,p10-openbmc</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <description>
        This field is of the form ?vendor,type? where the type indicates
        a type of system within the System Family. The textual portion of
        the string has a maximum length of 63 characters to accommodate a
        terminating NULL. Both vendor and name fields are lower case US
        ASCII. No special characters other than ",", "-", and "+" as described
        below should be used in the string.  If identification of specific
        models within a system type is desired, "-model" should be appended
        to the end of the name. The "-model" portion is optional and could be
        used to identify the packaging, specific model numbers, etc.
        NOTE: No Hostboot code should ever key off of this value.
    </description>
    <!-- TODO: RTC 256975 HDAT: Rainier system type for 2U and 4U
         Need to have separate values for different rainier types.
         SW497257 : To fix MRW value  -->
    <id>SYSTEM_TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>ibm,rainier</default>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
  </attribute>

  <attribute>
    <id>SYS_LOCATION_CODE</id>
    <description>
      Location code of the sys
    </description>
    <simpleType>
      <string>
        <sizeInclNull>64</sizeInclNull>
      </string>
    </simpleType>
    <persistency>volatile</persistency>
    <no_export/>
    <writeable/>
    <readable/>
  </attribute>

  <attribute>
    <id>TCE_START_TOKEN_FOR_HDAT</id>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      HDAT section into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <id>TCE_START_TOKEN_FOR_PAYLOAD</id>
    <description>
      Specifies which TCE Token the FSP should start with to transfer the
      PAYLOAD into system memory.
      If 0xFFFFFFFF, then invalid; otherwise, valid.
  </description>
    <simpleType>
      <uint32_t>
        <default>0xFFFFFFFF</default>
      </uint32_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <complexType>
      <description>Structure to define the addressing for an I2C
                     slave device.</description>
      <field>
        <default>physical:sys-0</default>
        <description>Entity path to the chip that contains the I2C
                         master</description>
        <name>i2cMasterPath</name>
        <type>EntityPath</type>
      </field>
      <field>
        <default>0x80</default>
        <description>I2C master engine. This is a 2-bit
                         value.</description>
        <name>engine</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Port from the I2C Master device. This is a 6-bit
                         value.</description>
        <name>port</name>
        <type>uint8_t</type>
      </field>
      <field>
        <default>0x80</default>
        <description>Device address on the I2C bus. This is a 7-bit value,
                         but then shifted 1 bit left.</description>
        <name>devAddr</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Bus Selector Definition -->
      <field>
        <default>0xFF</default>
        <description>Determines which of the N selectable buses the mux
                     will connect to. OxFF indicates no mux present
                     or N/A.</description>
        <name>i2cMuxBusSelector</name>
        <type>uint8_t</type>
      </field>
      <!-- i2c Mux Path Definition -->
      <field>
        <!-- NOTE: physical:sys-0 implies that there is no mux in
                   the bus path for this part.                     -->
        <default>physical:sys-0</default>
        <description>Entity path to the I2C mux for this device.</description>
        <name>i2cMuxPath</name>
        <type>EntityPath</type>
      </field>
    </complexType>
    <description>Information needed to address an I2C slave device</description>
    <id>TEMP_SENSOR_I2C_CONFIG</id>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>Test attribute; largest string possible given size</description>
    <id>TEST_MAX_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>abc</default>
        <sizeInclNull>4</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Test attribute; smallest string possible given size</description>
    <id>TEST_MIN_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default>a</default>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Attribute to test signed attribute
        functionality in the system</description>
    <id>TEST_NEGATIVE_FCN</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <int8_t>
        <default>-6</default>
      </int8_t>
    </simpleType>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Test attribute; string with no default supplied</description>
    <id>TEST_NO_DEFAULT_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Test attribute; string with empty default value</description>
    <id>TEST_NULL_STRING</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <string>
        <default/>
        <sizeInclNull>10</sizeInclNull>
      </string>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>Thread Count</description>
    <id>THREAD_COUNT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x4</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Time Base frequency in MHZ</description>
    <id>TIME_BASE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t>
        <default>0x800000</default>
      </uint32_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Data Associative Sets</description>
    <id>TLB_DATA_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Data Entries</description>
    <id>TLB_DATA_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Instruction Associative Sets</description>
    <id>TLB_INSTR_ASSOC_SETS</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TLB Instruction Entries</description>
    <id>TLB_INSTR_ENTRIES</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>Reserve Size in bytes</description>
    <id>TLB_RESERVE_SIZE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>TOD CHIP DATA for each CHIP
        The size of the TOD CHIP DATA must be equal to the sizeof(TodChipData)
    </description>
    <id>TOD_CPU_DATA</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <array>44</array>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <attribute>
    <description>
        Bitmask indicating what role this chip has in tod topology
    </description>
    <id>TOD_ROLE</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <default>NON_MASTER</default>
    <description>
        Enumeration indicating what role this chip has in tod topology
    </description>
    <enumerator>
      <name>NON_MASTER</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>PRIMARY</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>SECONDARY</name>
      <value>2</value>
    </enumerator>
    <id>TOD_ROLE</id>
  </enumerationType>

  <attribute>
    <id>TPM_ENABLED</id>
    <description>
        Kill-switch to withhold the use of TPM if any problem is found. HB code will not be updating
        this attribute.
        0: TPM is not enabled
        1: TPM is enabled
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <id>TPM_POISONED</id>
    <description>
        A flag indicating whether the TPM has been poisoned. A poisoned TPM
        has a random number extended into its PCR but not mirrorred to its
        log. That creates a disconnection between the TPM and its log, which
        in turn makes it impossible to perform remote attestation on the TPM.
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Setting to require(0x1) or not require(0x0) a functional TPM to
        boot the system.
    </description>
    <id>TPM_REQUIRED</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
  </attribute>

  <attribute>
    <id>TPM_UNUSABLE</id>
    <description>
        Indicates whether the TPM is unusable. Hostboot should not read this
        value for any purpose other than tracing. This value should only be
        written to when there is a certainty that the TPM is not usable.
        This attribute is consumed by FSP during alignment check to determine
        the optimal boot configuration. This attribute can be removed if TPM
        gard is ever supported.
    </description>
    <range>
      <min>0</min>
      <max>1</max>
    </range>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Attribute indicating the target's type</description>
    <hasStringConversion/>
    <id>TYPE</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <enumeration>
        <id>TYPE</id>
      </enumeration>
    </simpleType>
  </attribute>

  <enumerationType>
    <default>NA</default>
    <description>Enumeration indicating the target's type</description>
    <enumerator>
      <name>NA</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>SYS</name>
      <value>1</value>
    </enumerator>
    <enumerator>
      <name>NODE</name>
      <value>2</value>
    </enumerator>
    <enumerator>
      <name>DIMM</name>
      <value>3</value>
    </enumerator>
    <enumerator>
      <name>MEMBUF</name>
      <value>4</value>
    </enumerator>
    <enumerator>
      <name>PROC</name>
      <value>5</value>
    </enumerator>
    <enumerator>
      <name>EX</name>
      <value>6</value>
    </enumerator>
    <enumerator>
      <name>CORE</name>
      <value>7</value>
    </enumerator>
    <enumerator>
      <name>L2</name>
      <value>8</value>
    </enumerator>
    <enumerator>
      <name>L3</name>
      <value>9</value>
    </enumerator>
    <enumerator>
      <name>L4</name>
      <value>10</value>
    </enumerator>
    <enumerator>
      <name>MCS</name>
      <value>11</value>
    </enumerator>
    <enumerator>
      <name>MBA</name>
      <value>13</value>
    </enumerator>
    <enumerator>
      <name>XBUS</name>
      <value>14</value>
    </enumerator>
    <enumerator>
      <name>ABUS</name>
      <value>15</value>
    </enumerator>
    <enumerator>
      <name>PCI</name>
      <value>16</value>
    </enumerator>
    <enumerator>
      <name>DPSS</name>
      <value>17</value>
    </enumerator>
    <enumerator>
      <name>APSS</name>
      <value>18</value>
    </enumerator>
    <enumerator>
      <name>OCC</name>
      <value>19</value>
    </enumerator>
    <enumerator>
      <name>PSI</name>
      <value>20</value>
    </enumerator>
    <enumerator>
      <name>FSP</name>
      <value>21</value>
    </enumerator>
    <enumerator>
      <name>PNOR</name>
      <value>22</value>
    </enumerator>
    <enumerator>
      <name>OSC</name>
      <value>23</value>
    </enumerator>
    <enumerator>
      <name>TODCLK</name>
      <value>24</value>
    </enumerator>
    <enumerator>
      <name>CONTROL_NODE</name>
      <value>25</value>
    </enumerator>
    <enumerator>
      <name>OSCREFCLK</name>
      <value>26</value>
    </enumerator>
    <enumerator>
      <name>OSCPCICLK</name>
      <value>27</value>
    </enumerator>
    <enumerator>
      <name>REFCLKENDPT</name>
      <value>28</value>
    </enumerator>
    <enumerator>
      <name>PCICLKENDPT</name>
      <value>29</value>
    </enumerator>
    <enumerator>
      <name>NX</name>
      <value>30</value>
    </enumerator>
    <enumerator>
      <name>PORE</name>
      <value>31</value>
    </enumerator>
    <enumerator>
      <name>PCIESWITCH</name>
      <value>32</value>
    </enumerator>
    <enumerator>
      <name>CAPP</name>
      <value>33</value>
    </enumerator>
    <enumerator>
      <name>FSI</name>
      <value>34</value>
    </enumerator>
    <enumerator>
      <name>EQ</name>
      <value>35</value>
    </enumerator>
    <enumerator>
      <name>MCA</name>
      <value>36</value>
    </enumerator>
    <enumerator>
      <name>MCBIST</name>
      <value>37</value>
    </enumerator>
    <enumerator>
      <name>MI</name>
      <value>38</value>
    </enumerator>
    <enumerator>
      <name>DMI</name>
      <value>39</value>
    </enumerator>
    <enumerator>
      <name>OBUS</name>
      <value>40</value>
    </enumerator>
    <enumerator>
      <name>SBE</name>
      <value>42</value>
    </enumerator>
    <enumerator>
      <name>PPE</name>
      <value>43</value>
    </enumerator>
    <enumerator>
      <name>PERV</name>
      <value>44</value>
    </enumerator>
    <enumerator>
      <name>PEC</name>
      <value>45</value>
    </enumerator>
    <enumerator>
      <name>PHB</name>
      <value>46</value>
    </enumerator>
    <enumerator>
      <name>SYSREFCLKENDPT</name>
      <value>47</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLKENDPT</name>
      <value>48</value>
    </enumerator>
    <enumerator>
      <name>TPM</name>
      <value>49</value>
    </enumerator>
    <enumerator>
      <name>SP</name>
      <value>50</value>
    </enumerator>
    <enumerator>
      <name>UART</name>
      <value>51</value>
    </enumerator>
    <enumerator>
      <name>PS</name>
      <value>52</value>
    </enumerator>
    <enumerator>
      <name>FAN</name>
      <value>53</value>
    </enumerator>
    <enumerator>
      <name>VRM</name>
      <value>54</value>
    </enumerator>
    <enumerator>
      <name>USB</name>
      <value>55</value>
    </enumerator>
    <enumerator>
      <name>ETH</name>
      <value>56</value>
    </enumerator>
    <enumerator>
      <name>PANEL</name>
      <value>57</value>
    </enumerator>
    <enumerator>
      <name>BMC</name>
      <value>58</value>
    </enumerator>
    <enumerator>
      <name>FLASH</name>
      <value>59</value>
    </enumerator>
    <enumerator>
      <name>SEEPROM</name>
      <value>60</value>
    </enumerator>
    <enumerator>
      <name>TMP</name>
      <value>61</value>
    </enumerator>
    <enumerator>
      <name>GPIO_EXPANDER</name>
      <value>62</value>
    </enumerator>
    <enumerator>
      <name>POWER_SEQUENCER</name>
      <value>63</value>
    </enumerator>
    <enumerator>
      <name>RTC</name>
      <value>64</value>
    </enumerator>
    <enumerator>
      <name>FANCTLR</name>
      <value>65</value>
    </enumerator>
    <enumerator>
      <name>OBUS_BRICK</name>
      <value>66</value>
    </enumerator>
    <enumerator>
      <name>NPU</name>
      <value>67</value>
    </enumerator>
    <enumerator>
      <name>MC</name>
      <value>68</value>
    </enumerator>
    <enumerator>
      <name>TEST_FAIL</name>
      <value>69</value>
    </enumerator>
    <enumerator>
      <name>MFREFCLK</name>
      <value>70</value>
    </enumerator>
    <enumerator>
      <name>SMPGROUP</name>
      <value>71</value>
    </enumerator>
    <enumerator>
      <name>OMI</name>
      <value>72</value>
    </enumerator>
    <enumerator>
      <name>MCC</name>
      <value>73</value>
    </enumerator>
    <enumerator>
      <name>OMIC</name>
      <value>74</value>
    </enumerator>
    <enumerator>
      <name>OCMB_CHIP</name>
      <value>75</value>
    </enumerator>
    <enumerator>
      <name>MEM_PORT</name>
      <value>76</value>
    </enumerator>
    <enumerator>
      <name>I2C_MUX</name>
      <value>77</value>
    </enumerator>
    <enumerator>
      <name>PMIC</name>
      <value>78</value>
    </enumerator>
    <enumerator>
      <name>NMMU</name>
      <value>79</value>
    </enumerator>
    <enumerator>
      <name>PAU</name>
      <value>80</value>
    </enumerator>
    <enumerator>
      <name>IOHS</name>
      <value>81</value>
    </enumerator>
    <enumerator>
      <name>PAUC</name>
      <value>82</value>
    </enumerator>
    <enumerator>
      <name>FC</name>
      <value>83</value>
    </enumerator>
    <enumerator>
      <name>LPCREFCLKENDPT</name>
      <value>84</value>
    </enumerator>
    <enumerator>
      <name>GENERIC_I2C_DEVICE</name>
      <value>85</value>
    </enumerator>
    <enumerator>
      <name>LAST_IN_RANGE</name>
      <value>86</value>
    </enumerator>
    <id>TYPE</id>
  </enumerationType>

  <attribute>
    <id>UCD_MFR_REVISION_OVERRIDE</id>
    <description>
        If non-zero then use value as the discovered MFR_REVISION value from
        the UCD device rather than the actual value from the device.
    </description>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>
      The ultra turbo frequency in MHz.
      This is the same for all cores in the system.
      Data is provided by MVPD #V and is calculated as
      the minimum of the ultra turbo frequencies.
    </description>
    <id>ULTRA_TURBO_FREQ_MHZ</id>
    <persistency>volatile</persistency>
    <readable/>
    <simpleType>
      <uint32_t/>
    </simpleType>
    <writeable/>
    <hwpfToHbAttrMap>
      <id>ATTR_ULTRA_TURBO_NOMINAL</id>
      <macro>DIRECT</macro>
    </hwpfToHbAttrMap>
  </attribute>

  <attribute>
    <description>
        Indicator to Host Firmware to use the 11S SPD data
        for Part Number and Serial Number in DDIMM SPD instead
        of the standard location.
    </description>
    <id>USE_11S_SPD</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
  </attribute>

  <attribute>
    <id>USE_TCES_FOR_DMAS</id>
    <description>
      Specifies whether or not the FSP is ready for Hostboot to enable TCEs
      for DMAs for the given IPL.  This is a temporary attribute which will
      be used to phase-in TCE support.
      If 0, DO NOT use TCEs;
      If 1, use TCEs
  </description>
    <simpleType>
      <uint8_t>
        <default>1</default>
      </uint8_t>
    </simpleType>
    <persistency>volatile</persistency>
    <readable/>
  </attribute>

  <attribute>
    <description>
        Memory VCS voltage domain ID.  All memory buffers in the same VCS
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>VCS_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>Voltage Memory Rail Manager ID.  Currently HB only needs
        to configured the Vddr voltage rail manager during the IPL.  The ID
        is an arbitary value and needed as correlation token between HB and
        HWSV.  It will be generated by the MRW processing scripts.
    </description>
    <id>VDDR_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory VDD voltage domain ID.  All memory buffers in the same VDD
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>VDD_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <enumerationType>
    <description>Enumeration for Voltage Drop Monitor enable</description>
    <enumerator>
      <name>OFF</name>
      <value>0x00</value>
    </enumerator>
    <enumerator>
      <name>ON</name>
      <value>0x01</value>
    </enumerator>
    <id>VDM_ENABLE</id>
  </enumerationType>

  <attribute>
    <id>VENDOR_ID</id>
    <description>PCIe vendor ID definition</description>
    <simpleType>
      <uint8_t/>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <no_export/>
  </attribute>

  <attribute>
    <description>Record offset for this target's VPD</description>
    <id>VPD_REC_NUM</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0xFFFF</default>
      </uint16_t>
    </simpleType>
    <no_export/>
  </attribute>

  <attribute>
    <description>
        Memory VPP voltage domain ID.  All memory buffers in the same VPP
        voltage domain will share the same ID.  IDs are arbitrarily assigned,
        used for correlation between HB + HWSV, and are generated by
        MRW processing scripts.
    </description>
    <id>VPP_ID</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint16_t>
        <default>0</default>
      </uint16_t>
    </simpleType>
  </attribute>

  <attribute>
    <description>
      System control to set the power limit for Workload Optimized
      Frequency (WOF) algorithms.  This is used to select the
      proper VFRT tables.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <id>WOF_POWER_LIMIT</id>
    <persistency>non-volatile</persistency>
    <readable/>
    <simpleType>
      <uint8_t>
        <default>0</default>
      </uint8_t>
    </simpleType>
    <writeable/>
  </attribute>

  <enumerationType>
    <description>Enumeration to select WOF Power Limit</description>
    <enumerator>
      <name>NOMINAL</name>
      <value>0</value>
    </enumerator>
    <enumerator>
      <name>TURBO</name>
      <value>1</value>
    </enumerator>
    <id>WOF_POWER_LIMIT</id>
  </enumerationType>

  <attribute>
    <id>WOF_TABLE_LID_NUMBER</id>
    <description>
      LID id used to load tables for Workload Optimized
      Frequency (WOF) algorithms.
      Producer: TMGT
      Consumers: FW that selects VFRT tables
    </description>
    <simpleType>
      <uint32_t>
        <!-- @todo-RTC:172776-Get rid of default value that points to ZZ -->
        <default>0x81E00440</default>
      </uint32_t>
    </simpleType>
    <persistency>non-volatile</persistency>
    <readable/>
    <writeable/>
  </attribute>

  <attribute>
    <description>XIVE - Controller Bar address
        MMIO consumed by PHYP
    </description>
    <id>XIVE_CONTROLLER_BAR_ADDR</id>
    <persistency>volatile-zeroed</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
  </attribute>

  <attribute>
    <description>XSCOM base address</description>
    <id>XSCOM_BASE_ADDRESS</id>
    <persistency>volatile</persistency>
    <readable/>
    <writeable/>
    <simpleType>
      <uint64_t/>
    </simpleType>
    <no_export/>
  </attribute>

</attributes>
