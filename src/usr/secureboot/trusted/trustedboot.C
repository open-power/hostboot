/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/secureboot/trusted/trustedboot.C $                    */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2015,2024                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
/**
 * @file trustedboot.C
 *
 * @brief Trusted boot interfaces
 */

// ----------------------------------------------
// Includes
// ----------------------------------------------
#include <string.h>
#include <sys/time.h>
#include <trace/interface.H>
#include <errl/errlentry.H>
#include <errl/errlmanager.H>
#include <errl/errludtarget.H>
#include <errl/errludstring.H>
#include <targeting/attrsync.H>
#include <targeting/attrrp.H>
#include <attributeenums.H>
#include <targeting/targplatutil.H>
#include <targeting/common/targetservice.H>
#include <targeting/common/commontargeting.H>
#include <targeting/common/mfgFlagAccessors.H>
#include <runtime/runtime.H>
#include "../hdat/hdattpmdata.H"
#include "../runtime/hdatstructs.H"
#include <secureboot/service.H>
#include <secureboot/trustedbootif.H>
#include <secureboot/trustedboot_reasoncodes.H>
#include <sys/mmio.h>
#include <sys/task.h>
#include <sys/sync.h>
#include <initservice/initserviceif.H>
#include <devicefw/driverif.H>
#include <spi/tpmddif.H>
#include <spi/tpmdd_common.H>
#include <spi/tpmdd.H>
#include <spi/spi.H>
#include "trustedboot.H"
#include "trustedTypes.H"
#include "trustedbootCmds.H"
#include "trustedbootUtils.H"
#include "tpmLogMgr.H"
#include "base/trustedbootMsg.H"
#include <secureboot/settings.H>
#include <fapi2.H>
#include <plat_hwp_invoker.H>
#include <p10_update_security_ctrl.H>
#include <algorithm>
#include <util/misc.H>
#include <hwas/common/hwasCommon.H>
#include <hwas/common/deconfigGard.H>
#include <hwas/hwasPlat.H>
#include <kernel/bltohbdatamgr.H>
#include <sys/misc.h>

#include <sys/msg.h> // msg_q_t
#include <stdlib.h> // calloc
#include <util/utilmem.H> // UtilMem class
#include <sys/mm.h> // mm_virt_to_phys
#include <sys/internode.h> // MAX_NODES_PER_SYS
#include <conversions.H> // BITS_PER_BYTE
#include <errl/hberrltypes.H> // TWO_UINT32_TO_UINT64
#include <errno.h> // EFAULT
#include <mbox/ipc_msg_types.H> // IPC::IPC_EXTEND_PCR

namespace  T = TARGETING;
namespace  TU = TARGETING::UTIL;

namespace TRUSTEDBOOT
{

extern SystemData systemData;

errlHndl_t extendMeasurementToOtherNodes(
    const TPM_Pcr    i_pcr,
    const EventTypes i_eventType,
    const uint8_t*   i_digest,
    const size_t     i_digestSize,
    const uint8_t*   i_logMsg,
    const size_t     i_logMsgSize)
{
    const auto senderNode = TU::getCurrentNodePhysId();
    static size_t transactionId = ( static_cast<size_t>(senderNode) << 56);
    transactionId++;

    TRACFCOMP(g_trac_trustedboot, ENTER_MRK
              "extendMeasurementToOtherNodes(): Request to extend measurement "
              "from node = %d to other nodes, transaction ID = 0x%016llX. "
              "i_pcr = %d, i_eventType = 0x%02X, i_digestSize = %d, "
              "i_logMsgSize = %d",
              senderNode,transactionId,i_pcr,i_eventType,i_digestSize,
              i_logMsgSize);

    errlHndl_t pError = nullptr;
    void* pRequest = nullptr;
    msg_q_t msgQ = nullptr;
    bool msgQRegistered = false;
    uint64_t msgCount = 0;

    do
    {

    const size_t reqSize = sizeof(transactionId) + sizeof(i_pcr)
        + sizeof(i_eventType) + sizeof(i_digestSize) + i_digestSize
        + sizeof(i_logMsgSize) + i_logMsgSize;
    const size_t alignedReqSize = ALIGN_PAGE(reqSize);

    // Force the allocation size to a page boundary, causing the allocator to
    // align the allocation at the beginning of a page, making it easier to
    // compute the allocation's physical address.  Zero out the whole buffer
    // for good measure.  Assumes calloc puts the allocation on contiguous
    // physical pages.
    void* const pRequest = calloc(1,alignedReqSize);
    assert(pRequest != nullptr,"calloc returned nullptr, which this "
        "implementation doesn't support");

    // Note, the UtilMem object does -NOT- own the buffer, it just simplifies
    // serializing into it.
    UtilMem req(pRequest,reqSize);
    req << transactionId << i_pcr << i_eventType << i_digestSize;
    req.write(i_digest,i_digestSize);
    req << i_logMsgSize;
    req.write(i_logMsg,i_logMsgSize);
    pError=req.getLastError();
    if(pError)
    {
        TRACFCOMP(g_trac_trustedboot, ERR_MRK
                  "extendMeasurementToOtherNodes(): failed serializing remote "
                  "extend request into buffer. " TRACE_ERR_FMT,
                  TRACE_ERR_ARGS(pError));
        break;
    }

    const auto reqPhysAddr = mm_virt_to_phys(pRequest);
    if(reqPhysAddr == static_cast<uint64_t>(-EFAULT))
    {
        TRACFCOMP(g_trac_trustedboot, ERR_MRK
                  "extendMeasurementToOtherNodes(): Could not translate "
                  "virtual address %p to physical address (-EFAULT).",
                  pRequest);

        /*@
        * @errortype
        * @severity   ERRL_SEV_UNRECOVERABLE
        * @reasoncode TRUSTEDBOOT::RC_VIRT_TO_PHYS_FAIL
        * @moduleid   TRUSTEDBOOT::MOD_EXTEND_MEAS_OTHER_NODES
        * @userdata1  Virtual address to map
        * @devdesc    Could not translate virtual address to physical address.
        *             Likely a firmware bug.
        * @custdesc   Internal firmware error with trusted boot implications
        */
        pError = new ERRORLOG::ErrlEntry(
            ERRORLOG::ERRL_SEV_UNRECOVERABLE,
            TRUSTEDBOOT::MOD_EXTEND_MEAS_OTHER_NODES,
            TRUSTEDBOOT::RC_VIRT_TO_PHYS_FAIL,
            reinterpret_cast<uint64_t>(pRequest),
            0,
            ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
        break;
    }

    const auto pSys = TU::assertGetToplevelTarget();
    const auto hbImages = pSys->getAttr<TARGETING::ATTR_HB_EXISTING_IMAGE>();

    // This msgQ catches the node responses from the commands; it cannot fail.
    msgQ = msg_q_create();
    pError = MBOX::msgq_register(MBOX::HB_IPC_EXTEND_PCR_MSGQ,msgQ);
    if(pError)
    {
        TRACFCOMP(g_trac_trustedboot, ERR_MRK
                  "extendMeasurementToOtherNodes(): MBOX::msgq_register "
                  "failed. " TRACE_ERR_FMT,
                  TRACE_ERR_ARGS(pError));
        pError->collectTrace(MBOXMSG_TRACE_NAME);
        pError->collectTrace(MBOX_TRACE_NAME);
        break;
    }
    msgQRegistered=true;

    // Loop through other nodes, sending a message to each
    const decltype(hbImages) mask = 0x1 <<
        (  (sizeof(hbImages) * CONVERSIONS::BITS_PER_BYTE) -1);

    TRACFCOMP(g_trac_trustedboot, INFO_MRK
              "extendMeasurementToOtherNodes(): HB_EXISTING_IMAGE (mask) = "
              "0x%02X, (hbImages=0x%02X)",
              mask, hbImages);

    for (size_t destNode=0; (destNode < MAX_NODES_PER_SYS); ++destNode)
    {
        if (destNode == senderNode)
        {
            TRACFCOMP(g_trac_trustedboot, INFO_MRK
                      "extendMeasurementToOtherNodes(): don't send "
                      "IPC_PCR_EXTEND message to primary node %d",
                      senderNode);
            continue;
        }

        if( 0 != ((mask >> destNode) & hbImages ) )
        {
            TRACFCOMP(g_trac_trustedboot, INFO_MRK
                      "extendMeasurementToOtherNodes(): send IPC_PCR_EXTEND "
                      "message to node %d",
                      destNode);

            msg_t* msg = msg_allocate(); // Can't fail
            msg->type = IPC::IPC_PCR_EXTEND;
            msg->data[0] = TWO_UINT32_TO_UINT64(destNode,senderNode);
            msg->data[1] = reqSize;
            // Physical address in memory where the request data resides
            msg->extra_data = reinterpret_cast<void*>(reqPhysAddr);

            // Send the message to the other nodal Hostboot instance
            pError = MBOX::send(MBOX::HB_IPC_MSGQ, msg, destNode);
            if(pError)
            {
                TRACFCOMP(g_trac_trustedboot, ERR_MRK
                          "extendMeasurementToOtherNodes(): MBOX::send to node "
                          "%d failed. " TRACE_ERR_FMT,
                          destNode,TRACE_ERR_ARGS(pError));
                pError->collectTrace(MBOXMSG_TRACE_NAME);
                pError->collectTrace(MBOX_TRACE_NAME);
                break;
            }
            ++msgCount;

        } // End of node to process

    } // End of for loop on nodes

    // Wait for a response from all messages that were successfully sent,
    // regardless of errors

    // @TODO RTC 189356: Add timeout here?
    while(msgCount)
    {
        msg_t* response = msg_wait(msgQ); // Can't fail
        TRACFCOMP(g_trac_trustedboot, INFO_MRK
                  "extendMeasurementToOtherNodes(): IPC_PCR_EXTEND : node %d "
                  "completed",
                  response->data[0] >> 32);
        msg_free(response);
        response = nullptr;
        --msgCount;
    }

    } while(0);

    // If we didn't receive all messages back, we can't predict if a remote node
    // will attempt to use our memory later, so intentionally orphan the memory
    // and write it off.
    if(msgCount==0)
    {
        free(pRequest); // Ok to free if already nullptr
        pRequest = nullptr;
    }

    if(msgQRegistered)
    {
        auto assocQ = MBOX::msgq_unregister(MBOX::HB_IPC_EXTEND_PCR_MSGQ);
        if(assocQ != msgQ)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK
                      "extendMeasurementToOtherNodes(): Unregistered "
                      "MBOX::HB_IPC_EXTEND_PCR_MSGQ queue, but the queue that "
                      "was unregistered (%p) was not the queue (%p) "
                      "originally registered.",
                      assocQ, msgQ);
            /*@
            * @errortype
            * @severity   ERRL_SEV_UNRECOVERABLE
            * @reasoncode TRUSTEDBOOT::RC_MBOX_QUEUE_MISMATCH
            * @moduleid   TRUSTEDBOOT::MOD_EXTEND_MEAS_OTHER_NODES
            * @userdata1  Queue that was registered
            * @userdata2  Queue that was unregistered
            * @devdesc    MBOX queue registered with
            *             MBOX::HB_IPC_EXTEND_PCR_MSGQ handle was different
            *             than expected when unregistering the handle.  Likely
            *             a firmware bug.
            * @custdesc   Internal firmware error with trusted boot
            *             implications
            */
            auto pUnregisterErr = new ERRORLOG::ErrlEntry(
                ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                TRUSTEDBOOT::MOD_EXTEND_MEAS_OTHER_NODES,
                TRUSTEDBOOT::RC_MBOX_QUEUE_MISMATCH,
                reinterpret_cast<uint64_t>(msgQ),
                reinterpret_cast<uint64_t>(assocQ),
                ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
            if(pError)
            {
                pUnregisterErr->plid(pError->plid());
                errlCommit(pUnregisterErr,TRBOOT_COMP_ID);
            }
            else
            {
                pError=pUnregisterErr;
                pUnregisterErr=nullptr;
            }
        }
    }

    if(msgQ)
    {
        msg_q_destroy(msgQ);
        msgQ = nullptr;
    }

    if(pError)
    {
        pError->collectTrace(TRBOOT_COMP_NAME);
    }

    TRACFCOMP(g_trac_trustedboot, EXIT_MRK
              "extendMeasurementToOtherNodes(): msgCount=%d. " TRACE_ERR_FMT,
              msgCount,TRACE_ERR_ARGS(pError));

    return pError;
}

errlHndl_t checkTdpBit(
    TpmTarget* const i_pTpm)
{
    assert(i_pTpm != nullptr,"checkTdpBit: BUG! i_pTpm was nullptr");

    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "checkTdpBit: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    TRACUCOMP(g_trac_trustedboot,ENTER_MRK"checkTdpBit: i_pTpm=0x%.08X", get_huid(i_pTpm));

    errlHndl_t err = nullptr;
    tpm_info_t tpmInfo;

    do {

    err = tpmReadAttributes(i_pTpm,
                            tpmInfo,
                            TPM_LOCALITY_0);
    if(err)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK
            "checkTdpBit: Bug! Failed in call to tpmReadAttributes() for "
            "TPM with HUID=0x%08X. "
            TRACE_ERR_FMT,
            get_huid(i_pTpm),
            TRACE_ERR_ARGS(err));
        break;
    }

    if(tpmInfo.spiTarget->getAttr<TARGETING::ATTR_TYPE>()
        == TARGETING::TYPE_PROC)
    {
        const auto scomSwitches = tpmInfo.spiTarget->getAttr<
            TARGETING::ATTR_SCOM_SWITCHES>();
        if(!scomSwitches.useXscom)
        {
            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "checkTdpBit: TPM with HUID=0x%08X is not "
                "accessible, as the proc that drives it (HUID 0x%08X) "
                "is not XSCOM accessible",
                get_huid(i_pTpm),
                get_huid(tpmInfo.spiTarget));

            /*@
             * @errortype
             * @reasoncode       TRUSTEDBOOT::RC_UNREACHABLE_TPM
             * @moduleid         TRUSTEDBOOT::MOD_TPM_CHECK_TDP_BIT
             * @severity         ERRL_SEV_UNRECOVERABLE
             * @userdata1        Processor Target Driving SPI To The TPM
             * @userdata2        TPM Target
             * @devdesc          Input Processor Target cannot use XSCOMs yet
             *                   so the TPM is unreachable
             * @custdesc         Platform security problem detected
             */
            err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                        TRUSTEDBOOT::MOD_TPM_CHECK_TDP_BIT,
                        TRUSTEDBOOT::RC_UNREACHABLE_TPM,
                        TARGETING::get_huid(tpmInfo.spiTarget),
                        TARGETING::get_huid(i_pTpm));
            break;
        }

        // Check the Security Switch Register and see if the SPI Driver's
        // TPM Deconfig Protect bit is set.
        uint64_t l_securitySwitchValue = 0;
        err = SECUREBOOT::getSecuritySwitch(l_securitySwitchValue, tpmInfo.spiTarget);
        if (err)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK
                      "checkTdpBit: Unable to read the Security Switch Register on "
                      "procTarget HUID=0x%.08X, the SPI master of TPM with HUID=0x%.08X"
                       TRACE_ERR_FMT,
                       get_huid(tpmInfo.spiTarget),
                       get_huid(i_pTpm),
                       TRACE_ERR_ARGS(err));
            break;
        }

        TRACDCOMP(g_trac_trustedboot,INFO_MRK
                  "checkTdpBit: procTarget HUID=0x%.08X (SPI master of TPM with "
                  "HUID=0x%.08X): security switch value = 0x%016lX",
                  get_huid(tpmInfo.spiTarget),
                  get_huid(i_pTpm),
                  l_securitySwitchValue);

        if ((l_securitySwitchValue &
             static_cast<uint64_t>(SECUREBOOT::ProcSecurity::TDPBit)) != 0)
        {
            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                      "checkTdpBit: TPM with HUID=0x%08X has the TDPBit set in its "
                      "SPI master proc (HUID 0x%08X): Security Switch=0x%.16llX. ",
                      get_huid(i_pTpm),
                      get_huid(tpmInfo.spiTarget),
                      l_securitySwitchValue);
            /*@
             * @errortype
             * @reasoncode       TRUSTEDBOOT::RC_TPM_TDP_BIT_IS_SET
             * @moduleid         TRUSTEDBOOT::MOD_TPM_CHECK_TDP_BIT
             * @severity         ERRL_SEV_UNRECOVERABLE
             * @userdata1[0:31]  Processor Target Driving SPI To The TPM
             * @userdata1[32:63] TPM Target
             * @userdata2        Security Switch Register Value
             * @devdesc          TPM Deconfig Protect bit was set in TPM's SPI
             *                   Driver Processor's Security Switch Register
             * @custdesc         Platform security problem detected
             */
            err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                        TRUSTEDBOOT::MOD_TPM_CHECK_TDP_BIT,
                        TRUSTEDBOOT::RC_TPM_TDP_BIT_IS_SET,
                        TWO_UINT32_TO_UINT64(
                          TARGETING::get_huid(tpmInfo.spiTarget),
                          TARGETING::get_huid(i_pTpm)),
                        l_securitySwitchValue);
            break;
        }
    } // end of if spiTarget is a proc
    } while ( 0 );

    TRACUCOMP(g_trac_trustedboot,EXIT_MRK"checkTdpBit");
    return err;
}

errlHndl_t getTpmLogDevtreeInfo(
    const TpmTarget* const i_pTpm,
          uint64_t &       io_logAddr,
          size_t &         o_allocationSize,
          uint64_t &       o_xscomAddr,
          uint32_t &       o_spiControllerOffset)
{
    assert(i_pTpm != nullptr,"getTpmLogDevtreeInfo: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "getTpmLogDevtreeInfo: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    errlHndl_t err = nullptr;
    auto * const pTpmLogMgr = getTpmLogMgr(i_pTpm);
    TRACUCOMP( g_trac_trustedboot,
               ENTER_MRK"getTpmLogDevtreeInfo() tgt=0x%08X Addr:0x%016lX "
               "0x%016lX",
               TARGETING::get_huid(i_pTpm),
               io_logAddr ,reinterpret_cast<uint64_t>(pTpmLogMgr));

    o_allocationSize = 0;

    auto hwasState = i_pTpm->getAttr<TARGETING::ATTR_HWAS_STATE>();

    if (nullptr != pTpmLogMgr &&
        hwasState.present)
    {
        err = TpmLogMgr_getDevtreeInfo(pTpmLogMgr,
                                       io_logAddr,
                                       o_allocationSize,
                                       o_xscomAddr,
                                       o_spiControllerOffset);
    }
    TRACUCOMP( g_trac_trustedboot,
               EXIT_MRK"getTpmLogDevtreeInfo() Addr:0x%016lX",io_logAddr);
    return err;
}

void setTpmDevtreeInfo(
    const TpmTarget* const i_pTpm,
    const uint64_t         i_xscomAddr,
    const uint32_t         i_spiControllerOffset)
{
    assert(i_pTpm != nullptr,"setTpmLogDevtreeInfo: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "setTpmLogDevtreeInfo: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    TRACUCOMP( g_trac_trustedboot,
               ENTER_MRK"setTpmLogDevtreeOffset() tgt=0x%08X "
               "Xscom:0x%016lX Controller:0x%08X",
               TARGETING::get_huid(i_pTpm),
               i_xscomAddr, i_spiControllerOffset);

    auto * const pTpmLogMgr = getTpmLogMgr(i_pTpm);
    if (nullptr != pTpmLogMgr)
    {
        TpmLogMgr_setTpmDevtreeInfo(pTpmLogMgr,
                                    i_xscomAddr, i_spiControllerOffset);
    }
}

void getTpmWithRoleOf(
    TARGETING::TPM_ROLE const i_tpmRole,
    TARGETING::Target*&       o_pTpm)
{
    o_pTpm = nullptr;
    TARGETING::TargetHandleList tpmList;
    getTPMs(tpmList,TPM_FILTER::ALL_IN_BLUEPRINT);

    TARGETING::PredicateAttrVal<TARGETING::ATTR_TPM_ROLE>
        hasMatchingTpmRole(i_tpmRole);
    auto itr = std::find_if(tpmList.begin(),tpmList.end(),
        [&hasMatchingTpmRole](const TARGETING::Target* const i_pTpm)
        {
            return hasMatchingTpmRole(i_pTpm);
        });
    if(itr!=tpmList.end())
    {
        o_pTpm=*itr;
    }
}

void getPrimaryTpm(TARGETING::Target*& o_pPrimaryTpm)
{
    getTpmWithRoleOf(TARGETING::TPM_ROLE_TPM_PRIMARY,
        o_pPrimaryTpm);
}

void getBackupTpm(TARGETING::Target*& o_pBackupTpm)
{
    getTpmWithRoleOf(TARGETING::TPM_ROLE_TPM_BACKUP,
        o_pBackupTpm);
}

errlHndl_t anyFunctionalPrimaryTpmExists(bool &o_exists)
{
    o_exists = false;
    errlHndl_t l_errl = nullptr;
    do
    {
        uint64_t l_dataSizeMax = 0;
        uint32_t l_instance = 0;
        uint64_t l_hdatBaseAddr = 0;
        uint64_t l_hdatInstanceCount = 0;

        l_errl = RUNTIME::get_instance_count(RUNTIME::NODE_TPM_RELATED,
            l_hdatInstanceCount);
        if (l_errl)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK
                "anyFunctionalPrimaryTpmExists failed to get instance count");
            break;
        }

        for (l_instance = 0; l_instance < l_hdatInstanceCount; ++l_instance)
        {
            if (o_exists)
            {
                break;
            }

            l_errl = RUNTIME::get_host_data_section(RUNTIME::NODE_TPM_RELATED,
                l_instance,
                l_hdatBaseAddr,
                l_dataSizeMax);

            if (l_errl)
            {
                TRACFCOMP(g_trac_trustedboot, ERR_MRK
                    "anyFunctionalPrimaryTpmExists failed to get host data"
                    " section with instance: %d", l_instance);
                break;
            }

            auto const l_hdatTpmData = reinterpret_cast<HDAT::hdatTpmData_t*>
                (l_hdatBaseAddr);

            auto l_hdatTpmInfo = reinterpret_cast<const HDAT::hdatHDIFDataArray_t*>
                (reinterpret_cast<const uint8_t*>(l_hdatTpmData) +
                l_hdatTpmData->hdatSbTpmInfo.hdatOffset);

            auto l_hdatTpmInstInfo = reinterpret_cast<const HDAT::hdatSbTpmInstInfo_t*>
                (reinterpret_cast<const uint8_t*>(l_hdatTpmInfo) +
                l_hdatTpmInfo->hdatOffset);

            for (uint32_t l_hdatCount = 0; l_hdatCount < l_hdatTpmInfo->hdatArrayCnt;
                l_hdatCount++)
            {
                // Check for any functional, un-poisoned, primary TPM
                if ((!l_hdatTpmInstInfo->hdatTpmConfigFlags.pcrPoisonedFlag) &&
                    ((l_hdatTpmInstInfo->hdatFunctionalStatus & HDAT::TpmPresentAndFunctional) ==
                        HDAT::TpmPresentAndFunctional) &&
                    (l_hdatTpmInstInfo->hdatTpmConfigFlags.tpmRole ==
                        TARGETING::TPM_ROLE_TPM_PRIMARY))
                {
                    o_exists = true;
                    break;
                }
                // Increment the TPM pointer
                l_hdatTpmInstInfo = reinterpret_cast<const HDAT::hdatSbTpmInstInfo_t*>
                    (reinterpret_cast<const uint8_t*>(l_hdatTpmInstInfo) +
                    l_hdatTpmInfo->hdatAllocSize);
            }
        }
    } while(0);
    return l_errl;
}

bool functionalPrimaryTpmExists()
{
    bool exists = false;
#ifdef CONFIG_TPMDD
    TARGETING::TargetHandleList tpmList;
    getTPMs(tpmList,TPM_FILTER::ALL_IN_BLUEPRINT);

    TARGETING::PredicateHwas present;
    present.present(true);

    TARGETING::PredicateHwas functional;
    functional.functional(true);

    TARGETING::PredicateAttrVal<TARGETING::ATTR_HB_TPM_INIT_ATTEMPTED>
        initialized(true);

    // Only look for primary TPM
    TARGETING::PredicateAttrVal<TARGETING::ATTR_TPM_ROLE>
                    isPrimaryTpm(TARGETING::TPM_ROLE_TPM_PRIMARY);

    // Trace if it's poisoned
    TARGETING::PredicateAttrVal<TARGETING::ATTR_TPM_POISONED>
        poisoned(true);

    auto itr = std::find_if(tpmList.begin(),tpmList.end(),
        [&present,&functional, &initialized, &isPrimaryTpm, &poisoned](
            const TARGETING::Target* const i_pTpm)
        {
            const auto isPresent = present(i_pTpm);
            const auto isFunctional = functional(i_pTpm);
            const auto isInitialized = initialized(i_pTpm);
            const auto isPrimary = isPrimaryTpm(i_pTpm);
            const auto isPoisoned = poisoned(i_pTpm);

            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "functionalPrimaryTpmExists(): TPM HUID 0x%08X's state = "
                "{present=%d,functional=%d,initialized=%d,primary=%d,poisoned=%d}",
                TARGETING::get_huid(i_pTpm),
                isPresent,isFunctional,isInitialized,isPrimary,isPoisoned);

            return (   isPrimaryTpm(i_pTpm)
                    && (   (present(i_pTpm) && functional(i_pTpm))
                        || !initialized(i_pTpm)));
        });

    exists = (itr!=tpmList.end()) ? true : false;
#endif
    return exists;
}

/**
 * @brief Checks if a TPM is connected to the boot processor
 *
 * @param[in] i_pTpm the TPM target to check
 *
 * @return true if TPM is connected to the boot proc; otherwise, return false
 */
bool isTpmConnectedToBootProc(TARGETING::Target* i_pTpm)
{
    // Default to true because most systems only have a single TPM
    bool retval = true;
    TPMDD::tpm_info_t tpmData;
    errlHndl_t err = nullptr;

    do
    {
        TARGETING::Target* bootProcTarget = nullptr;
        err = TARGETING::targetService().queryMasterProcChipTargetHandle(bootProcTarget);
        if (nullptr != err)
        {
            TRACFCOMP(g_trac_trustedboot,ERR_MRK
                "isTpmConnectedToBootProc: Failed to find master processor target");

            // Break here and log error below
            break;
        }

        err = tpmReadAttributes(i_pTpm,
                                tpmData,
                                TPM_LOCALITY_0);
        if (nullptr != err)
        {
            TRACFCOMP(g_trac_trustedboot,ERR_MRK
                "isTpmConnectedToBootProc: Failed to read TPM attributes");

            // Break here and log error below
            break;
        }
        else
        {
            // Check if the TPM is connected to the boot proc
            if (tpmData.spiTarget != bootProcTarget)
            {
                retval = false;
            }
        }
    } while ( 0 );

    // Log any errors found above
    if (err)
    {
        ERRORLOG::ErrlUserDetailsTarget(i_pTpm).addToLog(err);
        err->collectTrace(SECURE_COMP_NAME);
        err->collectTrace(TRBOOT_COMP_NAME);

        // commit this error log
        errlCommit(err, TRBOOT_COMP_ID);
    }

    return retval;
}

void* host_update_primary_tpm( void *io_pArgs )
{
    errlHndl_t err = nullptr;
    bool unlock = false;

    TRACFCOMP(g_trac_trustedboot,ENTER_MRK
        "host_update_primary_tpm()");

    // Get all TPMs to setup our array
    TARGETING::TargetHandleList tpmList;
    getTPMs(tpmList,TPM_FILTER::ALL_IN_BLUEPRINT);

    // Currently we only support a MAX of two TPMS per node
    assert(tpmList.size() <= MAX_TPMS_PER_NODE, "Too many TPMs found");

    TRACFCOMP(g_trac_trustedboot,INFO_MRK
        "host_update_primary_tpm: Found %d TPM(s) in blueprint",
        tpmList.size());

    do
    {
        if (tpmList.empty())
        {
            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "No TPM targets found");
            break;
        }

        TARGETING::TargetService& tS = TARGETING::targetService();

        TARGETING::Target* bootProcTarget = nullptr;
        err = tS.queryMasterProcChipTargetHandle( bootProcTarget );
        if (nullptr != err)
        {
            TRACFCOMP(g_trac_trustedboot,ERR_MRK
                "Failed to find master processor target");
            break;
        }

        for(auto tpm : tpmList)
        {
            mutex_lock(tpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>());
        }
        unlock = true;

        // Loop through the TPMs and score them to determine which TPM would be
        // best to use as the Primary TPM based on this criteria:
        // Best  Score 4: connected to master proc (+2) and not poisoned (+2)
        //       Score 3: connected to alternate master proc (+1) and not poisoned (+2)
        //       Score 2: connected to master proc (+2) and poisoned (+0)
        //       Score 1: connected to alternate master proc (+1) and poisoned (+0)
        // Worst Score 0: default
        uint8_t score = 0;
        std::pair <TARGETING::Target*, uint8_t> master_pair (nullptr,0);
        std::pair <TARGETING::Target*, uint8_t> alternate_pair (nullptr,0);
        for (auto tpm : tpmList)
        {
            score = 0;

            // Add 2 to the score if the TPM has not been poisoned
            if (!(tpm->getAttr<TARGETING::ATTR_TPM_POISONED>()))
            {
                score += 2;
            }

            // Check if the TPM is connected to the boot proc
            if (isTpmConnectedToBootProc(tpm))
            {
                score += 2; // +2 since connected to boot proc
                master_pair.first = tpm;
                master_pair.second = score;
            }
            else
            {
                score++; // +1 since connected to alternate boot proc
                alternate_pair.first = tpm;
                alternate_pair.second = score;
            }
        }

        // Now based on score, set Primary and Backup TPM
        if (master_pair.first != nullptr)
        {
           const auto originalTpmRole = master_pair.first->getAttr<TARGETING::ATTR_TPM_ROLE>();
           auto newTpmRole = TARGETING::TPM_ROLE_INVALID;

           // if has the highest score then make it the primary tpm
           if (master_pair.second >= alternate_pair.second)
           {
               newTpmRole = TARGETING::TPM_ROLE_TPM_PRIMARY;
           }
           else // make it the backup tpm
           {
               newTpmRole = TARGETING::TPM_ROLE_TPM_BACKUP;
           }
           master_pair.first->setAttr<TARGETING::ATTR_TPM_ROLE>(newTpmRole);
           TRACFCOMP(g_trac_trustedboot,INFO_MRK
                     "TPM HUID 0x%08X's original role: %d, new role: %d (score: %d)",
                     TARGETING::get_huid(master_pair.first),
                     originalTpmRole, newTpmRole, master_pair.second);
        }

        if (alternate_pair.first != nullptr)
        {
           const auto originalTpmRole = alternate_pair.first->getAttr<TARGETING::ATTR_TPM_ROLE>();
           auto newTpmRole = TARGETING::TPM_ROLE_INVALID;

           // if has the highest score then make it the primary tpm
           if (alternate_pair.second > master_pair.second)
           {
               newTpmRole = TARGETING::TPM_ROLE_TPM_PRIMARY;
           }
           else // make it the backup tpm
           {
               newTpmRole = TARGETING::TPM_ROLE_TPM_BACKUP;
           }
           alternate_pair.first->setAttr<TARGETING::ATTR_TPM_ROLE>(newTpmRole);
           TRACFCOMP(g_trac_trustedboot,INFO_MRK
                     "TPM HUID 0x%08X's original role: %d, new role: %d (score: %d)",
                     TARGETING::get_huid(alternate_pair.first),
                     originalTpmRole, newTpmRole, alternate_pair.second);
        }

        // Initialize primary TPM
        TARGETING::Target* pPrimaryTpm = nullptr;
        (void)getPrimaryTpm(pPrimaryTpm);
        if(pPrimaryTpm)
        {
            auto hwasState = pPrimaryTpm->getAttr<TARGETING::ATTR_HWAS_STATE>();
            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "Prior to init, TPM HUID 0x%08X has state of {present=%d, "
                "functional=%d}",
                TARGETING::get_huid(pPrimaryTpm),
                hwasState.present,hwasState.functional);

            if(   hwasState.present
               && hwasState.functional)
            {
                // API call will set TPM init attempted appropriately
                tpmInitialize(pPrimaryTpm);
            }
            else
            {
                pPrimaryTpm->setAttr<
                    TARGETING::ATTR_HB_TPM_INIT_ATTEMPTED>(true);
            }

            // Allocate TPM log if it hasn't been already; note that
            // during MPIPL, the targeting init will attempt to re-use old
            // values, but then has logic to set the log manager pointer back to
            // 0.
            auto pTpmLogMgr = getTpmLogMgr(pPrimaryTpm);
            // Need to grab state again, as it could have changed
            hwasState = pPrimaryTpm->getAttr<
                TARGETING::ATTR_HWAS_STATE>();
            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "Prior to log init, TPM HUID 0x%08X has state of {present=%d, "
                "functional=%d}.  Log pointer is %p",
                TARGETING::get_huid(pPrimaryTpm),
                hwasState.present,hwasState.functional,pTpmLogMgr);

            if(   hwasState.present
               && hwasState.functional
               && nullptr == pTpmLogMgr)
            {
                pTpmLogMgr = new TpmLogMgr;
                setTpmLogMgr(pPrimaryTpm,pTpmLogMgr);
                TpmLogMgr_initialize(pTpmLogMgr);
            }
        }
        else
        {
            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "No primary TPM found");
        }

        bool primaryTpmAvail = (pPrimaryTpm != nullptr);
        if(primaryTpmAvail)
        {
            auto primaryHwasState = pPrimaryTpm->getAttr<
                TARGETING::ATTR_HWAS_STATE>();

            TRACFCOMP(g_trac_trustedboot,INFO_MRK
                "Prior to usability determination, Primary TPM HUID 0x%08X has state "
                "of {present=%d, functional=%d}",
                TARGETING::get_huid(pPrimaryTpm),
                primaryHwasState.present,primaryHwasState.functional);

            if (!primaryHwasState.functional ||
                !primaryHwasState.present)
            {
                primaryTpmAvail = false;
            }
        }

        if(!primaryTpmAvail)
        {
            // Primary TPM not available
            TRACFCOMP( g_trac_trustedboot,INFO_MRK
                       "Primary TPM Existence Fail");
        }

        TARGETING::Target* pBackupTpm = nullptr;
        getBackupTpm(pBackupTpm);
        if(pBackupTpm == nullptr)
        {
            TRACFCOMP( g_trac_trustedboot,INFO_MRK
                       "host_update_primary_tpm() "
                       "Backup TPM unavailable "
                       "since it's not in the system blueprint.");
        }

    } while ( 0 );

    if( unlock )
    {
        for(auto tpm : tpmList)
        {
            mutex_unlock(tpm->getHbMutexAttr<
                TARGETING::ATTR_HB_TPM_MUTEX>());
        }
        unlock = false;
    }

    // Make sure we are in a state
    //  where we have a functional TPM
    TRUSTEDBOOT::tpmVerifyFunctionalPrimaryTpmExists();

    if (nullptr == err)
    {
        // Start the task to start to handle the message queue/extends
        task_create(&TRUSTEDBOOT::tpmDaemon, nullptr);
    }

    TARGETING::Target* pPrimaryTpm = nullptr;
    (void)getPrimaryTpm(pPrimaryTpm);

    if (nullptr == err)
    {
        // Log config entries to TPM - needs to be after mutex_unlock
        if(pPrimaryTpm)
        {
            err = tpmLogConfigEntries(pPrimaryTpm);
        }
    }

    if(pPrimaryTpm)
    {
        TRACUCOMP( g_trac_trustedboot,
                   "host_update_primary_tpm() - "
                   "Primary TPM Present:%d Functional:%d Init Attempted:%d"
                   " Usable:%d",
                   pPrimaryTpm->getAttr<TARGETING::ATTR_HWAS_STATE>().
                       present,
                   pPrimaryTpm->getAttr<TARGETING::ATTR_HWAS_STATE>().
                       functional,
                   pPrimaryTpm->getAttr<
                       TARGETING::ATTR_HB_TPM_INIT_ATTEMPTED>(),
                   !(pPrimaryTpm->getAttr<TARGETING::ATTR_TPM_UNUSABLE>()));
    }

    TARGETING::Target* pBackupTpm = nullptr;
    (void)getBackupTpm(pBackupTpm);
    if(pBackupTpm)
    {
        TRACUCOMP( g_trac_trustedboot,
                   "host_update_primary_tpm() - "
                   "Backup TPM Present:%d Functional:%d Init Attempted:%d "
                   "Usable: %d. "
                   "Backup TPM initialization is deferred to istep 10.14.",
                   pBackupTpm->getAttr<TARGETING::ATTR_HWAS_STATE>().
                       present,
                   pBackupTpm->getAttr<TARGETING::ATTR_HWAS_STATE>().
                       functional,
                   pBackupTpm->getAttr<
                       TARGETING::ATTR_HB_TPM_INIT_ATTEMPTED>(),
                   !(pPrimaryTpm->getAttr<TARGETING::ATTR_TPM_UNUSABLE>()));
    }

    TRACFCOMP( g_trac_trustedboot,EXIT_MRK
        "host_update_primary_tpm() - %s",
        ((nullptr == err) ? "No Error" : "With Error") );

    return err;
}

/**
 * @brief Performs SPI init and sets the TPM locality to 0 for the given TPM.
 *        This function is meant to be called on MPIPL, since in regular IPL
 *        those actions are performed by presence detection logic.
 *
 * @param[in] i_pTpm the TPM target to re-initialize
 * @return nullptr on success; non-nullptr on error
 */
errlHndl_t tpmInitInMpipl(TRUSTEDBOOT::TpmTarget* const i_pTpm)
{
    errlHndl_t l_errl = nullptr;

    do {
    tpm_info_t l_tpmInfo;
    l_errl = tpmReadAttributes(i_pTpm,
                               l_tpmInfo,
                               TPM_LOCALITY_0);
    if(l_errl)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"tpmInitInMpipl(): could not read attributes from TPM HUID 0x%x",
                  TARGETING::get_huid(i_pTpm));
        break;
    }

    l_errl = SPI::spiInitEngine(l_tpmInfo.spiTarget, l_tpmInfo.spiEngine);
    if(l_errl)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"tpmInitInMpipl(): Could not re-init SPI engine in MPIPL");
        break;
    }

    uint8_t l_localityData = TPMDD::TPM_ACCESS_REQUEST_LOCALITY_USE;
    size_t l_dataSize = sizeof(l_localityData);
    l_tpmInfo.offset = TPM_REG_75x_TPM_ACCESS;
    l_errl = tpmWrite(&l_localityData,
                      l_dataSize,
                      l_tpmInfo);
    if(l_errl)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"tpmInitInMpipl(): could not write TPM locality to TPM HUID 0x%x in MPIPL",
                  TARGETING::get_huid(i_pTpm));
        break;
    }
    } while(0);

    return l_errl;
}

void tpmInitialize(TRUSTEDBOOT::TpmTarget* const i_pTpm)
{
    assert(i_pTpm != nullptr,"tpmInitialize: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "tpmInitialize: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    errlHndl_t err = nullptr;

    TRACFCOMP( g_trac_trustedboot,
               ENTER_MRK"tpmInitialize() TPM HUID = 0x%08X",
               TARGETING::get_huid(i_pTpm));

    do
    {
        // TPM Initialization sequence
        i_pTpm->setAttr<TARGETING::ATTR_HB_TPM_INIT_ATTEMPTED>(true);
        auto hwasState = i_pTpm->getAttr<
            TARGETING::ATTR_HWAS_STATE>();
        hwasState.functional = true;
        i_pTpm->setAttr<
            TARGETING::ATTR_HWAS_STATE>(hwasState);

        // Before accessing the TPM, make sure that TDP (TPM_DECONFIG_PROTECT) bit has not been
        // set in the TPM's SPI Driver's Processor Security Switch Register
        err = checkTdpBit(i_pTpm);
        if (err)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK
                      "tpmInitialize: Fail back from checkTdpBit: "
                       TRACE_ERR_FMT,
                       TRACE_ERR_ARGS(err));
            break;
        }

        if(TARGETING::UTIL::assertGetToplevelTarget()->getAttr<TARGETING::ATTR_IS_MPIPL_HB>())
        {
            // Since we bypass presence detection in MPIPL, we need to do SPI
            // re-init and set the TPM locality here.
            err = tpmInitInMpipl(i_pTpm);
            if(err)
            {
                break;
            }
        }

        // TPM_STARTUP
        err = tpmCmdStartup(i_pTpm);
        if (nullptr != err)
        {
            break;
        }

        // TPM_GETCAPABILITY to read FW Version
        err = tpmCmdGetCapFwVersion(i_pTpm);
        if (nullptr != err)
        {
            break;
        }

#ifdef CONFIG_TPM_NVIDX_VALIDATE
        // Find out if in manufacturing mode
        // Only validate during MFG IPL
        if ( TARGETING::areAllSrcsTerminating() &&
             !Util::isSimicsRunning())
        {
            // TPM_GETCAPABILITY to validate NV Indexes
            err = tpmCmdGetCapNvIndexValidate(i_pTpm);
            if (nullptr != err)
            {
                break;
            }
        }
#endif
    } while ( 0 );

    // If the TPM failed we will mark it not functional and commit err
    if (nullptr != err)
    {
        // Mark TPM as not functional, commit err and set it to nullptr
        tpmMarkFailed(i_pTpm, err);
    }

    TRACFCOMP( g_trac_trustedboot,
               EXIT_MRK"tpmInitialize()");
}

void tpmReplayLog(TRUSTEDBOOT::TpmTarget* const i_primaryTpm,
                  TRUSTEDBOOT::TpmTarget* const i_backupTpm)
{
    assert(i_primaryTpm != nullptr,
                                 "tpmReplayLog: BUG! i_primaryTpm was nullptr");
    assert(i_backupTpm != nullptr,
                               "tpmReplayLog: BUG! i_backupTpm was nullptr");
    assert(i_primaryTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "tpmReplayLog: BUG! Expected primary target to be of TPM type, but "
           "it was of type 0x%08X",
                                 i_primaryTpm->getAttr<TARGETING::ATTR_TYPE>());
    assert(i_backupTpm->getAttr<TARGETING::ATTR_TYPE>()
                                                         == TARGETING::TYPE_TPM,
           "tpmReplayLog: BUG! Expected secondary target to be of TPM type, but"
           " it was of type 0x%08X",
                               i_backupTpm->getAttr<TARGETING::ATTR_TYPE>());
    TRACUCOMP(g_trac_trustedboot, ENTER_MRK"tpmReplayLog()");

    errlHndl_t err = nullptr;
    bool unMarshalError = false;


    // Create EVENT2 structure to be populated by getNextEvent()
    TCG_PCR_EVENT2 l_eventLog = {0};
    // Move past header event to get a pointer to the first event
    // If there are no events besides the header, l_eventHndl = nullptr
    auto * const pTpmLogMgr = getTpmLogMgr(i_primaryTpm);
    auto * const bTpmLogMgr = getTpmLogMgr(i_backupTpm);
    assert(pTpmLogMgr != nullptr, "tpmReplayLog: BUG! Primary TPM's log manager"
           " is nullptr!");
    assert(bTpmLogMgr != nullptr, "tpmReplayLog: BUG! Backup TPM's log manager"
           " is nullptr!");
    const uint8_t* l_eventHndl = TpmLogMgr_getFirstEvent(pTpmLogMgr);
    while ( l_eventHndl != nullptr )
    {
        // Get next event
        l_eventHndl = TpmLogMgr_getNextEvent(pTpmLogMgr,
                                             l_eventHndl, &l_eventLog,
                                             &unMarshalError);
        if (unMarshalError)
        {
            /*@
             * @errortype
             * @reasoncode     RC_TPM_UNMARSHALING_FAIL
             * @severity       ERRL_SEV_UNRECOVERABLE
             * @moduleid       MOD_TPM_REPLAY_LOG
             * @userdata1      Starting address of event that caused error
             * @userdata2      0
             * @devdesc        Unmarshal error while replaying tpm log.
             * @custdesc       Internal firmware error with trusted boot implications
             */
            err = new ERRORLOG::ErrlEntry( ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                        MOD_TPM_REPLAY_LOG,
                                        RC_TPM_UNMARSHALING_FAIL,
                                        reinterpret_cast<uint64_t>(l_eventHndl),
                                        0,
                                        true /*Add HB SW Callout*/ );

            err->collectTrace( SECURE_COMP_NAME );
            err->collectTrace(TRBOOT_COMP_NAME);
            tpmMarkFailed(i_primaryTpm, err);
            break;
        }

        err = TpmLogMgr_addEvent(bTpmLogMgr, &l_eventLog);
        if(err)
        {
            tpmMarkFailed(i_backupTpm, err);
            break;
        }

        TRACUBIN(g_trac_trustedboot, "tpmReplayLog: Extending event:",
                 &l_eventLog, sizeof(TCG_PCR_EVENT2));
        for (size_t i = 0; i < l_eventLog.digests.count; i++)
        {
            TPM_Alg_Id l_algId = (TPM_Alg_Id)l_eventLog.digests.digests[i]
                                                                   .algorithmId;
            err = tpmCmdPcrExtend(i_backupTpm,
                                  (TPM_Pcr)l_eventLog.pcrIndex,
                                  l_algId,
                                  reinterpret_cast<uint8_t*>
                                      (&(l_eventLog.digests.digests[i].digest)),
                                  getDigestSize(l_algId));
            if (err)
            {
                tpmMarkFailed(i_backupTpm, err);
                break;
            }
        }
        if (err)
        {
            break;
        }
    }

    TRACUCOMP(g_trac_trustedboot, EXIT_MRK"tpmReplayLog()");
}

errlHndl_t tpmLogConfigEntries(TRUSTEDBOOT::TpmTarget* const i_pTpm)
{
    assert(i_pTpm != nullptr,"tpmLogConfigEntries: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "tpmLogConfigEntries: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    TRACUCOMP(g_trac_trustedboot, ENTER_MRK"tpmLogConfigEntries()");

    errlHndl_t l_err = nullptr;

    do
    {
        // Create digest buffer and set to largest config entry size.
        uint8_t l_digest[sizeof(uint64_t)];
        memset(l_digest, 0, sizeof(uint64_t));

        // Security switches
        uint64_t l_securitySwitchValue = 0;
        l_err = SECUREBOOT::getSecuritySwitch(l_securitySwitchValue,
                            TARGETING::MASTER_PROCESSOR_CHIP_TARGET_SENTINEL);
        if (l_err)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK"tpmLogConfigEntries() - "
                      "Call to SECUREBOOT::getSecuritySwitch Failed: "
                      TRACE_ERR_FMT,
                      TRACE_ERR_ARGS(l_err));
            break;
        }
        TRACFCOMP(g_trac_trustedboot, "security switch value = 0x%016lX",
                                l_securitySwitchValue);
        // Extend to TPM - PCR_1
        memcpy(l_digest, &l_securitySwitchValue, sizeof(l_securitySwitchValue));
        uint8_t l_sswitchesLogMsg[] = "Security Switches";
        l_err = pcrExtend(PCR_1, EV_PLATFORM_CONFIG_FLAGS,
                          l_digest, sizeof(l_securitySwitchValue),
                          l_sswitchesLogMsg, sizeof(l_sswitchesLogMsg));
        if (l_err)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK"tpmLogConfigEntries() - "
                      "Call to pcrExtend for Security Switches Failed: "
                      TRACE_ERR_FMT,
                      TRACE_ERR_ARGS(l_err));
            break;
        }
        memset(l_digest, 0, sizeof(uint64_t));

        // Chip type and EC
        // Fill in the actual PVR of chip
        // Layout of the PVR is (32-bit): (see cpuid.C for latest format)
        //     2 nibbles reserved.
        //     2 nibbles chip type.
        //     1 nibble technology.
        //     1 nibble major DD.
        //     1 nibble reserved.
        //     1 nibble minor D
        uint32_t l_pvr = mmio_pvr_read() & 0xFFFFFFFF;
        TRACDCOMP(g_trac_trustedboot, "PVR of chip = 0x%08X", l_pvr);
        // Extend to TPM - PCR_1
        memcpy(l_digest, &l_pvr, sizeof(l_pvr));
        uint8_t l_pvrLogMsg[] = "PVR of Chip";
        l_err = pcrExtend(PCR_1, EV_PLATFORM_CONFIG_FLAGS,
                          l_digest, sizeof(l_pvr), l_pvrLogMsg,
                          sizeof(l_pvrLogMsg));
        if (l_err)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK"tpmLogConfigEntries() - "
                      "Call to pcrExtend for PVR of Chip Failed: "
                      TRACE_ERR_FMT,
                      TRACE_ERR_ARGS(l_err));
            break;
        }
        memset(l_digest, 0, sizeof(uint64_t));

        // Figure out which node we are running on
        TARGETING::Target* l_masterProc = nullptr;
        TARGETING::targetService().masterProcChipTargetHandle(l_masterProc);

        TARGETING::EntityPath l_entityPath =
                        l_masterProc->getAttr<TARGETING::ATTR_PHYS_PATH>();
        const TARGETING::EntityPath::PathElement l_pathElement =
                        l_entityPath.pathElementOfType(TARGETING::TYPE_NODE);
        uint64_t l_nodeid = l_pathElement.instance;
        // Extend to TPM - PCR_1,4,5,6
        memcpy(l_digest, &l_nodeid, sizeof(l_nodeid));
        const TPM_Pcr l_pcrs[] = {PCR_1,PCR_4,PCR_5};
        for (size_t i = 0; i < (sizeof(l_pcrs)/sizeof(TPM_Pcr)) ; ++i)
        {
            uint8_t l_nodeIdLogMsg[] = "Node id";
            l_err = pcrExtend(l_pcrs[i],
                              (l_pcrs[i] == PCR_1 ?
                               EV_PLATFORM_CONFIG_FLAGS : EV_COMPACT_HASH),
                              l_digest, sizeof(l_nodeid), l_nodeIdLogMsg,
                              sizeof(l_nodeIdLogMsg));
            if (l_err)
            {
                TRACFCOMP(g_trac_trustedboot, ERR_MRK"tpmLogConfigEntries() - "
                          "Call to pcrExtend for Node id Failed for "
                          "l_pcrs[i=%d]: %d. "
                          TRACE_ERR_FMT,
                          i, l_pcrs[i],
                          TRACE_ERR_ARGS(l_err));
                break;
            }
        }
        if (l_err)
        {
            break;
        }

        // TPM Required
        memset(l_digest, 0, sizeof(uint64_t));
        bool l_tpmRequired = isTpmRequired();
        l_digest[0] = static_cast<uint8_t>(l_tpmRequired);
        uint8_t l_tpmRequiredLogMsg[] = "TPM Required";
        l_err = pcrExtend(PCR_1, EV_PLATFORM_CONFIG_FLAGS,
                          l_digest, sizeof(l_tpmRequired),
                          l_tpmRequiredLogMsg,
                          sizeof(l_tpmRequiredLogMsg));
        if (l_err)
        {
            TRACFCOMP(g_trac_trustedboot, ERR_MRK"tpmLogConfigEntries() - "
                      "Call to pcrExtend for TPM Required Failed: "
                      TRACE_ERR_FMT,
                      TRACE_ERR_ARGS(l_err));
            break;
        }

    } while(0);

    TRACUCOMP(g_trac_trustedboot, EXIT_MRK"tpmLogConfigEntries()");

    return l_err;
}

/**
 * @brief Look for special situation where on a MPIPL the Hostboot Bootloader (HBBL)
 *        measured the Hostboot Base Image (HBB) to the wrong TPM.  Specifically, since
 *        the HBBL only extends to the boot proc, this function looks for the MPIPL case
 *        where the TPM the HBB is using is actually connected to the alternate boot proc.
 *        In this case, if the PCR operation is for the HBB to log this incorrect extension
 *        of the HBBL, then it returns TRUE.
 *
 * @param[in] i_pTpm -       The TPM that the HBB is using
 * @param[in] i_pcr -        The PCR the extend operation is targeting
 * @param[in] i_logMsg -     The message to be sent to the TPM log
 * @param[in] i_logMsgSize - Size of the message to be sent to the TPM log
 *
 * @return true, if the special condition described above is found; else, false.
 */
// @TODO 620212 - Remove this workaround when/if the HBBL can extend to the correct TPM
// in this special case
bool pcrExtendSpecialCaseException(TpmTarget* const i_pTpm,
                                   const TPM_Pcr i_pcr,
                                   const uint8_t* i_logMsg,
                                   const size_t i_logMsgSize)
{
    bool retval = false;

    auto isMpipl = TARGETING::UTIL::assertGetToplevelTarget()->getAttr<TARGETING::ATTR_IS_MPIPL_HB>();

    TRACUCOMP(g_trac_trustedboot, "pcrExtendSpecialCaseException: TPM 0x%08X, isMpipl=%d, "
              "i_pcr=%d, i_logMsgSize=%d",
              TARGETING::get_huid(i_pTpm), isMpipl, i_pcr, i_logMsgSize);

    // Evaluate the quick conditions first
    if ((isMpipl == false) ||       // MPIPL check
        (i_pcr != PCR_0) ||         // HBB only gets measured to PCR_0
        (i_logMsgSize != 4) ||      // Make sure that it's just "HBB" and not "HBBL"
        (i_logMsg == nullptr) ||    // Make sure there's some log message
        ((i_logMsg != nullptr) &&   // Make sure it's "HBB"
         (strncmp(reinterpret_cast<const char*>(i_logMsg), "HBB", 4))))
    {
        retval = false;
    }
    // Look if HBBL extended to wrong TPM (see this function header for details)
    else if (!isTpmConnectedToBootProc(i_pTpm))
    {
        retval = true;
    }

    TRACUCOMP(g_trac_trustedboot, "pcrExtendSpecialCaseException: retval=%d", retval);

    return retval;
}

void pcrExtendSingleTpm(TpmTarget* const i_pTpm,
                        const TPM_Pcr i_pcr,
                        const EventTypes i_eventType,
                        TPM_Alg_Id i_algId,
                        const uint8_t* i_digest,
                        size_t  i_digestSize,
                        const uint8_t* i_logMsg,
                        const size_t i_logMsgSize,
                        const bool i_extendToTpm,
                        const bool i_extendToSwLog)
{
    assert(i_pTpm != nullptr,"pcrExtendSingleTpm: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "pcrExtendSingleTpm: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    TRACUCOMP(g_trac_trustedboot, ENTER_MRK"pcrExtendSingleTpm: i_tpm=0x%.8X, i_pcr=%d, i_eventType=%d, "
              "i_digestSize=0x%X, i_logSize=0x%X, i_extendToTpm=%d, i_extendToSwLog=%d",
              get_huid(i_pTpm), i_pcr, i_eventType, i_digestSize, i_logMsgSize,
              i_extendToTpm, i_extendToSwLog);

    if (i_logMsg != nullptr)
    {
        TRACUBIN(g_trac_trustedboot, "pcrExtendSingleTpm:  Extended Data Log msg",
                 i_logMsg, i_logMsgSize);
    }

    errlHndl_t err = nullptr;
    TCG_PCR_EVENT2 eventLog;
    bool unlock = false;

    TPM_Pcr pcr = i_pcr;
    bool useStaticLog = true;

    memset(&eventLog, 0, sizeof(eventLog));
    do
    {
        mutex_lock( i_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>() ) ;
        unlock = true;

        // Check for special case where HBB should get measured, rather than just getting logged
        // - see function description for details
        // @TODO 620212 - Remove this workaround when/if the HBBL can extend to the correct TPM
        // in this special case
        bool l_extendToTpm = i_extendToTpm;
        if ((l_extendToTpm == false) &&
            pcrExtendSpecialCaseException(i_pTpm, i_pcr,  i_logMsg, i_logMsgSize))
        {
            TRACFCOMP(g_trac_trustedboot, INFO_MRK
                "pcrExtendSingleTpm: Overriding inputs to measure HBB because pcrExtendSpecialCaseException is true");
            l_extendToTpm = true;
        }

        auto hwasState = i_pTpm->getAttr<TARGETING::ATTR_HWAS_STATE>();

        // Log the event
        if (hwasState.present &&
             hwasState.functional)
        {
            if ((i_logMsg != nullptr) // null log indicates we don't log
                && (i_extendToSwLog == true))
            {
                // Fill in TCG_PCR_EVENT2 and add to log
                eventLog = TpmLogMgr_genLogEventPcrExtend(pcr, i_eventType,
                                                          i_algId, i_digest,
                                                          i_digestSize,
                                                          TPM_ALG_INVALID_ID,
                                                          nullptr,
                                                          0,
                                                          i_logMsg,
                                                          i_logMsgSize);
                if(useStaticLog)
                {
                    auto * const pTpmLogMgr = getTpmLogMgr(i_pTpm);
                    err = TpmLogMgr_addEvent(pTpmLogMgr,&eventLog);
                    if (nullptr != err)
                    {
                        break;
                    }
                }
            }

            if (l_extendToTpm == true)
            {
                // Perform the requested extension
                err = tpmCmdPcrExtend2Hash(i_pTpm,
                                           pcr,
                                           i_algId,
                                           i_digest,
                                           i_digestSize,
                                           TPM_ALG_INVALID_ID,
                                           nullptr,
                                           0);
            }
            else
            {
                TRACUCOMP(g_trac_trustedboot, "pcrExtendSingleTpm: "
                          "Purposely Skipped Extension for i_pcr=%d", i_pcr);
                TRACUBIN(g_trac_trustedboot, "Skipped Extended Data Log msg",
                         i_logMsg, i_logMsgSize);
            }
        }
    } while ( 0 );

    if (nullptr != err)
    {
        // We failed to extend to this TPM we can no longer use it
        // Mark TPM as not functional, commit err and set it to nullptr
        tpmMarkFailed(i_pTpm, err);
    }

    if (unlock)
    {
        mutex_unlock( i_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>() ) ;
    }
    return;
}

void pcrExtendSeparator(TpmTarget* const i_pTpm,
                        bool const i_extendToTpm,
                        bool const i_extendToSwLog)
{
    assert(i_pTpm != nullptr,"pcrExtendSeparator: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "pcrExtendSeparator: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    TRACUCOMP(g_trac_trustedboot, ENTER_MRK"pcrExtendSeparator(): "
              "i_pTpm=0x%.8X, i_extendToTpm=%d, i_extendToSwLog=%d",
              TARGETING::get_huid(i_pTpm), i_extendToTpm, i_extendToSwLog);

    errlHndl_t err = nullptr;
    TCG_PCR_EVENT2 eventLog = {0};
    bool unlock = false;

    // Separators are always the same values

    // The digest is a sha256 hash of 0xFFFFFFFF
    const uint8_t sha256_digest[] = {
        0xAD, 0x95, 0x13, 0x1B, 0xC0, 0xB7, 0x99, 0xC0,
        0xB1, 0xAF, 0x47, 0x7F, 0xB1, 0x4F, 0xCF, 0x26,
        0xA6, 0xA9, 0xF7, 0x60, 0x79, 0xE4, 0x8B, 0xF0,
        0x90, 0xAC, 0xB7, 0xE8, 0x36, 0x7B, 0xFD, 0x0E};
    // The event message is 0xFFFFFFFF
    const uint8_t logMsg[] = { 0xFF, 0xFF, 0xFF, 0xFF };

    memset(&eventLog, 0, sizeof(eventLog));
    do
    {
        mutex_lock( i_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>() ) ;
        unlock = true;

        std::vector<TPM_Pcr> pcrs =
            {PCR_0,PCR_1,PCR_2,PCR_3,PCR_4,PCR_5,PCR_6,PCR_7};
        bool useStaticLog = true;

        for (const auto &pcr : pcrs)
        {
            auto hwasState = i_pTpm->getAttr<
                TARGETING::ATTR_HWAS_STATE>();

            // Log the separator
            if (hwasState.present &&
                hwasState.functional)
            {
                if (i_extendToSwLog == true)
                {
                    // Fill in TCG_PCR_EVENT2 and add to log
                    eventLog = TpmLogMgr_genLogEventPcrExtend(pcr,
                                                              EV_SEPARATOR,
                                                              TPM_ALG_SHA256,
                                                              sha256_digest,
                                                              sizeof(sha256_digest),
                                                              TPM_ALG_INVALID_ID,
                                                              nullptr,
                                                              0,
                                                              logMsg,
                                                              sizeof(logMsg));

                    if(useStaticLog)
                    {
                        auto * const pTpmLogMgr = getTpmLogMgr(i_pTpm);
                        err = TpmLogMgr_addEvent(pTpmLogMgr,&eventLog);
                        if (nullptr != err)
                        {
                            break;
                        }
                    }
                } // end of i_extendToSwLog check

                if (i_extendToTpm == true)
                {
                    // Perform the requested extension
                    err = tpmCmdPcrExtend2Hash(i_pTpm,
                                               pcr,
                                               TPM_ALG_SHA256,
                                               sha256_digest,
                                               sizeof(sha256_digest),
                                               TPM_ALG_INVALID_ID,
                                               nullptr,
                                               0);

                    if (nullptr != err)
                    {
                        break;
                    }
                } // end of i_extendToTpm check

            } // end of hwasState.present and hwasState.functional check

        } // end of pcr loop
    } while ( 0 );

    if (nullptr != err)
    {
        // We failed to extend to this TPM we can no longer use it
        // Mark TPM as not functional, commit err and set it to nullptr
        tpmMarkFailed(i_pTpm, err);

        // Log this failure
        errlCommit(err, TRBOOT_COMP_ID);
    }

    if (unlock)
    {
        mutex_unlock( i_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>() ) ;
    }

    TRACUCOMP(g_trac_trustedboot, EXIT_MRK"pcrExtendSeparator()");

    return;
}

void forceTpmDeconfigCallout(TpmTarget* const i_pTpm,
                             errlHndl_t& i_err)
{
    const auto search_results = i_err->queryCallouts(i_pTpm);
    using compare_enum = ERRORLOG::ErrlEntry::callout_search_criteria;
    // Check if we found any callouts for this TPM
    if((search_results & compare_enum::TARGET_MATCH) == compare_enum::TARGET_MATCH)
    {
        // If we found a callout for this TPM w/o a DECONFIG,
        // edit the callout to include a deconfig
        if((search_results & compare_enum::DECONFIG_FOUND) != compare_enum::DECONFIG_FOUND)
        {
            i_err->setDeconfigState(i_pTpm, HWAS::DECONFIG);
        }
    }
    else
    {
        // Add HW callout for TPM with low priority
        i_err->addHwCallout(i_pTpm,
                            HWAS::SRCI_PRIORITY_LOW,
                            HWAS::DECONFIG,
                            HWAS::GARD_NULL);
    }
}

void tpmMarkFailed(TpmTarget* const i_pTpm,
                   errlHndl_t& io_err)
{
    assert(i_pTpm != nullptr,"tpmMarkFailed: BUG! i_pTpm was nullptr");
    assert(i_pTpm->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "tpmMarkFailed: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_pTpm->getAttr<TARGETING::ATTR_TYPE>());

    TRACFCOMP( g_trac_trustedboot,
               ENTER_MRK"tpmMarkFailed() Marking TPM as failed : "
               "tgt=0x%08X; io_err rc=0x%04X, plid=0x%08X",
               TARGETING::get_huid(i_pTpm), ERRL_GETRC_SAFE(io_err),
               ERRL_GETPLID_SAFE(io_err));

    #ifdef CONFIG_SECUREBOOT
    TARGETING::Target* l_tpm = i_pTpm;

    errlHndl_t l_err = nullptr;
    TARGETING::Target* l_proc = nullptr;

    do {

    // for the given tpm target, find the processor target
    TARGETING::TargetHandleList l_procList;
    getAllChips(l_procList,TARGETING::TYPE_PROC,false);

    auto l_tpmInfo = l_tpm->getAttr<TARGETING::ATTR_SPI_TPM_INFO>();

    for(auto it : l_procList)
    {
        auto l_physPath = it->getAttr<TARGETING::ATTR_PHYS_PATH>();
        if (l_tpmInfo.spiMasterPath == l_physPath)
        {
            // found processor acting as SPI master for this TPM
            l_proc = it;
            break;
        }
    }
    if (l_proc == nullptr)
    {
        assert(false,"tpmMarkFailed - TPM with non-existent processor indicates"
            " a bad MRW. TPM tgt=0x%08X", TARGETING::get_huid(l_tpm));
    }

    // set ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM for the processor
    uint8_t l_protectTpm = 1;
    l_proc->setAttr<TARGETING::ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM>(
        l_protectTpm);

    // Add TPM-related FFDC to the log
    // Note: the function uses the state of ATTR_SECUREBOOT_PROTECT_DECONFIGURED_TPM
    // to determine the source of TDP bit.
    addTpmFFDC(i_pTpm, io_err);

    // There is no way to fence off a TPM when its SPI master
    // processor is not functional. If the SPI master is not scommable
    // the scom accesses below will fail so we must defer them to when the
    // processor is up.
    TARGETING::PredicateHwas isNonFunctional;
    isNonFunctional.functional(false);
    if (isNonFunctional(l_proc) || !l_proc->getAttr<TARGETING::ATTR_SCOM_SWITCHES>().useXscom)
    {
        // Note: at this point l_err is nullptr so
        // no error log is created on break
        break;
    }

    uint64_t l_regValue = 0;
    l_err = SECUREBOOT::getSecuritySwitch(l_regValue, l_proc);
    if (l_err)
    {
        TRACFCOMP(g_trac_trustedboot,
            ERR_MRK"tpmMarkFailed - call to getSecuritySwitch failed");
        break;
    }
    // if the SBE lock bit is not set, it means that istep 10.3 hasn't executed
    // yet, so we will let istep 10.3 call p10_update_security_control HWP
    // if the SBE lock bit is set, then we will call the HWP here
    if (!(l_regValue & static_cast<uint64_t>(SECUREBOOT::ProcSecurity::SULBit)))
    {
        break;
    }

    const fapi2::Target<fapi2::TARGET_TYPE_PROC_CHIP> l_fapiTarg(l_proc);

    FAPI_INVOKE_HWP(l_err, p10_update_security_ctrl, l_fapiTarg);

    if (l_err)
    {
        TRACFCOMP(g_trac_trustedboot,
            ERR_MRK"tpmMarkFailed - call to p10_update_security_ctrl failed ");
    }

    } while(0);

    // If we got a local error log, link it to input error log and then
    // commit it
    if (l_err)
    {
        // commit this error log first before creating the new one
        auto plid = l_err->plid();

        // If we have an input error log then link these all together
        if (io_err)
        {
           TRACFCOMP(g_trac_trustedboot,
                ERR_MRK "tpmMarkFailed(): Processor tgt=0x%08X TPM tgt=0x%08X. "
                "Deconfiguring proc because future security cannot be "
                "guaranteed. Linking new l_err rc=0x%04X eid=0x%08X to "
                "io_err rc=0x%04X, plid=0x%08X",
                TARGETING::get_huid(l_proc),
                TARGETING::get_huid(l_tpm),
                l_err->reasonCode(), l_err->eid(),
                io_err->reasonCode(), io_err->plid());

            // Use io_err's plid to link all errors together
            plid = io_err->plid();
            l_err->plid(plid);
        }
        else
        {
            TRACFCOMP(g_trac_trustedboot,
                ERR_MRK "tpmMarkFailed(): Processor tgt=0x%08X TPM tgt=0x%08X: "
                "Deconfiguring proc because future security cannot be "
                "guaranteed due to new l_err rc=0x%04X plid=0x%08X",
                TARGETING::get_huid(l_proc),
                TARGETING::get_huid(l_tpm),
                l_err->reasonCode(), l_err->plid());
        }

        ERRORLOG::ErrlUserDetailsTarget(l_proc).addToLog(l_err);
        l_err->collectTrace(SECURE_COMP_NAME);
        l_err->collectTrace(TRBOOT_COMP_NAME);

        // commit this error log first before creating the new one
        errlCommit(l_err, TRBOOT_COMP_ID);

       /*@
        * @errortype
        * @reasoncode       TRUSTEDBOOT::RC_UPDATE_SECURITY_CTRL_HWP_FAIL
        * @moduleid         TRUSTEDBOOT::MOD_TPM_MARK_FAILED
        * @severity         ERRL_SEV_UNRECOVERABLE
        * @userdata1        Processor Target
        * @userdata2        TPM Target
        * @devdesc          Failed to set SEEPROM lock and/or TPM deconfig
        *                   protection for this processor, so we cannot
        *                   guarrantee platform secuirty for this processor
        * @custdesc         Platform security problem detected
        */
        l_err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
            TRUSTEDBOOT::MOD_TPM_MARK_FAILED,
            TRUSTEDBOOT::RC_UPDATE_SECURITY_CTRL_HWP_FAIL,
            TARGETING::get_huid(l_proc),
            TARGETING::get_huid(l_tpm));

        // Pass on the plid to connect all previous error(s)
        l_err->plid(plid);

       TRACFCOMP(g_trac_trustedboot,
            ERR_MRK "tpmMarkFailed(): Processor tgt=0x%08X TPM tgt=0x%08X. "
            "Deconfiguring proc errorlog is rc=0x%04X plid=0x%08X, eid=0x%08X",
            TARGETING::get_huid(l_proc),
            TARGETING::get_huid(l_tpm),
            l_err->reasonCode(), l_err->plid(), l_err->eid());

        l_err->addHwCallout(l_proc,
                            HWAS::SRCI_PRIORITY_LOW,
                            HWAS::DELAYED_DECONFIG,
                            HWAS::GARD_NULL);

        l_err->collectTrace(SECURE_COMP_NAME);
        l_err->collectTrace(TRBOOT_COMP_NAME);

        ERRORLOG::ErrlUserDetailsTarget(l_proc).addToLog(l_err);

        ERRORLOG::errlCommit(l_err, TRBOOT_COMP_ID);
    }
    #endif

    // Commit input error log
    if (io_err)
    {
       TRACFCOMP(g_trac_trustedboot,
            ERR_MRK "Committing io_err rc=0x%04X plid=0x%08X, eid=0x%08X",
            io_err->reasonCode(), io_err->plid(), io_err->eid());
        // ensure there is, at minimum, a low priority hw callout for the TPM
        // that has a deconfigure action associated with it.
        forceTpmDeconfigCallout(i_pTpm,io_err);

        io_err->collectTrace(SECURE_COMP_NAME);
        io_err->collectTrace(TRBOOT_COMP_NAME);

        ERRORLOG::errlCommit(io_err, TRBOOT_COMP_ID);

        // Flush the error logs and process all outstanding deconfigs
        // prior to continuing as we will rely on the HWAS state to be
        // set appropriately according to the gard/deconfig callouts tied
        // to the error log that was just committed.
        ERRORLOG::ErrlManager::callFlushErrorLogs();

        HWAS::theDeconfigGard().processDeferredDeconfig();
    }

}

void tpmVerifyFunctionalPrimaryTpmExists(
    const NoTpmShutdownPolicy i_noTpmShutdownPolicy)
{
    errlHndl_t err = nullptr;
    bool foundFunctional = functionalPrimaryTpmExists();
    const bool isBackgroundShutdown =
        (i_noTpmShutdownPolicy == NoTpmShutdownPolicy::BACKGROUND_SHUTDOWN);

    if (!foundFunctional && !systemData.failedTpmsPosted)
    {
        systemData.failedTpmsPosted = true;
        TRACFCOMP( g_trac_trustedboot,
                   "NO FUNCTIONAL PRIMARY TPM FOUND ON THE NODE");

        // Check to ensure jumper indicates we are running secure
        SECUREBOOT::SecureJumperState l_state
                          = SECUREBOOT::SecureJumperState::SECURITY_DEASSERTED;
        err = SECUREBOOT::getJumperState(l_state);
        if (err)
        {
            auto errEid = err->eid();
            errlCommit(err, TRBOOT_COMP_ID);

            // we should not continue if we could not read the jumper state
            INITSERVICE::doShutdown(errEid,isBackgroundShutdown);
        }
        else if (l_state == SECUREBOOT::SecureJumperState::SECURITY_ASSERTED)
        {
            if (isTpmRequired())
            {
                /*@
                 * @errortype
                 * @reasoncode     RC_TPM_NOFUNCTIONALTPM_FAIL
                 * @severity       ERRL_SEV_UNRECOVERABLE
                 * @moduleid       MOD_TPM_VERIFYFUNCTIONAL
                 * @userdata1      0
                 * @userdata2      0
                 * @devdesc        The system (or node, if multi-node system)
                 *                 is configured in the hardware (via processor
                 *                 secure jumpers) to enable Secure Boot, and
                 *                 the system's/node's "TPM required" policy is
                 *                 configured to require at least one
                 *                 functional boot processor TPM in order to
                 *                 boot with Trusted Boot enabled. Therefore,
                 *                 the system (or node, if multi-node system)
                 *                 will terminate due to lack of functional
                 *                 boot processor TPM.
                 * @custdesc       The system is configured for Secure Boot and
                 *                 trusted platform module required mode; a
                 *                 functional boot processor trusted platform
                 *                 module is required to boot the system (or
                 *                 node, if multi-node system), but none are
                 *                 available. Therefore, the system (or node,
                 *                 if multi-node system) will terminate.
                 *                 Trusted platform module required mode may be
                 *                 disabled via the appropriate systems
                 *                 management interface to allow platform boot
                 *                 without the remote trusted attestation
                 *                 capability. Look for other errors which call
                 *                 out the trusted platform module and follow
                 *                 the repair actions for these errors.
                 */
                err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                              MOD_TPM_VERIFYFUNCTIONAL,
                                              RC_TPM_NOFUNCTIONALTPM_FAIL);

                TRACFCOMP(g_trac_trustedboot, ERR_MRK
                          "tpmVerifyFunctionalPrimaryTpmExists: Shutting down "
                          "system because no Functional Primary TPM was found "
                          "but system policy required it. errl EID 0x%08X",
                          err->eid());

                // Add low priority HB SW callout
                err->addProcedureCallout(HWAS::EPUB_PRC_HB_CODE,
                                         HWAS::SRCI_PRIORITY_LOW);
                err->collectTrace(TRBOOT_COMP_NAME);
                err->collectTrace(TPMDD_COMP_NAME );
                err->collectTrace(SPI_COMP_NAME );
                err->collectTrace(SECURE_COMP_NAME );
                const auto reasonCode = err->reasonCode();
                const auto l_eid = err->eid();

                // Add Security Registers to the error log
                SECUREBOOT::addSecurityRegistersToErrlog(err);

                // HW callout TPM
                TARGETING::Target* l_primaryTpm = nullptr;
                getPrimaryTpm(l_primaryTpm);
                if(l_primaryTpm)
                {
                    err->addHwCallout(l_primaryTpm,
                                      HWAS::SRCI_PRIORITY_HIGH,
                                      HWAS::NO_DECONFIG,
                                      HWAS::GARD_NULL);
                }
                errlCommit(err, TRBOOT_COMP_ID);

                // if a TPM is guarded out for FSP systems, the recovery action is
                // to force a failover and flip sides to utilize TPM redundancy.
                // eBMC systems will attempt to recover the TPM via Resourse Recovery
                if (!INITSERVICE::spBaseServicesEnabled())
                {
                    // Get all node targets
                    TARGETING::TargetHandleList l_nodelist;
                    getEncResources(l_nodelist, TARGETING::TYPE_NODE,
                                    TARGETING::UTIL_FILTER_FUNCTIONAL);
                    for( auto l_node : l_nodelist )
                    {
                        //For eBMC, in the case where the TPM is garded out by a recoverable gard,
                        //set block speculative deconfig to resource recover the TPM on next ipl
                        l_node->setAttr<TARGETING::ATTR_BLOCK_SPEC_DECONFIG>(1);
                    }
                }

                // Sync the attributes to FSP or BMC if applicable.
                // This will allow for FSP to attempt to perform
                // TPM alignment check.
                err = TARGETING::AttrRP::syncAllAttributesToSP();
                if(err)
                {
                    TRACFCOMP(g_trac_trustedboot, ERR_MRK
                              "tpmVerifyFunctionalPrimaryTpmExists: Could "
                              "not sync attributes to FSP/BMC; errl EID 0x%08X",
                              err->eid());
                    errlCommit(err, TRBOOT_COMP_ID);
                }

                // terminating the IPL with this fail
                // Terminate IPL immediately
                // For eBMC, we want to TI with EID so proper PELs can be created
                if (!INITSERVICE::spBaseServicesEnabled())
                {
                    TRACFCOMP(g_trac_trustedboot, "eBMC tpmVerifyFunctionalPrimaryTpmExists doShutdown");
                    INITSERVICE::doShutdown(l_eid,isBackgroundShutdown);
                }
                else
                {
                    INITSERVICE::doShutdown(reasonCode,isBackgroundShutdown);
                }
            }
            else
            {
                TRACUCOMP(g_trac_trustedboot,
                          "tpmVerifyFunctionalPrimaryTpmExists: No functional "
                          "primary TPM found but TPM not Required");
            }
        }
        else
        {
            TRACUCOMP(g_trac_trustedboot,"tpmVerifyFunctionalPrimaryTpmExists: "
                      "No functional primary TPM found but not running secure");
        }

    }

    return;
}

void doInitBackupTpm()
{
    TARGETING::Target* l_backupTpm = nullptr;
    errlHndl_t l_errl = nullptr;
    TRUSTEDBOOT::getBackupTpm(l_backupTpm);

    do {
    if(l_backupTpm)
    {
        auto l_backupHwasState = l_backupTpm->getAttr<
                                                  TARGETING::ATTR_HWAS_STATE>();
        if(!l_backupHwasState.functional)
        {
            // Its possible this TPM was marked non-functional due to a gard
            // record or a deconfig-by-association. In this case we will not
            // attempt further action.
            TRACFCOMP(g_trac_trustedboot, "doInitBackupTpm: Backup TPM was found to be non-functional, exiting init early!");
            break;
        }

        // Make sure the SPI master is functional before continuing.
        TPMDD::tpm_info_t tpmData;
        l_errl = TPMDD::tpmReadAttributes(l_backupTpm,
                                          tpmData,
                                          TPMDD::TPM_LOCALITY_0);
        if(l_errl)
        {
            TRACFCOMP(g_trac_trustedboot, "doInitBackupTpm: tpmReadAttributes returned an error, marking TPM as failed and giving up on init");
            tpmMarkFailed(l_backupTpm, l_errl);
            break;
        }

        if(!tpmData.spiTarget->getAttr<TARGETING::ATTR_HWAS_STATE>().functional)
        {
            // If we find that the SPI master is not functional, mark
            // this TPM as non-functional and stop attempting to initialize it.
            // We will hit this path if the 2nd processor is not present.
            TRACFCOMP(g_trac_trustedboot,
                      "doInitBackupTpm: Backup TPM's SPI master was found to be non-functional."
                      " Setting backup TPM to be non-functional and exiting init early!");
            l_backupHwasState.functional = 0;
            l_backupTpm->setAttr<TARGETING::ATTR_HWAS_STATE>(l_backupHwasState);
            break;
        }

        TARGETING::Target* pSysTarget = TARGETING::UTIL::assertGetToplevelTarget();
        if(pSysTarget->getAttr<TARGETING::ATTR_IS_MPIPL_HB>())
        {
            // If this TPM was found to be not present on the previous IPL
            // then do not attempt any further action.
            if(!l_backupHwasState.present)
            {
                TRACFCOMP(g_trac_trustedboot, "doInitBackupTpm: Backup TPM was found not to be present on MPIPL, exiting init early!");
                break;
            }
        }
        else
        {
            // Presence-detect the secondary TPM
            TARGETING::TargetHandleList l_targetList;
            l_targetList.push_back(l_backupTpm);
            l_errl = HWAS::platPresenceDetect(l_targetList);
            if(l_errl)
            {
                errlCommit(l_errl, SECURE_COMP_ID);
                break;
            }

            // The TPM target would have been deleted from the list if it's
            // not present.
            if(l_targetList.size())
            {
                l_backupHwasState.present = true;
                l_backupTpm->setAttr<TARGETING::ATTR_HWAS_STATE>(
                    l_backupHwasState);
            }
            else
            {
                l_backupHwasState.present = false;
                l_backupHwasState.functional = false;
                l_backupTpm->setAttr<TARGETING::ATTR_HWAS_STATE>(
                    l_backupHwasState);
            }

            // Crosscheck with the state that the SP had
            l_errl = HWAS::crosscheck_sp_presence_target(l_backupTpm);
            if(l_errl)
            {
                // Mark tpm as failed; among other things this commits the error log
                tpmMarkFailed(l_backupTpm, l_errl);
                break;
            }
        }

        // If present, try to initialize
        if (l_backupHwasState.present == true)
        {
            mutex_lock(l_backupTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>());
            tpmInitialize(l_backupTpm);
            TpmLogMgr* l_tpmLogMgr = getTpmLogMgr(l_backupTpm);
            if(!l_tpmLogMgr)
            {
                l_tpmLogMgr = new TpmLogMgr;
                setTpmLogMgr(l_backupTpm, l_tpmLogMgr);
                TpmLogMgr_initialize(l_tpmLogMgr);
            }
            mutex_unlock(l_backupTpm->
                                getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>());
        }
    }
    else
    {
        TRACFCOMP(g_trac_trustedboot, "tpmDaemon: Backup TPM init message was"
                  " received but the backup TPM cannot be found.");
    }

    } while(0);

    // Always mark that the init was attempted even if it didn't succeed
    if(l_backupTpm)
    {
        l_backupTpm->setAttr<TARGETING::ATTR_HB_TPM_INIT_ATTEMPTED>(true);
    }
}

errlHndl_t doCreateAttKeys(TpmTarget* i_tpm)
{
    errlHndl_t l_errl = nullptr;

    do {
    l_errl = validateTpmHandle(i_tpm);
    if(l_errl)
    {
        break;
    }

    l_errl = tpmCmdCreateAttestationKeys(i_tpm);
    if(l_errl)
    {
        break;
    }

    } while(0);

    return l_errl;
}

errlHndl_t doReadAKCert(TpmTarget* i_tpm, TPM2B_MAX_NV_BUFFER* o_data)
{
    errlHndl_t l_errl = nullptr;

    do {
    l_errl = validateTpmHandle(i_tpm);
    if(l_errl)
    {
        break;
    }

    l_errl = tpmCmdReadAKCertificate(i_tpm, o_data);
    if(l_errl)
    {
        break;
    }
    } while(0);

    return l_errl;
}

errlHndl_t doGenQuote(TpmTarget* i_tpm,
                      const TpmNonce_t* const i_nonce,
                      QuoteDataOut* o_data)
{
    errlHndl_t l_errl = nullptr;

    do {
    l_errl = validateTpmHandle(i_tpm);
    if(l_errl)
    {
        break;
    }

    l_errl = tpmCmdGenerateQuote(i_tpm, i_nonce, o_data);
    if(l_errl)
    {
        break;
    }
    } while(0);

    return l_errl;
}

errlHndl_t doFlushContext(TpmTarget* i_tpm)
{
    errlHndl_t l_errl = nullptr;

    do {
    l_errl = validateTpmHandle(i_tpm);
    if(l_errl)
    {
        break;
    }

    l_errl = tpmCmdFlushContext(i_tpm);
    if(l_errl)
    {
        break;
    }
    } while(0);

    return l_errl;
}

errlHndl_t doPcrRead(TpmTarget* i_target,
                     const TPM_Pcr i_pcr,
                     const TPM_Alg_Id i_algId,
                     const size_t i_digestSize,
                     uint8_t* const o_digest)
{
    errlHndl_t l_errl = nullptr;

    do {
    l_errl = validateTpmHandle(i_target);
    if(l_errl)
    {
        break;
    }

    l_errl = tpmCmdPcrRead(i_target,
                           i_pcr,
                           i_algId,
                           o_digest,
                           i_digestSize);
    if(l_errl)
    {
        break;
    }

    } while(0);
    return l_errl;
}

errlHndl_t doExpandTpmLog(TpmTarget* i_target)
{
    errlHndl_t l_errl = nullptr;

    do {
    l_errl = validateTpmHandle(i_target);
    if(l_errl)
    {
        break;
    }

    l_errl = tpmCmdExpandTpmLog(i_target);
    if(l_errl)
    {
        break;
    }
    } while(0);
    return l_errl;
}

void* tpmDaemon(void* unused)
{
    bool shutdownPending = false;
    errlHndl_t err = nullptr;

    // Mark as an independent daemon so if it crashes we terminate
    task_detach();

    TRACUCOMP( g_trac_trustedboot, ENTER_MRK "TpmDaemon Thread Start");

    // Register shutdown events with init service.
    //      Done at the "end" of shutdown processing.
    // This will flush any other messages (PCR extends) and terminate task
    INITSERVICE::registerShutdownEvent(TRBOOT_COMP_ID,
                                       systemData.msgQ,
                                       TRUSTEDBOOT::MSG_TYPE_SHUTDOWN);

    Message* tb_msg = nullptr;
    while (true)
    {
        msg_t* msg = msg_wait(systemData.msgQ);

        const MessageType type =
            static_cast<MessageType>(msg->type);
        tb_msg = nullptr;

        TRACUCOMP( g_trac_trustedboot, "TpmDaemon Handle CmdType %d",
                   type);

        switch (type)
        {
          case TRUSTEDBOOT::MSG_TYPE_SHUTDOWN:
              {
                  shutdownPending = true;

                  // Un-register message queue from the shutdown
                  INITSERVICE::unregisterShutdownEvent(systemData.msgQ);

              }
              break;
          case TRUSTEDBOOT::MSG_TYPE_PCREXTEND:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);

                  TRUSTEDBOOT::PcrExtendMsgData* msgData =
                      reinterpret_cast<TRUSTEDBOOT::PcrExtendMsgData*>
                      (tb_msg->iv_data);

                  assert(tb_msg->iv_len == sizeof(TRUSTEDBOOT::PcrExtendMsgData)
                         && msgData != nullptr, "Invalid PCRExtend Message");

                  TpmTarget* l_tpm = nullptr;
                  // if null TPM was passed extend the primary TPM.  Otherwise, extend
                  // only the TPM that was passed
                  if (msgData->mSingleTpm == nullptr)
                  {
                      getPrimaryTpm(l_tpm);
                  }
                  else
                  {
                      l_tpm = const_cast<TpmTarget*>(msgData->mSingleTpm);
                  }

                  // Add the event to this TPM,
                  // if an error occurs the TPM will
                  //  be marked as failed and the error log committed
                  TRUSTEDBOOT::pcrExtendSingleTpm(
                                l_tpm,
                                msgData->mPcrIndex,
                                msgData->mEventType,
                                msgData->mAlgId,
                                msgData->mDigest,
                                msgData->mDigestSize,
                                msgData->mExtendToSwLog? msgData->mLogMsg:
                                                                  nullptr,
                                msgData->mExtendToSwLog? msgData->mLogMsgSize:
                                                                  0,
                                msgData->mExtendToTpm,
                                msgData->mExtendToSwLog);

                    auto pSys = TARGETING::UTIL::assertGetToplevelTarget();
                    // Need to stop the cycle; i.e. a mirrored extend
                    // cannot lead to other nodes themselves mirroring
                    // to other nodes
                    if(pSys->getAttr<TARGETING::ATTR_EXTEND_TPM_MEAS_TO_OTHER_NODES>()
                       && !msgData->mInhibitNodeMirroring)
                    {
                        TARGETING::Target* pPrimaryTpm = nullptr;
                        getPrimaryTpm(pPrimaryTpm);

                        // If directed towards primary TPM, and it's an extend
                        // to both HW + SW log (i.e. not a poison op), then
                        // mirror to other nodes.  Don't have to worry about
                        // screening out separator extends here because that
                        // runs through a separate API
                        if(   (l_tpm == pPrimaryTpm)
                           && (msgData->mExtendToTpm)
                           && (msgData->mExtendToSwLog))
                        {
                            err =  extendMeasurementToOtherNodes(msgData->mPcrIndex,
                                msgData->mEventType,msgData->mDigest,msgData->mDigestSize,
                                msgData->mLogMsg,msgData->mLogMsgSize);
                            if(err)
                            {
                                // Any failure in the API above is a severe
                                // FW or infrastructure fail orthogonal to any
                                // TPM fails on the other node.  Since this
                                // path can be disconnected from the IPL, force
                                // a firmware termination.
                                TRACFCOMP(g_trac_trustedboot, ERR_MRK
                                    "Call to extendMeasurementToOtherNodes "
                                    "failed, invoking shutdown. " TRACE_ERR_FMT,
                                    TRACE_ERR_ARGS(err));
                                err->collectTrace(TRBOOT_COMP_NAME);
                                err->collectTrace(SECURE_COMP_NAME);
                                const auto eid = err->eid();
                                errlCommit(err, TRBOOT_COMP_ID);
                                const bool inBackground = true;
                                INITSERVICE::doShutdown(eid,inBackground);
                            }
                        }
                    }

                  // Lastly make sure we are in a state
                  //  where we have a functional TPM
                  TRUSTEDBOOT::tpmVerifyFunctionalPrimaryTpmExists(
                      NoTpmShutdownPolicy::BACKGROUND_SHUTDOWN);
              }
              break;
          case TRUSTEDBOOT::MSG_TYPE_SEPARATOR:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);

                  TRUSTEDBOOT::SeparatorMsgData* msgData =
                      reinterpret_cast<TRUSTEDBOOT::SeparatorMsgData*>
                      (tb_msg->iv_data);

                  TARGETING::TargetHandleList tpmList;
                  getTPMs(tpmList);
                  for (auto tpm : tpmList)
                  {
                      // Add the separator to this TPM,
                      // if an error occurs the TPM will
                      //  be marked as failed and the error log committed
                      TRUSTEDBOOT::pcrExtendSeparator(tpm,
                                                      msgData->mExtendToTpm,
                                                      msgData->mExtendToSwLog);
                  }

                  // Lastly make sure we are in a state
                  //  where we have a functional TPM
                  TRUSTEDBOOT::tpmVerifyFunctionalPrimaryTpmExists(
                      NoTpmShutdownPolicy::BACKGROUND_SHUTDOWN);
              }
              break;
          case TRUSTEDBOOT::MSG_TYPE_INIT_BACKUP_TPM:
              {
                  doInitBackupTpm();
              }
              break;
          case TRUSTEDBOOT::MSG_TYPE_GETRANDOM:
              {
                  errlHndl_t err = nullptr;
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  assert(tb_msg != nullptr,
                      "Trusted boot message pointer absent in the extra data");
                  tb_msg->iv_errl = nullptr;

                  auto msgData =
                      reinterpret_cast<struct GetRandomMsgData*>
                      (tb_msg->iv_data);
                  assert(msgData != nullptr,
                      "Trusted boot message data pointer is null");
                  auto l_pTpm = msgData->i_pTpm;
                  size_t l_randNumSize = msgData->i_randNumSize;

                  if(l_randNumSize > sizeof(TPM2B_DIGEST))
                  {
                      TRACFCOMP( g_trac_trustedboot,
                        ERR_MRK"TPM GetRandom: The size of the requested random number (%d) is larger than max size the TPM can return (%d).", l_randNumSize, sizeof(TPM2B_DIGEST));
                      /*@
                       * @errortype  ERRL_SEV_UNRECOVERABLE
                       * @moduleid   MOD_TPM_TPMDAEMON
                       * @reasoncode RC_RAND_NUM_TOO_BIG
                       * @userdata1  The size of requested random number
                       * @userdata2  The maximum random number size
                       * @devdesc    Attempted to request a random number that
                       *             is bigger than the max a TPM can provide
                       * @custdesc   Trusted boot failure
                       */
                      err = new ERRORLOG::ErrlEntry(
                                           ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                           MOD_TPM_TPMDAEMON,
                                           RC_RAND_NUM_TOO_BIG,
                                           l_randNumSize,
                                           sizeof(TPM2B_DIGEST),
                                           ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);

                      tb_msg->iv_errl = err;
                      err = nullptr;
                      break;
                  }

                  mutex_lock(l_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>());
                  err = validateTpmHandle(l_pTpm);
                  if (err)
                  {
                      mutex_unlock(l_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>());
                      tb_msg->iv_errl = err;
                      err = nullptr;
                      break;
                  }

                  uint8_t dataBuf[sizeof(TPM2_GetRandomOut)] = {0};
                  size_t dataSize = sizeof(dataBuf);
                  auto cmd = reinterpret_cast<TPM2_GetRandomIn*>(dataBuf);
                  auto resp = reinterpret_cast<TPM2_GetRandomOut*>(dataBuf);

                  cmd->base.tag = TPM_ST_NO_SESSIONS;
                  cmd->base.commandCode = TPM_CC_GetRandom;
                  cmd->bytesRequested = l_randNumSize;

                  err = tpmTransmitCommand(l_pTpm, dataBuf, dataSize,
                                           TPM_LOCALITY_0);
                  if (err != nullptr)
                  {
                      TRACFCOMP( g_trac_trustedboot,
                          ERR_MRK"TPM GetRandom Transmit Fail! huid = 0x%08X",
                          TARGETING::get_huid(l_pTpm));
                      auto l_errPlid = err->plid();
                      tpmMarkFailed(l_pTpm, err);
                      /*@
                       * @errortype       ERRL_SEV_UNRECOVERABLE
                       * @moduleid        MOD_TPM_TPMDAEMON
                       * @reasoncode      RC_UNREACHABLE_TPM
                       * @userdata1       TPM HUID or nullptr
                       * @devdesc         Unable to reach the TPM
                       * @custdesc        Trusted boot failure
                       */
                      err = new ERRORLOG::ErrlEntry(
                                          ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                          MOD_TPM_TPMDAEMON,
                                          RC_UNREACHABLE_TPM,
                                          TARGETING::get_huid(l_pTpm),
                                          0,
                                          ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
                      err->plid(l_errPlid);
                      tb_msg->iv_errl = err;
                      err = nullptr;
                  }
                  else
                  {
                      memcpy(msgData->o_randNum,
                             resp->randomBytes.buffer,
                             l_randNumSize);
                  }
                  mutex_unlock(l_pTpm->getHbMutexAttr<TARGETING::ATTR_HB_TPM_MUTEX>());
              }
              break;
          case TRUSTEDBOOT::MSG_TYPE_FLUSH:
              {
                  TRACFCOMP(g_trac_trustedboot, "Flushing TPM message queue");
              }
              break;

          case TRUSTEDBOOT::MSG_TYPE_CREATE_ATT_KEYS:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  TpmTargetData* l_data =
                           reinterpret_cast<TpmTargetData*>(tb_msg->iv_data);
                  tb_msg->iv_errl = doCreateAttKeys(l_data->tpm);
              }
              break;

          case TRUSTEDBOOT::MSG_TYPE_READ_AK_CERT:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  ReadAKCertData* l_data =
                             reinterpret_cast<ReadAKCertData*>(tb_msg->iv_data);
                  tb_msg->iv_errl = doReadAKCert(l_data->tpm, l_data->data);
              }
              break;

          case TRUSTEDBOOT::MSG_TYPE_GEN_QUOTE:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  GenQuoteData* l_data =
                               reinterpret_cast<GenQuoteData*>(tb_msg->iv_data);
                  tb_msg->iv_errl = doGenQuote(l_data->tpm,
                                               l_data->Nonce,
                                               l_data->data);
              }
              break;

          case TRUSTEDBOOT::MSG_TYPE_FLUSH_CONTEXT:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  TpmTargetData* l_data =
                              reinterpret_cast<TpmTargetData*>(tb_msg->iv_data);
                  tb_msg->iv_errl = doFlushContext(l_data->tpm);
              }
              break;

          case TRUSTEDBOOT::MSG_TYPE_PCR_READ:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  PcrReadData* l_data =
                                reinterpret_cast<PcrReadData*>(tb_msg->iv_data);
                  tb_msg->iv_errl = doPcrRead(l_data->tpm,
                                              l_data->pcr,
                                              l_data->alg,
                                              l_data->digestSize,
                                              l_data->digest);
              }
              break;
          case TRUSTEDBOOT::MSG_TYPE_EXPAND_TPM_LOG:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  TpmTargetData* l_data =
                              reinterpret_cast<TpmTargetData*>(tb_msg->iv_data);
                  tb_msg->iv_errl = doExpandTpmLog(l_data->tpm);
              }
              break;

          case MSG_TYPE_SYNCHRONIZE_TPM_LOG:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  synchronizePrimaryTpmLogs();
              }
              break;

          case MSG_TYPE_LOG_SBE_MEASUREMENT_REGS:
              {
                  tb_msg = static_cast<TRUSTEDBOOT::Message*>(msg->extra_data);
                  LogSbeMeasurementRegs* l_data =
                               reinterpret_cast<LogSbeMeasurementRegs*>(tb_msg->iv_data);
                  tb_msg->iv_errl = logMeasurementRegs(l_data->tpm,
                                                       l_data->proc,
                                                       l_data->regs,
                                                       l_data->extendToTpm);
              }
              break;


          default:
            assert(false, "Invalid msg command");
            break;
        };

        // Reply back, if we have a tb_msg do that way
        if (nullptr != tb_msg)
        {
            tb_msg->response(systemData.msgQ);
        }
        else
        {
            // use the HB message type to respond
            int rc = msg_respond(systemData.msgQ, msg);
            if (rc)
            {
                TRACFCOMP( g_trac_trustedboot,
                           ERR_MRK "TpmDaemon: response msg_respond failure %d",
                           rc);
                /*@
                 * @errortype       ERRL_SEV_UNRECOVERABLE
                 * @moduleid        MOD_TPM_TPMDAEMON
                 * @reasoncode      RC_MSGRESPOND_FAIL
                 * @userdata1       rc from msq_respond()
                 * @devdesc         msg_respond() failed
                 * @custdesc        Firmware error during system boot
                 */
                err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                              MOD_TPM_TPMDAEMON,
                                              RC_MSGRESPOND_FAIL,
                                              rc,
                                              0,
                                              true);
                err->collectTrace(SECURE_COMP_NAME);
                err->collectTrace(TRBOOT_COMP_NAME);

                // Log this failure here since we can't reply to caller
                errlCommit(err, TRBOOT_COMP_ID);

            }
        }

        if (shutdownPending)
        {
            // Exit loop and terminate task
            break;
        }
    }

    TRACUCOMP( g_trac_trustedboot, EXIT_MRK "TpmDaemon Thread Terminate");
    return nullptr;
}

errlHndl_t validateTpmHandle(const TpmTarget* i_pTpm)
{
    errlHndl_t err = nullptr;

    do {

    if (i_pTpm == nullptr ||
        i_pTpm->getAttr<TARGETING::ATTR_TYPE>() != TARGETING::TYPE_TPM)
    {
        TRACFCOMP(g_trac_trustedboot,
            ERR_MRK"Invalid TPM handle passed to validateTpmHandle: huid = 0x%08X",
            TARGETING::get_huid(i_pTpm));
        /*@
         * @errortype       ERRL_SEV_UNRECOVERABLE
         * @moduleid        MOD_VALIDATE_TPM_HANDLE
         * @reasoncode      RC_INVALID_TPM_HANDLE
         * @userdata1       TPM HUID if it's not nullptr
         * @devdesc         Caller attempted to get a random number from a TPM
         *                  using an invalid TPM target.
         * @custdesc        Trusted boot failure
         */
        err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                          MOD_VALIDATE_TPM_HANDLE,
                                          RC_INVALID_TPM_HANDLE,
                                          TARGETING::get_huid(i_pTpm),
                                          0,
                                          true);

        break;
    }

    auto l_tpmHwasState = i_pTpm->getAttr<TARGETING::ATTR_HWAS_STATE>();
    if (!l_tpmHwasState.functional)
    {
        TRACFCOMP(g_trac_trustedboot,
            ERR_MRK"Non functional TPM handle passed to validateTpmHandle: huid = 0x%08X",
            TARGETING::get_huid(i_pTpm));
       /*@
         * @errortype       ERRL_SEV_UNRECOVERABLE
         * @moduleid        MOD_VALIDATE_TPM_HANDLE
         * @reasoncode      RC_NON_FUNCTIONAL_TPM_HANDLE
         * @userdata1       TPM HUID if it's not nullptr
         * @devdesc         Call attempted to get a random number from a TPM
         *                  that was not functional
         * @custdesc        Trusted boot failure
         */
        err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                          MOD_VALIDATE_TPM_HANDLE,
                                          RC_NON_FUNCTIONAL_TPM_HANDLE,
                                          TARGETING::get_huid(i_pTpm),
                                          0,
                                          true);
        break;
    }

    } while(0);
    return err;
}

bool isTpmRequired()
{
    bool retVal = false;
    do
    {
        TARGETING::Target* pTopLevel =
          TARGETING::UTIL::assertGetToplevelTarget();
        retVal = pTopLevel->getAttr<TARGETING::ATTR_TPM_REQUIRED>();

        TRACUCOMP( g_trac_trustedboot, "isTpmRequired: Using ATTR_TPM_REQUIRED:"
                   " retVal=%d",
                   retVal );

    } while(0);

    TRACFCOMP( g_trac_trustedboot,
               "Tpm Required: %s",(retVal ? "Yes" : "No") );

    return retVal;
}

#ifdef CONFIG_TPMDD
errlHndl_t GetRandom(const TpmTarget* i_pTpm,
                     const size_t i_randNumSize,
                     uint8_t* o_randNum)
{
    errlHndl_t err = nullptr;
    Message* msg = nullptr;

    auto pData = new struct GetRandomMsgData;

    do {

    memset(pData, 0, sizeof(*pData));
    pData->i_pTpm = const_cast<TpmTarget*>(i_pTpm);
    pData->i_randNumSize = i_randNumSize;
    pData->o_randNum = new uint8_t[i_randNumSize];
    memset(pData->o_randNum, 0, i_randNumSize);

    msg = Message::factory(MSG_TYPE_GETRANDOM, sizeof(*pData),
                           reinterpret_cast<uint8_t*>(pData), MSG_MODE_SYNC);

    assert(msg != nullptr, "BUG! Message is null");
    pData = nullptr; // Message owns msgData now

    int rc = msg_sendrecv(systemData.msgQ, msg->iv_msg);
    if (0 == rc)
    {
        err = msg->iv_errl;
        msg->iv_errl = nullptr; // taking over ownership of error log
        if (err != nullptr)
        {
            break;
        }
    }
    else // sendrecv failure
    {
        /*@
         * @errortype       ERRL_SEV_UNRECOVERABLE
         * @moduleid        MOD_TPM_GETRANDOM
         * @reasoncode      RC_SENDRECV_FAIL
         * @userdata1       rc from msq_sendrecv()
         * @userdata2       TPM HUID if it's not nullptr
         * @devdesc         msg_sendrecv() failed
         * @custdesc        Trusted boot failure
         */
        err = new ERRORLOG::ErrlEntry(ERRORLOG::ERRL_SEV_UNRECOVERABLE,
                                      MOD_TPM_GETRANDOM,
                                      RC_SENDRECV_FAIL,
                                      rc,
                                      TARGETING::get_huid(i_pTpm),
                                      ERRORLOG::ErrlEntry::ADD_SW_CALLOUT);
        break;
    }

    pData = reinterpret_cast<struct GetRandomMsgData*>(msg->iv_data);
    assert(pData != nullptr,
        "BUG! Completed send/recv to random num generator has null data ptr!");

    memcpy(o_randNum, pData->o_randNum, pData->i_randNumSize);

    } while (0);

    // If an error occurs before the reponse is written, then pData
    // will be nullptr and dereferencing o_randNum will cause crashes.
    // So, we need to check for pData before attempting to delete the
    // o_randNum.
    if(pData)
    {
        if(pData->o_randNum)
        {
            delete[](pData->o_randNum);
            pData->o_randNum = nullptr;
        }
    }

    if (msg != nullptr)
    {
        delete msg; // also deletes the msg->iv_data
        msg = nullptr;
    }

    if (err)
    {
        err->collectTrace(SECURE_COMP_NAME);
        err->collectTrace(TRBOOT_COMP_NAME);
    }

    return err;
}
#endif // CONFIG_TPMDD

errlHndl_t poisonTpm(TpmTarget* i_pTpm)
{
    uint64_t l_randNum = 0;
    errlHndl_t l_errl = nullptr;

#ifdef CONFIG_TPMDD

    do {

    l_errl = validateTpmHandle(i_pTpm);
    if(l_errl)
    {
        break;
    }

    i_pTpm->setAttr<TARGETING::ATTR_TPM_POISONED>(true);

    // Note: GetRandom validates the TPM handle internally and returns an
    // error log if invalid
    l_errl = GetRandom(i_pTpm,
                       sizeof(l_randNum),
                       reinterpret_cast<uint8_t*>(&l_randNum));

    if (l_errl)
    {
        break;
    }

    const TPM_Pcr l_pcrRegs[] = {PCR_0, PCR_1, PCR_2, PCR_3,
                                 PCR_4, PCR_5, PCR_6, PCR_7};

    // poison all PCR banks
    for (const auto l_pcrReg : l_pcrRegs)
    {
        l_errl = pcrExtend(l_pcrReg,
                           TRUSTEDBOOT::EV_INVALID,
                           reinterpret_cast<sha2_byte*>(&l_randNum),
                           sizeof(l_randNum),
                           nullptr, // log not needed for poison operation
                           0,       // log size is 0
                           false,   // call synchronously to daemon
                           i_pTpm,  // only extend to pcr banks for this TPM
                           true,    // do extend to the TPM's PCR
                           false);  // don't add PCR measurement to the log
        if (l_errl)
        {
            break;
        }

    }

    // make sure the poisoning and any other queued data gets out to the TPM
    l_errl = TRUSTEDBOOT::flushTpmQueue();
    if (l_errl)
    {
        TRACFCOMP(g_trac_trustedboot, ERR_MRK"Unable to flushTpmQueue after poisoning TPM 0x%X",
            TARGETING::get_huid(i_pTpm));
    }

    } while (0);

    TRACFCOMP(g_trac_trustedboot, "%ssuccessfully poisoned TPM with huid 0x%X",
              l_errl? "Un":"", TARGETING::get_huid(i_pTpm));

#endif
    return l_errl;
}

errlHndl_t poisonBackupTpm(void)
{
    errlHndl_t l_errl = nullptr;
#ifdef CONFIG_TPMDD
    TARGETING::Target* l_backupTpm = nullptr;
    TRUSTEDBOOT::getBackupTpm(l_backupTpm);
    do {
    if(l_backupTpm && l_backupTpm->getAttr<TARGETING::ATTR_HWAS_STATE>().functional)
    {
        l_errl = poisonTpm(l_backupTpm);
    }
    else
    {
        // Do nothing if no functional backup TPM if found
        TRACFCOMP(g_trac_trustedboot, "poisonBackupTpm: No functional backup TPM found.");
    }
    }while(0);
#endif

    return l_errl;
}

errlHndl_t poisonAllTpms()
{
    errlHndl_t l_errl = nullptr;
#ifdef CONFIG_TPMDD
    do {

    TARGETING::TargetHandleList l_tpms;
    getTPMs(l_tpms, TRUSTEDBOOT::TPM_FILTER::ALL_FUNCTIONAL);
    for(auto l_tpm : l_tpms)
    {
        l_errl = poisonTpm(l_tpm);
        if(l_errl)
        {
            break;
        }
    }

    } while(0);
#endif
    return l_errl;
}

#define LOG_REGS_MSG_MAX_CHARACTERS 40

/**
 * @brief Appends the chip position number onto a string used for TPM SW Log messages
 *
 * @param[in/out] io_log_msg_str - pointer to a pre-allocated array of characters with
 *                  the size of LOG_REGS_MSG_MAX_CHARACTERS
 * @param[in]     i_original_str - pointer to original string
 * @param[in]     i_pos_str - pointer to position string to append onto original string
 *
 * @pre   io_log_msg_str must point to an array of characters that is large enough
 *        to hold i_original_str appended with i_pos_str
 */
void appendPosToStr(char* io_log_msg_str,
                    const char* i_original_str,
                    const char* i_pos_str)
{
    TRACDCOMP(g_trac_trustedboot, ENTER_MRK "appendPosToStr(): "
              "io_log_msg_str=%s (size=%d) (i_original_str=%s, i_pos_str=%s)",
              io_log_msg_str, sizeof(io_log_msg_str), i_original_str, i_pos_str);

    // Clear io_log_msg_str
    memset(io_log_msg_str, 0, LOG_REGS_MSG_MAX_CHARACTERS);

    // Start the string with i_original_str
    strcat(io_log_msg_str, i_original_str);

    // Append the position string
    strcat(io_log_msg_str, i_pos_str);

    TRACDCOMP(g_trac_trustedboot, EXIT_MRK "appendPosToStr(): "
              "io_log_msg_str=%s (i_original_str=%s, i_pos_str=%s)",
              io_log_msg_str, i_original_str, i_pos_str);
}

errlHndl_t logMeasurementRegs(TpmTarget* i_tpm_target,
                              TARGETING::Target*    i_proc_target,
                              TPM_sbe_measurements_regs_grouped i_regs,
                              bool i_extendToTpm)
{
    errlHndl_t err = nullptr;
#ifdef CONFIG_TPMDD

    assert(i_tpm_target != nullptr,"logMeasurementRegs: BUG! i_tpm_target was nullptr");
    assert(i_tpm_target->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_TPM,
           "logMeasurementRegs: BUG! Expected target to be of TPM type, but "
           "it was of type 0x%08X",i_tpm_target->getAttr<TARGETING::ATTR_TYPE>());

    assert(i_proc_target != nullptr,"logMeasurementRegs: BUG! i_proc_target was nullptr");
    assert(i_proc_target->getAttr<TARGETING::ATTR_TYPE>() == TARGETING::TYPE_PROC,
           "logMeasurementRegs: BUG! Expected target to be of PROC type, but "
           "it was of type 0x%08X",i_proc_target->getAttr<TARGETING::ATTR_TYPE>());

    TRACUCOMP(g_trac_trustedboot, ENTER_MRK "logMeasurementRegs(): "
              "tpm=0x%.8X, proc=0x%.8X, i_extendToTpm=%d",
              TARGETING::get_huid(i_tpm_target),
              TARGETING::get_huid(i_proc_target),
              i_extendToTpm);

    do {

    // Check if i_proc_target is boot proc
    TARGETING::Target* l_bootProc = nullptr;
    err = TARGETING::targetService().queryMasterProcChipTargetHandle(l_bootProc);
    if (err)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"LogMeasurementRegs(): "
                  ".queryMasterProcChipTargetHandle FAILED");
        break;
    }
    const bool l_isBootProc = (l_bootProc == i_proc_target);

    const auto l_proc_position = i_proc_target->getAttr<TARGETING::ATTR_POSITION>();

    // System HW Keys' Hash
    SHA512_t hw_keys_hash = {0};
    SECUREBOOT::getHwKeyHash(hw_keys_hash);

    // String setup
    // - specific strings:
    const char l_hash_str[] = "HW KEY HASH chip ";
    const char l_sbeSecurityState_str[] = "SBE Security State chip ";
    const char l_sbeSbValidationCode_str[] = "SBE Secure Boot Validation Code chip ";
    const char l_bootLoadersAndBase_str[] = "SBE L1/L2 Boot loaders and Base chip ";
    const char l_securitySwitches_str[] = "Security Switches chip ";

    // - common strings
    char l_pos_str[2];
    memset(l_pos_str, 0, 2);
    sprintf(l_pos_str, "%.1d", l_proc_position);
    static_assert(P10_MAX_PROCS<10, "Since P10_MAX_PROCS >= 10, need more proc position digits");

    char l_log_msg_str[LOG_REGS_MSG_MAX_CHARACTERS];
    memset(l_log_msg_str, 0, LOG_REGS_MSG_MAX_CHARACTERS);


    // Static check to make sure l_log_msg_str is long enough to hold the specific strings
    // with the position string appended to them
    // NOTE: +1 for essentially inserting position value of one character before the
    //       null-terminating character - see appendPosToStr() above
    static_assert((sizeof(l_hash_str) + 1) <= LOG_REGS_MSG_MAX_CHARACTERS,
                  "l_hash_str + 1 is longer than LOG_REGS_MSG_MAX_CHARACTERS");
    static_assert((sizeof(l_sbeSecurityState_str) + 1) <= LOG_REGS_MSG_MAX_CHARACTERS,
                  "l_sbeSecurityState_str + 1 is longer than LOG_REGS_MSG_MAX_CHARACTERS");
    static_assert((sizeof(l_sbeSbValidationCode_str) + 1) <= LOG_REGS_MSG_MAX_CHARACTERS,
                  "l_sbeSbValidationCode_str + 1 is longer than LOG_REGS_MSG_MAX_CHARACTERS");
    static_assert((sizeof(l_bootLoadersAndBase_str) + 1) <= LOG_REGS_MSG_MAX_CHARACTERS,
                  "l_bootLoadersAndBase_str + 1 is longer than LOG_REGS_MSG_MAX_CHARACTERS");
    static_assert((sizeof(l_securitySwitches_str) + 1) <= LOG_REGS_MSG_MAX_CHARACTERS,
                  "l_securitySwitches_str + 1 is longer than LOG_REGS_MSG_MAX_CHARACTERS");

    /*********************/
    /* PCR_0 Settings    */
    /*********************/

    // PCR 0 : Hash of SBE secureboot validation code
    appendPosToStr(l_log_msg_str, l_sbeSbValidationCode_str, l_pos_str);
    pcrExtendSingleTpm(i_tpm_target,
                       PCR_0,
                       EV_S_CRTM_CONTENTS,
                       TPM_ALG_SHA256,
                       &i_regs.sbe_measurement_regs_4_7[0],
                       TPM_SBE_MEASUREMENT_REGS_4_7_SIZE,
                       reinterpret_cast<uint8_t*>(l_log_msg_str),
                       strlen(l_log_msg_str) + 1,
                       i_extendToTpm);


    // PCR 0 : Hash of boot SEEProm L1/L2 Boot loaders and Base
    appendPosToStr(l_log_msg_str, l_bootLoadersAndBase_str, l_pos_str);
    pcrExtendSingleTpm(i_tpm_target,
                       PCR_0,
                       EV_S_CRTM_CONTENTS,
                       TPM_ALG_SHA256,
                       &i_regs.sbe_measurement_regs_8_11[0],
                       TPM_SBE_MEASUREMENT_REGS_8_11_SIZE,
                       reinterpret_cast<uint8_t*>(l_log_msg_str),
                       strlen(l_log_msg_str) + 1,
                       i_extendToTpm);

    // PCR 0 : Hash of HBBL - Only Done On Boot Proc
    if (l_isBootProc)
    {
        uint8_t l_hashOfHbbl_str[] = "HBBL";
        pcrExtendSingleTpm(i_tpm_target,
                           PCR_0,
                           EV_S_CRTM_CONTENTS,
                           TPM_ALG_SHA256,
                           &i_regs.sbe_measurement_regs_12_15[0],
                           TPM_SBE_MEASUREMENT_REGS_12_15_SIZE,
                           l_hashOfHbbl_str,
                           sizeof(l_hashOfHbbl_str),
                           i_extendToTpm);
    }

    /*********************/
    /* PCR_1 Settings    */
    /*********************/
    // PCR1 : boot proc, HW Keys' Hash
    if (l_isBootProc)
    {
        appendPosToStr(l_log_msg_str, l_hash_str, l_pos_str);
        pcrExtendSingleTpm(i_tpm_target,
                        PCR_1,
                        EV_PLATFORM_CONFIG_FLAGS,
                        TPM_ALG_SHA256,
                        hw_keys_hash,
                        SHA512_DIGEST_LENGTH,
                        reinterpret_cast<uint8_t*>(l_log_msg_str),
                        strlen(l_log_msg_str) + 1,
                        i_extendToTpm);
    }
    // PCR1 : secondary proc, register 1's 8 byte abbreviated HW key hash
    else
    {
        appendPosToStr(l_log_msg_str, l_hash_str, l_pos_str);
        pcrExtendSingleTpm(i_tpm_target,
                        PCR_1,
                        EV_PLATFORM_CONFIG_FLAGS,
                        TPM_ALG_SHA256,
                        &i_regs.sbe_measurement_regs_1[0],
                        TPM_SBE_MEASUREMENT_REGS_1_SIZE,
                        reinterpret_cast<uint8_t*>(l_log_msg_str),
                        strlen(l_log_msg_str) + 1,
                        i_extendToTpm);
    }

    // PCR1 : SBE Security State
    appendPosToStr(l_log_msg_str, l_sbeSecurityState_str, l_pos_str);
    pcrExtendSingleTpm(i_tpm_target,
                       PCR_1,
                       EV_PLATFORM_CONFIG_FLAGS,
                       TPM_ALG_SHA256,
                       &i_regs.sbe_measurement_regs_2[0],
                       TPM_SBE_MEASUREMENT_REGS_2_SIZE,
                       reinterpret_cast<uint8_t*>(l_log_msg_str),
                       strlen(l_log_msg_str) + 1,
                       i_extendToTpm);

    // PCR1 : Security Switches
    appendPosToStr(l_log_msg_str, l_securitySwitches_str, l_pos_str);
    pcrExtendSingleTpm(i_tpm_target,
                       PCR_1,
                       EV_PLATFORM_CONFIG_FLAGS,
                       TPM_ALG_SHA256,
                       &i_regs.sbe_measurement_regs_3[0],
                       TPM_SBE_MEASUREMENT_REGS_3_SIZE,
                       reinterpret_cast<uint8_t*>(l_log_msg_str),
                       strlen(l_log_msg_str) + 1,
                       i_extendToTpm);


    /******************************************************************/
    /* PCR_6 Settings - all of these are only done on the boot proc   */
    /******************************************************************/
    if (l_isBootProc)
    {
        // PCR6 : HW Keys' Hash
        uint8_t l_hwKeyHashLogMsg[] = "HW KEY HASH";
        pcrExtendSingleTpm(i_tpm_target,
                           PCR_6,
                           EV_COMPACT_HASH,
                           TPM_ALG_SHA256,
                           hw_keys_hash,
                           SHA512_DIGEST_LENGTH,
                           l_hwKeyHashLogMsg,
                           sizeof(l_hwKeyHashLogMsg),
                           i_extendToTpm);


        // PCR 6 : SBE Security State
        uint8_t l_sbeSecurityState[] = "SBE Security State";
        pcrExtendSingleTpm(i_tpm_target,
                           PCR_6,
                           EV_COMPACT_HASH,
                           TPM_ALG_SHA256,
                           &i_regs.sbe_measurement_regs_0[0],
                           TPM_SBE_MEASUREMENT_REGS_0_SIZE,
                           l_sbeSecurityState,
                           sizeof(l_sbeSecurityState),
                           i_extendToTpm);

        // PCR 6 : Hash of SBE secureboot validation code
        uint8_t l_sbeSbValidationCode[] = "SBE Secure Boot Validation Code";
        pcrExtendSingleTpm(i_tpm_target,
                           PCR_6,
                           EV_COMPACT_HASH,
                           TPM_ALG_SHA256,
                           &i_regs.sbe_measurement_regs_4_7[0],
                           TPM_SBE_MEASUREMENT_REGS_4_7_SIZE,
                           l_sbeSbValidationCode,
                           sizeof(l_sbeSbValidationCode),
                           i_extendToTpm);

    } // end of l_isBootProc check

    } while(0);

    TRACUCOMP(g_trac_trustedboot, EXIT_MRK "logMeasurementRegs()");
#endif
    return err;


}

/**
 * @brief Synchronizes the Primary TPM Logs to what has already been extended by
 *         the SBE and Hostboot Bootloader code
 *
 * @warning No-op if trusted boot compiled out
 *
 * @return nullptr on success; non-nullptr on error
 */
void synchronizePrimaryTpmLogs()
{
    errlHndl_t err = nullptr;
#ifdef CONFIG_TPMDD
    TARGETING::Target* l_primaryTpm = nullptr;
    TARGETING::Target* l_bootProc = nullptr;
    TPM_sbe_measurements_regs_grouped l_sbe_measurement_regs;

    TRACUCOMP(g_trac_trustedboot, ENTER_MRK "synchronizePrimaryTpmLogs()");

    // Get the mpipl attribute from the system
    const auto pSys = TARGETING::UTIL::assertGetToplevelTarget();
    auto l_isMpipl = pSys->getAttr<TARGETING::ATTR_IS_MPIPL_HB>();

    // Get the capability attribute from the node
    TARGETING::TargetHandle_t l_nodeTarget =
        TARGETING::UTIL::getCurrentNodeTarget();
    auto l_sbeExtend =
        l_nodeTarget->getAttr<TARGETING::ATTR_SBE_HANDLES_SMP_TPM_EXTEND>();

    do {

    // In MPIPL, ATTR_SBE_HANDLES_SMP_TPM_EXTEND=1 means the SBE will not reset
    // through the normal SBE boot flow, thus SBE will skip resetting the TPM
    // and skip measuring into that TPM. Since Hostboot has to match the
    // hardware measurements with the software log, we have to skip whatever
    // the SBE skips, so do not log measurement regs.
    if(l_isMpipl && l_sbeExtend)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"synchronizePrimaryTpmLogs(): "
            "ATTR_IS_MPIPL_HB=1 and ATTR_SBE_HANDLES_SMP_TPM_EXTEND=1, do not log measurement regs");
        break;
    }

    // Get Primary TPM (no syncing to secondary TPM)
    getPrimaryTpm(l_primaryTpm);
    if(!l_primaryTpm)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"synchronizePrimaryTpmLogs(): primary TPM not found");
        break;
    }

    // Get boot processor
    err = TARGETING::targetService().queryMasterProcChipTargetHandle(l_bootProc);
    if (err)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"synchronizePrimaryTpmLogs(): "
                  ".queryMasterProcChipTargetHandle FAILED");
        break;
    }

    TRACUCOMP(g_trac_trustedboot,"synchronizePrimaryTpmLogs(): "
              "primary TPM: huid=0x%X, bootProc HUID=0x%.8X",
              TARGETING::get_huid(l_primaryTpm),
              TARGETING::get_huid(l_bootProc));

    // Get SBE Measurement Values
    err = groupSbeMeasurementRegs(l_bootProc,
                                  l_sbe_measurement_regs);
    if (err)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"synchronizePrimaryTpmLogs(): groupSbeMeasurementRegs() FAILED");
        break;
    }

    // Log - but do not extend - SBE Measurement Values
    err = logMeasurementRegs(l_primaryTpm,
                             l_bootProc,
                             l_sbe_measurement_regs,
                             false); // false: do not extend
    if (err)
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"synchronizePrimaryTpmLogs(): logMeasurementRegs() FAILED");
        break;
    }


    } while(0);

    if(!l_isMpipl || !l_sbeExtend)
    {
        if (nullptr != err)
        {
            // We failed to extend to this TPM we can no longer use it
            // Mark TPM as not functional, commit err and set it to nullptr
            tpmMarkFailed(l_primaryTpm, err);
        }

        // Do Separators For All PCRs on i_tpm_target.
        pcrExtendSeparator(l_primaryTpm,
                           false, // false: do NOT extend to TPM
                           true); // true: do extend to SW Log
    }
    else
    {
        TRACFCOMP(g_trac_trustedboot,ERR_MRK"synchronizePrimaryTpmLogs(): "
            "ATTR_IS_MPIPL_HB=1 and ATTR_SBE_HANDLES_SMP_TPM_EXTEND=1, do not call pcrExtendSeparator");
    }

    TRACUCOMP(g_trac_trustedboot, EXIT_MRK "synchronizePrimaryTpmLogs()");

#endif
    return;
}

} // end TRUSTEDBOOT
