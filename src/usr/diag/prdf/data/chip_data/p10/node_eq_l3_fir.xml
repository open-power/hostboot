<?xml version="1.0" encoding="UTF-8"?>
<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/usr/diag/prdf/data/chip_data/p10/node_eq_l3_fir.xml $     -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2020                             -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->
<attn_node model_ec="P10_10" name="EQ_L3_FIR" reg_type="SCOM">
    <local_fir config="" name="EQ_L3_FIR">
        <instance addr="0x20018600" reg_inst="0"/>
        <instance addr="0x20014600" reg_inst="1"/>
        <instance addr="0x20012600" reg_inst="2"/>
        <instance addr="0x20011600" reg_inst="3"/>
        <instance addr="0x21018600" reg_inst="4"/>
        <instance addr="0x21014600" reg_inst="5"/>
        <instance addr="0x21012600" reg_inst="6"/>
        <instance addr="0x21011600" reg_inst="7"/>
        <instance addr="0x22018600" reg_inst="8"/>
        <instance addr="0x22014600" reg_inst="9"/>
        <instance addr="0x22012600" reg_inst="10"/>
        <instance addr="0x22011600" reg_inst="11"/>
        <instance addr="0x23018600" reg_inst="12"/>
        <instance addr="0x23014600" reg_inst="13"/>
        <instance addr="0x23012600" reg_inst="14"/>
        <instance addr="0x23011600" reg_inst="15"/>
        <instance addr="0x24018600" reg_inst="16"/>
        <instance addr="0x24014600" reg_inst="17"/>
        <instance addr="0x24012600" reg_inst="18"/>
        <instance addr="0x24011600" reg_inst="19"/>
        <instance addr="0x25018600" reg_inst="20"/>
        <instance addr="0x25014600" reg_inst="21"/>
        <instance addr="0x25012600" reg_inst="22"/>
        <instance addr="0x25011600" reg_inst="23"/>
        <instance addr="0x26018600" reg_inst="24"/>
        <instance addr="0x26014600" reg_inst="25"/>
        <instance addr="0x26012600" reg_inst="26"/>
        <instance addr="0x26011600" reg_inst="27"/>
        <instance addr="0x27018600" reg_inst="28"/>
        <instance addr="0x27014600" reg_inst="29"/>
        <instance addr="0x27012600" reg_inst="30"/>
        <instance addr="0x27011600" reg_inst="31"/>
        <action attn_type="CS" config="00"/>
        <action attn_type="RE" config="01"/>
    </local_fir>
    <bit pos="0">When this error occurs, no members are available for a particular CGC. This will cause an infinite hang of a CI machine. There may be no members available due to a combination of line delete, way disable, and segr lco/qbit mode.</bit>
    <bit pos="1">L3 attempted to master a CP (Castout/Push) command to the fabric when in chip_contained mode</bit>
    <bit pos="2">Access attempted to use invalid topology table entry. Access may be from CO, RD, PF or snoop</bit>
    <bit pos="3">This error indicates at least 1 CE and 1 UE have occurred within 1 fabric data hang pulse interval. This is an indication that a wordline fail may be occurring.</bit>
    <bit pos="4">CE detected along read dataflow. This may assert due to cache read, casthru, pf_byp. If we are configured to do a single line delete and detect a CE for a cache read from a snoop/read machine, then fir26 will assert instead (fir4 will not assert). If set to do continuous line deletes fir4 will assert on CE (fir26 will not assert).</bit>
    <bit pos="5">UE detected along read dataflow. May assert due to cache read, casthru, pf_byp.</bit>
    <bit pos="6">SUE detected along read dataflow. May assert due to cache read, casthru, pf_byp.</bit>
    <bit pos="7">CE detected along write dataflow with data from PowerBus (Prefetch, LCO or Cache Inject)</bit>
    <bit pos="8">UE detected along write dataflow with data from PowerBus (Prefetch, LCO or Cache Inject)</bit>
    <bit pos="9">SUE detected along write dataflow with data from PowerBus (Prefetch, LCO or Cache Inject)</bit>
    <bit pos="10">CE detected along write dataflow with data from L2 CPI buffer or WIHPC</bit>
    <bit pos="11">UE detected along write dataflow with data from L2 CPI buffer or WIHPC</bit>
    <bit pos="12">SUE detected along write dataflow with data from L2 CPI buffer or WIHPC</bit>
    <bit pos="13">Directory CE Occured</bit>
    <bit pos="14">Directory UE Occured</bit>
    <bit pos="15">Directory error occured but no error found during re-read of the directory again</bit>
    <bit pos="16">Received addr_error cresp on Snoop Machine or Castout Operation</bit>
    <bit pos="17">Received addr_error cresp for Prefetch Operation</bit>
    <bit pos="18">Asserts when the L3 returns presp_rty_other to a PowerBus hang.poll or hang.check RCMD. This is typically masked, but provides an indication that an operation hang has been detected and signalled.</bit>
    <bit pos="19">lru invalid count error. Violation of requirement that, when not in dmap or fixed-member mode, each group must have a member with lru_cnt=0 for 1st class and a member with lru_cnt=0 for 2nd class if there is a 2nd class member. Will not assert when an lru_cnt=0 is found for a member that is disabled. This error (missing lru_cnt=0) is recoverable - the L3 fails dispatch and then goes into random-victim- selection mode until it succeeds. On an L2-read or snoop, an LRU array is read, but errors aren't corrected because no LRU array write occurs. Thus, repeated reads to the location with the error may cause this bit to repeated assert. This bit may assert despite no error if the group and config have changed since the last time the CGC was accessed.</bit>
    <bit pos="20">spare20</bit>
    <bit pos="21">spare21</bit>
    <bit pos="22">spare22</bit>
    <bit pos="23">Prefetcj or Write Inject machine PowerBus data hang check</bit>
    <bit pos="24">Hardware Control Error. See Hardware Control Error Read0/1 SCOM Registers for details.</bit>
    <bit pos="25">Cache Inhibited operation was hit in the L3 directory. This is usually a software bug.</bit>
    <bit pos="26">Snoop Machine or Read machine has performed a line delete from a cache read</bit>
    <bit pos="27">Indicates that this l3 has snooped an incoming lco and in which the source (rcmdx_source) is not proxime. This is likely due to a programming error and could result in multiple owners of a line</bit>
    <bit pos="28">Indicates the LRU intended to victimize a line, but failed to select exactly one member for victimization. This asserts due to a LRU array bit error (lru_inval_cnt_err also asserts) or an algorithm or implementation error in the logic that generates the selection. The lru_inval_cnt_err, and thus this bit, may assert despite no error if the group and config have changed since the last time the CGC was accessed. This error is recoverable - the L3 fails dispatch and then goes into random-victim- selection mode until it succeeds. On an l2-read or snoop, an LRU array is read, but errors aren't corrected because there is no LRU array write. Thus, repeated reads to the location with the error may cause this bit to repeated assert.</bit>
    <bit pos="29">All members are either column or line deleted in some CGC class</bit>
    <bit pos="30">Indicates that this l3 has snooped an incoming lco and we are the target however, our lco target id (set via SCOM in mode_reg1) does not match the chiplet id set by pb through input pins pb_ex_chiplet_id_dc Note that in chip-contained mode, the LCOs ID are often set to values that dont match the pb_ex_chiplet_id, thus this error is masked in that mode.</bit>
    <bit pos="31">Received ack_dead or ed_ack_dead cresp on CO, SN operation (pb write)</bit>
    <bit pos="32">Received ack_dead or ed_ack_dead cresp on PF operation (pb read)</bit>
</attn_node>
