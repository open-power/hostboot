/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/diag/prdf/common/plat/mem/prdfMemEccAnalysis.C $      */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2024                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

#include <prdfMemEccAnalysis.H>

// Platform includes
#include <prdfMemAddress.H>
#include <prdfMemCaptureData.H>
#include <prdfMemDbUtils.H>
#include <prdfMemDqBitmap.H>
#include <prdfMemExtraSig.H>
#include <prdfOdyExtraSig.H>
#include <prdfMemUtils.H>
#include <prdfPlatServices.H>
#include <prdfRegisterCache.H>

#ifdef __HOSTBOOT_RUNTIME
    #include <prdfMemDynDealloc.H>
#endif

using namespace TARGETING;

namespace PRDF
{

using namespace PlatServices;

namespace MemEcc
{

//------------------------------------------------------------------------------

template<>
uint32_t handleMemUe<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
    const MemAddr & i_addr, UE_TABLE::Type i_type,
    STEP_CODE_DATA_STRUCT & io_sc, bool i_invAddr )
{
    #define PRDF_FUNC "[MemEcc::handleMemUe<TYPE_OCMB_CHIP>] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        MemRank rank = i_addr.getRank();

        // All memory UEs should be customer viewable.
        io_sc.service_data->setServiceCall();

        // Each OCMB needs to keep track of whether it has hit a UE. This
        // is needed for a workaround for clearing Hardware Force Mirror (HWFM)
        // when certain errors are hit, however if an OCMB has hit a UE, then
        // HWFM will not be cleared.
        #ifdef __HOSTBOOT_RUNTIME
        OcmbDataBundle * db = getOcmbDataBundle(i_chip);
        db->iv_hwfmUeSeen = true;
        #endif

        // Actions if we have potentially invalid address information
        if (i_invAddr)
        {
            // Since there's a UE on both ports and we don't have valid address
            // information, just callout both ports.
            TargetHandle_t port0 = getConnectedChild(i_chip->getTrgt(),
                                                     TYPE_MEM_PORT, 0);
            if (nullptr == port0)
            {
                PRDF_ERR(PRDF_FUNC "Invalid address for UE, but port0 on OCMB "
                         "0x%08x does not exist", i_chip->getHuid());
                io_sc.service_data->SetCallout(i_chip->getTrgt());
                return FAIL;
            }

            TargetHandle_t port1 = getConnectedChild(i_chip->getTrgt(),
                                                     TYPE_MEM_PORT, 1);
            if (nullptr == port1)
            {
                PRDF_ERR(PRDF_FUNC "Invalid address for UE, but port1 on OCMB "
                         "0x%08x does not exist", i_chip->getHuid());
                io_sc.service_data->SetCallout(i_chip->getTrgt());
                return FAIL;
            }

            io_sc.service_data->SetCallout(port0, MRU_MEDA);
            io_sc.service_data->SetCallout(port1, MRU_MEDA);

            // The address value is invalid, but add the address that was read
            // to the table anyway so something is there.
            MemAddr port0Addr = MemAddr(i_addr.getRank(), i_addr.getBank(),
                i_addr.getRow(), i_addr.getCol(), 0);
            MemAddr port1Addr = MemAddr(i_addr.getRank(), i_addr.getBank(),
                i_addr.getRow(), i_addr.getCol(), 1);

            MemDbUtils::addUeTableEntry<TYPE_OCMB_CHIP>( i_chip, i_type,
                port0Addr, i_invAddr );
            MemDbUtils::addUeTableEntry<TYPE_OCMB_CHIP>( i_chip, i_type,
                port1Addr, i_invAddr );

            #ifdef __HOSTBOOT_RUNTIME
            // Dynamically deallocate the ports.
            if ( SUCCESS != MemDealloc::port<TYPE_OCMB_CHIP>(i_chip, 0) )
            {
                PRDF_ERR( PRDF_FUNC "MemDealloc::port<TYPE_OCMB_CHIP>(0x%08x,0)"
                          " failed", i_chip->getHuid() );
            }
            if ( SUCCESS != MemDealloc::port<TYPE_OCMB_CHIP>(i_chip, 1) )
            {
                PRDF_ERR( PRDF_FUNC "MemDealloc::port<TYPE_OCMB_CHIP>(0x%08x,1)"
                          " failed", i_chip->getHuid() );
            }
            #endif
        }
        // Actions if we have valid address information
        else
        {
            // Since we have valid address information, callout the rank.
            PRDpriority rankPriority = MRU_MED;
            GARD_POLICY rankGard = GARD;

            if (MemUtils::checkOdpRootCause<TYPE_OCMB_CHIP>(i_chip,
                                                            i_addr.getPort()))
            {
                TargetHandle_t memport = getConnectedChild(i_chip->getTrgt(),
                    TYPE_MEM_PORT, i_addr.getPort());
                io_sc.service_data->SetCallout(memport, MRU_HIGH);
                rankPriority = MRU_LOW;
                rankGard = NO_GARD;
            }

            MemoryMru mm { i_chip->getTrgt(), rank, i_addr.getPort(),
                           MemoryMruData::CALLOUT_RANK };
            io_sc.service_data->SetCallout( mm, rankPriority, rankGard );

            MemDbUtils::addUeTableEntry<TYPE_OCMB_CHIP>( i_chip, i_type, i_addr,
                                                         i_invAddr );

            #ifdef __HOSTBOOT_RUNTIME
            // Dynamically deallocate the rank.
            if ( SUCCESS != MemDealloc::rank<TYPE_OCMB_CHIP>(i_chip, rank,
                                                             i_addr.getPort()) )
            {
                PRDF_ERR( PRDF_FUNC "MemDealloc::rank<TYPE_OCMB_CHIP>(0x%08x,"
                          "m%ds%d,%x) failed", i_chip->getHuid(),
                          rank.getMaster(), rank.getSlave(), i_addr.getPort() );
            }
            #endif

        }

        #ifdef __HOSTBOOT_RUNTIME
        // Increment the UE counter and store the rank we're on, resetting
        // the UE and CE counts if we have stopped on a new port/rank.
        OcmbDataBundle * ocmbdb = getOcmbDataBundle(i_chip);
        if ( ocmbdb->iv_ceUeRank.first != i_addr.getPort() ||
             ocmbdb->iv_ceUeRank.second != i_addr.getRank() )
        {
            ocmbdb->iv_ceStopCounter.reset();
            ocmbdb->iv_ueStopCounter.reset();
        }
        ocmbdb->iv_ueStopCounter.inc( io_sc );
        ocmbdb->iv_ceUeRank = std::make_pair(i_addr.getPort(),
                                             i_addr.getRank());
        #endif

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

void handleOdyMaintAue(ExtensibleChip * i_chip, const MemAddr & i_addr,
                       STEP_CODE_DATA_STRUCT & io_sc)
{
    PRDF_ASSERT(nullptr != i_chip);
    PRDF_ASSERT(TYPE_OCMB_CHIP == i_chip->getType());

    io_sc.service_data->setServiceCall();

    // DIMM rank high priority, MEM_PORT low priority callout.
    PRDpriority dimmPriority = MRU_HIGH;
    GARD_POLICY dimmGard = GARD;

    PRDpriority memportPriority = MRU_LOW;
    GARD_POLICY memportGard = NO_GARD;

    // If there is a possible root cause in the ODP_FIR, adjust the
    // callout to MEM_PORT high, DIMM low
    if (MemUtils::checkOdpRootCause<TYPE_OCMB_CHIP>(i_chip, i_addr.getPort()))
    {
        memportPriority = MRU_HIGH;
        memportGard = GARD;

        dimmPriority = MRU_LOW;
        dimmGard = NO_GARD;
    }

    TargetHandle_t memport = getConnectedChild(i_chip->getTrgt(), TYPE_MEM_PORT,
                                               i_addr.getPort());
    io_sc.service_data->SetCallout(memport, memportPriority, memportGard);

    MemRank rank = i_addr.getRank();
    MemoryMru mm {i_chip->getTrgt(), rank, i_addr.getPort(),
                  MemoryMruData::CALLOUT_RANK};
    io_sc.service_data->SetCallout(mm, dimmPriority, dimmGard);
}

//------------------------------------------------------------------------------

#ifdef __HOSTBOOT_MODULE

uint32_t __expMaskMemPort( ExtensibleChip * i_chip, uint8_t i_port )
{
    #define PRDF_FUNC "[MemEcc::__expMaskMemPort] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        // Mask all FIRs on the OCMB in the chiplet FIRs.
        SCAN_COMM_REGISTER_CLASS * chipletMask =
            i_chip->getRegister("OCMB_CHIPLET_FIR_MASK");
        SCAN_COMM_REGISTER_CLASS * chipletSpaMask =
            i_chip->getRegister("OCMB_CHIPLET_SPA_FIR_MASK");

        // We need to leave bits unmasked so we can still analyze to
        // SRQFIR[25] (to trigger a firmware initiated channel fail) and
        // the IUE bits, RDFFIR[17,37] if one of the IUE bits is set.

        chipletMask->setAllBits();
        chipletSpaMask->setAllBits();

        // Clear bits 7 and 9 so we can still analyze to the SRQFIR and RDFFIR
        chipletMask->ClearBit(7);
        chipletMask->ClearBit(9);

        o_rc = chipletMask->Write() | chipletSpaMask->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR(PRDF_FUNC "Write() failed for OCMB_CHIPLET_FIR_MASK or "
                     "OCMB_CHIPLET_SPA_FIR_MASK on 0x%08x", i_chip->getHuid());
            break;
        }

        // Mask off all bits in the SRQFIR except bit 25
        SCAN_COMM_REGISTER_CLASS * srqfir_mask_or =
            i_chip->getRegister("SRQFIR_MASK_OR");
        srqfir_mask_or->setAllBits();
        srqfir_mask_or->ClearBit(25);

        o_rc = srqfir_mask_or->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed for SRQFIR_MASK_OR on 0x%08x",
                      i_chip->getHuid() );
            break;
        }

        // Mask off all bits in the RDFFIR except bits 17,37 (if they are set)
        SCAN_COMM_REGISTER_CLASS * rdffir_mask_or =
            i_chip->getRegister("RDFFIR_MASK_OR");
        rdffir_mask_or->setAllBits();

        // We don't want to mask the IUE bits in the RDFFIR if they are on
        // so if we trigger a channel fail that causes a checkstop we have
        // something to blame it on.
        SCAN_COMM_REGISTER_CLASS * rdffir = i_chip->getRegister("RDFFIR");

        o_rc = rdffir->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read() failed for RDFFIR on 0x%08x",
                      i_chip->getHuid() );
            break;
        }

        if ( rdffir->IsBitSet(17) ) rdffir_mask_or->ClearBit(17);
        if ( rdffir->IsBitSet(37) ) rdffir_mask_or->ClearBit(37);

        o_rc = rdffir_mask_or->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed for RDFFIR_MASK_OR on 0x%08x",
                      i_chip->getHuid() );
            break;
        }

        #ifdef __HOSTBOOT_RUNTIME

        // Dynamically deallocate the port.
        if ( SUCCESS != MemDealloc::port<TYPE_OCMB_CHIP>( i_chip, i_port ) )
        {
            PRDF_ERR( PRDF_FUNC "MemDealloc::port<TYPE_OCMB_CHIP>(0x%08x,%x) "
                      "failed", i_chip->getHuid(), i_port );
        }

        #endif

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

uint32_t __odyMaskMemPort( ExtensibleChip * i_chip, uint8_t i_port )
{
    #define PRDF_FUNC "[MemEcc::__odyMaskMemPort] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        // Mask all FIRs on the OCMB in the chiplet FIRs.
        SCAN_COMM_REGISTER_CLASS * tpCsMaskOr =
            i_chip->getRegister("CFIR_TP_CS_MASK_OR");
        SCAN_COMM_REGISTER_CLASS * tpReMaskOr =
            i_chip->getRegister("CFIR_TP_RE_MASK_OR");
        SCAN_COMM_REGISTER_CLASS * tpSpaMaskOr =
            i_chip->getRegister("CFIR_TP_SPA_MASK_OR");
        SCAN_COMM_REGISTER_CLASS * tpUcsMaskOr =
            i_chip->getRegister("CFIR_TP_UCS_MASK_OR");

        SCAN_COMM_REGISTER_CLASS * memCsMaskOr =
            i_chip->getRegister("CFIR_MEM_CS_MASK_OR");
        SCAN_COMM_REGISTER_CLASS * memReMaskOr =
            i_chip->getRegister("CFIR_MEM_RE_MASK_OR");
        SCAN_COMM_REGISTER_CLASS * memSpaMaskOr =
            i_chip->getRegister("CFIR_MEM_SPA_MASK_OR");
        SCAN_COMM_REGISTER_CLASS * memUcsMaskOr =
            i_chip->getRegister("CFIR_MEM_UCS_MASK_OR");

        // We need to leave bits unmasked so we can still analyze to
        // SRQFIR[46] (to trigger a firmware initiated channel fail) and
        // the IUE bits, RDFFIR[18,38] if one of the IUE bits is set.

        tpCsMaskOr->setAllBits();
        tpReMaskOr->setAllBits();
        tpSpaMaskOr->setAllBits();
        tpUcsMaskOr->setAllBits();
        memCsMaskOr->setAllBits();
        memReMaskOr->setAllBits();
        memSpaMaskOr->setAllBits();
        memUcsMaskOr->setAllBits();

        // Clear bits 10 for CS/UCS so we can still analyze to the SRQFIR to
        // trigger a firmware initiate channel fail.
        memCsMaskOr->ClearBit(10);
        memUcsMaskOr->ClearBit(10);

        // Clear bits 8:9 for RE so we can still analyze to the RDFFIRs for IUEs
        memReMaskOr->ClearBit(8);
        memReMaskOr->ClearBit(9);

        o_rc = tpCsMaskOr->Write()   | tpReMaskOr->Write()  |
               tpSpaMaskOr->Write()  | tpUcsMaskOr->Write() |
               memCsMaskOr->Write()  | memReMaskOr->Write() |
               memSpaMaskOr->Write() | memUcsMaskOr->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR(PRDF_FUNC "Write() failed for chiplet masks on 0x%08x",
                     i_chip->getHuid());
            break;
        }

        // Mask off all bits in the SRQFIR except bit 46
        SCAN_COMM_REGISTER_CLASS * srqfir_mask_or =
            i_chip->getRegister("SRQ_FIR_MASK_OR");
        srqfir_mask_or->setAllBits();
        srqfir_mask_or->ClearBit(46);

        o_rc = srqfir_mask_or->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed for SRQ_FIR_MASK_OR on 0x%08x",
                      i_chip->getHuid() );
            break;
        }

        // Mask off all bits in the RDFFIR except bits 18,38 (if they are set)
        char maskName[64];
        sprintf(maskName, "RDF_FIR_MASK_OR_%x", i_port);
        SCAN_COMM_REGISTER_CLASS * rdffir_mask_or =
            i_chip->getRegister(maskName);
        rdffir_mask_or->setAllBits();

        // We don't want to mask the IUE bits in the RDFFIR if they are on
        // so if we trigger a channel fail that causes a checkstop we have
        // something to blame it on.
        char regName[64];
        sprintf(regName, "RDF_FIR_%x", i_port);
        SCAN_COMM_REGISTER_CLASS * rdffir = i_chip->getRegister(regName);

        o_rc = rdffir->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read() failed for %s on 0x%08x",
                      regName, i_chip->getHuid() );
            break;
        }

        if ( rdffir->IsBitSet(18) ) rdffir_mask_or->ClearBit(18);
        if ( rdffir->IsBitSet(38) ) rdffir_mask_or->ClearBit(38);

        o_rc = rdffir_mask_or->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed for RDFFIR_MASK_OR on 0x%08x",
                      i_chip->getHuid() );
            break;
        }

        #ifdef __HOSTBOOT_RUNTIME

        // Dynamically deallocate the port.
        if ( SUCCESS != MemDealloc::port<TYPE_OCMB_CHIP>( i_chip, i_port ) )
        {
            PRDF_ERR( PRDF_FUNC "MemDealloc::port<TYPE_OCMB_CHIP>(0x%08x,%x) "
                      "failed", i_chip->getHuid(), i_port );
        }

        #endif

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

template<>
uint32_t maskMemPort<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip, uint8_t i_port )
{
    // Odyssey OCMBs
    if (isOdysseyOcmb(i_chip->getTrgt()))
    {
        return __odyMaskMemPort(i_chip, i_port);
    }
    // Explorer OCMBs
    else
    {
        return __expMaskMemPort(i_chip, i_port);
    }
}

#endif // __HOSTBOOT_MODULE

//------------------------------------------------------------------------------

#ifdef __HOSTBOOT_RUNTIME

uint32_t __expTriggerChnlFail( ExtensibleChip * i_chip )
{
    #define PRDF_FUNC "[MemEcc::__expTriggerChnlFail] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        // Trigger a channel fail by unmasking and setting SRQFIR[25]

        // Set the SRQFIR[25] action registers to 0,0 for UNIT_CS
        // ACT0
        SCAN_COMM_REGISTER_CLASS * act0 = i_chip->getRegister( "SRQFIR_ACT0" );

        o_rc = act0->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read failed on SRQFIR_ACT0: i_chip=0x%08x",
                      i_chip->getHuid() );
            break;
        }

        // If bit 25 is set, clear it.
        if ( act0->IsBitSet(25) )
        {
            act0->ClearBit(25);
            o_rc = act0->Write();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "Write failed on SRQFIR_ACT0: "
                          "i_chip=0x%08x", i_chip->getHuid() );
                break;
            }
        }

        // ACT1
        SCAN_COMM_REGISTER_CLASS * act1 = i_chip->getRegister( "SRQFIR_ACT1" );

        o_rc = act1->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read failed on SRQFIR_ACT1: i_chip=0x%08x",
                      i_chip->getHuid() );
            break;
        }

        // If bit 25 is set, clear it.
        if ( act1->IsBitSet(25) )
        {
            act1->ClearBit(25);
            o_rc = act1->Write();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "Write failed on SRQFIR_ACT1: "
                          "i_chip=0x%08x", i_chip->getHuid() );
                break;
            }
        }

        // Set SRQFIR[25]
        SCAN_COMM_REGISTER_CLASS * srqfir_or = i_chip->getRegister("SRQFIR_OR");

        srqfir_or->clearAllBits();
        srqfir_or->SetBit(25);

        o_rc = srqfir_or->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write failed on SRQFIR_OR: i_chip=0x%08x",
                      i_chip->getHuid() );
            break;
        }

        // Unmask SRQFIR[25]
        SCAN_COMM_REGISTER_CLASS * mask_and =
            i_chip->getRegister( "SRQFIR_MASK_AND" );

        mask_and->setAllBits();
        mask_and->ClearBit(25);
        o_rc = mask_and->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write failed on SRQFIR_MASK_AND: "
                      "i_chip=0x%08x", i_chip->getHuid() );
            break;
        }

        // Reset thresholds to prevent issuing multiple channel failures on
        // the same port.
        OcmbDataBundle * db = getOcmbDataBundle( i_chip );
        for ( auto & resetTh : db->iv_iueTh )
        {
            resetTh.second.reset();
        }

        db->iv_iueChnlFail = true;

    }while(0);

    return o_rc;

    #undef PRDF_FUNC
}

uint32_t __odyTriggerChnlFail( ExtensibleChip * i_chip )
{
    #define PRDF_FUNC "[MemEcc::__odyTriggerChnlFail] "

    PRDF_ASSERT(nullptr != i_chip);
    PRDF_ASSERT(TYPE_OCMB_CHIP == i_chip->getType());

    uint32_t o_rc = SUCCESS;

    do
    {
        // Trigger a channel fail by unmasking and setting SRQFIR[46]

        // Set SRQ_FIR_CFG_CS[46]. Read, modify, write.
        SCAN_COMM_REGISTER_CLASS * cfg = i_chip->getRegister("SRQ_FIR_CFG_CS");

        o_rc = cfg->Read();
        if (SUCCESS != o_rc)
        {
            PRDF_ERR(PRDF_FUNC "Read failed on SRQ_FIR_CFG_CS: i_chip=0x%08x",
                     i_chip->getHuid());
            break;
        }

        // If bit 46 is not set, set it.
        if (!cfg->IsBitSet(46))
        {
            cfg->SetBit(46);
            o_rc = cfg->Write();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR(PRDF_FUNC "Write failed on SRQ_FIR_CFG_CS: "
                         "i_chip=0x%08x", i_chip->getHuid());
                break;
            }
        }

        // Set SRQFIR[46]
        SCAN_COMM_REGISTER_CLASS * srqfir_or =
            i_chip->getRegister("SRQ_FIR_OR");

        srqfir_or->clearAllBits();
        srqfir_or->SetBit(46);

        o_rc = srqfir_or->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR(PRDF_FUNC "Write failed on SRQ_FIR_OR: i_chip=0x%08x",
                     i_chip->getHuid());
            break;
        }

        // Unmask SRQFIR[46], write to clear
        SCAN_COMM_REGISTER_CLASS * mask = i_chip->getRegister("SRQ_FIR_MASK");

        mask->clearAllBits();
        mask->SetBit(46);
        o_rc = mask->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR(PRDF_FUNC "Write failed on SRQ_FIR_MASK: "
                     "i_chip=0x%08x", i_chip->getHuid());
            break;
        }

        // Reset thresholds to prevent issuing multiple channel failures on
        // the same port.
        OcmbDataBundle * db = getOcmbDataBundle(i_chip);
        for (auto & resetTh : db->iv_iueTh)
        {
            resetTh.second.reset();
        }

        db->iv_iueChnlFail = true;

    }while(0);

    return o_rc;

    #undef PRDF_FUNC
}

template<>
uint32_t triggerChnlFail<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip )
{
    // Odyssey OCMBs
    if (isOdysseyOcmb(i_chip->getTrgt()))
    {
        return __odyTriggerChnlFail(i_chip);
    }
    // Explorer OCMBs
    else
    {
        return __expTriggerChnlFail(i_chip);
    }
}

#endif // __HOSTBOOT_RUNTIME

//------------------------------------------------------------------------------

#ifdef __HOSTBOOT_MODULE

template<>
bool queryIueTh<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                 STEP_CODE_DATA_STRUCT & io_sc )
{
    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    bool iueAtTh = false;

    OcmbDataBundle * db = getOcmbDataBundle( i_chip );

    // Loop through all our thresholds
    for ( auto & th : db->iv_iueTh )
    {
        // If threshold reached
        if ( th.second.thReached(io_sc) )
        {
            iueAtTh = true;
        }
    }

    return iueAtTh;
}

#endif

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t handleMpe( ExtensibleChip * i_chip, const MemAddr & i_addr,
                    UE_TABLE::Type i_type, STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemEcc::handleMpe] "

    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    MemRank rank = i_addr.getRank();
    uint8_t port = i_addr.getPort();

    do
    {
        // Read the chip mark from markstore.
        MemMark chipMark;
        o_rc = MarkStore::readChipMark<T>( i_chip, rank, port, chipMark );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "readChipMark<T>(0x%08x,0x%02x,%x) failed",
                      i_chip->getHuid(), rank.getKey(), port );
            break;
        }

        // If the chip mark is not valid, then somehow the chip mark was
        // placed on a rank other than the rank in which the command
        // stopped. This would most likely be a code bug.
        if (!chipMark.isValid())
        {
            PRDF_ERR(PRDF_FUNC "Invalid chip mark");
            o_rc = FAIL;
            break;
        }

        // Add the mark to the callout list.
        MemoryMru mm { i_chip->getTrgt(), rank, port, chipMark.getSymbol() };
        io_sc.service_data->SetCallout( mm );

        // Add entry to UE table.
        MemDbUtils::addUeTableEntry<T>( i_chip, i_type, i_addr, false );

        // Add a VCM request to the TD queue if at runtime or at memdiags.
        #ifdef __HOSTBOOT_MODULE

        #ifndef __HOSTBOOT_RUNTIME
        if ( isInMdiaMode() )
        {
        #endif

        TdEntry * entry = new VcmEvent<T>( i_chip, rank, chipMark, port );
        MemDbUtils::pushToQueue<T>( i_chip, entry );

        #ifndef __HOSTBOOT_RUNTIME
        }
        #endif

        #endif

    }while(0);

    return o_rc;

    #undef PRDF_FUNC
}

// To resolve template linker errors.
template
uint32_t handleMpe<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                    const MemAddr & i_addr,
                                    UE_TABLE::Type i_type,
                                    STEP_CODE_DATA_STRUCT & io_sc );

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t analyzeFetchMpe( ExtensibleChip * i_chip, const MemRank & i_rank,
                          uint8_t i_port, STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemEcc::analyzeFetchMpe] "

    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    #if !defined(__HOSTBOOT_RUNTIME) && defined(__HOSTBOOT_MODULE) // HB IPL

    PRDF_ERR( PRDF_FUNC "Mainline MPE attns should be masked during IPL" );
    PRDF_ASSERT(false); // HWP bug.

    #else // runtime

    do
    {
        // Get the address of the failure.
        MemAddr addr;
        o_rc = getMemReadAddr<T>( i_chip, MemAddr::READ_MPE_ADDR, addr );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "getMemReadAddr(0x%08x, READ_MPE_ADDR) failed",
                      i_chip->getHuid() );
            break;
        }

        // There is only one address register and it will contain the latest
        // chip mark placed. So it is possible this address will be out of sync
        // with the port/rank that reported the attention. In this case, we will
        // simply fake an address with the correct port/rank and move on.
        if ( i_rank != addr.getRank() || i_port != addr.getPort())
        {
            o_rc = MemEcc::handleMpe<T>( i_chip, i_rank, i_port,
                                         UE_TABLE::FETCH_MPE, io_sc );
        }
        else
        {
            o_rc = MemEcc::handleMpe<T>( i_chip, addr, UE_TABLE::FETCH_MPE,
                                         io_sc );
        }
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "handleMpe<T>(0x%08x, 0x%02x) failed",
                      i_chip->getHuid(), i_rank.getKey() );
            break;
        }

        #ifdef __HOSTBOOT_RUNTIME

        // The chip mark has already been added to the queue. Now tell the TD
        // controller to process it if not already in progress.
        o_rc = MemDbUtils::handleTdEvent<T>( i_chip, io_sc, addr.getPort() );
        if ( SUCCESS != o_rc )
        {
                PRDF_ERR( PRDF_FUNC "handleTdEvent(0x%08x,%x) failed on rank "
                          "0x%02x", i_chip->getHuid(), addr.getPort(),
                          i_rank.getKey() );
            break;
        }

        #endif

    } while (0);

    // Add ECC capture data for FFDC.
    MemCaptureData::addEccData<T>( i_chip, io_sc );

    #endif // __HOSTBOOT_RUNTIME

    return o_rc;

    #undef PRDF_FUNC
}

// To resolve template linker errors.
template
uint32_t analyzeFetchMpe<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                          const MemRank & i_rank,
                                          uint8_t i_port,
                                          STEP_CODE_DATA_STRUCT & io_sc );

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t handleMemCe( ExtensibleChip * i_chip, const MemAddr & i_addr,
                      const MemSymbol & i_symbol, bool & o_doTps,
                      STEP_CODE_DATA_STRUCT & io_sc,  bool i_invAddr,
                      bool i_isHard )
{
    #define PRDF_FUNC "[MemEcc::handleMemCe] "

    uint32_t o_rc = SUCCESS;

    o_doTps = false;

    TargetHandle_t trgt = i_chip->getTrgt();
    MemRank        rank = i_addr.getRank();

    // Add the DIMM to the callout list
    MemoryMru memmru ( trgt, rank, i_addr.getPort(), i_symbol );
    io_sc.service_data->SetCallout( memmru, MRU_MEDA );

    uint32_t ceTableRc;
    // Add data to the CE table. If the address is potentially invalid, add an
    // entry for each port.
    if (i_invAddr)
    {
        // The address value is invalid, but add the address that was read
        // to the table anyway so something is there.
        MemAddr port0Addr = MemAddr(i_addr.getRank(), i_addr.getBank(),
            i_addr.getRow(), i_addr.getCol(), 0);
        MemAddr port1Addr = MemAddr(i_addr.getRank(), i_addr.getBank(),
            i_addr.getRow(), i_addr.getCol(), 1);

        ceTableRc = MemDbUtils::addCeTableEntry<T>(i_chip, port0Addr, i_symbol,
                                                   i_isHard, i_invAddr);
        ceTableRc = MemDbUtils::addCeTableEntry<T>(i_chip, port1Addr, i_symbol,
                                                   i_isHard, i_invAddr);

    }
    else
    {
        ceTableRc = MemDbUtils::addCeTableEntry<T>(i_chip, i_addr, i_symbol,
                                                   i_isHard, i_invAddr);
    }

    // Check MNFG thresholds, if needed.
    // NOTE: We will only check the MNFG thresholds if DRAM repairs is disabled.
    if ( areDramRepairsDisabled() )
    {
        if ( 0 != (MemCeTable<T>::MNFG_TH_DRAM & ceTableRc) )
        {
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MnfgDramCte );
            io_sc.service_data->setServiceCall();
            o_doTps = true;
        }
        else if ( 0 != (MemCeTable<T>::MNFG_TH_RANK & ceTableRc) )
        {
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MnfgRankCte );
            io_sc.service_data->setServiceCall();
            o_doTps = true;
        }
        else if ( 0 != (MemCeTable<T>::MNFG_TH_DIMM & ceTableRc) )
        {
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MnfgDimmCte );
            io_sc.service_data->setServiceCall();
            o_doTps = true;
        }
        else if ( 0 != (MemCeTable<T>::TABLE_FULL & ceTableRc) )
        {
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MnfgTableFull );

            // The table is full and no other threshold has been met. We are
            // in a state where we may never hit a MNFG threshold. Callout
            // all memory behind the chip. Also, since the counts are all
            // over the place, there may be a problem with the chip. So call
            // it out as well.
            MemoryMru all_mm ( trgt, rank, i_addr.getPort(),
                               MemoryMruData::CALLOUT_ALL_MEM );
            io_sc.service_data->SetCallout( all_mm, MRU_MEDA );
            io_sc.service_data->SetCallout( trgt,   MRU_MEDA );
            io_sc.service_data->setServiceCall();
            o_doTps = true;
        }
        else if ( 0 != (MemCeTable<T>::ENTRY_TH_REACHED & ceTableRc) )
        {
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MnfgEntryCte );

            // There is a single entry threshold and no other threshold
            // has been met. This is a potential flooding issue. So make
            // the DIMM callout predictive.
            io_sc.service_data->setServiceCall();
            o_doTps = true;
        }
    }
    else // field thresholds
    {
        // It is possible that the MNFG thresholds are higher than the field
        // thresholds because of the scaling due to DRAM side. Therefore, we
        // cannot simply trigger TPS on any threshold. The field and MNFG
        // thresholds must be handled separately.
        if ( !o_doTps )
            o_doTps = ( 0 != (MemCeTable<T>::FIELD_TH_ALL & ceTableRc) );
    }

    #ifdef __HOSTBOOT_RUNTIME

    if ( i_isHard )
    {
        // Dynamically deallocate the page.
        if ( SUCCESS != MemDealloc::page<T>( i_chip, i_addr ) )
        {
            PRDF_ERR( PRDF_FUNC "MemDealloc::page(0x%08x) failed",
                      i_chip->getHuid() );
        }
    }

    #endif

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t analyzeFetchNceTce( ExtensibleChip * i_chip, uint8_t i_port,
                             STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemEcc::analyzeFetchNceTce] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    // Get the address of the failure.
    MemAddr addr;
    o_rc = getMemReadAddr<T>( i_chip, MemAddr::READ_NCE_ADDR, addr );
    if ( SUCCESS != o_rc )
    {
        PRDF_ERR( PRDF_FUNC "getMemReadAddr(0x%08x) failed",
                  i_chip->getHuid() );
        return o_rc;
    }

    MemRank rank = addr.getRank();
    // Get the symbols for the NCE/TCE attention.
    MemSymbol sym1, sym2;
    o_rc = getMemReadSymbol<T>( i_chip, rank, i_port, sym1, sym2 );
    if ( SUCCESS != o_rc )
    {
        PRDF_ERR( PRDF_FUNC "getMemReadSymbol(0x%08x) failed",
                  i_chip->getHuid() );
        return o_rc;
    }

    // Odyssey only: Check if the address is potentially invalid. On Odyssey
    // OCMBs, if there is a CE reporting on both RDF/ports at the same time,
    // the address within the mainline address trap register may be invalid.
    bool invAddr = false;
    if (isOdysseyOcmb(i_chip->getTrgt()) &&
        nullptr != getConnectedChild(i_chip->getTrgt(), TYPE_MEM_PORT, 0) &&
        nullptr != getConnectedChild(i_chip->getTrgt(), TYPE_MEM_PORT, 1))
    {
        // Check both RDF_FIR[9:10] for mainline NCE/TCEs
        SCAN_COMM_REGISTER_CLASS * rdf0 = i_chip->getRegister("RDF_FIR_0");
        SCAN_COMM_REGISTER_CLASS * rdf1 = i_chip->getRegister("RDF_FIR_1");
        if ( SUCCESS != (rdf0->ForceRead() | rdf0->ForceRead()) )
        {
            PRDF_ERR( PRDF_FUNC "Read() failed on RDF_FIRs: i_chip=0x%08x",
                      i_chip->getHuid() );
        }
        else if ( (0 != rdf0->GetBitFieldJustified(9,2)) &&
                  (0 != rdf1->GetBitFieldJustified(9,2)) )
        {
            // Set a flag indicating the address is invalid
            invAddr = true;

            // sym1 returned from getMemReadSymbol may be invalid due to
            // this as well. If sym1 is invalid at this point, just replace it
            // with a dummy symbol so there is something to add to the CE table
            // at least.
            if (!sym1.isValid())
            {
                TargetHandle_t memport = getConnectedChild(i_chip->getTrgt(),
                    TYPE_MEM_PORT, i_port);

                // Use a value of 0 for a dummy symbol value
                sym1 = MemSymbol::fromSymbol(memport, rank, 0);
            }

            // Clear NCE/TCE FIR bits on both RDFs. Write to clear.
            rdf0->clearAllBits();
            rdf1->clearAllBits();
            rdf0->SetBitFieldJustified(9, 2, 0x3);
            rdf1->SetBitFieldJustified(9, 2, 0x3);
            if (SUCCESS != (rdf0->Write() | rdf1->Write()))
            {
                PRDF_ERR( PRDF_FUNC "Write() failed on RDF_FIRs: i_chip=0x%08x",
                          i_chip->getHuid() );
            }

            #ifdef __HOSTBOOT_RUNTIME
            // Increment the threshold of invalid CE addresses that have been
            // handled. If threshold has been hit, permanently mask mainline
            // NCEs and TCEs.
            OcmbDataBundle * ocmbdb = getOcmbDataBundle(i_chip);
            if (ocmbdb->iv_ceInvAddrTh.inc(io_sc))
            {
                // Permanently mask NCE/TCEs on both ports
                ocmbdb->iv_maskMainlineNceTce[0] = true;
                ocmbdb->iv_maskMainlineNceTce[1] = true;

                SCAN_COMM_REGISTER_CLASS * mask_or0 =
                    i_chip->getRegister("RDF_FIR_MASK_OR_0");
                SCAN_COMM_REGISTER_CLASS * mask_or1 =
                    i_chip->getRegister("RDF_FIR_MASK_OR_1");

                mask_or0->clearAllBits();
                mask_or0->SetBit(9);  // Mainline read NCE
                mask_or0->SetBit(10); // Mainline read TCE
                mask_or1->clearAllBits();
                mask_or1->SetBit(9);  // Mainline read NCE
                mask_or1->SetBit(10); // Mainline read TCE

                o_rc = (mask_or0->Write() | mask_or1->Write());
                if (SUCCESS != o_rc)
                {
                    PRDF_ERR(PRDF_FUNC "Write() failed on RDF_FIR_MASK_OR");
                }

                // Clear the register cache for the RDF_FIR_MASKs so the new
                // data will be read from hardware next time they are read.
                SCAN_COMM_REGISTER_CLASS * mask0 =
                    i_chip->getRegister("RDF_FIR_MASK_0");
                SCAN_COMM_REGISTER_CLASS * mask1 =
                    i_chip->getRegister("RDF_FIR_MASK_1");
                RegDataCache & cache = RegDataCache::getCachedRegisters();
                cache.flush(i_chip, mask0);
                cache.flush(i_chip, mask1);

            }
            #endif

            // Adjust the signature
            io_sc.service_data->setSignature(i_chip->getHuid(),
                                             PRDFSIG_NceTceInvAddr);
        }
    }

    do
    {
        // Add the first symbol to the callout list and CE table.
        bool doTps = false;
        if ( sym1.isValid() )
        {
            o_rc = handleMemCe<T>( i_chip, addr, sym1, doTps, io_sc, invAddr );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "handleMemCe(0x%08x,0x%02x,%d) failed",
                          i_chip->getHuid(), rank.getKey(), sym1.getSymbol() );
                break;
            }
        }
        else
        {
            // The first symbol should always be valid.
            PRDF_ERR( PRDF_FUNC "getMemReadSymbol(0x%08x) returned an invalid "
                      "symbol", i_chip->getHuid() );
            o_rc = FAIL;
            break;
        }

        // Add the second symbol to the callout list and CE table, if it exists.
        if ( sym2.isValid() )
        {
            bool tmp;
            o_rc = handleMemCe<T>( i_chip, addr, sym2, tmp, io_sc, invAddr );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "handleMemCe(0x%08x,0x%02x,%d) failed",
                          i_chip->getHuid(), rank.getKey(), sym2.getSymbol() );
                break;
            }
            if ( tmp ) doTps = true;
        }

        // Initiate a TPS procedure, if needed.
        if ( doTps )
        {
            #ifdef __HOSTBOOT_RUNTIME

            // If a MNFG threshold has been reached (predictive callout), we
            // will still try to start TPS just in case MNFG disables the
            // termination policy.

            MemDbUtils::pushToQueue<T>( i_chip, new TpsEvent<T>(i_chip, rank,
                i_port) );
            o_rc = MemDbUtils::handleTdEvent<T>(i_chip, io_sc, i_port);
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "handleTdEvent(0x%08x,%x) failed on rank "
                          "0x%02x", i_chip->getHuid(), i_port,
                          rank.getKey() );
                break;
            }

            #endif
        }

    } while (0);

    // Add ECC capture data for FFDC.
    MemCaptureData::addEccData<T>( i_chip, io_sc );

    return o_rc;

    #undef PRDF_FUNC
}

// To resolve template linker errors.
template
uint32_t analyzeFetchNceTce<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
    uint8_t i_port, STEP_CODE_DATA_STRUCT & io_sc );

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t analyzeFetchUe( ExtensibleChip * i_chip, uint8_t i_port,
                         STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemEcc::analyzeFetchUe] "

    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    // All memory UEs should be customer viewable. Normally, this would be done
    // by setting the threshold to 1, but we do not want to mask UEs on the
    // first occurrence.
    io_sc.service_data->setServiceCall();

    // Get the address of the failure.
    MemAddr addr;
    o_rc = getMemReadAddr<T>( i_chip, MemAddr::READ_UE_ADDR, addr );
    if ( SUCCESS != o_rc )
    {
        PRDF_ERR( PRDF_FUNC "getMemReadAddr(0x%08x, READ_UE_ADDR) failed",
                  i_chip->getHuid() );
        return o_rc;
    }

    // Odyssey only: Check if the address is potentially invalid. On Odyssey
    // OCMBs, if there is a UE reporting on both RDF/ports at the same time,
    // the address within the mainline address trap register may be invalid.
    bool invAddr = false;
    if (isOdysseyOcmb(i_chip->getTrgt()) &&
        nullptr != getConnectedChild(i_chip->getTrgt(), TYPE_MEM_PORT, 0) &&
        nullptr != getConnectedChild(i_chip->getTrgt(), TYPE_MEM_PORT, 1))
    {
        // Check both RDF_FIR[9:10] for mainline UEs
        SCAN_COMM_REGISTER_CLASS * rdf0 = i_chip->getRegister("RDF_FIR_0");
        SCAN_COMM_REGISTER_CLASS * rdf1 = i_chip->getRegister("RDF_FIR_1");
        if (SUCCESS != (rdf0->Read() | rdf0->Read()))
        {
            PRDF_ERR( PRDF_FUNC "Read() failed on RDF_FIRs: i_chip=0x%08x",
                      i_chip->getHuid() );
        }
        else if (rdf0->IsBitSet(15) && rdf1->IsBitSet(15))
        {
            // Set a flag indicating the address is invalid
            invAddr = true;

            // Clear UE FIR bits on both RDFs. Write to clear.
            rdf0->clearAllBits();
            rdf1->clearAllBits();
            rdf0->SetBit(15);
            rdf1->SetBit(15);
            if (SUCCESS != (rdf0->Write() | rdf1->Write()))
            {
                PRDF_ERR( PRDF_FUNC "Write() failed on RDF_FIRs: i_chip=0x%08x",
                          i_chip->getHuid() );
            }

            // Adjust the signature
            io_sc.service_data->setSignature(i_chip->getHuid(),
                                             PRDFSIG_UeInvAddr);
        }
    }

    do
    {
        // Do memory UE handling.
        o_rc = MemEcc::handleMemUe<T>(i_chip, addr, UE_TABLE::FETCH_UE, io_sc,
                                      invAddr);
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "handleMemUe<T>(0x%08x) failed",
                      i_chip->getHuid() );
            break;
        }

        #ifdef __HOSTBOOT_RUNTIME

        if (!invAddr)
        {
            // Add a TPS request to the TD queue for additional analysis. It is
            // unlikely the procedure will result in a repair because of the UE.
            // However, we want to run TPS once just to see how bad the rank is.
            MemRank rank = addr.getRank();
            MemDbUtils::pushToQueue<T>( i_chip, new TpsEvent<T>(i_chip, rank,
                i_port) );
            o_rc = MemDbUtils::handleTdEvent<T>( i_chip, io_sc, i_port );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "handleTdEvent(0x%08x,%x) failed on rank "
                          "0x%02x", i_chip->getHuid(), i_port, rank.getKey() );
                break;
            }

            // Because of the UE, any further TPS requests will likely have no
            // effect. So ban all subsequent requests.
            MemDbUtils::banTps<T>( i_chip, rank, i_port );
        }

        #endif // __HOSTBOOT_RUNTIME

    } while (0);

    // Add ECC capture data for FFDC.
    MemCaptureData::addEccData<T>( i_chip, io_sc );

    return o_rc;

    #undef PRDF_FUNC
}

// To resolve template linker errors.
template
uint32_t analyzeFetchUe<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
    uint8_t i_port, STEP_CODE_DATA_STRUCT & io_sc );

//------------------------------------------------------------------------------

template<>
uint32_t handleMemIue<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
    const MemRank & i_rank, uint8_t i_port, STEP_CODE_DATA_STRUCT & io_sc,
    bool i_mainline )
{
    #define PRDF_FUNC "[MemEcc::handleMemIue] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    // Mainline IUEs on Odyssey may have invalid rank information, so the port
    // will be called out instead.
    if (isOdysseyOcmb(i_chip->getTrgt()) && i_mainline)
    {
        TargetHandle_t memport = getConnectedChild(i_chip->getTrgt(),
                                                   TYPE_MEM_PORT, i_port);
        io_sc.service_data->SetCallout(memport);
    }
    else
    {
        MemoryMru mm { i_chip->getTrgt(), i_rank, i_port,
                    MemoryMruData::CALLOUT_RANK };

        // For Odyssey check ODP_FIR for possible root cause
        if (MemUtils::checkOdpRootCause<TYPE_OCMB_CHIP>(i_chip, i_port))
        {
            // Adjust callout to MEM_PORT high, DIMM low
            TargetHandle_t memport = getConnectedChild(i_chip->getTrgt(),
                                                       TYPE_MEM_PORT, i_port);
            io_sc.service_data->SetCallout( memport, MRU_HIGH );
            io_sc.service_data->SetCallout( mm, MRU_LOW, NO_GARD );
        }
        else
        {
            // Add the DIMM to the callout list.
            io_sc.service_data->SetCallout( mm );
        }

    }

    #ifdef __HOSTBOOT_MODULE

    do
    {
        // Nothing else to do if handling a system checkstop.
        if ( CHECK_STOP == io_sc.service_data->getPrimaryAttnType() ) break;

        // Get the data bundle from chip.
        OcmbDataBundle * db = getOcmbDataBundle( i_chip );

        // If we have already caused a channel fail, mask the IUE bits.
        if ( true == db->iv_iueChnlFail )
        {
            // Odyssey OCMBs
            if (isOdysseyOcmb(i_chip->getTrgt()))
            {
                char maskName[64];
                sprintf(maskName, "RDF_FIR_MASK_OR_%x", i_port);

                SCAN_COMM_REGISTER_CLASS * mask = i_chip->getRegister(maskName);
                mask->clearAllBits();
                mask->SetBit(18); // mainline
                mask->SetBit(38); // maintenance
                o_rc = mask->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on RDF_FIR_MASK_OR_%x: "
                              "0x%08x", i_port, i_chip->getHuid() );
                    break;
                }
            }
            else
            {
                SCAN_COMM_REGISTER_CLASS * mask_or =
                    i_chip->getRegister("RDFFIR_MASK_OR");

                mask_or->clearAllBits();
                mask_or->SetBit(17);
                mask_or->SetBit(37);

                o_rc = mask_or->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on 0x%08x",
                              i_chip->getHuid() );
                    break;
                }
            }
        }

        // Initialize threshold if it doesn't exist yet.
        if ( 0 == db->iv_iueTh.count(i_port) )
        {
            db->iv_iueTh[i_port] = TimeBasedThreshold( getIueTh() );
        }

        // Increment the count and check if at threshold.
        if ( db->iv_iueTh[i_port].inc(io_sc) )
        {
            // Make the error log predictive.
            io_sc.service_data->setServiceCall();

            // The port fail will be triggered in the PostAnalysis plugin after
            // the error log has been committed.

            // Mask off the entire port to avoid collateral.
            o_rc = MemEcc::maskMemPort<TYPE_OCMB_CHIP>( i_chip, i_port );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "MemEcc::maskMemPort(0x%08x,%x) failed",
                          i_chip->getHuid(), i_port );
                break;
            }
        }

    } while (0);

    #endif // __HOSTBOOT_MODULE

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t analyzeMainlineIue( ExtensibleChip * i_chip, uint8_t i_port,
                             STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemEcc::analyzeMainlineIue] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        // Use the address in MBRCER. This address also traps IRCDs, but it is
        // not likely that we will have two independent failure modes at the
        // same time. So we just assume the address is correct.
        MemAddr addr;
        o_rc = getMemReadAddr<T>( i_chip, MemAddr::READ_RCE_ADDR, addr );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "getMemReadAddr(0x%08x, READ_RCE_ADDR) failed",
                      i_chip->getHuid() );
            break;
        }
        MemRank rank = addr.getRank();

        o_rc = handleMemIue<T>( i_chip, rank, i_port, io_sc, true );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "handleMemIue(0x%08x,m%ds%d,%x) failed",
                      i_chip->getHuid(), rank.getMaster(), rank.getSlave(),
                      i_port );
            break;
        }

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

template
uint32_t analyzeMainlineIue<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
    uint8_t i_port, STEP_CODE_DATA_STRUCT & io_sc );

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t analyzeMaintIue( ExtensibleChip * i_chip,
                          STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemEcc::analyzeMaintIue] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        // Use the current address in the MCBMCAT.
        MemAddr addr;
        o_rc = getMemMaintAddr<T>( i_chip, addr );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "getMemMaintAddr(0x%08x) failed",
                      i_chip->getHuid() );
            break;
        }
        MemRank rank = addr.getRank();

        o_rc = handleMemIue<T>( i_chip, rank, addr.getPort(), io_sc );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "handleMemIue(0x%08x,m%ds%d,%x) failed",
                      i_chip->getHuid(), rank.getMaster(), rank.getSlave(),
                      addr.getPort() );
            break;
        }

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

template
uint32_t analyzeMaintIue<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                          STEP_CODE_DATA_STRUCT & io_sc );

//------------------------------------------------------------------------------

template<>
uint32_t analyzeImpe<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                      STEP_CODE_DATA_STRUCT & io_sc,
                                      uint8_t i_port )
{

    #define PRDF_FUNC "[MemEcc::analyzeImpe] "

    PRDF_ASSERT( TYPE_OCMB_CHIP == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    do
    {
        // get the mark shadow register
        char regName[64];

        // Odyssey OCMBs
        if (isOdysseyOcmb(i_chip->getTrgt()))
        {
            sprintf(regName, "MSR_%x", i_port);
        }
        else
        {
            sprintf(regName, "EXP_MSR");
        }

        SCAN_COMM_REGISTER_CLASS * msr = i_chip->getRegister(regName);
        o_rc = msr->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read() failed on MSR_%x: i_chip=0x%08x",
                      i_port, i_chip->getHuid() );
            break;
        }

        TargetHandle_t trgt = i_chip->getTrgt();

        // get galois field code - bits 8:15 of MSR
        uint8_t galois = msr->GetBitFieldJustified( 8, 8 );

        // get rank - bits 16:18 of MSR
        uint8_t mrnk = msr->GetBitFieldJustified( 16, 3 );
        MemRank rank( mrnk );

        // get symbol and DRAM
        TargetHandle_t memport = getConnectedChild(trgt, TYPE_MEM_PORT, i_port);
        MemSymbol symbol = MemSymbol::fromGalois( memport, rank, galois );
        if ( !symbol.isValid() )
        {
            PRDF_ERR( PRDF_FUNC "Galois 0x%02x from MSR is invalid: 0x%08x,"
                      "0x%02x", galois, getHuid(trgt), rank.getKey() );
            o_rc = FAIL;
            break;
        }

        // Add the DIMM to the callout list
        MemoryMru memmru( trgt, rank, i_port, MemoryMruData::CALLOUT_RANK );
        io_sc.service_data->SetCallout( memmru );

        #ifdef __HOSTBOOT_MODULE
        // get data bundle from chip
        OcmbDataBundle * db = getOcmbDataBundle( i_chip );
        uint8_t dram = symbol.getDram();

        // Increment the count and check threshold.
        if ( db->getImpeThresholdCounter()->inc(rank, dram, io_sc) )
        {
            // Check if a DRAM spare is available
            bool spareAvailable = false;
            o_rc = isSpareAvailable<TYPE_MEM_PORT>( memport, rank,
                                                    spareAvailable );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "isSpareAvailable(0x%08x, 0x%02x) "
                          "failed", getHuid(memport), rank.getKey() );
                break;
            }

            // Make the error log predictive if DRAM Repairs are disabled.
            if ( areDramRepairsDisabled() )
            {
                PRDF_TRAC( PRDF_FUNC "Dram repairs disabled, making log "
                           "predictive" );
                io_sc.service_data->setServiceCall();
            }
            // Make the error log predictive and ban TPS on this rank if IMPEs
            // are found for this rank from more than one DRAM and there is no
            // spare available to deploy.
            else if ( db->getImpeThresholdCounter()->queryDrams(rank,dram,io_sc)
                      && !spareAvailable )
            {
                PRDF_TRAC( PRDF_FUNC "IMPEs found for this rank from more than "
                           "one DRAM. Making log predictive and banning TPS on "
                           "target 0x%08x, rank 0x%02x", i_chip->getHuid(),
                           rank.getKey() );
                io_sc.service_data->setServiceCall();

                #ifdef __HOSTBOOT_RUNTIME

                // Also ban TPS on this rank since we don't want TPS making
                // things worse by placing a chip mark later.
                MemDbUtils::banTps<TYPE_OCMB_CHIP>( i_chip, rank, i_port );

                #endif // __HOSTBOOT_RUNTIME
            }
            else // Otherwise, place a chip mark on the failing DRAM.
            {
                MemMark chipMark( memport, rank, galois  );
                o_rc = MarkStore::writeChipMark<TYPE_OCMB_CHIP>( i_chip, rank,
                                                                 chipMark );
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "writeChipMark(0x%08x,0x%02x) failed",
                              i_chip->getHuid(), rank.getKey() );
                    break;
                }

                bool dsd = false;
                o_rc = MarkStore::chipMarkCleanup<TYPE_OCMB_CHIP>( i_chip, rank,
                    i_port, io_sc, dsd );
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "chipMarkCleanup(0x%08x,0x%02x) failed",
                              i_chip->getHuid(), rank.getKey() );
                    break;
                }

                #ifdef __HOSTBOOT_MODULE

                if ( dsd )
                {
                    // If a dram spare deploy procedure has been started,
                    // trigger the TD controller
                    MemDbUtils::triggerDsdImpeTh<TYPE_OCMB_CHIP>(i_chip, io_sc);
                }

                #endif
            }
        }

        // If a predictive callout is made, mask both mainline and maintenance
        // attentions.
        if ( io_sc.service_data->queryServiceCall() )
        {
            // Odyssey OCMBs
            if (isOdysseyOcmb(i_chip->getTrgt()))
            {
                char maskName[64];
                sprintf(maskName, "RDF_FIR_MASK_OR_%x", i_port);

                SCAN_COMM_REGISTER_CLASS * mask = i_chip->getRegister(maskName);
                mask->clearAllBits();
                mask->SetBit(20); // mainline
                mask->SetBit(40); // maintenance
                o_rc = mask->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on RDF_FIR_MASK_OR_%x: "
                              "0x%08x", i_port, i_chip->getHuid() );
                    break;
                }
            }
            // Explorer OCMBs
            else
            {
                SCAN_COMM_REGISTER_CLASS * mask =
                    i_chip->getRegister( "RDFFIR_MASK_OR" );
                mask->clearAllBits();
                mask->SetBit(19); // mainline
                mask->SetBit(39); // maintenance
                o_rc = mask->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR_MASK_OR: "
                              "0x%08x", i_chip->getHuid() );
                    break;
                }
            }
        }
        #endif // __HOSTBOOT_MODULE

    } while (0);


    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

} // end namespace MemEcc

} // end namespace PRDF

