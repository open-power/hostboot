# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/pegasus/Proc_acts_PB.rule $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2012,2014
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

################################################################################
# PB Chiplet Registers
################################################################################

rule PbChipletFir
{
  CHECK_STOP:
     (PB_CHIPLET_CS_FIR        & `1FDFF80000000000`) & ~PB_CHIPLET_FIR_MASK;
  RECOVERABLE:
    ((PB_CHIPLET_RE_FIR >> 2 ) & `1FDFF80000000000`) & ~PB_CHIPLET_FIR_MASK;
};

group gPbChipletFir filter singlebit
{
    /** PB_CHIPLET_FIR[3]
     *  Attention from LFIR
     */
    (PbChipletFir, bit(3)) ? analyze(gPbLFir);

    /** PB_CHIPLET_FIR[4]
     *  Attention from NXDMAENGFIR
     */
    (PbChipletFir, bit(4)) ? analyze(gNxDmaEngFir);

    /** PB_CHIPLET_FIR[5]
     *  Attention from NXCQFIR
     */
    (PbChipletFir, bit(5)) ? analyze(gNxCqFir);

    /** PB_CHIPLET_FIR[6]
     *  Attention from MCDFIR
     */
    (PbChipletFir, bit(6)) ? analyze(gMcdFir);

    /** PB_CHIPLET_FIR[7|9]
     *  Attention from PBWESTFIR or PBEASTFIR
     */
    (PbChipletFir, bit(7|9)) ? analyze(gPbWestEastFir);

    /** PB_CHIPLET_FIR[8]
     *  Attention from PBCENTFIR
     */
    (PbChipletFir, bit(8)) ? analyze(gPbCentFir);

    /** PB_CHIPLET_FIR[11]
     *  Attention from PSIHBFIR
     */
    (PbChipletFir, bit(11)) ? analyze(gPsiHbFir);

    /** PB_CHIPLET_FIR[12]
     *  Attention from ICPFIR
     */
    (PbChipletFir, bit(12)) ? analyze(gIcpFir);

    /** PB_CHIPLET_FIR[13]
     *  Attention from PBAFIR
     */
    (PbChipletFir, bit(13)) ? analyze(gPbaFir);

    /** PB_CHIPLET_FIR[14]
     *  Attention from EHHCAFIR
     */
    (PbChipletFir, bit(14)) ? analyze(gEhHcaFir);

    /** PB_CHIPLET_FIR[15]
     *  Attention from NXASFIR
     */
    (PbChipletFir, bit(15)) ? defaultMaskedError;

    /** PB_CHIPLET_FIR[16]
     *  Attention from ENHCAFIR
     */
    (PbChipletFir, bit(16)) ? analyze(gEnHcaFir);

    /** PB_CHIPLET_FIR[17|18|19]
     *  Attention from PCINESTFIRs
     */
    (PbChipletFir, bit(17|18|19)) ? analyze(gPciNestFir);

    /** PB_CHIPLET_FIR[20]
     *  Attention from NXCXAFIR
     */
    (PbChipletFir, bit(20)) ? analyze(gNxCxaFir);
};

rule PbChipletSpa
{
    SPECIAL: PB_CHIPLET_SPA & ~PB_CHIPLET_SPA_MASK;
};

group gPbChipletSpa filter singlebit
{
    /** PB_CHIPLET_SPA[0]
     *  Attention from PBCENTFIR
     */
    (PbChipletSpa, bit(0)) ? analyze(gPbCentFir);
};

################################################################################
# PB Chiplet LFIR
################################################################################

rule PbLFir
{
  CHECK_STOP:  PB_LFIR & ~PB_LFIR_MASK & ~PB_LFIR_ACT0 & ~PB_LFIR_ACT1;
  RECOVERABLE: PB_LFIR & ~PB_LFIR_MASK & ~PB_LFIR_ACT0 &  PB_LFIR_ACT1;
};

group gPbLFir filter singlebit
{
    /** PB_LFIR[0]
     *  CFIR internal parity error
     */
    (PbLFir, bit(0)) ? SelfHighThr32PerDay;

    /** PB_LFIR[1]
     *  Local errors from GPIO (PCB error)
     */
    (PbLFir, bit(1)) ? defaultMaskedError;

    /** PB_LFIR[2]
     *  Local errors from CC (PCB error)
     */
    (PbLFir, bit(2)) ? defaultMaskedError;

    /** PB_LFIR[3]
     *  Local errors from CC (OPCG, parity, scan collision, ...)
     */
    (PbLFir, bit(3)) ? SelfHighThr32PerDay;

    /** PB_LFIR[4]
     *  Local errors from PSC (PCB error)
     */
    (PbLFir, bit(4)) ? defaultMaskedError;

    /** PB_LFIR[5]
     *  Local errors from PSC (parity error)
     */
    (PbLFir, bit(5)) ? defaultMaskedError;

    /** PB_LFIR[6]
     *  Local errors from Thermal (parity error)
     */
    (PbLFir, bit(6)) ? defaultMaskedError;

    /** PB_LFIR[7]
     *  Local errors from Thermal (PCB error)
     */
    (PbLFir, bit(7)) ? defaultMaskedError;

    /** PB_LFIR[8|9]
     *  Local errors from Thermal (Trip error)
     */
    (PbLFir, bit(8|9)) ? defaultMaskedError;

    /** PB_LFIR[10]
     *  Local errors from Trace Array ( error)
     */
    (PbLFir, bit(10)) ? SelfHighThr32PerDay;

    /** PB_LFIR[11]
     *  Local errors from Trace Array ( error)
     */
    (PbLFir, bit(11)) ? defaultMaskedError;

    /** PB_LFIR[12:15]
     *  Local errors from io sense
     */
    (PbLFir, bit(12|13|14|15)) ? defaultMaskedError;

    /** PB_LFIR[16]
     *  Fast check stop fir
     */
    (PbLFir, bit(16)) ? defaultMaskedError;

    /** PB_LFIR[17:20]
     *  Unused local errors
     */
    (PbLFir, bit(17|18|19|20)) ? defaultMaskedError;

    /** PB_LFIR[21:30]
     *  Unused local errors
     */
    (PbLFir, bit(21|22|23|24|25|26|27|28|29|30)) ? defaultMaskedError;

    /** PB_LFIR[31:39]
     *  Unused local errors
     */
    (PbLFir, bit(31|32|33|34|35|36|37|38|39)) ? defaultMaskedError;

    /** PB_LFIR[40]
     *  Malfunction alert - local checkstop in another chiplet
     */
    (PbLFir, bit(40)) ? defaultMaskedError;

};

################################################################################
# PB Chiplet NXDMAENGFIR
################################################################################

# p8dd1_mss_FFDC_73_final.xls

rule NxDmaEngFir
{
    CHECK_STOP:
        NXDMAENGFIR & ~NXDMAENGFIR_MASK & ~NXDMAENGFIR_ACT0 & ~NXDMAENGFIR_ACT1;
    RECOVERABLE:
        NXDMAENGFIR & ~NXDMAENGFIR_MASK & ~NXDMAENGFIR_ACT0 &  NXDMAENGFIR_ACT1;
};

group gNxDmaEngFir filter singlebit
{
    /** NXDMAENGFIR[0]
     *  Reserved
     */
    (NxDmaEngFir, bit(0)) ? defaultMaskedError;

    /** NXDMAENGFIR[1]
     *  ICS invalid state error FIR bit
     */
    (NxDmaEngFir, bit(1)) ? calloutNxThr1;

    /** NXDMAENGFIR[2|3]
     *  Reserved
     */
    (NxDmaEngFir, bit(2|3)) ? defaultMaskedError;

    /** NXDMAENGFIR[4]
     *  Channel 0 842 array corrected ECC error
     */
    (NxDmaEngFir, bit(4)) ? calloutNxThr32;

    /** NXDMAENGFIR[5]
     *  Channel 0 842 array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(5)) ? calloutNxThr1;

    /** NXDMAENGFIR[6]
     *  Channel 1 842 array corrected ECC error
     */
    (NxDmaEngFir, bit(6)) ? calloutNxThr32;

    /** NXDMAENGFIR[7]
     *  Channel 1 842 array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(7)) ? calloutNxThr1;

    /** NXDMAENGFIR[8]
     *  DMA non-zero CSB CC detected
     */
    (NxDmaEngFir, bit(8)) ? defaultMaskedError;

    /** NXDMAENGFIR[9]
     *  DMA array correctable ECC error
     */
    (NxDmaEngFir, bit(9)) ? calloutNxThr32;

    /** NXDMAENGFIR[10]
     *  DMA outbound write/inbound read correctable ECC error
     */
    (NxDmaEngFir, bit(10)) ? calloutNxThr32;

    /** NXDMAENGFIR[11]
     *  Channel 5 AMF array corrected ECC error
     */
    (NxDmaEngFir, bit(11)) ? calloutNxThr32;

    /** NXDMAENGFIR[12]
     *  Channel 6 AMF array corrected ECC error
     */
    (NxDmaEngFir, bit(12)) ? calloutNxThr32;

    /** NXDMAENGFIR[13]
     *  Channel 7 AMF array corrected ECC error
     */
    (NxDmaEngFir, bit(13)) ? calloutNxThr32;

    /** NXDMAENGFIR[14]
     *  Error from other SCOM satellites
     */
    (NxDmaEngFir, bit(14)) ? defaultMaskedError;

    /** NXDMAENGFIR[15]
     *  DMA invalid state error
     */
    (NxDmaEngFir, bit(15)) ? calloutNxThr1;

    /** NXDMAENGFIR[16]
     *  DMA invalid state error
     */
    (NxDmaEngFir, bit(16)) ? calloutNxThr1;

    /** NXDMAENGFIR[17]
     *  DMA array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(17)) ? calloutNxThr1;

    /** NXDMAENGFIR[18]
     *  DMA outbound write/inbound read uncorrectable ECC error
     */
    (NxDmaEngFir, bit(18)) ? calloutNxThr1;

    /** NXDMAENGFIR[19]
     *  DMA inbound read error
     */
    (NxDmaEngFir, bit(19)) ? calloutNxThr1;

    /** NXDMAENGFIR[20]
     *  Channel 0 invalid state error
     */
    (NxDmaEngFir, bit(20)) ? calloutNxThr1;

    /** NXDMAENGFIR[21]
     *  Channel 1 invalid state error
     */
    (NxDmaEngFir, bit(21)) ? calloutNxThr1;

    /** NXDMAENGFIR[22]
     *  Channel 2 invalid state error
     */
    (NxDmaEngFir, bit(22)) ? calloutNxThr1;

    /** NXDMAENGFIR[23]
     *  Channel 3 invalid state error
     */
    (NxDmaEngFir, bit(23)) ? calloutNxThr1;

    /** NXDMAENGFIR[24]
     *  Channel 4 invalid state error
     */
    (NxDmaEngFir, bit(24)) ? calloutNxThr1;

    /** NXDMAENGFIR[25]
     *  Channel 5 invalid state error
     */
    (NxDmaEngFir, bit(25)) ? calloutNxThr1;

    /** NXDMAENGFIR[26]
     *  Channel 6 invalid state error
     */
    (NxDmaEngFir, bit(26)) ? calloutNxThr1;

    /** NXDMAENGFIR[27]
     *  Channel 7 invalid state error
     */
    (NxDmaEngFir, bit(27)) ? calloutNxThr1;

    /** NXDMAENGFIR[28]
     *  Channel 5 AMF array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(28)) ? calloutNxThr1;

    /** NXDMAENGFIR[29]
     *  Channel 6 AMF array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(29)) ? calloutNxThr1;

    /** NXDMAENGFIR[30]
     *  Channel 7 AMF array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(30)) ? calloutNxThr1;

    /** NXDMAENGFIR[31]
     *  UE error on CRB(CSB address, CCB)
     */
    (NxDmaEngFir, bit(31)) ? calloutNxThr1;

    /** NXDMAENGFIR[32]
     *  SUE error on CRB(CSB address, CCB)
     */
    (NxDmaEngFir, bit(32)) ? calloutNxThr1;

    /** NXDMAENGFIR[33]
     *  SUE error on something other than CRB(CSB address, CCB)
     */
    (NxDmaEngFir, bit(33)) ? defaultMaskedError;

    /** NXDMAENGFIR[34|35]
     *  Reserved
     */
    (NxDmaEngFir, bit(34|35)) ? defaultMaskedError;

    /** NXDMAENGFIR[36]
     *  Channel 4 AMF array corrected ECC error
     */
    (NxDmaEngFir, bit(36)) ? calloutNxThr32;

    /** NXDMAENGFIR[37]
     *  Channel 4 AMF array uncorrectable ECC error
     */
    (NxDmaEngFir, bit(37)) ? calloutNxThr1;

    /** NXDMAENGFIR[38]
     *  NX Unit Checkstop
     */
    # This is not a hardware attention. Instead, this bit is set manually by the
    # hypervisor to communicate to PRD that it handled an NX freeze.
    (NxDmaEngFir, bit(38)) ? nxUnitCheckstop;

    /** NXDMAENGFIR[39|40|41|42|43|44|45|46|47]
     *  Reserved
     */
    (NxDmaEngFir, bit(39|40|41|42|43|44|45|46|47)) ? defaultMaskedError;

    /** NXDMAENGFIR[48]
     *  FIR/SCOM satellite parity error
     */
    (NxDmaEngFir, bit(48)) ? defaultMaskedError;

    /** NXDMAENGFIR[49]
     *  FIR/SCOM satellite parity error FIR bit duplicate
     */
    (NxDmaEngFir, bit(49)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet NXCQFIR
################################################################################

# p8dd1_mss_FFDC_73_final.xls

rule NxCqFir
{
    CHECK_STOP:  NXCQFIR & ~NXCQFIR_MASK & ~NXCQFIR_ACT0 & ~NXCQFIR_ACT1;
    RECOVERABLE: NXCQFIR & ~NXCQFIR_MASK & ~NXCQFIR_ACT0 &  NXCQFIR_ACT1;
};

group gNxCqFir filter singlebit
{
    /** NXCQFIR[0]
     *  PBI internal parity error
     */
    (NxCqFir, bit(0)) ? calloutNxThr1;

    /** NXCQFIR[1]
     *  PowerBus CE error
     */
    (NxCqFir, bit(1)) ? calloutNxThr5pHr;

    /** NXCQFIR[2]
     *  PowerBus UE error
     */
    (NxCqFir, bit(2)) ? calloutNxThr1;

    /** NXCQFIR[3]
     *  PowerBus SUE error
     */
    (NxCqFir, bit(3)) ? defaultMaskedError;

    /** NXCQFIR[4]
     *  Inbound array CE error
     */
    (NxCqFir, bit(4)) ? calloutNxThr5pHr;

    /** NXCQFIR[5]
     *  Inbound array UE error
     */
    (NxCqFir, bit(5)) ? calloutNxThr1;

    /** NXCQFIR[6]
     *  PowerBus data hang error
     */
    (NxCqFir, bit(6)) ? callout2ndLvlMedThr1NoGard;

    /** NXCQFIR[7]
     *  PowerBus command hang error
     */
    (NxCqFir, bit(7)) ? defaultMaskedError;

    /** NXCQFIR[8]
     *  PowerBus read address error
     */
    (NxCqFir, bit(8)) ? calloutNxThr1;

    /** NXCQFIR[9]
     *  PowerBus write address error
     */
    (NxCqFir, bit(9)) ? calloutNxThr1;

    /** NXCQFIR[10]
     *  PowerBus miscellaneous error
     */
    (NxCqFir, bit(10)) ? callout2ndLvlMedThr1NoGard;

    /** NXCQFIR[11]
     *  MMIO BAR parity error
     */
    (NxCqFir, bit(11)) ? calloutNxThr1;

    /** NXCQFIR[12]
     *  CRB kill ISN received while holding ISN with UE error
     */
    (NxCqFir, bit(12)) ? calloutNxThr1;

    /** NXCQFIR[13]
     *  ACK_DEAD cresp received by read command
     */
    (NxCqFir, bit(13)) ? calloutNxThr1;

    /** NXCQFIR[14]
     *  ACK_DEAD cresp received by write command
     */
    (NxCqFir, bit(14)) ? calloutNxThr1;

    /** NXCQFIR[15]
     *  Link check aborted while waiting on data
     */
    (NxCqFir, bit(15)) ? calloutNxThr1;

    /** NXCQFIR[16]
     *  Hang poll time expired on internal transfer
     */
    (NxCqFir, bit(16)) ? calloutNxThr1;

    /** NXCQFIR[17]
     *  A write occurred to a secure register when it wasn't enabled
     */
    (NxCqFir, bit(17)) ? defaultMaskedError;

    /** NXCQFIR[18]
     *  FIR/SCOM satellite parity error
     */
    (NxCqFir, bit(18)) ? defaultMaskedError;

};

################################################################################
# PB Chiplet NXCXAFIR
################################################################################

# p8dd1_mss_FFDC_73_final.xls

rule NxCxaFir
{
    CHECK_STOP:  NXCXAFIR & ~NXCXAFIR_MASK & ~NXCXAFIR_ACT0 & ~NXCXAFIR_ACT1;
    RECOVERABLE: NXCXAFIR & ~NXCXAFIR_MASK & ~NXCXAFIR_ACT0 &  NXCXAFIR_ACT1;
};

group gNxCxaFir filter singlebit
{
    /** NXCXAFIR[0]
     *  BAR_PE
     */
    (NxCxaFir, bit(0)) ? defaultMaskedError;

    /** NXCXAFIR[1]
     *  REGISTER_PE
     */
    (NxCxaFir, bit(1)) ? SelfMedThr1;

    /** NXCXAFIR[2]
     *  MASTER_ARRAY_CE
     */
    (NxCxaFir, bit(2)) ? SelfMedThr32PerDay;

    /** NXCXAFIR[3]
     *  MASTER_ARRAY_UE
     */
    (NxCxaFir, bit(3)) ? SelfMedThr1;

    /** NXCXAFIR[4]
     *  TIMER_EXPIRED_RECOV_ERROR
     */
    (NxCxaFir, bit(4)) ? defaultMaskedError;

    /** NXCXAFIR[5]
     *  TIMER_EXPIRED_XSTOP_ERROR
     */
    (NxCxaFir, bit(5)) ? SelfMedThr1;

    /** NXCXAFIR[6]
     *  PSL_CMD_UE
     */
    (NxCxaFir, bit(6)) ? defaultMaskedError;

    /** NXCXAFIR[7]
     *  PSL_CMD_SUE
     */
    (NxCxaFir, bit(7)) ? defaultMaskedError;

    /** NXCXAFIR[8]
     *  SNOOP_ARRAY_CE
     */
    (NxCxaFir, bit(8)) ? callout2ndLvlMedThr32NoGard;

    /** NXCXAFIR[9]
     *  SNOOP_ARRAY_UE
     */
    (NxCxaFir, bit(9)) ? SelfMedThr1;

    /** NXCXAFIR[10]
     *  RECOVERY_FAILED
     */
    (NxCxaFir, bit(10)) ? SelfMedThr1;

    /** NXCXAFIR[11]
     *  ILLEGAL_LPC_BAR_ACCESS
     */
    (NxCxaFir, bit(11)) ? defaultMaskedError;

    /** NXCXAFIR[12]
     *  XPT_RECOVERABLE_ERROR_MASK
     */
    (NxCxaFir, bit(12)) ? defaultMaskedError;

    /** NXCXAFIR[13]
     *  MASTER_RECOVERABLE_ERROR
     */
    (NxCxaFir, bit(13)) ? defaultMaskedError;

    /** NXCXAFIR[14]
     *  SNOOPER_RECOVERABLE_ERROR
     */
    (NxCxaFir, bit(14)) ? defaultMaskedError;

    /** NXCXAFIR[15]
     *  XPT_RECOVERABLE_ERROR
     */
    (NxCxaFir, bit(15)) ? defaultMaskedError;

    /** NXCXAFIR[16]
     *  MASTER_SYS_XSTOP_ERROR
     */
    (NxCxaFir, bit(16)) ? SelfMedThr1;

    /** NXCXAFIR[17]
     *  SNOOPER_SYS_XSTOP_ERROR
     */
    (NxCxaFir, bit(17)) ? SelfMedThr1;

    /** NXCXAFIR[18]
     *  XPT_SYS_XSTOP_ERROR
     */
    (NxCxaFir, bit(18)) ? SelfMedThr1;

    /** NXCXAFIR[19]
     *  MUOP_ERROR_1
     */
    (NxCxaFir, bit(19)) ? defaultMaskedError;

    /** NXCXAFIR[20]
     *  MUOP_ERROR_2
     */
    (NxCxaFir, bit(20)) ? defaultMaskedError;

    /** NXCXAFIR[21]
     *  MUOP_ERROR_3
     */
    (NxCxaFir, bit(21)) ? defaultMaskedError;

    /** NXCXAFIR[22]
     *  SUOP_ERROR_1
     */
    (NxCxaFir, bit(22)) ? defaultMaskedError;

    /** NXCXAFIR[23]
     *  SUOP_ERROR_2
     */
    (NxCxaFir, bit(23)) ? defaultMaskedError;

    /** NXCXAFIR[24]
     *  SUOP_ERROR_3
     */
    (NxCxaFir, bit(24)) ? defaultMaskedError;

    /** NXCXAFIR[25]
     *  POWERBUS_MISC_ERROR
     */
    (NxCxaFir, bit(25)) ? SelfHighThr1;

    /** NXCXAFIR[26]
     *  POWERBUS_INTERFACE_PE
     */
    (NxCxaFir, bit(26)) ? SelfHighThr1;

    /** NXCXAFIR[27]
     *POWERBUS_DATA_HANG_ERROR
     */
    (NxCxaFir, bit(27)) ? defaultMaskedError;

    /** NXCXAFIR[28]
     *  POWERBUS_HANG_ERROR
     */
    (NxCxaFir, bit(28)) ? defaultMaskedError;

    /** NXCXAFIR[29]
     *  LD_CLASS_CMD_ADDR_ERR
     */
    (NxCxaFir, bit(29)) ? callout2ndLvlMedThr1NoGard;

    /** NXCXAFIR[30]
     *  ST_CLASS_CMD_ADDR_ERR
     */
    (NxCxaFir, bit(30)) ? callout2ndLvlMedThr1NoGard;

    /** NXCXAFIR[31]
     *  PHB_LINK_DOWN
     */
    (NxCxaFir, bit(31)) ? defaultMaskedError;

    /** NXCXAFIR[32]
     *  LD_CLASS_CMD_FOREIGN_LINK_FAIL
     */
    (NxCxaFir, bit(32)) ? defaultMaskedError;

    /** NXCXAFIR[33]
     *  FOREIGN_LINK_HANG_ERROR
     */
    (NxCxaFir, bit(33)) ? defaultMaskedError;

    /** NXCXAFIR[34]
     *  XPT_POWERBUS_CE
     */
    (NxCxaFir, bit(34)) ? callout2ndLvlMedThr32NoGard;

    /** NXCXAFIR[35]
     *  XPT_POWERBUS_UE
     */
    (NxCxaFir, bit(35)) ? defaultMaskedError;

    /** NXCXAFIR[36]
     *  XPT_POWERBUS_SUE
     */
    (NxCxaFir, bit(36)) ? defaultMaskedError;

    /** NXCXAFIR[37]
     *  TLBI_TIMEOUT
     */
    (NxCxaFir, bit(37)) ? defaultMaskedError;

    /** NXCXAFIR[38]
     *  TLBI_SEQ_ERR
     */
    (NxCxaFir, bit(38)) ? SelfHighThr1;

    /** NXCXAFIR[39]
     *  TLBI_BAD_OP_ERR
     */
    (NxCxaFir, bit(39)) ? SelfHighThr1;

    /** NXCXAFIR[40]
     *  TLBI_SEQ_NUM_PARITY_ERR
     */
    (NxCxaFir, bit(40)) ? SelfHighThr1;

    /** NXCXAFIR[41]
     *  ST_CLASS_CMD_FOREIGN_LINK_FAIL
     */
    (NxCxaFir, bit(41)) ? defaultMaskedError;

    /** NXCXAFIR[42]
     *  TIMEBASE_ERR
     */
    (NxCxaFir, bit(42)) ? defaultMaskedError;

    /** NXCXAFIR[43]
     *  XPT_INFORMATIONAL_ERR
     */
    (NxCxaFir, bit(43)) ? defaultMaskedError;

    /** NXCXAFIR[44|45|46]
     *  SPARE_BIT
     */
    (NxCxaFir, bit(44|45|46)) ? defaultMaskedError;

    /** NXCXAFIR[47|48]
     *  SCOM_ERR
     */
    (NxCxaFir, bit(47|48)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet MCDFIR
################################################################################
# based on p8dd1_mss_FFDC_59.xls
################################################################################

rule McdFir
{
    CHECK_STOP:  MCDFIR & ~MCDFIR_MASK & ~MCDFIR_ACT0 & ~MCDFIR_ACT1;
    RECOVERABLE: MCDFIR & ~MCDFIR_MASK & ~MCDFIR_ACT0 &  MCDFIR_ACT1;
};

group gMcdFir filter singlebit
{
    /** MCDFIR[0]
     *  MCD_ARRAY_ECC_UE_ERR
     */
    (McdFir, bit(0)) ? SelfHighThr32PerDay;

    /** MCDFIR[1]
     *  MCD_ARRAY_ECC_CE_ERR
     */
    (McdFir, bit(1)) ? SelfHighThr32PerDay;

    /** MCDFIR[2]
     *  MCD_REG_PARITY_ERR
     */
    (McdFir, bit(2)) ? defaultMaskedError;

    /** MCDFIR[3]
     *  MCD_SM_ERR
     */
    (McdFir, bit(3)) ? calloutNxThr1;

    /** MCDFIR[4]
     *  MCD_REC_HANG_ERR
     */
    (McdFir, bit(4)) ? defaultMaskedError;

    /** MCDFIR[5]
     *  MCD_PB_PARITY_ERR
     */
    (McdFir, bit(5)) ? defaultMaskedError;

    /** MCDFIR[6]
     *  MCD_UNSOLICITED_CRESP_ERR
     */
    (McdFir, bit(6)) ? defaultMaskedError;

    /** MCDFIR[7]
     *  MCD_ACK_DEAD_ERR
     */
    (McdFir, bit(7)) ? defaultMaskedError;

    /** MCDFIR[8]
     *  FIR_PARITY_ERR2
     */
    (McdFir, bit(8)) ? defaultMaskedError;

    /** MCDFIR[9]
     *  FIR_PARITY_ERR
     */
    (McdFir, bit(9)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet PBEASTFIR and PBWESTFIR
################################################################################

#        All these FIRs should have the same bit definition. Ideally, we want
#        to have only one copy of the bit definition. Currently rule code
#        parser does not have the support for something like this.
#        Maybe we can add this as a later feature.

################################################################################
# based on p8dd1_mss_FFDC_37_ reviewd.xls
################################################################################

rule PbEastFir
{
  CHECK_STOP:  PBEASTFIR & ~PBEASTFIR_MASK & ~PBEASTFIR_ACT0 & ~PBEASTFIR_ACT1;
  RECOVERABLE: PBEASTFIR & ~PBEASTFIR_MASK & ~PBEASTFIR_ACT0 &  PBEASTFIR_ACT1;
};

rule PbWestFir
{
  CHECK_STOP:  PBWESTFIR & ~PBWESTFIR_MASK & ~PBWESTFIR_ACT0 & ~PBWESTFIR_ACT1;
  RECOVERABLE: PBWESTFIR & ~PBWESTFIR_MASK & ~PBWESTFIR_ACT0 &  PBWESTFIR_ACT1;
};

group gPbWestEastFir filter singlebit
{
    /** PBWESTFIR[0]
     *  PB_WEST_PBIEX01_PBH_HW_ERROR
     */
    (PbWestFir, bit(0)) ? SelfHighThr1;

    /** PBEASTFIR[0]
     *  PB_EAST_PBIEX04_PBH_HW_ERROR
     */
    (PbEastFir, bit(0)) ? SelfHighThr1;

    /** PBWESTFIR[1]
     *  PB_WEST_PBIEX01_PBH_RECOV_ERROR
     */
    (PbWestFir, bit(1)) ? SelfHighThr1;

    /** PBEASTFIR[1]
     *  PB_EAST_PBIEX04_PBH_RECOV_ERROR
     */
    (PbEastFir, bit(1)) ? SelfHighThr1;

    /** PBWESTFIR[2]
     *  PB_WEST_PBIEX01_PBH_PROTOCOL_ERROR
     */
    (PbWestFir, bit(2)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[2]
     *  PB_EAST_PBIEX04_PBH_PROTOCOL_ERROR
     */
    (PbEastFir, bit(2)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[3]
     *  PB_WEST_PBIEX01_PBH_OVERFLOW_ERROR
     */
    (PbWestFir, bit(3)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[3]
     *  PB_EAST_PBIEX04_PBH_OVERFLOW_ERROR
     */
    (PbEastFir, bit(3)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[4]
     *  PB_WEST_PBIEX02_PBH_HW_ERROR
     */
    (PbWestFir, bit(4)) ? SelfHighThr1;

    /** PBEASTFIR[4]
     *  PB_EAST_PBIEX05_PBH_HW_ERROR
     */
    (PbEastFir, bit(4)) ? SelfHighThr1;

    /** PBWESTFIR[5]
     *  PB_WEST_PBIEX02_PBH_RECOV_ERROR
     */
    (PbWestFir, bit(5)) ? SelfHighThr1;

    /** PBEASTFIR[5]
     *  PB_EAST_PBIEX05_PBH_RECOV_ERROR
     */
    (PbEastFir, bit(5)) ? SelfHighThr1;

    /** PBWESTFIR[6]
     *  PB_WEST_PBIEX02_PBH_PROTOCOL_ERROR
     */
    (PbWestFir, bit(6)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[6]
     *  PB_EAST_PBIEX05_PBH_PROTOCOL_ERROR
     */
    (PbEastFir, bit(6)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[7]
     *  PB_WEST_PBIEX02_PBH_OVERFLOW_ERROR
     */
    (PbWestFir, bit(7)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[7]
     *  PB_EAST_PBIEX05_PBH_OVERFLOW_ERROR
     */
    (PbEastFir, bit(7)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[8]
     *  PB_WEST_PBIEX03_PBH_HW_ERROR
     */
    (PbWestFir, bit(8)) ? SelfHighThr1;

    /** PBEASTFIR[8]
     *  PB_EAST_PBIEX06_PBH_HW_ERROR
     */
    (PbEastFir, bit(8)) ? SelfHighThr1;

    /** PBWESTFIR[9]
     *  PB_WEST_PBIEX03_PBH_RECOV_ERROR
     */
    (PbWestFir, bit(9)) ? SelfHighThr1;

    /** PBEASTFIR[9]
     *  PB_EAST_PBIEX06_PBH_RECOV_ERROR
     */
    (PbEastFir, bit(9)) ? SelfHighThr1;

    /** PBWESTFIR[10]
     *  PB_WEST_PBIEX03_PBH_PROTOCOL_ERROR
     */
    (PbWestFir, bit(10)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[10]
     *  PB_EAST_PBIEX06_PBH_PROTOCOL_ERROR
     */
    (PbEastFir, bit(10)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[11]
     *  PB_WEST_PBIEX03_PBH_OVERFLOW_ERROR
     */
    (PbWestFir, bit(11)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[11]
     *  PB_EAST_PBIEX06_PBH_OVERFLOW_ERROR
     */
    (PbEastFir, bit(11)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[12]
     *  PB_WEST_PBIEX09_PBH_HW_ERROR
     */
    (PbWestFir, bit(12)) ? SelfHighThr1;

    /** PBEASTFIR[12]
     *  PB_EAST_PBIEX12_PBH_HW_ERROR
     */
    (PbEastFir, bit(12)) ? SelfHighThr1;

    /** PBWESTFIR[13]
     *  PB_WEST_PBIEX09_PBH_RECOV_ERROR
     */
    (PbWestFir, bit(13)) ? SelfHighThr1;

    /** PBEASTFIR[13]
     *  PB_EAST_PBIEX12_PBH_RECOV_ERROR
     */
    (PbEastFir, bit(13)) ? SelfHighThr1;

    /** PBWESTFIR[14]
     *  PB_WEST_PBIEX09_PBH_PROTOCOL_ERROR
     */
    (PbWestFir, bit(14)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[14]
     *  PB_EAST_PBIEX12_PBH_PROTOCOL_ERROR
     */
    (PbEastFir, bit(14)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[15]
     *  PB_WEST_PBIEX09_PBH_OVERFLOW_ERROR
     */
    (PbWestFir, bit(15)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[15]
     *  PB_EAST_PBIEX12_PBH_OVERFLOW_ERROR
     */
    (PbEastFir, bit(15)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[16]
     *  PB_WEST_PBIEX10_PBH_HW_ERROR
     */
    (PbWestFir, bit(16)) ? SelfHighThr1;

    /** PBEASTFIR[16]
     *  PB_EAST_PBIEX13_PBH_HW_ERROR
     */
    (PbEastFir, bit(16)) ? SelfHighThr1;

    /** PBWESTFIR[17]
     *  PB_WEST_PBIEX10_PBH_RECOV_ERROR
     */
    (PbWestFir, bit(17)) ? SelfHighThr1;

    /** PBEASTFIR[17]
     *  PB_EAST_PBIEX13_PBH_RECOV_ERROR
     */
    (PbEastFir, bit(17)) ? SelfHighThr1;

    /** PBWESTFIR[18]
     *  PB_WEST_PBIEX10_PBH_PROTOCOL_ERROR
     */
    (PbWestFir, bit(18)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[18]
     *  PB_EAST_PBIEX13_PBH_PROTOCOL_ERROR
     */
    (PbEastFir, bit(18)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[19]
     *  PB_WEST_PBIEX10_PBH_OVERFLOW_ERROR
     */
    (PbWestFir, bit(19)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[19]
     *  PB_EAST_PBIEX13_PBH_OVERFLOW_ERROR
     */
    (PbEastFir, bit(19)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[20]
     *  PB_WEST_PBIEX11_PBH_HW_ERROR
     */
    (PbWestFir, bit(20)) ? SelfHighThr1;

    /** PBEASTFIR[20]
     *  PB_EAST_PBIEX14_PBH_HW_ERROR
     */
    (PbEastFir, bit(20)) ? SelfHighThr1;

    /** PBWESTFIR[21]
     *  PB_WEST_PBIEX11_PBH_RECOV_ERROR
     */
    (PbWestFir, bit(21)) ? SelfHighThr1;

    /** PBEASTFIR[21]
     *  PB_EAST_PBIEX14_PBH_RECOV_ERROR
     */
    (PbEastFir, bit(21)) ? SelfHighThr1;

    /** PBWESTFIR[22]
     *  PB_WEST_PBIEX11_PBH_PROTOCOL_ERROR
     */
    (PbWestFir, bit(22)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[22]
     *  PB_EAST_PBIEX14_PBH_PROTOCOL_ERROR
     */
    (PbEastFir, bit(22)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[23]
     *  PB_WEST_PBIEX11_PBH_OVERFLOW_ERROR
     */
    (PbWestFir, bit(23)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[23]
     *  PB_EAST_PBIEX14_PBH_OVERFLOW_ERROR
     */
    (PbEastFir, bit(23)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[24]
     *  PB_WEST_DATA_OVERFLOW_ERROR
     */
    (PbWestFir, bit(24)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[24]
     *  PB_EAST_DATA_OVERFLOW_ERROR
     */
    (PbEastFir, bit(24)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[25]
     *  PB_WEST_DATA_PROTOCOL_ERROR
     */
    (PbWestFir, bit(25)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[25]
     *  PB_EAST_DATA_PROTOCOL_ERROR
     */
    (PbEastFir, bit(25)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[26]
     *  PB_WEST_DATA_ROUTE_ERROR
     */
    (PbWestFir, bit(26)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[26]
     *  PB_EAST_DATA_ROUTE_ERROR
     */
    (PbEastFir, bit(26)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[27]
     *  PB_WEST_CMD_OVERFLOW_ERROR
     */
    (PbWestFir, bit(27)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[27]
     *  PB_EAST_CMD_OVERFLOW_ERROR
     */
    (PbEastFir, bit(27)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[28]
     *  PB_WEST_CMD_OVERFLOW_ERROR
     */
    (PbWestFir, bit(28)) ? calloutProcLevel2MedThr1;

    /** PBEASTFIR[28]
     *  PB_EAST_CMD_OVERFLOW_ERROR
     */
    (PbEastFir, bit(28)) ? calloutProcLevel2MedThr1;

    /** PBWESTFIR[29|30|31]
     *  PB_WEST_FIR_SPARE_0,1 and 2
     */
    (PbWestFir, bit(29|30|31)) ? defaultMaskedError;

    /** PBEASTFIR[29|30|31]
     *  PB_EAST_FIR_SPARE_0,1 and 2
     */
    (PbEastFir, bit(29|30|31)) ? defaultMaskedError;

    /** PBWESTFIR[32]
     *  FIR_SCOM_WEST_ERR
     */
    (PbWestFir, bit(32)) ? defaultMaskedError;

    /** PBEASTFIR[32]
     *  FIR_SCOM_EAST_ERR
     */
    (PbEastFir, bit(32)) ? defaultMaskedError;

    /** PBWESTFIR[33]
     *  FIR_SCOM_WEST_ERR_DUP
     */
    (PbWestFir, bit(33)) ? defaultMaskedError;

    /** PBEASTFIR[33]
     *  FIR_SCOM_EAST_ERR_DUP
     */
    (PbEastFir, bit(33)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet PBCENTFIR
################################################################################

rule PbCentFir
{
  CHECK_STOP:  PBCENTFIR & ~PBCENTFIR_MASK & ~PBCENTFIR_ACT0 & ~PBCENTFIR_ACT1;
  RECOVERABLE: PBCENTFIR & ~PBCENTFIR_MASK & ~PBCENTFIR_ACT0 &  PBCENTFIR_ACT1;
  SPECIAL:     PBCENTFIR & ~PBCENTFIR_MASK &  PBCENTFIR_ACT0 & ~PBCENTFIR_ACT1;
};

group gPbCentFir filter singlebit
{
    /** PBCENTFIR[0]
     *  PB_CENT_PROTOCOL_ERROR
     */
    (PbCentFir, bit(0)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[1]
     *  PB_CENT_OVERFLOW_ERROR
     */
    (PbCentFir, bit(1)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[2]
     *  PB_CENT_HW_PARITY_ERROR
     */
    (PbCentFir, bit(2)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[3]
     *  PB_CENT_TLBIE_TM_TIMEOUT_ERROR
     */
    (PbCentFir, bit(3)) ? defaultMaskedError;

    /** PBCENTFIR[4]
     *  PB_CENT_COHERENCY_ERROR
     */
    (PbCentFir, bit(4)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[5]
     *  PB_CENT_CRESP_ADDR_ERROR
     */
    (PbCentFir, bit(5)) ? combinedResponseError;

    /** PBCENTFIR[6]
     *  PB_CENT_CRESP_ERROR
     */
    (PbCentFir, bit(6)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[7]
     *  PB_CENT_HANG_RECOVERY_LIMIT_ERROR
     */
    (PbCentFir, bit(7)) ? defaultMaskedError;

    /** PBCENTFIR[8]
     *  PB_CENT_DATA_ROUTE_ERROR
     */
    (PbCentFir, bit(8)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[9]
     *  PB_CENT_HANG_RECOVERY_GTE_LEVEL1
     */
    (PbCentFir, bit(9)) ? defaultMaskedError;

    /** PBCENTFIR[10]
     *  PB_CENT_FORCE_MP_IPL
     */
    (PbCentFir, bit(10)) ? forceMpIpl;

    /** PBCENTFIR[11]
     *  PB_CENT_FIR_SPARE_0
     */
    (PbCentFir, bit(11)) ? calloutProcLevel2MedThr1;

    /** PBCENTFIR[12]
     *  PB_CENT_F0LINK_ERROR
     */
    (PbCentFir, bit(12)) ? defaultMaskedError;

    /** PBCENTFIR[13]
     *  PB_CENT_F1LINK_ERROR
     */
    (PbCentFir, bit(13)) ? defaultMaskedError;

    /** PBCENTFIR[14]
     *  PB_CENT_F0_OVERFLOW
     */
    (PbCentFir, bit(14)) ? defaultMaskedError;

    /** PBCENTFIR[15]
     *  PB_CENT_F1_OVERFLOW
     */
    (PbCentFir, bit(15)) ? defaultMaskedError;

    /** PBCENTFIR[16]
     *  FIR_SCOM_CENT_ERR
     */
    (PbCentFir, bit(16)) ? defaultMaskedError;

    /** PBCENTFIR[17]
     *  FIR_SCOM_CENT_ERR_DUP
     */
    (PbCentFir, bit(17)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet PSIHBFIR
################################################################################

#actions for bits updated based  on p8dd1_mss_FFDC_54

rule PsiHbFir
{
    CHECK_STOP:  PSIHBFIR & ~PSIHBFIR_MASK & ~PSIHBFIR_ACT0 & ~PSIHBFIR_ACT1;
    RECOVERABLE: PSIHBFIR & ~PSIHBFIR_MASK & ~PSIHBFIR_ACT0 &  PSIHBFIR_ACT1;
};

group gPsiHbFir filter singlebit
{
    /** PSIHBFIR[0]
     *  PB_ECC_ERR_CE
     */
    (PsiHbFir, bit(0)) ? SelfHighThr32PerDay;

    /** PSIHBFIR[1]
     *  PB_ECC_ERR_UE
     */
    (PsiHbFir, bit(1)) ? SelfHighThr1;

    /** PSIHBFIR[2]
     *  PB_ECC_ERR_SUE
     */
    (PsiHbFir, bit(2)) ? defaultMaskedError;

    /** PSIHBFIR[3]
     *  INTERRUPT_FROM_ERROR
     */
    (PsiHbFir, bit(3)) ? defaultMaskedError;

    /** PSIHBFIR[4]
     *  INTERRUPT_FROM_FSP
     */
    (PsiHbFir, bit(4)) ? defaultMaskedError;

    /** PSIHBFIR[5]
     *  FSP_ECC_ERR_CE
     */
    (PsiHbFir, bit(5)) ? calloutPsiThr32;

    /** PSIHBFIR[6]
     *  FSP_ECC_ERR_UE
     */
    (PsiHbFir, bit(6)) ? calloutPsiThr1;

    /** PSIHBFIR[7]
     *  ERROR_STATE
     */
    (PsiHbFir, bit(7)) ? defaultMaskedError;

    /** PSIHBFIR[8]
     *  INVALID_TTYPE
     */
    (PsiHbFir, bit(8)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[9]
     *  INVALID_CRESP
     */
    (PsiHbFir, bit(9)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[10]
     *  PB_DATA_TIME_OUT
     */
    (PsiHbFir, bit(10)) ? callout2ndLvlMedThr1NoGard;

    /** PSIHBFIR[11]
     *  PB_PARITY_ERROR
     */
    (PsiHbFir, bit(11)) ? callout2ndLvlMedThr1NoGard;

    /** PSIHBFIR[12]
     *  FSP_ACCESS_TRUSTED_SPACE
     */
    (PsiHbFir, bit(12)) ? callout2ndLvlMedThr1NoGard;

    /** PSIHBFIR[13]
     *  UNEXPECTED_PB
     */
    (PsiHbFir, bit(13)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[14]
     *  INTERRUPT_REG_CHANGE_WHILE_ACTIVE
     */
    (PsiHbFir, bit(14)) ? defaultMaskedError;

    /** PSIHBFIR[15]
     *  INTERRUPT0_ADDRESS_ERROR
     */
    (PsiHbFir, bit(15)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[16]
     *  INTERRUPT1_ADDRESS_ERROR
     */
    (PsiHbFir, bit(16)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[17]
     *  INTERRUPT2_ADDRESS_ERROR
     */
    (PsiHbFir, bit(17)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[18]
     *  INTERRUPT3_ADDRESS_ERROR
     */
    (PsiHbFir, bit(18)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[19]
     *  INTERRUPT4_ADDRESS_ERROR
     */
    (PsiHbFir, bit(19)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[20]
     *  INTERRUPT5_ADDRESS_ERROR
     */
    (PsiHbFir, bit(20)) ? calloutProcLevel2MedThr1dumpShNoGard;

    /** PSIHBFIR[21]
     *  TCBR_TP_PSI_GLB_ERR_0
     */
    #FIXME RTC 23127 Need to get validation from Rolf Fitz
    (PsiHbFir, bit(21)) ? defaultMaskedError;

    /** PSIHBFIR[22]
     *  TCBR_TP_PSI_GLB_ERR_1
     */
    (PsiHbFir, bit(22)) ? defaultMaskedError;

    /** PSIHBFIR[23]
     *  UPSTREAM_FIR
     */
    (PsiHbFir, bit(23)) ? calloutProcLevel2MedThr32dumpShNoGard;

    /** PSIHBFIR[24|25|26]
     *  SPARE_FIR
     */
    (PsiHbFir, bit(24|25|26)) ? defaultMaskedError;

    /** PSIHBFIR[27]
     *  SCOM_ERROR
     */
    (PsiHbFir, bit(27)) ? defaultMaskedError;

    /** PSIHBFIR[28]
     *  FIR_PARITY_ERROR
     */
    (PsiHbFir, bit(28)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet ICPFIR
################################################################################

#Based on p8dd1_mss_FFDC_70.xls
rule IcpFir
{
    CHECK_STOP:  ICPFIR & ~ICPFIR_MASK & ~ICPFIR_ACT0 & ~ICPFIR_ACT1;
    RECOVERABLE: ICPFIR & ~ICPFIR_MASK & ~ICPFIR_ACT0 &  ICPFIR_ACT1;
};

group gIcpFir filter singlebit
{
    /** ICPFIR[0]
     *  INT_HW_ERROR_EOI_Q
     */
    (IcpFir, bit(0)) ? SelfMedThr1;

    /** ICPFIR[1]
     *  INT_HW_ERROR_FWD_Q
     */
    (IcpFir, bit(1)) ? SelfMedThr1;

    /** ICPFIR[2]
     *  INT_HW_ERROR_IR_QU
     */
    (IcpFir, bit(2)) ? SelfMedThr1;

    /** ICPFIR[3]
     *  INT_HW_ERROR_RET_Q
     */
    (IcpFir, bit(3)) ? SelfMedThr32PerDay;

    /** ICPFIR[4]
     *  INT_HW_ERROR_ADDRI
     */
    (IcpFir, bit(4)) ? defaultMaskedError;

    /** ICPFIR[5]
     *  INT_HW_ERROR_DATAI
     */
    (IcpFir, bit(5)) ? SelfMedThr32PerDay;

    /** ICPFIR[6]
     *  INT_HW_ERROR_ADDRO
     */
    (IcpFir, bit(6)) ? SelfMedThr32PerDay;

    /** ICPFIR[7]
     *  INT_HW_ERROR_DATAO
     */
    (IcpFir, bit(7)) ? SelfMedThr32PerDay;

    /** ICPFIR[8]
     *  INT_HW_ERROR_LDSTQ
     */
    (IcpFir, bit(8)) ? SelfMedThr32PerDay;

    /** ICPFIR[9]
     *  INT_HW_ERROR_REQQ
     */
    (IcpFir, bit(9)) ? SelfMedThr32PerDay;

    /** ICPFIR[10]
     *  SCOM_REG_CHECK
     */
    (IcpFir, bit(10)) ? SelfMedThr32PerDay;

    /** ICPFIR[11]
     *  LOOP IN CHAIN OF LINK REGISTER OR INVALID CORE ID
     */
    (IcpFir, bit(11)) ? defaultMaskedError;

    /** ICPFIR[12]
     *  INVALID CORE NUMBER IN INTERRUPT COMMANDS
     */
    (IcpFir, bit(12)) ? defaultMaskedError;

    /** ICPFIR[13]
     *  INVALID CORE NUMBER IN MMIO COMMANDS
     */
    (IcpFir, bit(13)) ? defaultMaskedError;

    /** ICPFIR[14]
     *  UNSOLICITED_CRESP
     */
    (IcpFir, bit(14)) ? defaultMaskedError;

    /** ICPFIR[15]
     *  UNSOLICITED_DATA
     */
    (IcpFir, bit(15)) ? defaultMaskedError;

    /** ICPFIR[16]
     *  INVALID_CMD
     */
    (IcpFir, bit(16)) ? defaultMaskedError;

    /** ICPFIR[17]
     *  INVALID_CRESPZ
     */
    (IcpFir, bit(17)) ? defaultMaskedError;

    /** ICPFIR[18]
     *  INVALID_CRESP
     */
    (IcpFir, bit(18)) ? defaultMaskedError;

    /** ICPFIR[19]
     *  Reserved field (Access type is reserved)
     */
    (IcpFir, bit(19)) ? defaultMaskedError;

    /** ICPFIR[20]
     *  ECC_CE_ON_DATA
     */
    (IcpFir, bit(20)) ? SelfMedThr32PerDay;

    /** ICPFIR[21]
     *  ECC_UE_ON_DATA
     */
    (IcpFir, bit(21)) ? SelfMedThr32PerDay;

    /** ICPFIR[22]
     *  ECC_SUE_ON_DATA
     */
    (IcpFir, bit(22)) ? SelfMedThr32PerDay;

    /** ICPFIR[23]
     *  PARITY_CHK_ADDRESS
     */
    (IcpFir, bit(23)) ? SelfMedThr32PerDay;

    /** ICPFIR[24]
     *  PARITY_CHK_TAG
     */
    (IcpFir, bit(24)) ? SelfMedThr32PerDay;

    /** ICPFIR[25]
     *  TIMEOUT_LD_STQ
     */
    (IcpFir, bit(25)) ? SelfMedThr32PerDay;

    /** ICPFIR[26]
     *  TIMEOUT_RETURNQ
     */
    (IcpFir, bit(26)) ? SelfMedThr32PerDay;

    /** ICPFIR[27]
     *  TIMEOUT_FWDQ
     */
    (IcpFir, bit(27)) ? SelfMedThr32PerDay;

    /** ICPFIR[28]
     *  TIMEOUT_EOIQ
     */
    (IcpFir, bit(28)) ? SelfMedThr32PerDay;

    /** ICPFIR[29]
     *  RESERVED
     */
    (IcpFir, bit(29)) ? SelfMedThr32PerDay;

    /** ICPFIR[30]
     *  RESERVED
     */
    (IcpFir, bit(30)) ? SelfMedThr32PerDay;

    /** ICPFIR[31]
     *  RESERVED
     */
    (IcpFir, bit(31)) ? defaultMaskedError;

    /** ICPFIR[32]
     *  EXT_TRACE_0
     */
    (IcpFir, bit(32)) ? SelfMedThr32PerDay;

    /** ICPFIR[33]
     *  EXT_TRACE_1
     */
    (IcpFir, bit(33)) ? SelfMedThr32PerDay;

    /** ICPFIR[34]
     *  ADU_RECOV
     */
    (IcpFir, bit(34)) ? SelfMedThr32PerDay;

    /** ICPFIR[35]
     *  EXT_XSTOP
     */
    (IcpFir, bit(35)) ? SelfMedThr32PerDay;

    /** ICPFIR[36:37]
     *  Reserved
     */
    (IcpFir, bit(36|37)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet PBAFIR
################################################################################

rule PbaFir
{
    CHECK_STOP:  PBAFIR & ~PBAFIR_MASK & ~PBAFIR_ACT0 & ~PBAFIR_ACT1;
    RECOVERABLE: PBAFIR & ~PBAFIR_MASK & ~PBAFIR_ACT0 &  PBAFIR_ACT1;
};

group gPbaFir filter singlebit
{
    /** PBAFIR[0]
     *  PBAFIR_OCI_APAR_ERR
     */
    (PbaFir, bit(0)) ? SelfHighThr1;

    /** PBAFIR[1]
     *  PBAFIR_PB_RDADRERR_FW
     */
    (PbaFir, bit(1)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[2]
     *  PBAFIR_PB_RDDATATO_FW
     */
    (PbaFir, bit(2)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[3]
     *  PBAFIR_PB_SUE_FW
     */
    (PbaFir, bit(3)) ? callout2ndLvlMedThr32NoGard;

    /** PBAFIR[4]
     *  PBAFIR_PB_UE_FW
     */
    (PbaFir, bit(4)) ? SelfHighThr1;

    /** PBAFIR[3:4]
     *  PBAFIR_PB_SUE_FW
     */
    (PbaFir, bit(3,4)) ? callout2ndLvlMedThr32NoGard;

    /** PBAFIR[5]
     *  PBAFIR_PB_CE_FW
     */
    (PbaFir, bit(5)) ? callout2ndLvlMedThr32NoGard;

    /** PBAFIR[6]
     *  PBAFIR_OCI_SLAVE_INIT
     */
    (PbaFir, bit(6)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[7]
     *  PBAFIR_OCI_WRPAR_ERR
     */
    (PbaFir, bit(7)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[8]
     *  PBAFIR_OCI_REREQTO
     */
    (PbaFir, bit(8)) ? defaultMaskedError;

    /** PBAFIR[9]
     *  PBAFIR_PB_UNEXPCRESP
     */
    (PbaFir, bit(9)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[10]
     *  PBAFIR_PB_UNEXPDATA
     */
    (PbaFir, bit(10)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[11]
     *  PBAFIR_PB_PARITY_ERR
     */
    (PbaFir, bit(11)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[12]
     *  PBAFIR_PB_WRADRERR_FW
     */
    (PbaFir, bit(12)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[13]
     *  PBAFIR_PB_BADCRESP
     */
    (PbaFir, bit(13)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[14]
     *  PBAFIR_PB_ACKDEAD_FW
     */
    (PbaFir, bit(14)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[15]
     *  PBAFIR_PB_CRESPTO
     */
    (PbaFir, bit(15)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[16:19]
     *  PBAFIR_BCUE
     */
    (PbaFir, bit(16|17|18|19)) ? defaultMaskedError;

    /** PBAFIR[20:27]
     *  PBAFIR_BCDE
     */
    (PbaFir, bit(20|21|22|23|24|25|26|27)) ? defaultMaskedError;

    /** PBAFIR[28]
     *  PBAFIR_INTERNAL_ERR
     */
    (PbaFir, bit(28)) ? SelfHighThr1;

    /** PBAFIR[29]
     *  PBAFIR_ILLEGAL_CACHE_OP
     */
    (PbaFir, bit(29)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[30]
     *  PBAFIR_OCI_BAD_REG_ADDR
     */
    (PbaFir, bit(30)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[31:39]
     *  PBAFIR_AX
     */
    (PbaFir, bit(31|32|33|34|35|36|37|38|39)) ? defaultMaskedError;

    /** PBAFIR[40]
     *  PBAFIR_PB_ACKDEAD_FW_WR
     */
    (PbaFir, bit(40)) ? callout2ndLvlMedThr1NoGard;

    /** PBAFIR[41:43]
     *  RESERVED
     */
    (PbaFir, bit(41|42|43)) ? defaultMaskedError;

    /** PBAFIR[44|45]
     *  PBAFIR_FIR_PARITY_ERR
     */
    (PbaFir, bit(44|45)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet EHHCAFIR
################################################################################
# based on p8dd1_mss_FFDC_59.xls
################################################################################
rule EhHcaFir
{
    CHECK_STOP:  EHHCAFIR & ~EHHCAFIR_MASK & ~EHHCAFIR_ACT0 & ~EHHCAFIR_ACT1;
    RECOVERABLE: EHHCAFIR & ~EHHCAFIR_MASK & ~EHHCAFIR_ACT0 &  EHHCAFIR_ACT1;
};

group gEhHcaFir filter singlebit
{
    /** EHHCAFIR[0]
     *  CE1_0_OUT: array0_a CE
     */
    (EhHcaFir, bit(0)) ? defaultMaskedError;

    /** EHHCAFIR[1]
     *  CE2_0_OUT: array0_b CE
     */
    (EhHcaFir, bit(1)) ? defaultMaskedError;

    /** EHHCAFIR[2]
     *  UE1_0_OUT: array0_a ue
     */
    (EhHcaFir, bit(2)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[3]
     *  UE2_0_OUT: array0_b ue
     */
    (EhHcaFir, bit(3)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[4]
     *  CE1_1_OUT: array1_a CE
     */
    (EhHcaFir, bit(4)) ? defaultMaskedError;

    /** EHHCAFIR[5]
     *  CE2_1_OUT: array1_b CE
     */
    (EhHcaFir, bit(5)) ? defaultMaskedError;

    /** EHHCAFIR[6]
     *  UE1_1_OUT: array1_a ue
     */
    (EhHcaFir, bit(6)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[7]
     *  UE2_1_OUT: array1_b ue
     */
    (EhHcaFir, bit(7)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[8]
     *  CE1_2_OUT: array2_a CE
     */
    (EhHcaFir, bit(8)) ? defaultMaskedError;

    /** EHHCAFIR[9]
     *  CE2_2_OUT: array2_b CE
     */
    (EhHcaFir, bit(9)) ? defaultMaskedError;

    /** EHHCAFIR[10]
     *  UE1_2_OUT: array2_a ue
     */
    (EhHcaFir, bit(10)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[11]
     *  UE2_2_OUT: array2_b ue
     */
    (EhHcaFir, bit(11)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[12]
     *  CE1_3_OUT: array3_a CE
     */
    (EhHcaFir, bit(12)) ? defaultMaskedError;

    /** EHHCAFIR[13]
     *  CE2_3_OUT: array3_b CE
     */
    (EhHcaFir, bit(13)) ? defaultMaskedError;

    /** EHHCAFIR[14]
     *  UE1_3_OUT: array3_a ue
     */
    (EhHcaFir, bit(14)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[15]
     *  UE2_3_OUT: array3_b ue
     */
    (EhHcaFir, bit(15)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[16]
     *  CE1_4_OUT: array4_a CE
     */
    (EhHcaFir, bit(16)) ? defaultMaskedError;

    /** EHHCAFIR[17]
     *  CE2_4_OUT: array4_b CE
     */
    (EhHcaFir, bit(17)) ? defaultMaskedError;

    /** EHHCAFIR[18]
     *  UE1_4_OUT: array4_a ue
     */
    (EhHcaFir, bit(18)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[19]
     *  UE2_4_OUT: array4_b ue
     */
    (EhHcaFir, bit(19)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[20]
     *  CE1_5_OUT: array5_a CE
     */
    (EhHcaFir, bit(20)) ? defaultMaskedError;

    /** EHHCAFIR[21]
     *  CE2_5_OUT: array5_b CE
     */
    (EhHcaFir, bit(21)) ? defaultMaskedError;

    /** EHHCAFIR[22]
     *  UE1_5_OUT: array5_a ue
     */
    (EhHcaFir, bit(22)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[23]
     *  UE2_5_OUT: array5_b ue
     */
    (EhHcaFir, bit(23)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[24]
     *  CE1_6_OUT: array6_a CE
     */
    (EhHcaFir, bit(24)) ? defaultMaskedError;

    /** EHHCAFIR[25]
     *  CE2_6_OUT: array6_b CE
     */
    (EhHcaFir, bit(25)) ? defaultMaskedError;

    /** EHHCAFIR[26]
     *  UE1_6_OUT: array6_a ue
     */
    (EhHcaFir, bit(26)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[27]
     *  UE2_6_OUT: array6_b ue
     */
    (EhHcaFir, bit(27)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[28]
     *  CE1_7_OUT: array7_a CE
     */
    (EhHcaFir, bit(28)) ? defaultMaskedError;

    /** EHHCAFIR[29]
     *  CE2_7_OUT: array7_b CE
     */
    (EhHcaFir, bit(29)) ? defaultMaskedError;

    /** EHHCAFIR[30]
     *  UE1_7_OUT: array7_a ue
     */
    (EhHcaFir, bit(30)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[31]
     *  UE2_7_OUT: array7_b ue
     */
    (EhHcaFir, bit(31)) ? SelfHighThr32PerDay;

    /** EHHCAFIR[32]
     *  DROP_COUNTER_FULL: Drop Counter Full
     */
    (EhHcaFir, bit(32)) ? defaultMaskedError;

    /** EHHCAFIR[33]
     *  INTERNAL_ERROR: Internal Error
     */
    (EhHcaFir, bit(33)) ? defaultMaskedError;

    /** EHHCAFIR[34]
     *  SCOM_ERROR
     */
    (EhHcaFir, bit(34)) ? defaultMaskedError;

    /** EHHCAFIR[35]
     *  FIR_PARITY_ERROR
     */
    (EhHcaFir, bit(35)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet ENHCAFIR
################################################################################
#action updated based on p8dd1_mss_FFDC_59.xls
################################################################################

rule EnHcaFir
{
    CHECK_STOP:  ENHCAFIR & ~ENHCAFIR_MASK & ~ENHCAFIR_ACT0 & ~ENHCAFIR_ACT1;
    RECOVERABLE: ENHCAFIR & ~ENHCAFIR_MASK & ~ENHCAFIR_ACT0 &  ENHCAFIR_ACT1;
};

group gEnHcaFir filter singlebit
{
    /** ENHCAFIR[0]
     *  DPX0_DAT_UE: PB0 data UE
     */
    (EnHcaFir, bit(0)) ? SelfHighThr32PerDay;

    /** ENHCAFIR[1]
     *  DPX0_DAT_SUE: PB0 data SUE
     */
    (EnHcaFir, bit(1)) ? defaultMaskedError;

    /** ENHCAFIR[2]
     *  DPX0_DAT_CE: PB0 data ue
     */
    (EnHcaFir, bit(2)) ? SelfHighThr32PerDay;

    /** ENHCAFIR[3]
     *  Undefined
     */
    (EnHcaFir, bit(3)) ? defaultMaskedError;

    /** ENHCAFIR[4]
     *  CO_DROP_COUNTER_FULL: Castout Drop Counter Full
     */
    (EnHcaFir, bit(4)) ? defaultMaskedError;

    /** ENHCAFIR[5]
     *  DATA_HANG_DETECT: Castout Drop Counter Full
     */
    (EnHcaFir, bit(5)) ? defaultMaskedError;

    /** ENHCAFIR[6]
     *  UNEXPECTED_DATA_OR_CRESP: Castout Drop Counter Full
     */
    (EnHcaFir, bit(6)) ? defaultMaskedError;

    /** ENHCAFIR[7]
     *  INTERNAL_ERROR: Castout Drop Counter Full
     */
    (EnHcaFir, bit(7)) ? defaultMaskedError;

    /** ENHCAFIR[8]
     *  SCOM_ERROR
     */
    (EnHcaFir, bit(8)) ? defaultMaskedError;

    /** ENHCAFIR[9]
     *  FIR_PARITY_ERROR
     */
    (EnHcaFir, bit(9)) ? defaultMaskedError;
};

# PB Chiplet PCINESTFIRs
################################################################################

#        All these FIRs should have the same bit definition. Ideally, we want
#        to have only one copy of the bit definition. Currently rule code
#        parser does not have the support for something like this.
#        Maybe we can add this as a later feature.

################################################################################
# FIR last updated based on p8dd1_mss_FFDC_37_ reviewd.xls
################################################################################
rule PciNestFir_0
{
  CHECK_STOP:
    PCINESTFIR_0 & ~PCINESTFIR_0_MASK & ~PCINESTFIR_0_ACT0 & ~PCINESTFIR_0_ACT1;
  RECOVERABLE:
    PCINESTFIR_0 & ~PCINESTFIR_0_MASK & ~PCINESTFIR_0_ACT0 &  PCINESTFIR_0_ACT1;
};

rule PciNestFir_1
{
  CHECK_STOP:
    PCINESTFIR_1 & ~PCINESTFIR_1_MASK & ~PCINESTFIR_1_ACT0 & ~PCINESTFIR_1_ACT1;
  RECOVERABLE:
    PCINESTFIR_1 & ~PCINESTFIR_1_MASK & ~PCINESTFIR_1_ACT0 &  PCINESTFIR_1_ACT1;
};

rule PciNestFir_2
{
  CHECK_STOP:
    PCINESTFIR_2 & ~PCINESTFIR_2_MASK & ~PCINESTFIR_2_ACT0 & ~PCINESTFIR_2_ACT1;
  RECOVERABLE:
    PCINESTFIR_2 & ~PCINESTFIR_2_MASK & ~PCINESTFIR_2_ACT0 &  PCINESTFIR_2_ACT1;
};

group gPciNestFir filter singlebit
{
    /** PCINESTFIR_0[0]
     *  BAR_PE
     */
    (PciNestFir_0, bit(0)) ? calloutConnPci0Th1NoGard;

    /** PCINESTFIR_1[0]
     *  BAR_PE
     */
    (PciNestFir_1, bit(0)) ? calloutConnPci1Th1NoGard;

    /** PCINESTFIR_2[0]
     *  BAR_PE
     */
    (PciNestFir_2, bit(0)) ? calloutConnPci2Th1NoGard;

    /** PCINESTFIR_0[1]
     *  NONBAR_PE
     */
    (PciNestFir_0, bit(1)) ? defaultMaskedError;

    /** PCINESTFIR_1[1]
     *  NONBAR_PE
     */
    (PciNestFir_1, bit(1)) ? defaultMaskedError;

    /** PCINESTFIR_2[1]
     *  NONBAR_PE
     */
    (PciNestFir_2, bit(1)) ? defaultMaskedError;

    /** PCINESTFIR_0[2]
     *  PB_TO_PEC_CE
     */
    (PciNestFir_0, bit(2)) ? calloutConnPci0Th32NoGard;

    /** PCINESTFIR_1[2]
     *  PB_TO_PEC_CE
     */
    (PciNestFir_1, bit(2)) ? calloutConnPci1Th32NoGard;

    /** PCINESTFIR_2[2]
     *  PB_TO_PEC_CE
     */
    (PciNestFir_2, bit(2)) ? calloutConnPci1Th32NoGard;

    /** PCINESTFIR_0[3]
     *  PB_TO_PEC_UE
     */
    (PciNestFir_0, bit(3)) ? defaultMaskedError;

    /** PCINESTFIR_1[3]
     *  PB_TO_PEC_UE
     */
    (PciNestFir_1, bit(3)) ? defaultMaskedError;

    /** PCINESTFIR_2[3]
     *  PB_TO_PEC_UE
     */
    (PciNestFir_2, bit(3)) ? defaultMaskedError;

    /** PCINESTFIR_0[4]
     *  PB_TO_PEC_SUE
     */
    (PciNestFir_0, bit(4)) ? defaultMaskedError;

    /** PCINESTFIR_1[4]
     *  PB_TO_PEC_SUE
     */
    (PciNestFir_1, bit(4)) ? defaultMaskedError;

    /** PCINESTFIR_2[4]
     *  PB_TO_PEC_SUE
     */
    (PciNestFir_2, bit(4)) ? defaultMaskedError;

    /** PCINESTFIR_0[5]
     *  ARY_ECC_CE
     */
    (PciNestFir_0, bit(5)) ? calloutConnPci0Th32NoGard;

    /** PCINESTFIR_1[5]
     *  ARY_ECC_CE
     */
    (PciNestFir_1, bit(5)) ? calloutConnPci1Th32NoGard;

    /** PCINESTFIR_2[5]
     *  ARY_ECC_CE
     */
    (PciNestFir_2, bit(5)) ? calloutConnPci2Th32NoGard;

    /** PCINESTFIR_0[6]
     *  ARY_ECC_UE
     */
    (PciNestFir_0, bit(6)) ? defaultMaskedError;

    /** PCINESTFIR_1[6]
     *  ARY_ECC_UE
     */
    (PciNestFir_1, bit(6)) ? defaultMaskedError;

    /** PCINESTFIR_2[6]
     *  ARY_ECC_UE
     */
    (PciNestFir_2, bit(6)) ? defaultMaskedError;

    /** PCINESTFIR_0[7]
     *  ARY_ECC_SUE
     */
    (PciNestFir_0, bit(7)) ? defaultMaskedError;

    /** PCINESTFIR_1[7]
     *  ARY_ECC_SUE
     */
    (PciNestFir_1, bit(7)) ? defaultMaskedError;

    /** PCINESTFIR_2[7]
     *  ARY_ECC_SUE
     */
    (PciNestFir_2, bit(7)) ? defaultMaskedError;

    /** PCINESTFIR_0[8]
     *  REGISTER_ARRAY_PE
     */
    (PciNestFir_0, bit(8)) ? calloutConnPci0Th1NoGard;

    /** PCINESTFIR_1[8]
     *  REGISTER_ARRAY_PE
     */
    (PciNestFir_1, bit(8)) ? calloutConnPci1Th1NoGard;

    /** PCINESTFIR_2[8]
     *  REGISTER_ARRAY_PE
     */
    (PciNestFir_2, bit(8)) ? calloutConnPci2Th1NoGard;

    /** PCINESTFIR_0[9]
     *  PB_INTERFACE_PE
     */
    (PciNestFir_0, bit(9)) ? calloutConnPci0Th1NoGard;

    /** PCINESTFIR_1[9]
     *  PB_INTERFACE_PE
     */
    (PciNestFir_1, bit(9)) ? calloutConnPci1Th1NoGard;

    /** PCINESTFIR_2[9]
     *  PB_INTERFACE_PE
     */
    (PciNestFir_2, bit(9)) ? calloutConnPci2Th1NoGard;

    /** PCINESTFIR_0[10]
     *  PB_DATA_HANG_ERRORS
     */
    (PciNestFir_0, bit(10)) ? defaultMaskedError;

    /** PCINESTFIR_1[10]
     *  PB_DATA_HANG_ERRORS
     */
    (PciNestFir_1, bit(10)) ? defaultMaskedError;

    /** PCINESTFIR_2[10]
     *  PB_DATA_HANG_ERRORS
     */
    (PciNestFir_2, bit(10)) ? defaultMaskedError;

    /** PCINESTFIR_0[11]
     *  PB_HANG_ERRORS
     */
    (PciNestFir_0, bit(11)) ? defaultMaskedError;

    /** PCINESTFIR_1[11]
     *  PB_HANG_ERRORS
     */
    (PciNestFir_1, bit(11)) ? defaultMaskedError;

    /** PCINESTFIR_2[11]
     *  PB_HANG_ERRORS
     */
    (PciNestFir_2, bit(11)) ? defaultMaskedError;

    /** PCINESTFIR_0[12]
     *  RD_ARE_ERRORS
     */
    (PciNestFir_0, bit(12)) ? defaultMaskedError;

    /** PCINESTFIR_1[12]
     *  RD_ARE_ERRORS
     */
    (PciNestFir_1, bit(12)) ? defaultMaskedError;

    /** PCINESTFIR_2[12]
     *  RD_ARE_ERRORS
     */
    (PciNestFir_2, bit(12)) ? defaultMaskedError;

    /** PCINESTFIR_0[13]
     *  NONRD_ARE_ERRORS
     */
    (PciNestFir_0, bit(13)) ? defaultMaskedError;

    /** PCINESTFIR_1[13]
     *  NONRD_ARE_ERRORS
     */
    (PciNestFir_1, bit(13)) ? defaultMaskedError;

    /** PCINESTFIR_2[13]
     *  NONRD_ARE_ERRORS
     */
    (PciNestFir_2, bit(13)) ? defaultMaskedError;

    /** PCINESTFIR_0[14]
     *  PCI_HANG_ERROR
     */
    (PciNestFir_0, bit(14)) ? defaultMaskedError;

    /** PCINESTFIR_1[14]
     *  PCI_HANG_ERROR
     */
    (PciNestFir_1, bit(14)) ? defaultMaskedError;

    /** PCINESTFIR_2[14]
     *  PCI_HANG_ERROR
     */
    (PciNestFir_2, bit(14)) ? defaultMaskedError;

    /** PCINESTFIR_0[15]
     *  PCI_CLOCK_ERROR
     *
     *  These should never trigger directly themselves.
     *  Should be handled by global PRD PLL code.
     */
    (PciNestFir_0, bit(15)) ? threshold32pday;

    /** PCINESTFIR_1[15]
     *  PCI_CLOCK_ERROR
     *
     *  These should never trigger directly themselves.
     *  Should be handled by global PRD PLL code.
     */
    (PciNestFir_1, bit(15)) ? threshold32pday;

    /** PCINESTFIR_2[15]
     *  PCI_CLOCK_ERROR
     *
     *  These should never trigger directly themselves.
     *  Should be handled by global PRD PLL code.
     */
    (PciNestFir_2, bit(15)) ? threshold32pday;

    /** PCINESTFIR_0[16]
     *  AIB_FENCE
     */
    (PciNestFir_0, bit(16)) ? defaultMaskedError;

    /** PCINESTFIR_1[16]
     *  AIB_FENCE
     */
    (PciNestFir_1, bit(16)) ? defaultMaskedError;

    /** PCINESTFIR_2[16]
     *  AIB_FENCE
     */
    (PciNestFir_2, bit(16)) ? defaultMaskedError;

    /** PCINESTFIR_0[17]
     *  HW_ERRORS
     */
    (PciNestFir_0, bit(17)) ? calloutConnPci0Th1NoGard;

    /** PCINESTFIR_1[17]
     *  HW_ERRORS
     */
    (PciNestFir_1, bit(17)) ? calloutConnPci1Th1NoGard;

    /** PCINESTFIR_2[17]
     *  HW_ERRORS
     */
    (PciNestFir_2, bit(17)) ? calloutConnPci2Th1NoGard;

    /** PCINESTFIR_0[18]
     *  UNSOLICITIEDPBDATA
     */
    (PciNestFir_0, bit(18)) ? callout2ndLvlMedThr1NoGard;

    /** PCINESTFIR_1[18]
     *  UNSOLICITIEDPBDATA
     */
    (PciNestFir_1, bit(18)) ? callout2ndLvlMedThr1NoGard;

    /** PCINESTFIR_2[18]
     *  UNSOLICITIEDPBDATA
     */
    (PciNestFir_2, bit(18)) ? callout2ndLvlMedThr1NoGard;

    /** PCINESTFIR_0[19]
     *  UNEXPECTEDCRESP
     */
    (PciNestFir_0, bit(19)) ? callout2ndLvlMedThr1NoGard;

    /** PCINESTFIR_1[19]
     *  UNEXPECTEDCRESP
     */
    (PciNestFir_1, bit(19)) ? callout2ndLvlMedThr1NoGard;

    /** PCINESTFIR_2[19]
     *  UNEXPECTEDCRESP
     */
    (PciNestFir_2, bit(19)) ? callout2ndLvlMedThr1NoGard;

    /** PCINESTFIR_0[20]
     *  INVALIDCRESP
     */
    (PciNestFir_0, bit(20)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_1[20]
     *  INVALIDCRESP
     */
    (PciNestFir_1, bit(20)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_2[20]
     *  INVALIDCRESP
     */
    (PciNestFir_2, bit(20)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_0[21]
     *  PBUNSUPPORTEDSIZE
     */
    (PciNestFir_0, bit(21)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_1[21]
     *  PBUNSUPPORTEDSIZE
     */
    (PciNestFir_1, bit(21)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_2[21]
     *  PBUNSUPPORTEDSIZE
     */
    (PciNestFir_2, bit(21)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_0[22]
     *  PBUNSUPPORTEDCMD
     */
    (PciNestFir_0, bit(22)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_1[22]
     *  PBUNSUPPORTEDCMD
     */
    (PciNestFir_1, bit(22)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_2[22]
     *  PBUNSUPPORTEDCMD
     */
    (PciNestFir_2, bit(22)) ? calloutProcLevel2MedThr1;

    /** PCINESTFIR_0[23]
     *  AIB_PE
     */
    (PciNestFir_0, bit(23)) ? defaultMaskedError;

    /** PCINESTFIR_1[23]
     *  AIB_PE
     */
    (PciNestFir_1, bit(23)) ? defaultMaskedError;

    /** PCINESTFIR_2[23]
     *  AIB_PE
     */
    (PciNestFir_2, bit(23)) ? defaultMaskedError;

    /** PCINESTFIR_0[24]
     *  ASB_ERROR
     */
    (PciNestFir_0, bit(24)) ? defaultMaskedError;

    /** PCINESTFIR_1[24]
     *  ASB_ERROR
     */
    (PciNestFir_1, bit(24)) ? defaultMaskedError;

    /** PCINESTFIR_2[24]
     *  ASB_ERROR
     */
    (PciNestFir_2, bit(24)) ? defaultMaskedError;

    /** PCINESTFIR_0[25]
     *  FOREIGN_LINK_FAIL
     */
    (PciNestFir_0, bit(25)) ? defaultMaskedError;

    /** PCINESTFIR_1[25]
     *  FOREIGN_LINK_FAIL
     */
    (PciNestFir_1, bit(25)) ? defaultMaskedError;

    /** PCINESTFIR_2[25]
     *  FOREIGN_LINK_FAIL
     */
    (PciNestFir_2, bit(25)) ? defaultMaskedError;

    /** PCINESTFIR_0[26]
     *  FOREIGN_PB_HANG
     */
    (PciNestFir_0, bit(26)) ? defaultMaskedError;

    /** PCINESTFIR_1[26]
     *  FOREIGN_PB_HANG
     */
    (PciNestFir_1, bit(26)) ? defaultMaskedError;

    /** PCINESTFIR_2[26]
     *  FOREIGN_PB_HANG
     */
    (PciNestFir_2, bit(26)) ? defaultMaskedError;

    /** PCINESTFIR_0[27]
     *  CAPP_ERROR
     */
    (PciNestFir_0, bit(27)) ? defaultMaskedError;

    /** PCINESTFIR_1[27]
     *  CAPP_ERROR
     */
    (PciNestFir_1, bit(27)) ? defaultMaskedError;

    /** PCINESTFIR_2[27]
     *  CAPP_ERROR
     */
    (PciNestFir_2, bit(27)) ? defaultMaskedError;

    /** PCINESTFIR_0[28]
     *  SYNC_SCOM_ERR
     */
    (PciNestFir_0, bit(28)) ? defaultMaskedError;

    /** PCINESTFIR_1[28]
     *  SYNC_SCOM_ERR
     */
    (PciNestFir_1, bit(28)) ? defaultMaskedError;

    /** PCINESTFIR_2[28]
     *  SYNC_SCOM_ERR
     */
    (PciNestFir_2, bit(28)) ? defaultMaskedError;

    /** PCINESTFIR_0[29]
     *  SCOM Engine ERROR 0
     */
    (PciNestFir_0, bit(29)) ? defaultMaskedError;

    /** PCINESTFIR_1[29]
     *  SCOM Engine ERROR 0
     */
    (PciNestFir_1, bit(29)) ? defaultMaskedError;

    /** PCINESTFIR_2[29]
     *  SCOM Engine ERROR 0
     */
    (PciNestFir_2, bit(29)) ? defaultMaskedError;

    /** PCINESTFIR_0[30]
     *  SCOM Engine ERROR 0
     */
    (PciNestFir_0, bit(30)) ? defaultMaskedError;

    /** PCINESTFIR_1[30]
     *  SCOM Engine ERROR 1
     */
    (PciNestFir_1, bit(30)) ? defaultMaskedError;

    /** PCINESTFIR_2[30]
     *  SCOM Engine ERROR 1
     */
    (PciNestFir_2, bit(30)) ? defaultMaskedError;

};

################################################################################
# PB Chiplet IOMCFIR_0
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_37_ reviewd.xls

rule IomcFir_0
{
  CHECK_STOP:  IOMCFIR_0 & ~IOMCFIR_0_MASK & ~IOMCFIR_0_ACT0 & ~IOMCFIR_0_ACT1;
  RECOVERABLE: IOMCFIR_0 & ~IOMCFIR_0_MASK & ~IOMCFIR_0_ACT0 &  IOMCFIR_0_ACT1;
};

group gIomcFir_0 filter priority( 10, 18, 26, 34,   # Channel failure
                                   2,               # Recoverable
                                  11, 19, 27, 35,   # Recoverable
                                  12, 20, 28, 36,   # Recoverable
                                   9, 17, 25, 33  ) # Recoverable
{
    /** IOMCFIR_0[0]
     *  FIR_RX_INVALID_STATE_OR_PARITY_ERROR
     */
    (IomcFir_0, bit(0)) ? defaultMaskedError;

    /** IOMCFIR_0[1]
     *  FIR_TX_INVALID_STATE_OR_PARITY_ERROR
     */
    (IomcFir_0, bit(1)) ? defaultMaskedError;

    /** IOMCFIR_0[2]
     *  FIR_GCR_HANG_ERROR
     */
    (IomcFir_0, bit(2)) ? SelfHighThr1;

    /** IOMCFIR_0[3:7]
     *  Reserved
     */
    (IomcFir_0, bit(3|4|5|6|7)) ? defaultMaskedError;

    /** IOMCFIR_0[8]
     *  MCS0 Training Error
     */
    (IomcFir_0, bit(8)) ? defaultMaskedError;

    /** IOMCFIR_0[9]
     *  MCS0 Spare Deployed
     */
    (IomcFir_0, bit(9)) ? spareDeployed_dmiBus0;

    /** IOMCFIR_0[10]
     *  MCS0 Max Spares Exceeded
     */
    (IomcFir_0, bit(10)) ? maxSparesExceeded_dmiBus0;

    /** IOMCFIR_0[11]
     *  MCS0 Recalibration or Dynamic Repair Error
     */
    (IomcFir_0, bit(11)) ? calloutDmiBus0Th1;

    /** IOMCFIR_0[12]
     *  MCS0 Too Many Bus Errors
     */
    (IomcFir_0, bit(12)) ? calloutDmiBus0Th1;

    /** IOMCFIR_0[13:15]
     *  Reserved
     */
    (IomcFir_0, bit(13|14|15)) ? defaultMaskedError;

    /** IOMCFIR_0[16]
     *  MCS1 Training Error
     */
    (IomcFir_0, bit(16)) ? defaultMaskedError;

    /** IOMCFIR_0[17]
     *  MCS1 Spare Deployed
     */
    (IomcFir_0, bit(17)) ? spareDeployed_dmiBus1;

    /** IOMCFIR_0[18]
     *  MCS1 Max Spares Exceeded
     */
    (IomcFir_0, bit(18)) ? maxSparesExceeded_dmiBus1;

    /** IOMCFIR_0[19]
     *  MCS1 Recalibration or Dynamic Repair Error
     */
    (IomcFir_0, bit(19)) ? calloutDmiBus1Th1;

    /** IOMCFIR_0[20]
     *  MCS1 Too Many Bus Errors
     */
    (IomcFir_0, bit(20)) ? calloutDmiBus1Th1;

    /** IOMCFIR_0[21:23]
     *  Reserved
     */
    (IomcFir_0, bit(21|22|23)) ? defaultMaskedError;

    /** IOMCFIR_0[24]
     *  MCS2 Training Error
     */
    (IomcFir_0, bit(24)) ? defaultMaskedError;

    /** IOMCFIR_0[25]
     *  MCS2 Spare Deployed
     */
    (IomcFir_0, bit(25)) ? spareDeployed_dmiBus2;

    /** IOMCFIR_0[26]
     *  MCS2 Max Spares Exceeded
     */
    (IomcFir_0, bit(26)) ? maxSparesExceeded_dmiBus2;

    /** IOMCFIR_0[27]
     *  MCS2 Recalibration or Dynamic Repair Error
     */
    (IomcFir_0, bit(27)) ? calloutDmiBus2Th1;

    /** IOMCFIR_0[28]
     *  MCS2 Too Many Bus Errors
     */
    (IomcFir_0, bit(28)) ? calloutDmiBus2Th1;

    /** IOMCFIR_0[29:31]
     *  Reserved
     */
    (IomcFir_0, bit(29|30|31)) ? defaultMaskedError;

    /** IOMCFIR_0[32]
     *  MCS3 Training Error
     */
    (IomcFir_0, bit(32)) ? defaultMaskedError;

    /** IOMCFIR_0[33]
     *  MCS3 Spare Deployed
     */
    (IomcFir_0, bit(33)) ? spareDeployed_dmiBus3;

    /** IOMCFIR_0[34]
     *  MCS3 Max Spares Exceeded
     */
    (IomcFir_0, bit(34)) ? maxSparesExceeded_dmiBus3;

    /** IOMCFIR_0[35]
     *  MCS3 Recalibration or Dynamic Repair Error
     */
    (IomcFir_0, bit(35)) ? calloutDmiBus3Th1;

    /** IOMCFIR_0[36]
     *  MCS3 Too Many Bus Errors
     */
    (IomcFir_0, bit(36)) ? calloutDmiBus3Th1;

    /** IOMCFIR_0[37:39]
     *  Reserved
     */
    (IomcFir_0, bit(37|38|39)) ? defaultMaskedError;

    /** IOMCFIR_0[40:47]
     *  FIR_RX_BUS4 unused
     */
    (IomcFir_0, bit(40|41|42|43|44|45|46|47)) ? defaultMaskedError;

    /** IOMCFIR_0[48]
     *  FIR_SCOMFIR_ERROR
     */
    (IomcFir_0, bit(48)) ? defaultMaskedError;

    /** IOMCFIR_0[49]
     *  FIR_SCOMFIR_ERROR_CLONE
     */
    (IomcFir_0, bit(49)) ? defaultMaskedError;
};

################################################################################
# PB Chiplet IOMCFIR_1
################################################################################
# RAS spreadsheet: p8dd1_mss_FFDC_72_ reviewd.xls on Jan 18,2014

rule IomcFir_1
{
  CHECK_STOP:  IOMCFIR_1 & ~IOMCFIR_1_MASK & ~IOMCFIR_1_ACT0 & ~IOMCFIR_1_ACT1;
  RECOVERABLE: IOMCFIR_1 & ~IOMCFIR_1_MASK & ~IOMCFIR_1_ACT0 &  IOMCFIR_1_ACT1;
};

group gIomcFir_1 filter priority( 10, 18, 26, 34,   # Channel failure
                                   2,               # Recoverable
                                  11, 19, 27, 35,   # Recoverable
                                  12, 20, 28, 36,   # Recoverable
                                   9, 17, 25, 33  ) # Recoverable
{
    /** IOMCFIR_1[0]
     *  FIR_RX_INVALID_STATE_OR_PARITY_ERROR
     */
    (IomcFir_1, bit(0)) ? defaultMaskedError;

    /** IOMCFIR_1[1]
     *  FIR_TX_INVALID_STATE_OR_PARITY_ERROR
     */
    (IomcFir_1, bit(1)) ? defaultMaskedError;

    /** IOMCFIR_1[2]
     *  FIR_GCR_HANG_ERROR
     */
    (IomcFir_1, bit(2)) ? SelfHighThr1;

    /** IOMCFIR_1[3:7]
     *  Reserved
     */
    (IomcFir_1, bit(3|4|5|6|7)) ? defaultMaskedError;

    /** IOMCFIR_1[8]
     *  MCS4 Training Error
     */
    (IomcFir_1, bit(8)) ? defaultMaskedError;

    /** IOMCFIR_1[9]
     *  MCS4 Spare Deployed
     */
    (IomcFir_1, bit(9)) ? spareDeployed_dmiBus4;

    /** IOMCFIR_1[10]
     *  MCS4 Max Spares Exceeded
     */
    (IomcFir_1, bit(10)) ? maxSparesExceeded_dmiBus4;

    /** IOMCFIR_1[11]
     *  MCS4 Recalibration or Dynamic Repair Error
     */
    (IomcFir_1, bit(11)) ? calloutDmiBus4Th1;

    /** IOMCFIR_1[12]
     *  MCS4 Too Many Bus Errors
     */
    (IomcFir_1, bit(12)) ? calloutDmiBus4Th1;

    /** IOMCFIR_1[13:15]
     *  Reserved
     */
    (IomcFir_1, bit(13|14|15)) ? defaultMaskedError;

    /** IOMCFIR_1[16]
     *  MCS5 Training Error
     */
    (IomcFir_1, bit(16)) ? defaultMaskedError;

    /** IOMCFIR_1[17]
     *  MCS5 Spare Deployed
     */
    (IomcFir_1, bit(17)) ? spareDeployed_dmiBus5;

    /** IOMCFIR_1[18]
     *  MCS5 Max Spares Exceeded
     */
    (IomcFir_1, bit(18)) ? maxSparesExceeded_dmiBus5;

    /** IOMCFIR_1[19]
     *  MCS5 Recalibration or Dynamic Repair Error
     */
    (IomcFir_1, bit(19)) ? calloutDmiBus5Th1;

    /** IOMCFIR_1[20]
     *  MCS5 Too Many Bus Errors
     */
    (IomcFir_1, bit(20)) ? calloutDmiBus5Th1;

    /** IOMCFIR_1[21:23]
     *  Reserved
     */
    (IomcFir_1, bit(21|22|23)) ? defaultMaskedError;

    /** IOMCFIR_1[24]
     *  MCS6 Training Error
     */
    (IomcFir_1, bit(24)) ? defaultMaskedError;

    /** IOMCFIR_1[25]
     *  MCS6 Spare Deployed
     */
    (IomcFir_1, bit(25)) ? spareDeployed_dmiBus6;

    /** IOMCFIR_1[26]
     *  MCS6 Max Spares Exceeded
     */
    (IomcFir_1, bit(26)) ? maxSparesExceeded_dmiBus6;

    /** IOMCFIR_1[27]
     *  MCS6 Recalibration or Dynamic Repair Error
     */
    (IomcFir_1, bit(27)) ? calloutDmiBus6Th1;

    /** IOMCFIR_1[28]
     *  MCS6 Too Many Bus Errors
     */
    (IomcFir_1, bit(28)) ? calloutDmiBus6Th1;

    /** IOMCFIR_1[29:31]
     *  Reserved
     */
    (IomcFir_1, bit(29|30|31)) ? defaultMaskedError;

    /** IOMCFIR_1[32]
     *  MCS7 Training Error
     */
    (IomcFir_1, bit(32)) ? defaultMaskedError;

    /** IOMCFIR_1[33]
     *  MCS7 Spare Deployed
     */
    (IomcFir_1, bit(33)) ? spareDeployed_dmiBus7;

    /** IOMCFIR_1[34]
     *  MCS7 Max Spares Exceeded
     */
    (IomcFir_1, bit(34)) ? maxSparesExceeded_dmiBus7;

    /** IOMCFIR_1[35]
     *  MCS7 Recalibration or Dynamic Repair Error
     */
    (IomcFir_1, bit(35)) ? calloutDmiBus7Th1;

    /** IOMCFIR_1[36]
     *  MCS7 Too Many Bus Errors
     */
    (IomcFir_1, bit(36)) ? calloutDmiBus7Th1;

    /** IOMCFIR_1[37:39]
     *  Reserved
     */
    (IomcFir_1, bit(37|38|39)) ? defaultMaskedError;

    /** IOMCFIR_1[40:47]
     *  FIR_RX_BUS4 unused
     */
    (IomcFir_1, bit(40|41|42|43|44|45|46|47)) ? defaultMaskedError;

    /** IOMCFIR_1[48]
     *  FIR_SCOMFIR_ERROR
     */
    (IomcFir_1, bit(48)) ? defaultMaskedError;

    /** IOMCFIR_1[49]
     *  FIR_SCOMFIR_ERROR_CLONE
     */
    (IomcFir_1, bit(49)) ? defaultMaskedError;
};

################################################################################
# Actions specific to PB chiplet
################################################################################

/** Callout the connected PCI 0 controller. */
actionclass calloutConnPci0 { callout(connected(TYPE_PCI,0), MRU_MED); };

/** Callout the connected PCI 1 controller. */
actionclass calloutConnPci1 { callout(connected(TYPE_PCI,1), MRU_MED); };

/** Callout the connected PCI 2 controller. */
actionclass calloutConnPci2 { callout(connected(TYPE_PCI,2), MRU_MED); };

/** Callout the connected PCI 0 controller, threshold 1 , no garding */
actionclass calloutConnPci0Th1NoGard
{
    calloutConnPci0;
    threshold1;
    gard(NoGard);
};

/** Callout the connected PCI 1 controller, threshold 1, no garding */
actionclass calloutConnPci1Th1NoGard
{
    calloutConnPci1;
    threshold1;
    gard(NoGard);
};

/** Callout the connected PCI 2 controller, threshold 1, no garding */
actionclass calloutConnPci2Th1NoGard
{
    calloutConnPci2;
    threshold1;
    gard(NoGard);
};

/** Callout the connected PCI 0 controller, threshold 32 per day, no garding */
actionclass calloutConnPci0Th32NoGard
{
    calloutConnPci0;
    threshold32pday;
    gard(NoGard);
};

/** Callout the connected PCI 1 controller, threshold 32 per day, no garding */
actionclass calloutConnPci1Th32NoGard
{
    calloutConnPci1;
    threshold32pday;
    gard(NoGard);
};

/** Callout the connected PCI 2 controller, threshold 32 per day , no garding */
actionclass calloutConnPci2Th32NoGard
{
    calloutConnPci2;
    threshold32pday;
    gard(NoGard);
};

/** Callout the DMI bus 0 */
actionclass calloutDmiBus0
{
    callout(connected(TYPE_MCS,    0), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 0), MRU_MEDA);
    calloutDmiBusSymFru;

};

/** Callout the DMI bus 1 */
actionclass calloutDmiBus1
{
    callout(connected(TYPE_MCS,    1), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 1), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 2 */
actionclass calloutDmiBus2
{
    callout(connected(TYPE_MCS,    2), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 2), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 3 */
actionclass calloutDmiBus3
{
    callout(connected(TYPE_MCS,    3), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 3), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 4 */
actionclass calloutDmiBus4
{
    callout(connected(TYPE_MCS,    4), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 4), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 5 */
actionclass calloutDmiBus5
{
    callout(connected(TYPE_MCS,    5), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 5), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 6 */
actionclass calloutDmiBus6
{
    callout(connected(TYPE_MCS,    6), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 6), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 7 */
actionclass calloutDmiBus7
{
    callout(connected(TYPE_MCS,    7), MRU_MEDA);
    callout(connected(TYPE_MEMBUF, 7), MRU_MEDA);
    calloutDmiBusSymFru;
};

/** Callout the DMI bus 0, threshold 1 */
actionclass calloutDmiBus0Th1 { calloutDmiBus0; threshold1; };

/** Callout the DMI bus 1, threshold 1 */
actionclass calloutDmiBus1Th1 { calloutDmiBus1; threshold1; };

/** Callout the DMI bus 2, threshold 1 */
actionclass calloutDmiBus2Th1 { calloutDmiBus2; threshold1; };

/** Callout the DMI bus 3, threshold 1 */
actionclass calloutDmiBus3Th1 { calloutDmiBus3; threshold1; };

/** Callout the DMI bus 4, threshold 1 */
actionclass calloutDmiBus4Th1 { calloutDmiBus4; threshold1; };

/** Callout the DMI bus 5, threshold 1 */
actionclass calloutDmiBus5Th1 { calloutDmiBus5; threshold1; };

/** Callout the DMI bus 6, threshold 1 */
actionclass calloutDmiBus6Th1 { calloutDmiBus6; threshold1; };

/** Callout the DMI bus 7, threshold 1 */
actionclass calloutDmiBus7Th1 { calloutDmiBus7; threshold1; };

/** Lane Repair: spare deployed - DMI bus 0 */
actionclass spareDeployed_dmiBus0
{ calloutDmiBus0; funccall("spareDeployed_dmiBus0"); };

/** Lane Repair: spare deployed - DMI bus 1 */
actionclass spareDeployed_dmiBus1
{ calloutDmiBus1; funccall("spareDeployed_dmiBus1"); };

/** Lane Repair: spare deployed - DMI bus 2 */
actionclass spareDeployed_dmiBus2
{ calloutDmiBus2; funccall("spareDeployed_dmiBus2"); };

/** Lane Repair: spare deployed - DMI bus 3 */
actionclass spareDeployed_dmiBus3
{ calloutDmiBus3; funccall("spareDeployed_dmiBus3"); };

/** Lane Repair: spare deployed - DMI bus 4 */
actionclass spareDeployed_dmiBus4
{ calloutDmiBus4; funccall("spareDeployed_dmiBus4"); };

/** Lane Repair: spare deployed - DMI bus 5 */
actionclass spareDeployed_dmiBus5
{ calloutDmiBus5; funccall("spareDeployed_dmiBus5"); };

/** Lane Repair: spare deployed - DMI bus 6 */
actionclass spareDeployed_dmiBus6
{ calloutDmiBus6; funccall("spareDeployed_dmiBus6"); };

/** Lane Repair: spare deployed - DMI bus 7 */
actionclass spareDeployed_dmiBus7
{ calloutDmiBus7; funccall("spareDeployed_dmiBus7"); };

/** Lane Repair: max spares exceeded - DMI bus 0 */
actionclass maxSparesExceeded_dmiBus0
{ calloutDmiBus0Th1; funccall("maxSparesExceeded_dmiBus0"); };

/** Lane Repair: max spares exceeded - DMI bus 1 */
actionclass maxSparesExceeded_dmiBus1
{ calloutDmiBus1Th1; funccall("maxSparesExceeded_dmiBus1"); };

/** Lane Repair: max spares exceeded - DMI bus 2 */
actionclass maxSparesExceeded_dmiBus2
{ calloutDmiBus2Th1; funccall("maxSparesExceeded_dmiBus2"); };

/** Lane Repair: max spares exceeded - DMI bus 3 */
actionclass maxSparesExceeded_dmiBus3
{ calloutDmiBus3Th1; funccall("maxSparesExceeded_dmiBus3"); };

/** Lane Repair: max spares exceeded - DMI bus 4 */
actionclass maxSparesExceeded_dmiBus4
{ calloutDmiBus4Th1; funccall("maxSparesExceeded_dmiBus4"); };

/** Lane Repair: max spares exceeded - DMI bus 5 */
actionclass maxSparesExceeded_dmiBus5
{ calloutDmiBus5Th1; funccall("maxSparesExceeded_dmiBus5"); };

/** Lane Repair: max spares exceeded - DMI bus 6 */
actionclass maxSparesExceeded_dmiBus6
{ calloutDmiBus6Th1; funccall("maxSparesExceeded_dmiBus6"); };

/** Lane Repair: max spares exceeded - DMI bus 7 */
actionclass maxSparesExceeded_dmiBus7
{ calloutDmiBus7Th1; funccall("maxSparesExceeded_dmiBus7"); };

/** callout NX associated with Proc with a threshold of 32 per day*/
actionclass calloutNxThr32
{
    calloutNx;
    threshold32pday;
};

/** callout NX associated with Proc with a threshold of 1 per day*/
actionclass calloutNxThr1
{
    calloutNx;
    threshold1;
};

/**callout Nx connected to Proc */
actionclass calloutNx
{
    callout(connected(TYPE_NX, 0), MRU_MED);
};

actionclass calloutNxThr5pHr
{
    calloutNx;
    threshold5phour;
};

actionclass combinedResponseError
{
    # TODO: RTC 116213 proc_mpipl_check_eligibility() is completely broken so
    #       reverting this bug fix to the original 810 and 820 behavior (per
    #       request from Kevin) until proc_mpipl_check_eligibility() is fixed
    #       in FW830.
    funccall("analyzeMpIPL");
    #dumpSH;
    funccall("combinedResponseCallout");
};

actionclass forceMpIpl
{
    # TODO: RTC 116213 proc_mpipl_check_eligibility() is completely broken so
    #       reverting this bug fix to the original 810 and 820 behavior (per
    #       request from Kevin) until proc_mpipl_check_eligibility() is fixed
    #       in FW830.
    funccall("analyzeMpIPL");
    #dumpSH;
    callout2ndLvlMedThr1NoGard;
};

/** callout both ends of PSI Link.Threshold is 32 events per day.
 */
actionclass calloutPsiThr32
{
    calloutPsiLink;
    threshold32pday;
};

/** callout both ends of PSI Link on first instance.*/
actionclass calloutPsiThr1
{
    calloutPsiLink;
    threshold1;
};

/** callout both ends of PSI link */
actionclass calloutPsiLink
{
    funccall("calloutPeerPsiBusTgt");
};

/** Callout the NX on first occurrence and collect additional FFDC. */
actionclass nxUnitCheckstop
{
    calloutNxThr1;
    flag(UNIT_CS);
    # only collect NX debug traces on FSP
    try(funccall("inHostboot"), funccall("collectNxTraceArray"));
};
