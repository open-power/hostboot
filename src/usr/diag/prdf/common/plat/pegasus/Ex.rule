# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/pegasus/Ex.rule $
#
# IBM CONFIDENTIAL
#
# COPYRIGHT International Business Machines Corp. 2012,2014
#
# p1
#
# Object Code Only (OCO) source materials
# Licensed Internal Code Source Materials
# IBM HostBoot Licensed Internal Code
#
# The source code for this program is not published or otherwise
# divested of its trade secrets, irrespective of what has been
# deposited with the U.S. Copyright Office.
#
# Origin: 30
#
# IBM_PROLOG_END_TAG

################################################################################
#
# Scope:
#   Registers and actions for the following chiplets:
#       Note that only addresses for EX0 will be used.
#
# Chiplet  Register Addresses       Description
# =======  =======================  ============================================
#   EX0    0x10000000 - 0x10FFFFFF  EX0 pervasive logic
#   EX1    0x11000000 - 0x11FFFFFF  EX1 pervasive logic
#   EX2    0x12000000 - 0x12FFFFFF  EX2 pervasive logic
#   EX3    0x13000000 - 0x13FFFFFF  EX3 pervasive logic
#   EX4    0x14000000 - 0x14FFFFFF  EX4 pervasive logic
#   EX5    0x15000000 - 0x15FFFFFF  EX5 pervasive logic
#   EX6    0x16000000 - 0x16FFFFFF  EX6 pervasive logic
#   EX7    0x17000000 - 0x17FFFFFF  EX7 pervasive logic
#   EX8    0x18000000 - 0x18FFFFFF  EX8 pervasive logic
#   EX9    0x19000000 - 0x19FFFFFF  EX9 pervasive logic
#   EX10   0x1A000000 - 0x1AFFFFFF  EX10 pervasive logic
#   EX11   0x1B000000 - 0x1BFFFFFF  EX11 pervasive logic
#   EX12   0x1C000000 - 0x1CFFFFFF  EX12 pervasive logic
#   EX13   0x1D000000 - 0x1DFFFFFF  EX13 pervasive logic
#   EX14   0x1E000000 - 0x1EFFFFFF  EX14 pervasive logic
#   EX15   0x1F000000 - 0x1FFFFFFF  EX15 pervasive logic
#
################################################################################

chip Ex
{
    name        "Power8 EX Chiplet";
    targettype  TYPE_EX;
    sigoff      0x8000;
    dump        DUMP_CONTENT_HW;
    scomlen     64;

 #############################################################################
 #                                                                           #
 #  ######                                                                   #
 #  #     #  ######   ####     ###    ####    #####  ######  #####    ####   #
 #  #     #  #       #    #     #    #          #    #       #    #  #       #
 #  ######   #####   #          #     ####      #    #####   #    #   ####   #
 #  #   #    #       #  ###     #         #     #    #       #####        #  #
 #  #    #   #       #    #     #    #    #     #    #       #   #   #    #  #
 #  #     #  ######   ####     ###    ####      #    ######  #    #   ####   #
 #                                                                           #
 #############################################################################

    ############################################################################
    # EX Chiplet Registers
    ############################################################################

    register EX_CHIPLET_CS_FIR
    {
        name        "EX00.TP.ECO_DOM.XFIR";
        scomaddr    0x10040000;
        capture     group default;
    };

    register EX_CHIPLET_RE_FIR
    {
        name        "EX00.TP.ECO_DOM.RFIR";
        scomaddr    0x10040001;
        capture     group default;
    };

    register EX_CHIPLET_FIR_MASK
    {
        name        "EX00.TP.ECO_DOM.FIR_MASK";
        scomaddr    0x10040002;
        capture     group default;
    };

    # EX special attention registers - Used for FFDC only
    # Currently, all analysis of these registers is done by ATTN.

    register EX_CHIPLET_SPA
    {
        name        "EX00.TP.ECO_DOM.EPS.FIR.SPATTN";
        scomaddr    0x10040004;
        capture     group default;
    };

    ############################################################################
    # EX Chiplet LFIR
    ############################################################################

    register EX_LFIR
    {
        name        "EX00.TP.ECO_DOM.LOCAL_FIR";
        scomaddr    0x1004000a;
        reset       (&, 0x1004000b);
        mask        (|, 0x1004000f);
        capture     group default;
    };

    register EX_LFIR_MASK
    {
        name        "EX00.TP.ECO_DOM.EPS.FIR.LOCAL_FIR_MASK";
        scomaddr    0x1004000d;
        capture     group default;
    };

    register EX_LFIR_ACT0
    {
        name        "EX00.TP.ECO_DOM.EPS.FIR.LOCAL_FIR_ACTION0";
        scomaddr    0x10040010;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("EX_LFIR");
    };

    register EX_LFIR_ACT1
    {
        name        "EX00.TP.ECO_DOM.EPS.FIR.LOCAL_FIR_ACTION1";
        scomaddr    0x10040011;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("EX_LFIR");
    };

    ############################################################################
    # EX Chiplet COREFIR
    ############################################################################

    register COREFIR
    {
        name        "EX00.EC.PC.PC_NE.FIR.CORE_FIR";
        scomaddr    0x10013100;
        mask        (|, 0x10013105);
        capture     group default;
    };

    register COREFIR_MASK
    {
        name        "EX00.EC.PC.PC_NE.FIR.CORE_FIRMASK";
        scomaddr    0x10013103;
        capture     group default;
    };

    register COREFIR_ACT0
    {
        name        "EX00.EC.PC.PC_NE.FIR.CORE_ACTION0";
        scomaddr    0x10013106;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("COREFIR");
    };

    register COREFIR_ACT1
    {
        name        "EX00.EC.PC.PC_NE.FIR.CORE_ACTION1";
        scomaddr    0x10013107;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("COREFIR");
    };

    register COREFIRWOF
    {
        name        "Core FIR WOF";
        scomaddr    0x10013108;
        reset       (|, 0x10013108);
        capture     group default;
    };

    ###########################################################################
    # EX Chiplet COREFIR Error Report Registers
    ###########################################################################

    register PCNE_REG0_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG0_HOLD_OUT";
        scomaddr    0x1001300D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG1_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG1_HOLD_OUT";
        scomaddr    0x1001301D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG2_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG2_HOLD_OUT";
        scomaddr    0x1001302D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG3_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG3_HOLD_OUT";
        scomaddr    0x1001303D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG4_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG4_HOLD_OUT";
        scomaddr    0x1001304D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG5_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG5_HOLD_OUT";
        scomaddr    0x1001305D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG6_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG6_HOLD_OUT";
        scomaddr    0x1001306D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNE_REG7_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NE.PCNE_REG7_HOLD_OUT";
        scomaddr    0x1001307D;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNW_REG0_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NW.PCNW_REG0_HOLD_OUT";
        scomaddr    0x100132A9;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCNW_REG1_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_NW.PCNW_REG1_HOLD_OUT";
        scomaddr    0x100132AA;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCS_REG0_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_S.PCS_REG0_HOLD_OUT";
        scomaddr    0x100132CB;
        capture     group default;
        capture     group CerrRegs;
    };

    register PCS_REG1_HOLD_OUT
    {
        name        "EXP.EC.PC.PC_S.PCS_REG1_HOLD_OUT";
        scomaddr    0x100132D5;
        capture     req funccall("isMuranoVeniceNotDD1");
        capture     group default;
        capture     group CerrRegs;
    };

    register FXU_REG0_HOLD_OUT
    {
        name        "EXP.EC.FX.FXU_REG0_HOLD_OUT";
        scomaddr    0x10013300;
        capture     group default;
        capture     group CerrRegs;
    };

    register FXU_REG1_HOLD_OUT
    {
        name        "EXP.EC.FX.FXU_REG1_HOLD_OUT";
        scomaddr    0x10013301;
        capture     group default;
        capture     group CerrRegs;
    };

    register FXU_REG2_HOLD_OUT
    {
        name        "EXP.EC.FX.FXU_REG2_HOLD_OUT";
        scomaddr    0x10013302;
        capture     group default;
        capture     group CerrRegs;
    };

    register FXU_REG3_HOLD_OUT
    {
        name        "EXP.EC.FX.FXU_REG3_HOLD_OUT";
        scomaddr    0x10013303;
        capture     group default;
        capture     group CerrRegs;
    };

    register FXU_REG4_HOLD_OUT
    {
        name        "EXP.EC.FX.FXU_REG4_HOLD_OUT";
        scomaddr    0x10013304;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG0_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG0_HOLD_OUT";
        scomaddr    0x10013340;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG1_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG1_HOLD_OUT";
        scomaddr    0x10013341;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG2_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG2_HOLD_OUT";
        scomaddr    0x10013342;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG3_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG3_HOLD_OUT";
        scomaddr    0x10013343;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG4_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG4_HOLD_OUT";
        scomaddr    0x10013344;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG5_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG5_HOLD_OUT";
        scomaddr    0x10013345;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG6_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG6_HOLD_OUT";
        scomaddr    0x10013346;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG7_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG7_HOLD_OUT";
        scomaddr    0x10013347;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG8_ISU_HOLD_OUT_ERRPT
    {
        name        "EXP.EC.SD.ISU_REG8_HOLD_OUT";
        scomaddr    0x10013348;
        capture     group default;
        capture     group CerrRegs;
    };

    register ISU_REG9_ISU_HOLD_OUT
    {
        name        "EXP.EC.SD.ISU_REG9_HOLD_OUT";
        scomaddr    0x10013349;
        capture     group default;
        capture     group CerrRegs;
    };

    register IFU_REG0_HOLD_OUT
    {
        name        "EXP.EC.IFU.IFU_REG0_HOLD_OUT";
        scomaddr    0x10013381;
        capture     group default;
        capture     group CerrRegs;
    };

    register IFU_REG1_HOLD_OUT
    {
        name        "EXP.EC.IFU.IFU_REG1_HOLD_OUT";
        scomaddr    0x10013382;
        capture     group default;
        capture     group CerrRegs;
    };

    register IFU_REG2_HOLD_OUT
    {
        name        "EXP.EC.IFU.IFU_REG2_HOLD_OUT";
        scomaddr    0x10013383;
        capture     group default;
        capture     group CerrRegs;
    };

    register IFU_REG3_HOLD_OUT
    {
        name        "EXP.EC.IFU.IFU_REG3_HOLD_OUT";
        scomaddr    0x10013384;
        capture     group default;
        capture     group CerrRegs;
    };

    register IFU_REG4_HOLD_OUT
    {
        name        "EXP.EC.IFU.IFU_REG4_HOLD_OUT";
        scomaddr    0x10013385;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG0_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG0_HOLD_OUT";
        scomaddr    0x100133C0;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG1_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG1_HOLD_OUT";
        scomaddr    0x100133C1;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG2_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG2_HOLD_OUT";
        scomaddr    0x100133C2;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG3_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG3_HOLD_OUT";
        scomaddr    0x100133C3;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG4_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG4_HOLD_OUT";
        scomaddr    0x100133C4;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG5_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG5_HOLD_OUT";
        scomaddr    0x100133C5;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG6_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG6_HOLD_OUT";
        scomaddr    0x100133C6;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG7_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG7_HOLD_OUT";
        scomaddr    0x100133C7;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG8_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG8_HOLD_OUT";
        scomaddr    0x100133C8;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG9_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG9_HOLD_OUT";
        scomaddr    0x100133C9;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG10_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG10_HOLD_OUT";
        scomaddr    0x100133CA;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG11_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG11_HOLD_OUT";
        scomaddr    0x100133CB;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG12_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG12_HOLD_OUT";
        scomaddr    0x100133CC;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG13_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG13_HOLD_OUT";
        scomaddr    0x100133CD;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG14_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG14_HOLD_OUT";
        scomaddr    0x100133CE;
        capture     group default;
        capture     group CerrRegs;
    };

    register LSU_REG15_HOLD_OUT
    {
        name        "EXP.EC.LS.LSU_REG15_HOLD_OUT";
        scomaddr    0x100133CF;
        capture     group default;
        capture     group CerrRegs;
    };

    ############################################################################
    # EX Chiplet L2FIR
    ############################################################################

    register L2FIR
    {
        name        "EX00.L2.L2MISC.L2CERRS.FIR_REG";
        scomaddr    0x10012800;
        reset       (&, 0x10012801);
        mask        (|, 0x10012805);
        capture     group default;
    };

    register L2FIR_MASK
    {
        name        "EX00.L2.L2MISC.L2CERRS.FIR_MASK_REG";
        scomaddr    0x10012803;
        capture     group default;
    };

    register L2FIR_ACT0
    {
        name        "EX00.L2.L2MISC.L2CERRS.FIR_ACTION0_REG";
        scomaddr    0x10012806;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("L2FIR");
    };

    register L2FIR_ACT1
    {
        name        "EX00.L2.L2MISC.L2CERRS.FIR_ACTION1_REG";
        scomaddr    0x10012807;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("L2FIR");
    };

    register L2FIR_ERROR_REPORT_0
    {
        name        "EXP.L2.L2MISC.L2CERRS.ERR_RPT0";
        scomaddr    0x10012815;
        capture     group default;
        capture     group CerrRegs;
    };

    register L2FIR_ERROR_REPORT_1
    {
        name        "EXP.L2.L2MISC.L2CERRS.ERR_RPT1";
        scomaddr    0x10012816;
        capture     group default;
        capture     group CerrRegs;
    };

    ############################################################################
    # EX Chiplet L3FIR
    ############################################################################

    register L3FIR
    {
        name        "EX00.L3.L3_MISC.L3CERRS.FIR_REG";
        scomaddr    0x10010800;
        reset       (&, 0x10010801);
        mask        (|, 0x10010805);
        capture     group default;
    };

    register L3FIR_MASK
    {
        name        "EX00.L3.L3_MISC.L3CERRS.FIR_MASK_REG";
        scomaddr    0x10010803;
        capture     group default;
    };

    register L3FIR_ACT0
    {
        name        "EX00.L3.L3_MISC.L3CERRS.FIR_ACTION0_REG";
        scomaddr    0x10010806;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("L3FIR");
    };

    register L3FIR_ACT1
    {
        name        "EX00.L3.L3_MISC.L3CERRS.FIR_ACTION1_REG";
        scomaddr    0x10010807;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("L3FIR");
    };

    register L3FIR_RD0_ERROR_REPORT
    {
        name        "EXP.L3.L3_MISC.L3CERRS.L3_CTL_CHECK_RD0_REG";
        scomaddr    0x10010810;
        capture     group default;
        capture     group CerrRegs;
    };

    register L3FIR_RD1_ERROR_REPORT
    {
        name        "EXP.L3.L3_MISC.L3CERRS.L3_CTL_CHECK_RD1_REG";
        scomaddr    0x10010817;
        capture     group default;
        capture     group CerrRegs;
    };

    ############################################################################
    # EX Chiplet NCUFIR
    ############################################################################

    register NCUFIR
    {
        name        "EX00.NC.NCMISC.NCSCOMS.FIR_REG";
        scomaddr    0x10010c00;
        reset       (&, 0x10010c01);
        mask        (|, 0x10010c05);
        capture     group default;
    };

    register NCUFIR_MASK
    {
        name        "EX00.NC.NCMISC.NCSCOMS.FIR_MASK_REG";
        scomaddr    0x10010c03;
        capture     group default;
    };

    register NCUFIR_ACT0
    {
        name        "EX00.NC.NCMISC.NCSCOMS.FIR_ACTION0_REG";
        scomaddr    0x10010c06;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("NCUFIR");
    };

    register NCUFIR_ACT1
    {
        name        "EX00.NC.NCMISC.NCSCOMS.FIR_ACTION1_REG";
        scomaddr    0x10010c07;
        capture     type secondary;
        capture     group default;
        capture     req nonzero("NCUFIR");
    };

    register NCUFIR_ERROR_REPORT
    {
        name        "EXP.NC.NCMISC.NCSCOMS.ERR_RPT_REG";
        scomaddr    0x10010C0C;
        capture     group default;
        capture     group CerrRegs;
    };

    ############################################################################
    # EX Chiplet SPATTNs
    ############################################################################

    # EX special attention registers - Used for FFDC only
    # Currently, all analysis of these registers is done by ATTN.

    register SPATTN_0
    {
        name        "EX00.EC.PC.PC_NE.TCTL0.SPATTN";
        scomaddr    0x10013007;
        capture     group default;
        capture     group CerrRegs;
    };

    register SPATTN_1
    {
        name        "EX00.EC.PC.PC_NE.TCTL1.SPATTN";
        scomaddr    0x10013017;
        capture     group default;
        capture     group CerrRegs;
    };

    register SPATTN_2
    {
        name        "EX00.EC.PC.PC_NE.TCTL2.SPATTN";
        scomaddr    0x10013027;
        capture     group default;
        capture     group CerrRegs;
    };
    register SPATTN_3
    {
        name        "EX00.EC.PC.PC_NE.TCTL3.SPATTN";
        scomaddr    0x10013037;
        capture     group default;
        capture     group CerrRegs;
    };

    register SPATTN_4
    {
        name        "EX00.EC.PC.PC_NE.TCTL4.SPATTN";
        scomaddr    0x10013047;
        capture     group default;
        capture     group CerrRegs;
    };

    register SPATTN_5
    {
        name        "EX00.EC.PC.PC_NE.TCTL5.SPATTN";
        scomaddr    0x10013057;
        capture     group default;
        capture     group CerrRegs;
    };

    register SPATTN_6
    {
        name        "EX00.EC.PC.PC_NE.TCTL6.SPATTN";
        scomaddr    0x10013067;
        capture     group default;
        capture     group CerrRegs;
    };

    register SPATTN_7
    {
        name        "EX00.EC.PC.PC_NE.TCTL7.SPATTN";
        scomaddr    0x10013077;
        capture     group default;
        capture     group CerrRegs;
    };

    ############################################################################
    # EX Chiplet Other Registers
    ############################################################################

    register COREHMEER
    {
        name        "Core HMEER";
        scomaddr    0x1001329B;
        capture     type secondary;
        capture     group default;
    };

    ############################################################################
    # EX non-existent registers for capture
    ############################################################################
    register L2TRACE_ARRAY
    {
        name        "Capture Data for L2 Trace Array";
        capture     group never;
    };

    register L3TRACE_ARRAY
    {
        name        "Capture Data for L3 Trace Array";
        capture     group never;
    };

    ############################################################################
    # EX Chiplet PLL Registers
    ############################################################################

    register EX_ERROR_REG
    {
        name        "EH.TPCHIP.NET.PCBSLEX.TP_PCB_SLAVE_INST.ERROR_REG";
        scomaddr    0x100F001F;
        capture     group PllFIRs;
    };

    register EX_CONFIG_REG
    {
        name        "EH.TPCHIP.NET.PCBSLEX.TP_PCB_SLAVE_INST.SLAVE_CONFIG_REG";
        scomaddr    0x100F001E;
        capture     group PllFIRs;
    };


};

 ##############################################################################
 #                                                                            #
 # ####                                 #                                     #
 # #   # #   # #    #####  ###      #  # #    ##  ##### ###  ###  #   #  ###  #
 # #   # #   # #    #     #        #  #   #  #  #   #    #  #   # ##  # #     #
 # ####  #   # #    ####   ###    #  ####### #      #    #  #   # # # #  ###  #
 # #  #  #   # #    #         #  #   #     # #  #   #    #  #   # #  ##     # #
 # #   #  ###  #### #####  ###  #    #     #  ##    #   ###  ###  #   #  ###  #
 #                                                                            #
 ##############################################################################

################################################################################
# EX Chiplet Registers
################################################################################

rule ExChipletFir
{
  CHECK_STOP:
     EX_CHIPLET_CS_FIR       & `1F00000000000000`;
  RECOVERABLE:
    (EX_CHIPLET_RE_FIR >> 2) & `3F00000000000000`;
};

group gExChipletFir attntype CHECK_STOP, RECOVERABLE filter priority(3,5,6,7,4,2)
{
    /** EX_CHIPLET_FIR[2]
     *  Unit Checkstop from Core Local FIR (bit0 in RER)
     */
    (ExChipletFir, bit(2))? analyzeCoreUnitCheckstop;

    /** EX_CHIPLET_FIR[3]
     *  Attention from LFIR
     */
    (ExChipletFir, bit(3))? analyzeExLFir;

    /** EX_CHIPLET_FIR[4]
     *  Attention from COREFIR
     */
    (ExChipletFir, bit(4)) ? analyzeCore;

    /** EX_CHIPLET_FIR[5]
     *  Attention from L2FIR
     */
    (ExChipletFir, bit(5)) ? analyzeL2Fir;

    /** EX_CHIPLET_FIR[6]
     *  Attention from L3FIR
     */
    (ExChipletFir, bit(6)) ? analyzeL3Fir;

    /** EX_CHIPLET_FIR[7]
     *  Attention from NCUFIR
     */
    (ExChipletFir, bit(7)) ? analyzeNcuFir;
};

################################################################################
# EX Chiplet LFIR
################################################################################

rule ExLFir
{
    CHECK_STOP:  EX_LFIR & ~EX_LFIR_MASK & ~EX_LFIR_ACT0 & ~EX_LFIR_ACT1;
    RECOVERABLE: EX_LFIR & ~EX_LFIR_MASK & ~EX_LFIR_ACT0 &  EX_LFIR_ACT1;
};

group gExLFir filter singlebit
{
    /** EX_LFIR[0]
     *  CFIR internal parity error
     */
    (ExLFir, bit(0)) ? calloutParentChipHighThr32;

    /** EX_LFIR[1]
     *  Local errors from GPIO (PCB error)
     */
    (ExLFir, bit(1)) ? defaultMaskedError;

    /** EX_LFIR[2]
     *  Local errors from CC (PCB error)
     */
    (ExLFir, bit(2)) ? defaultMaskedError;

    /** EX_LFIR[3]
     *  Local errors from CC (OPCG, parity, scan collision, ...)
     */
    (ExLFir, bit(3)) ? defaultMaskedError;

    /** EX_LFIR[4]
     *  Local errors from PSC (PCB error)
     */
    (ExLFir, bit(4)) ? defaultMaskedError;

    /** EX_LFIR[5]
     *  Local errors from PSC (parity error)
     */
    (ExLFir, bit(5)) ? defaultMaskedError;

    /** EX_LFIR[6]
     *  Local errors from Thermal (parity error)
     */
    (ExLFir, bit(6)) ? defaultMaskedError;

    /** EX_LFIR[7]
     *  Local errors from Thermal (PCB error)
     */
    (ExLFir, bit(7)) ? defaultMaskedError;

    /** EX_LFIR[8|9]
     *  Local errors from Thermal (Trip error)
     */
    (ExLFir, bit(8|9)) ? defaultMaskedError;

    /** EX_LFIR[10]
     *  Local errors from trace array - error
     */
    (ExLFir, bit(10)) ? calloutParentChipHighThr32;

    /** EX_LFIR[11]
     *  Local errors from Trace Array ( error)
     */
    (ExLFir, bit(11)) ? defaultMaskedError;

    /** EX_LFIR[12|13]
     *  Local errors from trial
     */
    (ExLFir, bit(12|13)) ? defaultMaskedError;

    /** EX_LFIR[14]
     *  Local errors from OHA - recov error
     */
    (ExLFir, bit(14)) ? defaultMaskedError;

    /** EX_LFIR[15]
     *  Local errors from OHA - checkstop
     */
    (ExLFir, bit(15)) ? defaultMaskedError;

    /** EX_LFIR[16]
     *  Local errors from skewadj
     */
    (ExLFir, bit(16)) ? calloutParentChipHighThr32;

    /** EX_LFIR[17]
     *  local errors from dcadj
     */
    (ExLFir, bit(17)) ? calloutParentChipHighThr32;

    /** EX_LFIR[18:39]
     *  Unused local errors
     */
    (ExLFir, bit( 18|19|20|21|22|23|24|25|26|27|28|29|
                  30|31|32|33|34|35|36|37|38|39 )) ? defaultMaskedError;

    /** EX_LFIR[40]
     *  Malfunction alert - local checkstop in another chiplet
     */
    (ExLFir, bit(40)) ? defaultMaskedError;
};

################################################################################
# EX Chiplet COREFIR
################################################################################

rule CoreFir
{
    CHECK_STOP:  COREFIR    & ~COREFIR_MASK &  COREFIR_ACT0 & ~COREFIR_ACT1;
    PROC_CS:     COREFIR    & ~COREFIR_MASK &  COREFIR_ACT0 &  COREFIR_ACT1;
    RECOVERABLE: COREFIRWOF & ~COREFIR_MASK & ~COREFIR_ACT0 &  COREFIR_ACT1;
};

#Based on RAS SpreadSheet p8dd1_mss_FFDC_72.xls
group gCoreFir filter singlebit
{
    /** COREFIR[0]
     *  IFU_SRAM_PARITY_ERR: SRAM recoverable error (ICACHE parity error, etc.)
     */
    (CoreFir, bit(0)) ? calloutExThr5pHr;

    /** COREFIR[1]
     *  IF_SETDELETE_ERR: set deleted
     */
    (CoreFir, bit(1)) ? SelfHighThr1;

    /** COREFIR[2]
     *  IF_RFILE_REC_ERR: RegFile recoverable error
     */
    (CoreFir, bit(2)) ? calloutExThr5pHr;

    /** COREFIR[3]
     *  IF_RFILE_CHKSTOP_ERR: RegFile core check stop
     */
    (CoreFir, bit(3)) ? SelfHighThr1;

    /** COREFIR[4]
     *  IF_LOG_REC_ERR: logic recoverable error
     */
    (CoreFir, bit(4)) ? calloutExThr5pHr;

    /** COREFIR[5]
     *  IF_LOG_CHKSTOP_ERR: logic core check stop
     */
    (CoreFir, bit(5)) ? SelfHighThr1;

    /** COREFIR[6]
     *  IF_NOT_MT_REC_ERR: recoverable if not in MT window
     */
    (CoreFir, bit(6)) ? calloutExThr32pDay;

    /** COREFIR[7]
     *  IF_CHKSTOP_ERR: system check stop
     */
    (CoreFir, bit(7)) ? SelfHighThr1;

    /** COREFIR[8]
     *  RECOV_FIR_CHKSTOP_ERR: recovery core check stop
     */
    (CoreFir, bit(8)) ? SelfHighThr1;

    /** COREFIR[9]
     *  SD_RFILE_REC_ERR: RegFile recoverable error
     */
    (CoreFir, bit(9)) ? calloutExThr5pHr;

    /** COREFIR[10]
     *  SD_RFILE_CHKSTOP_ERR: RegFile core check stop (mapper error)
     */
    (CoreFir, bit(10)) ? SelfHighThr1;

    /** COREFIR[11]
     *  SD_LOG_REC_ERR: logic recoverable error
     */
    (CoreFir, bit(11)) ? calloutExThr5pHr;

    /** COREFIR[12]
     *  SD_LOG_CHKSTOP_ERR: logic core check stop
     */
    (CoreFir, bit(12)) ? SelfHighThr1;

    /** COREFIR[13]
     *  SD_NOT_MT_REC_ERR: recoverable if not in MT window
     */
    (CoreFir, bit(13)) ? calloutExThr32pDay;

    /** COREFIR[14]
     *  SD_MCHK_AND_ME_EQ_0: MCHK received while ME=0 non recoverable
     */
    # FIXME: RTC 85697: Make sure this is SUE-CS bit
    (CoreFir, bit(14)) ? calloutSelfHighSUE;

    /** COREFIR[15]
     *  SD_PC_L2_UE_ERR: UE from L2
     */
    (CoreFir, bit(15)) ? defaultMaskedError;

    /** COREFIR[16]
     *  ISU_L2_UE_OVER_TH_ERR: Number of UEs from L2 above threshold
     */
    (CoreFir, bit(16)) ? defaultMaskedError;

    /** COREFIR[17]
     *  SD_PC_CI_UE: UE on CI load
     */
    (CoreFir, bit(17)) ? defaultMaskedError;

    /** COREFIR[18]
     *  UNUSED_2
     */
    (CoreFir, bit(18)) ? defaultMaskedError;

    /** COREFIR[19]
     *  FX_GPR_REC_ERR: GPR recoverable error
     */
    (CoreFir, bit(19)) ? calloutExThr5pHr;

    /** COREFIR[20]
     *  UNUSED_3
     */
    (CoreFir, bit(20)) ? defaultMaskedError;

    /** COREFIR[21]
     *  FX_LOG_CHKSTOP_ERR: logic core check stop
     */
    (CoreFir, bit(21)) ? SelfHighThr1;

    /** COREFIR[22]
     *  FX_NOT_MT_REC_ERR: recoverable if not in MT window
     */
    (CoreFir, bit(22)) ? calloutExThr32pDay;

    /** COREFIR[23]
     *  VS_VRF_REC_ERR: VRF recoverable error
     */
    (CoreFir, bit(23)) ? calloutExThr5pHr;

    /** COREFIR[24]
     *  VS_LOG_REC_ERR: logic recoverable error
     */
    (CoreFir, bit(24)) ? calloutExThr5pHr;

    /** COREFIR[25]
     *  VS_LOG_CHKSTOP_ERR: logic core check stop
     */
    (CoreFir, bit(25)) ? SelfHighThr1;

    /** COREFIR[26]
     *  RECOV_IN_MAINT_ERR: 26 = recov_in_maint
     */
    (CoreFir, bit(26)) ? callout2ndLvlDumpSh;

    /** COREFIR[27]
     *  DU_LOG_REC_ERR: logic recoverable error
     */
    (CoreFir, bit(27)) ? calloutExThr5pHr;

    /** COREFIR[28]
     *  DU_LOG_CHKSTOP_ERR: logic core check stop
     */
    (CoreFir, bit(28)) ? defaultMaskedError;

    /** COREFIR[29]
     *  LSU_SRAM_PARITY_ERR: SRAM recoverable error (DCACHE parity error, etc.)
     */
    (CoreFir, bit(29)) ? calloutExThr5pHr;

    /** COREFIR[30]
     *  LS_SETDELETE_ERR: set deleted
     */
    (CoreFir, bit(30)) ? SelfHighThr1;

    /** COREFIR[31]
     *  LS_RFILE_REC_ERR: RegFile recoverable error
     */
    (CoreFir, bit(31)) ? calloutExThr5pHr;

    /** COREFIR[32]
     *  LS_RFILE_CHKSTOP_ERR: RegFile core check stop
     */
    (CoreFir, bit(32)) ? SelfHighThr1;

    /** COREFIR[33]
     *  LS_TLB_MULTIHIT_ERR: special recovery error TLB multi hit error occurred
     */
    (CoreFir, bit(33)) ? defaultMaskedError;

    /** COREFIR[34]
     *  LS_SLB_MULTIHIT_ERR: special recovery error SLBFEE multi hit error occurred
     */
    (CoreFir, bit(34)) ? defaultMaskedError;

    /** COREFIR[35]
     *  LS_DERAT_MULTIHIT_ERR: special recovery error ERAT multi hit error occurred
     */
    (CoreFir, bit(35)) ? defaultMaskedError;

    /** COREFIR[36]
     *  FORWARD_PROGRESS_ERR: forward progress error
     */
    (CoreFir, bit(36)) ? SelfHighThr1;

    /** COREFIR[37]
     *  LS_LOG_REC_ERR: logic recoverable error
     */
    (CoreFir, bit(37)) ? calloutExThr5pHr;

    /** COREFIR[38]
     *  LS_LOG_CHKSTOP_ERR: logic core check stop
     */
    (CoreFir, bit(38)) ? SelfHighThr1;

    /** COREFIR[39]
     *  LS_NOT_MT_REC_ERR: recoverable if not in MT window
     */
    (CoreFir, bit(39)) ? calloutExThr32pDay;

    /** COREFIR[40]
     *  LS_NOT_CI_REC_ERR: recoverable if not in CI window
     */
    (CoreFir, bit(40)) ? calloutExThr32pDay;

    /** COREFIR[41]
     *  LS_CHKSTOP_ERR: system check stop
     */
    (CoreFir, bit(41)) ? SelfHighThr1;

    /** COREFIR[42]
     *  LS_GPR_RCV_CHKSTOP_ERR: UE from GPR/VRF recovery process
     */
    (CoreFir, bit(42)) ? defaultMaskedError;

    /** COREFIR[43]
     *  THREAD_HANG_REC_ERR: thread hang recoverable error
     */
    (CoreFir, bit(43)) ? SelfAndLevel2MedThr5PerHr;

    /** COREFIR[44]
     *  FIR_LOG_RECOV_ERR: logic recoverable error
     */
    (CoreFir, bit(44)) ? calloutExThr5pHr;

    /** COREFIR[45]
     *  PC_LOG_CHKSTOP_ERR: PC logic core check stop
     */
    (CoreFir, bit(45)) ? SelfHighThr1;

    /** COREFIR[46]
     *  RESERVED
     */
    (CoreFir, bit(46)) ? defaultMaskedError;

    /** COREFIR[47]
     *  TFC_FIR_TFMR_P_ERR: TFMR Parity Error (timing facility may be corrupt)
     */
    (CoreFir, bit(47)) ? defaultMaskedError;

    /** COREFIR[48]
     *  SPRD_FIR_HYP_RES_P_ERR: Hypervisor Resource error - core check stop
     */
    (CoreFir, bit(48)) ? SelfHighThr1;

    /** COREFIR[49]
     *  TFC_FIR_P_ERR: TFAC parity error
     */
    (CoreFir, bit(49)) ? defaultMaskedError;

    /** COREFIR[50]
     *  TFC_FIR_CONTROL_ERR: TFAC control error
     */
    (CoreFir, bit(50)) ? defaultMaskedError;

    /** COREFIR[51]
     *  PC_FIRM_AND_SEL_ERR: TFAC firmware error and select error
     */
    (CoreFir, bit(51)) ? defaultMaskedError;

    /** COREFIR[52]
     *  CORE_HUNG: Hang recovery failed (core check stop)
     */
    (CoreFir, bit(52)) ? SelfHighThr1;

    /** COREFIR[53]
     *  CORE_HANG_DETECT: Internal hang detected (core hang)
     */
    (CoreFir, bit(53)) ? defaultMaskedError;

    /** COREFIR[54]
     *  AMBI_HANG_DETECT: Hang detected unknown source
     */
    (CoreFir, bit(54)) ? calloutExAndSecLvlThr1;

    /** COREFIR[55]
     *  NEST_HANG_DETECT: External Hang detected
     */
    # FIXME: RTC 85697: Make sure this is SUE-CS bit
    (CoreFir, bit(55)) ? calloutProcLow2ndLvlMedThr1SUE;

    /** COREFIR[56|57|58]
     *  RESERVED
     */
    (CoreFir, bit(56|57|58)) ? defaultMaskedError;

    /** COREFIR[59]
     *  PC_SOM_ERR: SCOM satellite error detected
     */
    (CoreFir, bit(59)) ? defaultMaskedError;

    /** COREFIR[60]
     *  DBG_FIR_CHECKSTOP_ON_TRIGGER: debug Trigger Error inject
     */
    (CoreFir, bit(60)) ? defaultMaskedError;

    /** COREFIR[61]
     *  SP_INJ_REC_ERR: SCOM or Firmware recoverable Error Inject
     */
    (CoreFir, bit(61)) ? defaultMaskedError;

    /** COREFIR[62]
     *  SP_INJ_XSTOP_ERR: Firmware Xstop Error Inject
     */
    (CoreFir, bit(62)) ? defaultMaskedError;

    /** COREFIR[63]
     *  SPRD_PHYP_ERR_INJ: Phyp Xstop via SPRC / SPRD
     */
    (CoreFir, bit(63)) ? calloutProcLow2ndLvlMedThr1dumpSh;
};

################################################################################
# EX Chiplet L2FIR
################################################################################

rule L2Fir
{
    CHECK_STOP:  L2FIR & ~L2FIR_MASK & ~L2FIR_ACT0 & ~L2FIR_ACT1;
    RECOVERABLE: L2FIR & ~L2FIR_MASK & ~L2FIR_ACT0 &  L2FIR_ACT1;
};

group gL2Fir filter singlebit
{
    /** L2FIR[0]
     *  CACHE_RD_CE
     */
    (L2Fir, bit(0)) ? L2CE;

    /** L2FIR[1]
     *  CACHE_RD_UE
     */
    (L2Fir, bit(1)) ? L2UE;

    /** L2FIR[2]
     *  CACHE_RD_SUE
     */
    (L2Fir, bit(2)) ? defaultMaskedError;

    /** L2FIR[3]
     *  HW_DIR_INTIATED_LINE_DELETE_OCCURRED
     */
    (L2Fir, bit(3)) ? defaultMaskedError;

    /** L2FIR[4]
     *  CACHE_UE_SUE_DETECTED_ON_MODIFIED_LINE_BY_CO
     */
    (L2Fir, bit(4)) ? defaultMaskedError;

    /** L2FIR[5]
     *  CACHE_UE_SUE_DETECTED_ON_NON_MODIFIED_LINE_BY_CO
     */
    (L2Fir, bit(5)) ? defaultMaskedError;

    /** L2FIR[6]
     *  DIR_CE_DETECTED
     */
    (L2Fir, bit(6)) ? L2DirCE;

    /** L2FIR[7]
     *  DIR_UE_DETECTED
     */
    (L2Fir, bit(7)) ? SelfHighThr1;

    /** L2FIR[8]
     *  DIR_STUCK_BIT_CE
     */
    (L2Fir, bit(8)) ? SelfHighThr1;

    /** L2FIR[9]
     *  DIR_SBCE_REPAIR_FAILED
     */
    (L2Fir, bit(9)) ? SelfHighThr1;

    /** L2FIR[10]
     *  MULTIPLE_DIR_ERRORS_DETECTED
     */
    (L2Fir, bit(10)) ? defaultMaskedError;

    /** L2FIR[11]
     *  LRU_READ_ERROR_DETECTED
     */
    (L2Fir, bit(11)) ? SelfHighThr32PerDay;

    /** L2FIR[12]
     *  RC_POWERBUS_DATA_TIMEOUT
     */
    (L2Fir, bit(12)) ? callout2ndLvlMedThr1;

    /** L2FIR[13]
     *  NCU_POWERBUS_DATA_TIMEOUT
     */
    (L2Fir, bit(13)) ? callout2ndLvlMedThr1;

    /** L2FIR[14]
     *  HW_CONTROL_ERROR
     */
    (L2Fir, bit(14)) ? L2ChipLevel2;

    /** L2FIR[15]
     *  LRU_ALL_MEMBERS_IN_CGC_ARE_LINE_DELETED
     */
    (L2Fir, bit(15)) ? SelfHighThr1;

    /** L2FIR[16]
     *  CACHE_INHIBITED_HIT_CACHEABLE_ERROR
     */
    (L2Fir, bit(16)) ? SelfHighThr1;

    /** L2FIR[17]
     *  RC_LOAD_RECIVED_PB_CRESP_ADR_ERR
     */
    (L2Fir, bit(17)) ? SelfHighThr1UE;

    /** L2FIR[18]
     *  RC_STORE_RECIVED_PB_CRESP_ADR_ERR
     */
    (L2Fir, bit(18)) ?  SelfHighThr1;

    /** L2FIR[19]
     *  RC_POWBUS_DATA_CE_ERR_FROM_F2CHK
     */
    (L2Fir, bit(19)) ? SelfHighThr32PerDay;

    /** L2FIR[20]
     *  RC_POWBUS_DATA_UE_ERR_FROM_F2CHK
     */
    (L2Fir, bit(20)) ? SelfHighThr1UE;

    /** L2FIR[21]
     *  RC_POWBUS_DATA_SUE_ERR_FROM_F2CHK
     */
    (L2Fir, bit(21)) ? defaultMaskedError;

    /** L2FIR[22]
     *  CO_ICSW_UE_SUE_DATA_ERR_FROM_F2CHK
     */
    (L2Fir, bit(22)) ? SelfHighThr1;

    /** L2FIR[23]
     *  RC_LOAD_RECIVED_PB_CRESP_ADR_ERR_FOR_HYP
     */
    (L2Fir, bit(23)) ? defaultMaskedError;

    /** L2FIR[24]
     *  RCDAT_RD_PARITY_ERR
     */
    (L2Fir, bit(24)) ? SelfHighThr1UE;

    /** L2FIR[25]
     *  CO_ICSW_RTY_BUSY_ABT_ERR
     */
    (L2Fir, bit(25)) ? defaultMaskedError;

    /** L2FIR[26]
     *  HA_LOG_STOP_SW_ERR
     */
    (L2Fir, bit(26)) ? callout2ndLvlMedThr1;

    /** L2FIR[27]
     *  RC_LOAD_RECEIVED_PB_ACK_DEAD_FROM_FOREIGN0
     */
    (L2Fir, bit(27)) ? callout2ndLvlMedThr1;

    /** L2FIR[28]
     *  RC_LOAD_RECEIVED_PB_ACK_DEAD_FROM_FOREIGN1
     */
    (L2Fir, bit(28)) ? callout2ndLvlMedThr1;

    /** L2FIR[29]
     *  RC_STORE_RECEIVED_PB_ACK_DEAD_FROM_FOREIGN0
     */
    (L2Fir, bit(29)) ? callout2ndLvlMedThr1;

    /** L2FIR[30]
     *  RC_STORE_RECEIVED_PB_ACK_DEAD_FROM_FOREIGN1
     */
    (L2Fir, bit(30)) ? callout2ndLvlMedThr1;

    /** L2FIR[31]
     *  ILLEGAL_MPALOG_TPID_SW_ERR
     */
    (L2Fir, bit(31)) ? defaultMaskedError;

    /** L2FIR[32]
     *  UNEXP_HA_ST_ERR
     */
    (L2Fir, bit(32)) ? defaultMaskedError;

    /** L2FIR[33]
     *  HA_LINE_IN_CONS_CACHE_ERR
     */
    (L2Fir, bit(33)) ? defaultMaskedError;

    /** L2FIR[34]
     *  HA_TABLE_IN_PROD_CACHE_ERR
     */
    (L2Fir, bit(34)) ? defaultMaskedError;

    /** L2FIR[35]
     *  ILLEGAL_LOG_STOP_SW_ERR
     */
    (L2Fir, bit(35)) ? defaultMaskedError;

    /** L2FIR[48]
     *  SCOM_ERR1: scom error
     */
    (L2Fir, bit(48)) ? defaultMaskedError;

    /** L2FIR[49]
     *  SCOM_ERR2: scom error
     */
    (L2Fir, bit(49)) ? defaultMaskedError;
};

################################################################################
# EX Chiplet L3FIR
################################################################################

rule L3Fir
{
    CHECK_STOP:  L3FIR & ~L3FIR_MASK & ~L3FIR_ACT0 & ~L3FIR_ACT1;
    RECOVERABLE: L3FIR & ~L3FIR_MASK & ~L3FIR_ACT0 &  L3FIR_ACT1;
};

group gL3Fir filter singlebit
{
    /** L3FIR[0]
     *  PowerBus Command Error - Overrun condition.
     */
    (L3Fir, bit(0)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** L3FIR[1]
     *  PowerBus Data Error - Overrun condition.
     */
    (L3Fir, bit(1)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** L3FIR[2]
     *  Spare
     */
    (L3Fir, bit(2)) ? defaultMaskedError;

    /** L3FIR[3]
     * Spare
     */
    (L3Fir, bit(3)) ? defaultMaskedError;

    /** L3FIR[4]
     *  L3 Cache CE, no line delete requested.
     */
    (L3Fir, bit(4)) ? L3CE;

    /** L3FIR[5]
     *  L3 Cache UE.
     */
    (L3Fir, bit(5)) ? L3UE;

    /** L3FIR[4,5]
     *  L3 Cache UE with CE.
     */
    (L3Fir, bit(4,5)) ? L3UE;

    /** L3FIR[6]
     *  L3 Cache SUE.
     */
    (L3Fir, bit(6)) ? defaultMaskedError;

    /** L3FIR[7]
     *  L3 Cache Write CE from PowerBus
     */
    (L3Fir, bit(7)) ? SelfMedThr32PerDay;

    /** L3FIR[8]
     *  L3 Cache Write UE from PowerBus
     */
    (L3Fir, bit(8)) ? SelfHighThr1UE;

    /** L3FIR[9]
     *  L3 Cache Write SUE from PowerBus
     */
    (L3Fir, bit(9)) ? defaultMaskedError;

    /** L3FIR[10]
     *  L3 Cache Write CE from L2
     */
    (L3Fir, bit(10)) ? SelfHighThr32PerDay;

    /** L3FIR[11]
     *  L3 Cache Write UE from L2
     */
    (L3Fir, bit(11)) ? L3UE;

    /** L3FIR[12]
     *  L3 Cache Write SUE from L2
     */
    (L3Fir, bit(12)) ? defaultMaskedError;

    /** L3FIR[13]
     *  L3 Dir Read CE
     */
    (L3Fir, bit(13)) ? L3DirCE;

    /** L3FIR[14]
     *  L3 Dir Read UE
     */
    (L3Fir, bit(14)) ? SelfHighThr1UE;

    /** L3FIR[15]
     *  L3 Dir Read \"Phantom Error\"
     */
    (L3Fir, bit(15)) ? defaultMaskedError;

    /** L3FIR[16]
     *  L3 Store Address Error
     */
    (L3Fir, bit(16)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** L3FIR[17]
     *  L3 Load Address Error (from Prefetch Machine)
     */
    (L3Fir, bit(17)) ? SelfHighThr1;

    /** L3FIR[18]
     *  L3 Address Hang
     */
    (L3Fir, bit(18)) ? defaultMaskedError;

    /** L3FIR[19]
     *  Reserved field (Access type is l3_flink_0_load_ack_dead)
     */
    (L3Fir, bit(19)) ? callout2ndLvlMedThr1;

    /** L3FIR[20]
     *  Reserved field (Access type is l3_flink_0_store_ack_dead)
     */
    (L3Fir, bit(20)) ? callout2ndLvlMedThr1;

    /** L3FIR[21]
     *  Reserved field (Access type is l3_flink_1_load_ack_dead)
     */
    (L3Fir, bit(21)) ? callout2ndLvlMedThr1;

    /** L3FIR[22]
     *  Reserved field (Access type is l3_flink_1_store_ack_dead)
     */
    (L3Fir, bit(22)) ? callout2ndLvlMedThr1;

    /** L3FIR[23]
     *  L3 Machine Hang
     */
    (L3Fir, bit(23)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** L3FIR[24]
     *  L3 Hw Control Error
     */
    (L3Fir, bit(24)) ? SelfHighThr1;

    /** L3FIR[25]
     *  L3 Snoop Sw error detected
     */
    (L3Fir, bit(25)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** L3FIR[26]
     *  L3 Line Delete CE done
     */
    (L3Fir, bit(26)) ? defaultMaskedError;

    /** L3FIR[27]
     *  L3 DRAM Logic Error
     */
    (L3Fir, bit(27)) ? SelfHighThr1;

    /** L3FIR[28]
     *  L3 LRU SRAM Logic Recoverable Error
     */
    (L3Fir, bit(28)) ? SelfHighThr32PerDay;

    /** L3FIR[29]
     *  L3 Cache Congruence Class Deleted
     */
    (L3Fir, bit(29)) ? SelfHighThr1;

    /** L3FIR[30]
     *  L3 Cache Timer Refresh Error
     */
    (L3Fir, bit(30)) ? SelfHighThr1;

    /** L3FIR[31]
     *  L3 HA Consumer SW Access Error
     */
    (L3Fir, bit(31)) ? defaultMaskedError;

    /** L3FIR[32]
     *  L3 HA Producer SW Access Error
     */
    (L3Fir, bit(32)) ? defaultMaskedError;

    /** L3FIR[33]
     *  L3 HA Line In Consumer Cache Error
     */
    (L3Fir, bit(33)) ? defaultMaskedError;

    /** L3FIR[34]
     *  L3 HA Table In Producer Cache Error
     */
    (L3Fir, bit(34)) ? defaultMaskedError;

    /** L3FIR[35]
     *  L3 HA Log Overflow
     */
    (L3Fir, bit(35)) ? callout2ndLvlDumpSW;

    /** L3FIR[36]
     *  SCOM_ERR: scom error
     */
    (L3Fir, bit(36)) ? defaultMaskedError;

    /** L3FIR[37]
     *  SCOM_ERR: scom error
     */
    (L3Fir, bit(37)) ? defaultMaskedError;
};

################################################################################
# EX Chiplet NCUFIR
################################################################################
# Based on p8dd1_mss_FFDC_37_reviewed
###############################################################################
rule NcuFir
{
    CHECK_STOP:  NCUFIR & ~NCUFIR_MASK & ~NCUFIR_ACT0 & ~NCUFIR_ACT1;
    RECOVERABLE: NCUFIR & ~NCUFIR_MASK & ~NCUFIR_ACT0 &  NCUFIR_ACT1;
};

group gNcuFir filter singlebit
{
    /** NCUFIR[0]
     *  CONTROL_ERR: H/W control error.
     */
    (NcuFir, bit(0)) ? SelfHighThr1;

    /** NCUFIR[1]
     *  TLBIE_SW_ERR: TLBIE received illegal AP/LP field from core.
     */
    (NcuFir, bit(1)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[2]
     *  ST_ADDR_ERR: Store address machine or TLBIE/sync machine received
     *  addr_err cresp.
     */
    (NcuFir, bit(2)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[3]
     *  LD_ADDR_ERR: Load address machine received addr_err cresp.
     */
    (NcuFir, bit(3)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[4]
     *  ST_FOREIGN0_ACK_DEAD: Store received ack_dead on foreign link0.
     */
    (NcuFir, bit(4)) ? SelfHighThr32PerDay;

    /** NCUFIR[5]
     *  ST_FOREIGN1_ACK_DEAD: Store received ack_dead on foreign link1.
     */
    (NcuFir, bit(5)) ? SelfHighThr32PerDay;

    /** NCUFIR[6]
     *  LD_FOREIGN0_ACK_DEAD: Load received ack_dead on foreign link0.
     */
    (NcuFir, bit(6)) ? SelfHighThr32PerDay;

    /** NCUFIR[7]
     *  LD_FOREIGN1_ACK_DEAD: Load received ack_dead on foreign link1.
     */
    (NcuFir, bit(7)) ? SelfHighThr32PerDay;

    /** NCUFIR[8]
     *  STQ_DATA_PARITY_ERR: Store data parity error from regfile detected.
     */
    (NcuFir, bit(8)) ? SelfHighThr1UE;

    /** NCUFIR[9]
     *  STORE_TIMEOUT: Store timed out on PB.
     */
    (NcuFir, bit(9)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[10]
     *  TLBIE_MASTER_TIMEOUT: TLBIE master timed out on PB.
     */
    (NcuFir, bit(10)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[11]
     *  TLBIE_SNOOP_TIMEOUT: TLBIE snooper timed out waiting for core.
     */
    (NcuFir, bit(11)) ? SelfHighThr1;

    /** NCUFIR[12]
     *  HTM_IMA_TIMEOUT: HTM/IMA address machine timed out on PB.
     */
    (NcuFir, bit(12)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[13]
     *  IMA_CRESP_ADDR_ERR: IMA received addr_err cresp.
     */
    (NcuFir, bit(13)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[14]
     *  IMA_FOREIGN0_ACK_DEAD: IMA received ack_dead on foreign link0.
     */
    (NcuFir, bit(14)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[15]
     *  IMA_FOREIGN1_ACK_DEAD: IMA received ack_dead on foreign link1.
     */
    (NcuFir, bit(15)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[16]
     *  HTM_GOT_ACK_DEAD: HTM received ack_dead on any foreign link.
     */
    (NcuFir, bit(16)) ? defaultMaskedError;

    /** NCUFIR[17]
     *  PMISC_CRESP_ADDR_ERR: PMISC received address error cresp.
     */

    (NcuFir, bit(17)) ? calloutParentProcHighThr1;

    /** NCUFIR[18]
     *  TLBIE_CONTROL_ERR: TLBIE control error.
     */
    (NcuFir, bit(18)) ? calloutExLowSecLvlThr1MedDumpSh;

    /** NCUFIR[19|20|21|22|23]
     *  SPARE
     */
    (NcuFir, bit(19|20|21|22|23)) ? defaultMaskedError;

    /** NCUFIR[24]
     *  SCOM_ERR1: scom error
     */
    (NcuFir, bit(24)) ? defaultMaskedError;

    /** NCUFIR[25]
     *  SCOM_ERR2: scom error
     */
    (NcuFir, bit(25)) ? defaultMaskedError;
};

 ##############################################################################
 #                                                                            #
 #    #                                  ###                                  #
 #   # #    ##  ##### ###  ###  #   #   #   # #     #    ###   ###  ###  ###  #
 #  #   #  #  #   #    #  #   # ##  #   #     #    # #  #     #     #   #     #
 # ####### #      #    #  #   # # # #   #     #   #####  ###   ###  ##   ###  #
 # #     # #  #   #    #  #   # #  ##   #   # #   #   #     #     # #       # #
 # #     #  ##    #   ###  ###  #   #    ###  ### #   #  ###   ###  ###  ###  #
 #                                                                            #
 ##############################################################################

# Include the common action set.
.include "CommonActions.rule"

# When analyzing CoreFir, check for/handle core checkstop
actionclass analyzeCore
{
    funccall("CheckCoreCheckstop");
    analyze(gCoreFir);
    funccall("MaskIfCoreCheckstop");
    funccall("RestartTraceArray");
};

# Chiplet recoverable FIR indicated Core checkstop, so take actions for
# handling core checkstop. Analyze CoreFir.
actionclass analyzeCoreUnitCheckstop
{
    funccall("CheckCoreCheckstop");
    funccall("SetCoreCheckstopCause");
    analyze(gCoreFir);
    funccall("MaskIfCoreCheckstop");
};

actionclass analyzeExLFir
{
    analyze(gExLFir);
    funccall("RestartTraceArray");
};

actionclass analyzeL2Fir
{
    analyze(gL2Fir);
    funccall("RestartTraceArray");
};

actionclass analyzeL3Fir
{
    analyze(gL3Fir);
    funccall("RestartTraceArray");
};

actionclass analyzeNcuFir
{
    analyze(gNcuFir);
    funccall("RestartTraceArray");
};

actionclass L3DirCE
{
    calloutSelfHigh;
    threshold( field(32 / day), mfg_file(P8EX_L3_DIR_CES) );
};

actionclass L3UE
{
    SelfHighThr1UE;
    funccall("L3UE");
};

# Thresholding and runtime handling (line deletes and column repairs)
# for cache CEs
actionclass thrAndL2CE
{
    threshold( field(32 / day), mfg_file(P8EX_L2_CACHE_CES) );
    funccall("L2CE");
};
actionclass thrAndL3CE
{
    threshold( field(32 / day), mfg_file(P8EX_L3_CACHE_CES) );
    funccall("L3CE");
};

actionclass L3CE
{
    calloutSelfHigh;
    # only threshold and attempt repairs on FSP
    try(funccall("InHostboot"), thrAndL3CE);
};

actionclass L2CE
{
    calloutSelfHigh;
    # only threshold and attempt repairs on FSP
    try(funccall("InHostboot"), thrAndL2CE);
};

actionclass L2UE
{
    SelfHighThr1UE;
    funccall("L2UE");
};

actionclass L2DirCE
{
    calloutSelfHigh;
    threshold( field(32 / day), mfg_file(P8EX_L2_DIR_CES) );
};

actionclass L2ChipLevel2
{
    calloutParentProcLow;
    callout2ndLvlMed;
    threshold1;
};

actionclass calloutSelfHighSUE
{
    SelfHighThr1;
    flag(SUE);
};

actionclass calloutParentProcLow
{
    callout(connected(TYPE_PROC),MRU_LOW);
};

/** calls out Ex if threshold exceeds. Calls for second level support as well*/
actionclass SelfAndLevel2MedThr5PerHr
{
    calloutSelfMed;
    callout2ndLvlMed;
    threshold5phour;
};

/** callouts Proc on first instance. Calls for second level support as well*/
actionclass calloutProcLow2ndLvlMedThr1dumpSh
{
    calloutParentProcLow;
    callout2ndLvlMedThr1dumpSh;
};

/** callouts Proc on first instance. Calls for second level support as well.
 *  Set SUE flag */
actionclass calloutProcLow2ndLvlMedThr1SUE
{
    calloutParentProcLow;
    callout2ndLvlMedThr1;
    flag(SUE);
};

/** callout connected parent proc with high priority.*/
actionclass calloutParentProcHigh
{
    callout(connected(TYPE_PROC),MRU_HIGH);
};

/** callout parent proc. Threshold is 32 events per day */
actionclass calloutParentChipHighThr32
{
    calloutParentProcHigh;
    threshold32pday;
};

/** callout core, threshold 5 per day */
actionclass calloutExThr5pHr
{
    SelfHighThr5PerHour;
};

/** callout core, threshold 32per day and initiate hw dump*/
actionclass calloutExThr32pDay
{
    SelfMedThr32PerDay;
};

/** callout Ex,Sec Level on first instance ,initiate software
 *  and Hardware dump */
actionclass calloutExAndSecLvlThr1
{
    calloutSelfAndLevel2MedThr1;
    dumpSH;
};

actionclass calloutExLowSecLvlThr1MedDumpSh
{
    SelfLowLevel2MedThr1;
    dumpSH;
};

