# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/p9/p9_nimbus.rule $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2016,2017
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

chip p9_nimbus
{
    name        "P9 Nimbus chip";
    targettype  TYPE_PROC;
    sigoff      0x9000;
    dump        DUMP_CONTENT_HW;
    scomlen     64;

#Import signatures
.include "prdfP9ProcMbCommonExtraSig.H";

 #############################################################################
 #                                                                           #
 #  ######                                                                   #
 #  #     #  ######   ####     ###    ####    #####  ######  #####    ####   #
 #  #     #  #       #    #     #    #          #    #       #    #  #       #
 #  ######   #####   #          #     ####      #    #####   #    #   ####   #
 #  #   #    #       #  ###     #         #     #    #       #####        #  #
 #  #    #   #       #    #     #    #    #     #    #       #   #   #    #  #
 #  #     #  ######   ####     ###    ####      #    ######  #    #   ####   #
 #                                                                           #
 #############################################################################

    ############################################################################
    # Global Attention FIR
    ############################################################################

    register GLOBAL_CS_FIR
    {
        name        "Global Checkstop Attention FIR";
        scomaddr    0x500F001C;
        capture     group default;
    };

    register GLOBAL_RE_FIR
    {
        name        "Global Recoverable Attention FIR";
        scomaddr    0x500F001B;
        capture     group default;
    };

    ############################################################################
    # Global Unit Checkstop FIR
    ############################################################################

    register GLOBAL_UCS_FIR
    {
        name        "Global Unit Checkstop FIR";
        scomaddr    0x50040018;
        capture     req funccall("isUcsFirAccessible");
        capture     group default;
    };

    ############################################################################
    # Global Host Attention FIR
    ############################################################################

    register GLOBAL_HA_FIR
    {
        name        "Global Host Attention FIR";
        scomaddr    0x50040009;
        capture     req funccall("isHostAttnFirAccessible");
        capture     group default;
    };

    ############################################################################
    # TP Chiplet FIR
    ############################################################################

    register TP_CHIPLET_CS_FIR
    {
        name        "TP Chiplet Checkstop FIR";
        scomaddr    0x01040000;
        capture     group default;
    };

    register TP_CHIPLET_RE_FIR
    {
        name        "TP Chiplet Recoverable FIR";
        scomaddr    0x01040001;
        capture     group default;
    };

    register TP_CHIPLET_FIR_MASK
    {
        name        "TP Chiplet FIR MASK";
        scomaddr    0x01040002;
        capture     group default;
    };

    ############################################################################
    # P9 chip TP_LFIR
    ############################################################################

    register TP_LFIR
    {
        name        "P9 chip TP_LFIR";
        scomaddr    0x0104000a;
        reset       (&, 0x0104000b);
        mask        (|, 0x0104000f);
        capture     group default;
    };

    register TP_LFIR_MASK
    {
        name        "P9 chip TP_LFIR MASK";
        scomaddr    0x0104000d;
        capture     group default;
    };

    register TP_LFIR_ACT0
    {
        name        "P9 chip TP_LFIR ACT0";
        scomaddr    0x01040010;
        capture     group default;
        capture     req nonzero("TP_LFIR");
    };

    register TP_LFIR_ACT1
    {
        name        "P9 chip TP_LFIR ACT1";
        scomaddr    0x01040011;
        capture     group default;
        capture     req nonzero("TP_LFIR");
    };

    ############################################################################
    # P9 chip OCCFIR
    ############################################################################

    register OCCFIR
    {
        name        "P9 chip OCCFIR";
        scomaddr    0x01010800;
        reset       (&, 0x01010801);
        mask        (|, 0x01010805);
        capture     group default;
    };

    register OCCFIR_MASK
    {
        name        "P9 chip OCCFIR MASK";
        scomaddr    0x01010803;
        capture     group default;
    };

    register OCCFIR_ACT0
    {
        name        "P9 chip OCCFIR ACT0";
        scomaddr    0x01010806;
        capture     group default;
        capture     req nonzero("OCCFIR");
    };

    register OCCFIR_ACT1
    {
        name        "P9 chip OCCFIR ACT1";
        scomaddr    0x01010807;
        capture     group default;
        capture     req nonzero("OCCFIR");
    };

    ############################################################################
    # N0 Chiplet FIR
    ############################################################################

    register N0_CHIPLET_CS_FIR
    {
        name        "N0 Chiplet Checkstop FIR";
        scomaddr    0x02040000;
        capture     group default;
    };

    register N0_CHIPLET_RE_FIR
    {
        name        "N0 Chiplet Recoverable FIR";
        scomaddr    0x02040001;
        capture     group default;
    };

    register N0_CHIPLET_FIR_MASK
    {
        name        "N0 Chiplet FIR MASK";
        scomaddr    0x02040002;
        capture     group default;
    };

    ############################################################################
    # N0 Chiplet Unit Checkstop FIR
    ############################################################################

    register N0_CHIPLET_UCS_FIR
    {
        name        "N0 Chiplet Unit Checkstop FIR";
        scomaddr    0x02040018;
        capture     group default;
    };

    register N0_CHIPLET_UCS_FIR_MASK
    {
        name        "N0 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x02040019;
        capture     group default;
    };

    ############################################################################
    # P9 chip N0_LFIR
    ############################################################################

    register N0_LFIR
    {
        name        "P9 chip N0_LFIR";
        scomaddr    0x0204000a;
        reset       (&, 0x0204000b);
        mask        (|, 0x0204000f);
        capture     group default;
    };

    register N0_LFIR_MASK
    {
        name        "P9 chip N0_LFIR MASK";
        scomaddr    0x0204000d;
        capture     group default;
    };

    register N0_LFIR_ACT0
    {
        name        "P9 chip N0_LFIR ACT0";
        scomaddr    0x02040010;
        capture     group default;
        capture     req nonzero("N0_LFIR");
    };

    register N0_LFIR_ACT1
    {
        name        "P9 chip N0_LFIR ACT1";
        scomaddr    0x02040011;
        capture     group default;
        capture     req nonzero("N0_LFIR");
    };

    ############################################################################
    # P9 chip NXCQFIR
    ############################################################################

    register NXCQFIR
    {
        name        "P9 chip NXCQFIR";
        scomaddr    0x02011080;
        reset       (&, 0x02011081);
        mask        (|, 0x02011085);
        capture     group default;
    };

    register NXCQFIR_MASK
    {
        name        "P9 chip NXCQFIR MASK";
        scomaddr    0x02011083;
        capture     group default;
    };

    register NXCQFIR_ACT0
    {
        name        "P9 chip NXCQFIR ACT0";
        scomaddr    0x02011086;
        capture     group default;
        capture     req nonzero("NXCQFIR");
    };

    register NXCQFIR_ACT1
    {
        name        "P9 chip NXCQFIR ACT1";
        scomaddr    0x02011087;
        capture     group default;
        capture     req nonzero("NXCQFIR");
    };

    ############################################################################
    # P9 chip NXDMAENGFIR
    ############################################################################

    register NXDMAENGFIR
    {
        name        "P9 chip NXDMAENGFIR";
        scomaddr    0x02011100;
        reset       (&, 0x02011101);
        mask        (|, 0x02011105);
        capture     group default;
    };

    register NXDMAENGFIR_MASK
    {
        name        "P9 chip NXDMAENGFIR MASK";
        scomaddr    0x02011103;
        capture     group default;
    };

    register NXDMAENGFIR_ACT0
    {
        name        "P9 chip NXDMAENGFIR ACT0";
        scomaddr    0x02011106;
        capture     group default;
        capture     req nonzero("NXDMAENGFIR");
    };

    register NXDMAENGFIR_ACT1
    {
        name        "P9 chip NXDMAENGFIR ACT1";
        scomaddr    0x02011107;
        capture     group default;
        capture     req nonzero("NXDMAENGFIR");
    };

    ############################################################################
    # N1 Chiplet FIR
    ############################################################################

    register N1_CHIPLET_CS_FIR
    {
        name        "N1 Chiplet Checkstop FIR";
        scomaddr    0x03040000;
        capture     group default;
    };

    register N1_CHIPLET_RE_FIR
    {
        name        "N1 Chiplet Recoverable FIR";
        scomaddr    0x03040001;
        capture     group default;
    };

    register N1_CHIPLET_FIR_MASK
    {
        name        "N1 Chiplet FIR MASK";
        scomaddr    0x03040002;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Unit Checkstop FIR
    ############################################################################

    register N1_CHIPLET_UCS_FIR
    {
        name        "N1 Chiplet Unit Checkstop FIR";
        scomaddr    0x03040018;
        capture     group default;
    };

    register N1_CHIPLET_UCS_FIR_MASK
    {
        name        "N1 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x03040019;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Host Attention FIR
    ############################################################################

    register N1_CHIPLET_HA_FIR
    {
        name        "N1 Chiplet Host Attention FIR";
        scomaddr    0x03040009;
        capture     group default;
    };

    register N1_CHIPLET_HA_FIR_MASK
    {
        name        "N1 Chiplet Host Attention FIR MASK";
        scomaddr    0x0304001a;
        capture     group default;
    };

    ############################################################################
    # P9 chip N1_LFIR
    ############################################################################

    register N1_LFIR
    {
        name        "P9 chip N1_LFIR";
        scomaddr    0x0304000a;
        reset       (&, 0x0304000b);
        mask        (|, 0x0304000f);
        capture     group default;
    };

    register N1_LFIR_MASK
    {
        name        "P9 chip N1_LFIR MASK";
        scomaddr    0x0304000d;
        capture     group default;
    };

    register N1_LFIR_ACT0
    {
        name        "P9 chip N1_LFIR ACT0";
        scomaddr    0x03040010;
        capture     group default;
        capture     req nonzero("N1_LFIR");
    };

    register N1_LFIR_ACT1
    {
        name        "P9 chip N1_LFIR ACT1";
        scomaddr    0x03040011;
        capture     group default;
        capture     req nonzero("N1_LFIR");
    };

    ############################################################################
    # P9 chip MCDFIR 0
    ############################################################################

    register MCDFIR_0
    {
        name        "P9 chip MCDFIR 0";
        scomaddr    0x03011000;
        reset       (&, 0x03011001);
        mask        (|, 0x03011005);
        capture     group default;
    };

    register MCDFIR_0_MASK
    {
        name        "P9 chip MCDFIR 0 MASK";
        scomaddr    0x03011003;
        capture     group default;
    };

    register MCDFIR_0_ACT0
    {
        name        "P9 chip MCDFIR 0 ACT0";
        scomaddr    0x03011006;
        capture     group default;
        capture     req nonzero("MCDFIR_0");
    };

    register MCDFIR_0_ACT1
    {
        name        "P9 chip MCDFIR 0 ACT1";
        scomaddr    0x03011007;
        capture     group default;
        capture     req nonzero("MCDFIR_0");
    };

    ############################################################################
    # P9 chip MCDFIR 1
    ############################################################################

    register MCDFIR_1
    {
        name        "P9 chip MCDFIR 1";
        scomaddr    0x03011400;
        reset       (&, 0x03011401);
        mask        (|, 0x03011405);
        capture     group default;
    };

    register MCDFIR_1_MASK
    {
        name        "P9 chip MCDFIR 1 MASK";
        scomaddr    0x03011403;
        capture     group default;
    };

    register MCDFIR_1_ACT0
    {
        name        "P9 chip MCDFIR 1 ACT0";
        scomaddr    0x03011406;
        capture     group default;
        capture     req nonzero("MCDFIR_1");
    };

    register MCDFIR_1_ACT1
    {
        name        "P9 chip MCDFIR 1 ACT1";
        scomaddr    0x03011407;
        capture     group default;
        capture     req nonzero("MCDFIR_1");
    };

    ############################################################################
    # P9 chip VASFIR
    ############################################################################

    register VASFIR
    {
        name        "P9 chip VASFIR";
        scomaddr    0x03011800;
        reset       (&, 0x03011801);
        mask        (|, 0x03011805);
        capture     group default;
    };

    register VASFIR_MASK
    {
        name        "P9 chip VASFIR MASK";
        scomaddr    0x03011803;
        capture     group default;
    };

    register VASFIR_ACT0
    {
        name        "P9 chip VASFIR ACT0";
        scomaddr    0x03011806;
        capture     group default;
        capture     req nonzero("VASFIR");
    };

    register VASFIR_ACT1
    {
        name        "P9 chip VASFIR ACT1";
        scomaddr    0x03011807;
        capture     group default;
        capture     req nonzero("VASFIR");
    };

    ############################################################################
    # N2 Chiplet FIR
    ############################################################################

    register N2_CHIPLET_CS_FIR
    {
        name        "N2 Chiplet Checkstop FIR";
        scomaddr    0x04040000;
        capture     group default;
    };

    register N2_CHIPLET_RE_FIR
    {
        name        "N2 Chiplet Recoverable FIR";
        scomaddr    0x04040001;
        capture     group default;
    };

    register N2_CHIPLET_FIR_MASK
    {
        name        "N2 Chiplet FIR MASK";
        scomaddr    0x04040002;
        capture     group default;
    };

    ############################################################################
    # N2 Chiplet Unit Checkstop FIR
    ############################################################################

    register N2_CHIPLET_UCS_FIR
    {
        name        "N2 Chiplet Unit Checkstop FIR";
        scomaddr    0x04040018;
        capture     group default;
    };

    register N2_CHIPLET_UCS_FIR_MASK
    {
        name        "N2 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x04040019;
        capture     group default;
    };

    ############################################################################
    # P9 chip N2_LFIR
    ############################################################################

    register N2_LFIR
    {
        name        "P9 chip N2_LFIR";
        scomaddr    0x0404000a;
        reset       (&, 0x0404000b);
        mask        (|, 0x0404000f);
        capture     group default;
    };

    register N2_LFIR_MASK
    {
        name        "P9 chip N2_LFIR MASK";
        scomaddr    0x0404000d;
        capture     group default;
    };

    register N2_LFIR_ACT0
    {
        name        "P9 chip N2_LFIR ACT0";
        scomaddr    0x04040010;
        capture     group default;
        capture     req nonzero("N2_LFIR");
    };

    register N2_LFIR_ACT1
    {
        name        "P9 chip N2_LFIR ACT1";
        scomaddr    0x04040011;
        capture     group default;
        capture     req nonzero("N2_LFIR");
    };

    ############################################################################
    # P9 chip PSIFIR
    ############################################################################

    register PSIFIR
    {
        name        "P9 chip PSIFIR";
        scomaddr    0x04011800;
        reset       (&, 0x04011801);
        mask        (|, 0x04011805);
        capture     group default;
    };

    register PSIFIR_MASK
    {
        name        "P9 chip PSIFIR MASK";
        scomaddr    0x04011803;
        capture     group default;
    };

    register PSIFIR_ACT0
    {
        name        "P9 chip PSIFIR ACT0";
        scomaddr    0x04011806;
        capture     group default;
        capture     req nonzero("PSIFIR");
    };

    register PSIFIR_ACT1
    {
        name        "P9 chip PSIFIR ACT1";
        scomaddr    0x04011807;
        capture     group default;
        capture     req nonzero("PSIFIR");
    };

    ############################################################################
    # N3 Chiplet FIR
    ############################################################################

    register N3_CHIPLET_CS_FIR
    {
        name        "N3 Chiplet Checkstop FIR";
        scomaddr    0x05040000;
        capture     group default;
    };

    register N3_CHIPLET_RE_FIR
    {
        name        "N3 Chiplet Recoverable FIR";
        scomaddr    0x05040001;
        capture     group default;
    };

    register N3_CHIPLET_FIR_MASK
    {
        name        "N3 Chiplet FIR MASK";
        scomaddr    0x05040002;
        capture     group default;
    };

    ############################################################################
    # N3 Chiplet Unit Checkstop FIR
    ############################################################################

    register N3_CHIPLET_UCS_FIR
    {
        name        "N3 Chiplet Unit Checkstop FIR";
        scomaddr    0x05040018;
        capture     group default;
    };

    register N3_CHIPLET_UCS_FIR_MASK
    {
        name        "N3 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x05040019;
        capture     group default;
    };

    ############################################################################
    # N3 Chiplet Host Attention FIR
    ############################################################################

    register N3_CHIPLET_HA_FIR
    {
        name        "N3 Chiplet Host Attention FIR";
        scomaddr    0x05040009;
        capture     group default;
    };

    register N3_CHIPLET_HA_FIR_MASK
    {
        name        "N3 Chiplet Host Attention FIR MASK";
        scomaddr    0x0504001a;
        capture     group default;
    };

    ############################################################################
    # P9 chip N3_LFIR
    ############################################################################

    register N3_LFIR
    {
        name        "P9 chip N3_LFIR";
        scomaddr    0x0504000a;
        reset       (&, 0x0504000b);
        mask        (|, 0x0504000f);
        capture     group default;
    };

    register N3_LFIR_MASK
    {
        name        "P9 chip N3_LFIR MASK";
        scomaddr    0x0504000d;
        capture     group default;
    };

    register N3_LFIR_ACT0
    {
        name        "P9 chip N3_LFIR ACT0";
        scomaddr    0x05040010;
        capture     group default;
        capture     req nonzero("N3_LFIR");
    };

    register N3_LFIR_ACT1
    {
        name        "P9 chip N3_LFIR ACT1";
        scomaddr    0x05040011;
        capture     group default;
        capture     req nonzero("N3_LFIR");
    };

    ############################################################################
    # P9 chip NPU0FIR for Nimbus DD1.0 only
    ############################################################################

    register NPU0FIR_NDD10
    {
        name        "P9 chip NPU0FIR for Nimbus DD1.0";
        scomaddr    0x05011400;
        reset       (&, 0x05011401);
        mask        (|, 0x05011405);
        capture     group cNPU0FIR_NDD10;
    };

    register NPU0FIR_MASK_NDD10
    {
        name        "P9 chip NPU0FIR MASK for Nimbus DD1.0";
        scomaddr    0x05011403;
        capture     group cNPU0FIR_NDD10;
    };

    register NPU0FIR_ACT0_NDD10
    {
        name        "P9 chip NPU0FIR ACT0 for Nimbus DD1.0";
        scomaddr    0x05011406;
        capture     group cNPU0FIR_NDD10;
        capture     req nonzero("NPU0FIR_NDD10");
    };

    register NPU0FIR_ACT1_NDD10
    {
        name        "P9 chip NPU0FIR ACT1 for Nimbus DD1.0";
        scomaddr    0x05011407;
        capture     group cNPU0FIR_NDD10;
        capture     req nonzero("NPU0FIR_NDD10");
    };

    ############################################################################
    # P9 chip NPU1FIR for Nimbus DD1.0 only
    ############################################################################

    register NPU1FIR_NDD10
    {
        name        "P9 chip NPU1FIR for Nimbus DD1.0";
        scomaddr    0x05011440;
        reset       (&, 0x05011441);
        mask        (|, 0x05011445);
        capture     group cNPU1FIR_NDD10;
    };

    register NPU1FIR_MASK_NDD10
    {
        name        "P9 chip NPU1FIR MASK for Nimbus DD1.0";
        scomaddr    0x05011443;
        capture     group cNPU1FIR_NDD10;
    };

    register NPU1FIR_ACT0_NDD10
    {
        name        "P9 chip NPU1FIR ACT0 for Nimbus DD1.0";
        scomaddr    0x05011446;
        capture     group cNPU1FIR_NDD10;
        capture     req nonzero("NPU1FIR_NDD10");
    };

    register NPU1FIR_ACT1_NDD10
    {
        name        "P9 chip NPU1FIR ACT1 for Nimbus DD1.0";
        scomaddr    0x05011447;
        capture     group cNPU1FIR_NDD10;
        capture     req nonzero("NPU1FIR_NDD10");
    };

    ############################################################################
    # P9 chip PBWESTFIR
    ############################################################################

    register PBWESTFIR
    {
        name        "P9 chip PBWESTFIR";
        scomaddr    0x05011800;
        reset       (&, 0x05011801);
        mask        (|, 0x05011805);
        capture     group default;
    };

    register PBWESTFIR_MASK
    {
        name        "P9 chip PBWESTFIR MASK";
        scomaddr    0x05011803;
        capture     group default;
    };

    register PBWESTFIR_ACT0
    {
        name        "P9 chip PBWESTFIR ACT0";
        scomaddr    0x05011806;
        capture     group default;
        capture     req nonzero("PBWESTFIR");
    };

    register PBWESTFIR_ACT1
    {
        name        "P9 chip PBWESTFIR ACT1";
        scomaddr    0x05011807;
        capture     group default;
        capture     req nonzero("PBWESTFIR");
    };

    ############################################################################
    # P9 chip PBCENTFIR
    ############################################################################

    register PBCENTFIR
    {
        name        "P9 chip PBCENTFIR";
        scomaddr    0x05011c00;
        reset       (&, 0x05011c01);
        mask        (|, 0x05011c05);
        capture     group default;
    };

    register PBCENTFIR_MASK
    {
        name        "P9 chip PBCENTFIR MASK";
        scomaddr    0x05011c03;
        capture     group default;
    };

    register PBCENTFIR_ACT0
    {
        name        "P9 chip PBCENTFIR ACT0";
        scomaddr    0x05011c06;
        capture     group default;
        capture     req nonzero("PBCENTFIR");
    };

    register PBCENTFIR_ACT1
    {
        name        "P9 chip PBCENTFIR ACT1";
        scomaddr    0x05011c07;
        capture     group default;
        capture     req nonzero("PBCENTFIR");
    };

    ############################################################################
    # P9 chip PBEASTFIR
    ############################################################################

    register PBEASTFIR
    {
        name        "P9 chip PBEASTFIR";
        scomaddr    0x05012000;
        reset       (&, 0x05012001);
        mask        (|, 0x05012005);
        capture     group default;
    };

    register PBEASTFIR_MASK
    {
        name        "P9 chip PBEASTFIR MASK";
        scomaddr    0x05012003;
        capture     group default;
    };

    register PBEASTFIR_ACT0
    {
        name        "P9 chip PBEASTFIR ACT0";
        scomaddr    0x05012006;
        capture     group default;
        capture     req nonzero("PBEASTFIR");
    };

    register PBEASTFIR_ACT1
    {
        name        "P9 chip PBEASTFIR ACT1";
        scomaddr    0x05012007;
        capture     group default;
        capture     req nonzero("PBEASTFIR");
    };

    ############################################################################
    # P9 chip PBPPEFIR
    ############################################################################

    register PBPPEFIR
    {
        name        "P9 chip PBPPEFIR";
        scomaddr    0x05012400;
        reset       (&, 0x05012401);
        mask        (|, 0x05012405);
        capture     group default;
    };

    register PBPPEFIR_MASK
    {
        name        "P9 chip PBPPEFIR MASK";
        scomaddr    0x05012403;
        capture     group default;
    };

    register PBPPEFIR_ACT0
    {
        name        "P9 chip PBPPEFIR ACT0";
        scomaddr    0x05012406;
        capture     group default;
        capture     req nonzero("PBPPEFIR");
    };

    register PBPPEFIR_ACT1
    {
        name        "P9 chip PBPPEFIR ACT1";
        scomaddr    0x05012407;
        capture     group default;
        capture     req nonzero("PBPPEFIR");
    };

    ############################################################################
    # P9 chip PBAFIR
    ############################################################################

    register PBAFIR
    {
        name        "P9 chip PBAFIR";
        scomaddr    0x05012840;
        reset       (&, 0x05012841);
        mask        (|, 0x05012845);
        capture     group default;
    };

    register PBAFIR_MASK
    {
        name        "P9 chip PBAFIR MASK";
        scomaddr    0x05012843;
        capture     group default;
    };

    register PBAFIR_ACT0
    {
        name        "P9 chip PBAFIR ACT0";
        scomaddr    0x05012846;
        capture     group default;
        capture     req nonzero("PBAFIR");
    };

    register PBAFIR_ACT1
    {
        name        "P9 chip PBAFIR ACT1";
        scomaddr    0x05012847;
        capture     group default;
        capture     req nonzero("PBAFIR");
    };

    ############################################################################
    # P9 chip PSIHBFIR
    ############################################################################

    register PSIHBFIR
    {
        name        "P9 chip PSIHBFIR";
        scomaddr    0x05012900;
        reset       (&, 0x05012901);
        mask        (|, 0x05012905);
        capture     group default;
    };

    register PSIHBFIR_MASK
    {
        name        "P9 chip PSIHBFIR MASK";
        scomaddr    0x05012903;
        capture     group default;
    };

    register PSIHBFIR_ACT0
    {
        name        "P9 chip PSIHBFIR ACT0";
        scomaddr    0x05012906;
        capture     group default;
        capture     req nonzero("PSIHBFIR");
    };

    register PSIHBFIR_ACT1
    {
        name        "P9 chip PSIHBFIR ACT1";
        scomaddr    0x05012907;
        capture     group default;
        capture     req nonzero("PSIHBFIR");
    };

    ############################################################################
    # P9 chip ENHCAFIR
    ############################################################################

    register ENHCAFIR
    {
        name        "P9 chip ENHCAFIR";
        scomaddr    0x05012940;
        reset       (&, 0x05012941);
        mask        (|, 0x05012945);
        capture     group default;
    };

    register ENHCAFIR_MASK
    {
        name        "P9 chip ENHCAFIR MASK";
        scomaddr    0x05012943;
        capture     group default;
    };

    register ENHCAFIR_ACT0
    {
        name        "P9 chip ENHCAFIR ACT0";
        scomaddr    0x05012946;
        capture     group default;
        capture     req nonzero("ENHCAFIR");
    };

    register ENHCAFIR_ACT1
    {
        name        "P9 chip ENHCAFIR ACT1";
        scomaddr    0x05012947;
        capture     group default;
        capture     req nonzero("ENHCAFIR");
    };

    ############################################################################
    # P9 chip EHHCAFIR
    ############################################################################

    # Only existed on DD1.0 and was completely masked. So this FIR has been
    # completely removed for all DD levels.

    ############################################################################
    # P9 chip PBAMFIR
    ############################################################################

    register PBAMFIR
    {
        name        "P9 chip PBAMFIR";
        scomaddr    0x050129c0;
        reset       (&, 0x050129c1);
        mask        (|, 0x050129c5);
        capture     group default;
    };

    register PBAMFIR_MASK
    {
        name        "P9 chip PBAMFIR MASK";
        scomaddr    0x050129c3;
        capture     group default;
    };

    register PBAMFIR_ACT0
    {
        name        "P9 chip PBAMFIR ACT0";
        scomaddr    0x050129c6;
        capture     group default;
        capture     req nonzero("PBAMFIR");
    };

    register PBAMFIR_ACT1
    {
        name        "P9 chip PBAMFIR ACT1";
        scomaddr    0x050129c7;
        capture     group default;
        capture     req nonzero("PBAMFIR");
    };

    ############################################################################
    # P9 chip NMMUCQFIR
    ############################################################################

    register NMMUCQFIR
    {
        name        "P9 chip NMMUCQFIR";
        scomaddr    0x05012c00;
        reset       (&, 0x05012c01);
        mask        (|, 0x05012c05);
        capture     group default;
    };

    register NMMUCQFIR_MASK
    {
        name        "P9 chip NMMUCQFIR MASK";
        scomaddr    0x05012c03;
        capture     group default;
    };

    register NMMUCQFIR_ACT0
    {
        name        "P9 chip NMMUCQFIR ACT0";
        scomaddr    0x05012c06;
        capture     group default;
        capture     req nonzero("NMMUCQFIR");
    };

    register NMMUCQFIR_ACT1
    {
        name        "P9 chip NMMUCQFIR ACT1";
        scomaddr    0x05012c07;
        capture     group default;
        capture     req nonzero("NMMUCQFIR");
    };

    ############################################################################
    # P9 chip NMMUFIR
    ############################################################################

    register NMMUFIR
    {
        name        "P9 chip NMMUFIR";
        scomaddr    0x05012c40;
        reset       (&, 0x05012c41);
        mask        (|, 0x05012c45);
        capture     group default;
    };

    register NMMUFIR_MASK
    {
        name        "P9 chip NMMUFIR MASK";
        scomaddr    0x05012c43;
        capture     group default;
    };

    register NMMUFIR_ACT0
    {
        name        "P9 chip NMMUFIR ACT0";
        scomaddr    0x05012c46;
        capture     group default;
        capture     req nonzero("NMMUFIR");
    };

    register NMMUFIR_ACT1
    {
        name        "P9 chip NMMUFIR ACT1";
        scomaddr    0x05012c47;
        capture     group default;
        capture     req nonzero("NMMUFIR");
    };

    ############################################################################
    # P9 chip INTCQFIR
    ############################################################################

    register INTCQFIR
    {
        name        "P9 chip INTCQFIR";
        scomaddr    0x05013030;
        reset       (&, 0x05013031);
        mask        (|, 0x05013035);
        capture     group default;
    };

    register INTCQFIR_MASK
    {
        name        "P9 chip INTCQFIR MASK";
        scomaddr    0x05013033;
        capture     group default;
    };

    register INTCQFIR_ACT0
    {
        name        "P9 chip INTCQFIR ACT0";
        scomaddr    0x05013036;
        capture     group default;
        capture     req nonzero("INTCQFIR");
    };

    register INTCQFIR_ACT1
    {
        name        "P9 chip INTCQFIR ACT1";
        scomaddr    0x05013037;
        capture     group default;
        capture     req nonzero("INTCQFIR");
    };

    ############################################################################
    # P9 chip PBIOEFIR
    ############################################################################

    register PBIOEFIR
    {
        name        "P9 chip PBIOEFIR";
        scomaddr    0x05013400;
        reset       (&, 0x05013401);
        mask        (|, 0x05013405);
        capture     group default;
    };

    register PBIOEFIR_MASK
    {
        name        "P9 chip PBIOEFIR MASK";
        scomaddr    0x05013403;
        capture     group default;
    };

    register PBIOEFIR_ACT0
    {
        name        "P9 chip PBIOEFIR ACT0";
        scomaddr    0x05013406;
        capture     group default;
        capture     req nonzero("PBIOEFIR");
    };

    register PBIOEFIR_ACT1
    {
        name        "P9 chip PBIOEFIR ACT1";
        scomaddr    0x05013407;
        capture     group default;
        capture     req nonzero("PBIOEFIR");
    };

    ############################################################################
    # P9 chip PBIOOFIR
    ############################################################################

    register PBIOOFIR
    {
        name        "P9 chip PBIOOFIR";
        scomaddr    0x05013800;
        reset       (&, 0x05013801);
        mask        (|, 0x05013805);
        capture     group default;
    };

    register PBIOOFIR_MASK
    {
        name        "P9 chip PBIOOFIR MASK";
        scomaddr    0x05013803;
        capture     group default;
    };

    register PBIOOFIR_ACT0
    {
        name        "P9 chip PBIOOFIR ACT0";
        scomaddr    0x05013806;
        capture     group default;
        capture     req nonzero("PBIOOFIR");
    };

    register PBIOOFIR_ACT1
    {
        name        "P9 chip PBIOOFIR ACT1";
        scomaddr    0x05013807;
        capture     group default;
        capture     req nonzero("PBIOOFIR");
    };

    ############################################################################
    # P9 chip NPU0FIR
    ############################################################################

    register NPU0FIR
    {
        name        "P9 chip NPU0FIR";
        scomaddr    0x05013C00;
        reset       (&, 0x05013C01);
        mask        (|, 0x05013C05);
        capture     group cNPU0FIR;
    };

    register NPU0FIR_MASK
    {
        name        "P9 chip NPU0FIR MASK";
        scomaddr    0x05013C03;
        capture     group cNPU0FIR;
    };

    register NPU0FIR_ACT0
    {
        name        "P9 chip NPU0FIR ACT0";
        scomaddr    0x05013C06;
        capture     group cNPU0FIR;
        capture     req nonzero("NPU0FIR");
    };

    register NPU0FIR_ACT1
    {
        name        "P9 chip NPU0FIR ACT1";
        scomaddr    0x05013C07;
        capture     group cNPU0FIR;
        capture     req nonzero("NPU0FIR");
    };

    ############################################################################
    # P9 chip NPU1FIR
    ############################################################################

    register NPU1FIR
    {
        name        "P9 chip NPU1FIR";
        scomaddr    0x05013C40;
        reset       (&, 0x05013C41);
        mask        (|, 0x05013C45);
        capture     group cNPU1FIR;
    };

    register NPU1FIR_MASK
    {
        name        "P9 chip NPU1FIR MASK";
        scomaddr    0x05013C43;
        capture     group cNPU1FIR;
    };

    register NPU1FIR_ACT0
    {
        name        "P9 chip NPU1FIR ACT0";
        scomaddr    0x05013C46;
        capture     group cNPU1FIR;
        capture     req nonzero("NPU1FIR");
    };

    register NPU1FIR_ACT1
    {
        name        "P9 chip NPU1FIR ACT1";
        scomaddr    0x05013C47;
        capture     group cNPU1FIR;
        capture     req nonzero("NPU1FIR");
    };

    ############################################################################
    # XB Chiplet FIR
    ############################################################################

    register XB_CHIPLET_CS_FIR
    {
        name        "XB Chiplet Checkstop FIR";
        scomaddr    0x06040000;
        capture     group default;
    };

    register XB_CHIPLET_RE_FIR
    {
        name        "XB Chiplet Recoverable FIR";
        scomaddr    0x06040001;
        capture     group default;
    };

    register XB_CHIPLET_FIR_MASK
    {
        name        "XB Chiplet FIR MASK";
        scomaddr    0x06040002;
        capture     group default;
    };

    ############################################################################
    # XB Chiplet Unit Checkstop FIR
    ############################################################################

    register XB_CHIPLET_UCS_FIR
    {
        name        "XB Chiplet Unit Checkstop FIR";
        scomaddr    0x06040018;
        capture     group default;
    };

    register XB_CHIPLET_UCS_FIR_MASK
    {
        name        "XB Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x06040019;
        capture     group default;
    };

    ############################################################################
    # P9 chip XB_LFIR
    ############################################################################

    register XB_LFIR
    {
        name        "P9 chip XB_LFIR";
        scomaddr    0x0604000a;
        reset       (&, 0x0604000b);
        mask        (|, 0x0604000f);
        capture     group default;
    };

    register XB_LFIR_MASK
    {
        name        "P9 chip XB_LFIR MASK";
        scomaddr    0x0604000d;
        capture     group default;
    };

    register XB_LFIR_ACT0
    {
        name        "P9 chip XB_LFIR ACT0";
        scomaddr    0x06040010;
        capture     group default;
        capture     req nonzero("XB_LFIR");
    };

    register XB_LFIR_ACT1
    {
        name        "P9 chip XB_LFIR ACT1";
        scomaddr    0x06040011;
        capture     group default;
        capture     req nonzero("XB_LFIR");
    };

    ############################################################################
    # P9 chip XBPPEFIR
    ############################################################################

    register XBPPEFIR
    {
        name        "P9 chip XBPPEFIR";
        scomaddr    0x06010840;
        reset       (&, 0x06010841);
        mask        (|, 0x06010845);
        capture     group default;
    };

    register XBPPEFIR_MASK
    {
        name        "P9 chip XBPPEFIR MASK";
        scomaddr    0x06010843;
        capture     group default;
    };

    register XBPPEFIR_ACT0
    {
        name        "P9 chip XBPPEFIR ACT0";
        scomaddr    0x06010846;
        capture     group default;
        capture     req nonzero("XBPPEFIR");
    };

    register XBPPEFIR_ACT1
    {
        name        "P9 chip XBPPEFIR ACT1";
        scomaddr    0x06010847;
        capture     group default;
        capture     req nonzero("XBPPEFIR");
    };

    ############################################################################
    # PCI0 Chiplet FIR
    ############################################################################

    register PCI0_CHIPLET_CS_FIR
    {
        name        "PCI0 Chiplet Checkstop FIR";
        scomaddr    0x0d040000;
        capture     group PciChipletFir0;
    };

    register PCI0_CHIPLET_RE_FIR
    {
        name        "PCI0 Chiplet Recoverable FIR";
        scomaddr    0x0d040001;
        capture     group PciChipletFir0;
    };

    register PCI0_CHIPLET_FIR_MASK
    {
        name        "PCI0 Chiplet FIR MASK";
        scomaddr    0x0d040002;
        capture     group PciChipletFir0;
    };

    ############################################################################
    # PCI1 Chiplet FIR
    ############################################################################

    register PCI1_CHIPLET_CS_FIR
    {
        name        "PCI1 Chiplet Checkstop FIR";
        scomaddr    0x0e040000;
        capture     group PciChipletFir1;
    };

    register PCI1_CHIPLET_RE_FIR
    {
        name        "PCI1 Chiplet Recoverable FIR";
        scomaddr    0x0e040001;
        capture     group PciChipletFir1;
    };

    register PCI1_CHIPLET_FIR_MASK
    {
        name        "PCI1 Chiplet FIR MASK";
        scomaddr    0x0e040002;
        capture     group PciChipletFir1;
    };

    ############################################################################
    # PCI2 Chiplet FIR
    ############################################################################

    register PCI2_CHIPLET_CS_FIR
    {
        name        "PCI2 Chiplet Checkstop FIR";
        scomaddr    0x0f040000;
        capture     group PciChipletFir2;
    };

    register PCI2_CHIPLET_RE_FIR
    {
        name        "PCI2 Chiplet Recoverable FIR";
        scomaddr    0x0f040001;
        capture     group PciChipletFir2;
    };

    register PCI2_CHIPLET_FIR_MASK
    {
        name        "PCI2 Chiplet FIR MASK";
        scomaddr    0x0f040002;
        capture     group PciChipletFir2;
    };

    ############################################################################
    # P9 PROC target  HDCT additions (open power chkstop analysis)
    ############################################################################

    register OCC_ERROR_REPORT_REG
    {
        name        "OCC ERROR REPORT REG";
        scomaddr    0x0101080a;
        capture     group default;
    };

    register PB_ERROR_REPORT
    {
        name        "PB ERROR REPORT REG";
        scomaddr    0x020110a1;
        capture     group default;
    };

    register PB_PTY_ERROR_REPORT
    {
        name        "PB PTY ERROR REPORT REG";
        scomaddr    0x020110a2;
        capture     group default;
    };

    register DMA_CERR_0
    {
        name        "DMA CERR 0";
        scomaddr    0x02011057;
        capture     group default;
    };

    register DMA_CERR_1
    {
        name        "DMA CERR 1";
        scomaddr    0x02011058;
        capture     group default;
    };

    register PB_CENT_CR_ERROR
    {
        name        "PB CENT CR ERROR";
        scomaddr    0x05011c2c;
        capture     group default;
    };

    register PBA_ERR_REPORT_0
    {
        name        "PBA ERROR REPORT 0";
        scomaddr    0x0501284c;
        capture     group default;
    };

    register PBA_ERR_REPORT_1
    {
        name        "PBA ERROR REPORT 1";
        scomaddr    0x0501284d;
        capture     group default;
    };

    register PBA_ERR_REPORT_2
    {
        name        "PBA ERROR REPORT 2";
        scomaddr    0x0501284e;
        capture     group default;
    };

    register PB_PTY_ERR_REPORT
    {
        name        "PB PTY ERROR REPORT";
        scomaddr    0x05012C22;
        capture     group default;
    };

    register TOD_SLAVE_PATH_CTRL
    {
        name        "TOD SLAVE PATH CTRL";
        scomaddr    0x00040005;
        capture     group default;
    };

    register TOD_INTERNAL_PATH_CTRL
    {
        name        "TOD INTERNAL PATH CTRL";
        scomaddr    0x00040006;
        capture     group default;
    };

    register TOD_CONFIG_CTRL
    {
        name        "TOD Prim Sec Config Control";
        scomaddr    0x00040007;
        capture     group default;
    };

    register TOD_PSS_MSS_STATUS
    {
        name        "TOD PSS MSS Status Reg";
        scomaddr    0x00040008;
        capture     group default;
    };

    register TOD_MASTER_PATH_STATUS
    {
        name        "TOD Master Path Status Reg";
        scomaddr    0x00040009;
        capture     group default;
    };

    register TOD_MASTER_PATH0_STEP_STEERING
    {
        name        "TOD Master Path0 Step Steering";
        scomaddr    0x0004000E;
        capture     group default;
    };

    register TOD_MASTER_PATH1_STEP_STEERING
    {
        name        "TOD Master Path1 Step Steering";
        scomaddr    0x0004000F;
        capture     group default;
    };

    register TOD_TRACE_DATASET_1
    {
        name        "TOD Trace Dataset 1";
        scomaddr    0x0004001D;
        capture     group default;
    };

    register TOD_TRACE_DATASET_2
    {
        name        "TOD Trace Dataset 2";
        scomaddr    0x0004001E;
        capture     group default;
    };

    register TOD_TRACE_DATASET_3
    {
        name        "TOD Trace Dataset 3";
        scomaddr    0x0004001F;
        capture     group default;
    };

    register OSC_ERROR_HOLD
    {
        name        "OSC ERROR HOLD";
        scomaddr    0x01020019;
        capture     group default;
    };

    register OSC_ERROR_MASK
    {
        name        "OSC ERROR MASK";
        scomaddr    0x0102001A;
        capture     group default;
    };

    register OSC_ERROR_MODE
    {
        name        "OSC ERROR MODE";
        scomaddr    0x0102001B;
        capture     group default;
    };

    register TOD_FSM_REGISTER
    {
        name        "TOD FSM Register";
        scomaddr    0x00040024;
        capture     group default;
    };

    register TOD_TX_TTYPE_CTRL_REG
    {
        name        "TOD TX TType Ctrl reg";
        scomaddr    0x00040027;
        capture     group default;
    };

    register TOD_RX_TTYPE_CTRL_REG
    {
        name        "TOD RX TType Ctrl reg";
        scomaddr    0x00040029;
        capture     group default;
    };

    register TOD_ERROR_INTERRUPTS
    {
        name        "TOD Error and Interrupts";
        scomaddr    0x00040030;
        capture     group default;
    };

    register TOD_CERR_REPORT
    {
        name        "TOD CERR Report";
        scomaddr    0x00040032;
        capture     group default;
    };

    register TOD_ROUTE_ERRORS_TO_CORE
    {
        name        "TOD Route Errors to Core";
        scomaddr    0x00040033;
        capture     group default;
    };

# Include registers not defined by the xml
.include "p9_nimbus_regs.rule";

};

 ##############################################################################
 #                                                                            #
 # ####                                 #                                     #
 # #   # #   # #    #####  ###      #  # #    ##  ##### ###  ###  #   #  ###  #
 # #   # #   # #    #     #        #  #   #  #  #   #    #  #   # ##  # #     #
 # ####  #   # #    ####   ###    #  ####### #      #    #  #   # # # #  ###  #
 # #  #  #   # #    #         #  #   #     # #  #   #    #  #   # #  ##     # #
 # #   #  ###  #### #####  ###  #    #     #  ##    #   ###  ###  #   #  ###  #
 #                                                                            #
 ##############################################################################

################################################################################
# Global Attention FIR
################################################################################

rule rGLOBAL_FIR
{
  CHECK_STOP:
    GLOBAL_CS_FIR;
  RECOVERABLE:
    GLOBAL_RE_FIR;
};

group gGLOBAL_FIR attntype CHECK_STOP, RECOVERABLE filter singlebit
{
    /** GLOBAL_FIR[1]
     *  Attention from TP chiplet
     */
    (rGLOBAL_FIR, bit(1)) ? analyze(gTP_CHIPLET_FIR);

    /** GLOBAL_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_FIR, bit(2)) ? analyze(gN0_CHIPLET_FIR);

    /** GLOBAL_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_FIR, bit(3)) ? analyze(gN1_CHIPLET_FIR);

    /** GLOBAL_FIR[4]
     *  Attention from N2 chiplet
     */
    (rGLOBAL_FIR, bit(4)) ? analyze(gN2_CHIPLET_FIR);

    /** GLOBAL_FIR[5]
     *  Attention from N3 chiplet
     */
    (rGLOBAL_FIR, bit(5)) ? analyze(gN3_CHIPLET_FIR);

    /** GLOBAL_FIR[6]
     *  Attention from XB chiplet
     */
    (rGLOBAL_FIR, bit(6)) ? analyze(gXB_CHIPLET_FIR);

    /** GLOBAL_FIR[7]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_FIR, bit(7)) ? analyzeConnectedMCBIST0;

    /** GLOBAL_FIR[8]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_FIR, bit(8)) ? analyzeConnectedMCBIST1;

    /** GLOBAL_FIR[9]
     *  Attention from OB 0 chiplet
     */
    (rGLOBAL_FIR, bit(9)) ? analyzeConnectedOBUS0;

    /** GLOBAL_FIR[12]
     *  Attention from OB 3 chiplet
     */
    (rGLOBAL_FIR, bit(12)) ? analyzeConnectedOBUS3;

    /** GLOBAL_FIR[13]
     *  Attention from PCI0 chiplet
     */
    (rGLOBAL_FIR, bit(13)) ? analyzePciChipletFir0;

    /** GLOBAL_FIR[14]
     *  Attention from PCI1 chiplet
     */
    (rGLOBAL_FIR, bit(14)) ? analyzePciChipletFir1;

    /** GLOBAL_FIR[15]
     *  Attention from PCI2 chiplet
     */
    (rGLOBAL_FIR, bit(15)) ? analyzePciChipletFir2;

    /** GLOBAL_FIR[16]
     *  Attention from EQ 0 chiplet
     */
    (rGLOBAL_FIR, bit(16)) ? analyzeConnectedEQ0;

    /** GLOBAL_FIR[17]
     *  Attention from EQ 1 chiplet
     */
    (rGLOBAL_FIR, bit(17)) ? analyzeConnectedEQ1;

    /** GLOBAL_FIR[18]
     *  Attention from EQ 2 chiplet
     */
    (rGLOBAL_FIR, bit(18)) ? analyzeConnectedEQ2;

    /** GLOBAL_FIR[19]
     *  Attention from EQ 3 chiplet
     */
    (rGLOBAL_FIR, bit(19)) ? analyzeConnectedEQ3;

    /** GLOBAL_FIR[20]
     *  Attention from EQ 4 chiplet
     */
    (rGLOBAL_FIR, bit(20)) ? analyzeConnectedEQ4;

    /** GLOBAL_FIR[21]
     *  Attention from EQ 5 chiplet
     */
    (rGLOBAL_FIR, bit(21)) ? analyzeConnectedEQ5;

    /** GLOBAL_FIR[32]
     *  Attention from EC 0 chiplet
     */
    (rGLOBAL_FIR, bit(32)) ? analyzeConnectedEC0;

    /** GLOBAL_FIR[33]
     *  Attention from EC 1 chiplet
     */
    (rGLOBAL_FIR, bit(33)) ? analyzeConnectedEC1;

    /** GLOBAL_FIR[34]
     *  Attention from EC 2 chiplet
     */
    (rGLOBAL_FIR, bit(34)) ? analyzeConnectedEC2;

    /** GLOBAL_FIR[35]
     *  Attention from EC 3 chiplet
     */
    (rGLOBAL_FIR, bit(35)) ? analyzeConnectedEC3;

    /** GLOBAL_FIR[36]
     *  Attention from EC 4 chiplet
     */
    (rGLOBAL_FIR, bit(36)) ? analyzeConnectedEC4;

    /** GLOBAL_FIR[37]
     *  Attention from EC 5 chiplet
     */
    (rGLOBAL_FIR, bit(37)) ? analyzeConnectedEC5;

    /** GLOBAL_FIR[38]
     *  Attention from EC 6 chiplet
     */
    (rGLOBAL_FIR, bit(38)) ? analyzeConnectedEC6;

    /** GLOBAL_FIR[39]
     *  Attention from EC 7 chiplet
     */
    (rGLOBAL_FIR, bit(39)) ? analyzeConnectedEC7;

    /** GLOBAL_FIR[40]
     *  Attention from EC 8 chiplet
     */
    (rGLOBAL_FIR, bit(40)) ? analyzeConnectedEC8;

    /** GLOBAL_FIR[41]
     *  Attention from EC 9 chiplet
     */
    (rGLOBAL_FIR, bit(41)) ? analyzeConnectedEC9;

    /** GLOBAL_FIR[42]
     *  Attention from EC 10 chiplet
     */
    (rGLOBAL_FIR, bit(42)) ? analyzeConnectedEC10;

    /** GLOBAL_FIR[43]
     *  Attention from EC 11 chiplet
     */
    (rGLOBAL_FIR, bit(43)) ? analyzeConnectedEC11;

    /** GLOBAL_FIR[44]
     *  Attention from EC 12 chiplet
     */
    (rGLOBAL_FIR, bit(44)) ? analyzeConnectedEC12;

    /** GLOBAL_FIR[45]
     *  Attention from EC 13 chiplet
     */
    (rGLOBAL_FIR, bit(45)) ? analyzeConnectedEC13;

    /** GLOBAL_FIR[46]
     *  Attention from EC 14 chiplet
     */
    (rGLOBAL_FIR, bit(46)) ? analyzeConnectedEC14;

    /** GLOBAL_FIR[47]
     *  Attention from EC 15 chiplet
     */
    (rGLOBAL_FIR, bit(47)) ? analyzeConnectedEC15;

    /** GLOBAL_FIR[48]
     *  Attention from EC 16 chiplet
     */
    (rGLOBAL_FIR, bit(48)) ? analyzeConnectedEC16;

    /** GLOBAL_FIR[49]
     *  Attention from EC 17 chiplet
     */
    (rGLOBAL_FIR, bit(49)) ? analyzeConnectedEC17;

    /** GLOBAL_FIR[50]
     *  Attention from EC 18 chiplet
     */
    (rGLOBAL_FIR, bit(50)) ? analyzeConnectedEC18;

    /** GLOBAL_FIR[51]
     *  Attention from EC 19 chiplet
     */
    (rGLOBAL_FIR, bit(51)) ? analyzeConnectedEC19;

    /** GLOBAL_FIR[52]
     *  Attention from EC 20 chiplet
     */
    (rGLOBAL_FIR, bit(52)) ? analyzeConnectedEC20;

    /** GLOBAL_FIR[53]
     *  Attention from EC 21 chiplet
     */
    (rGLOBAL_FIR, bit(53)) ? analyzeConnectedEC21;

    /** GLOBAL_FIR[54]
     *  Attention from EC 22 chiplet
     */
    (rGLOBAL_FIR, bit(54)) ? analyzeConnectedEC22;

    /** GLOBAL_FIR[55]
     *  Attention from EC 23 chiplet
     */
    (rGLOBAL_FIR, bit(55)) ? analyzeConnectedEC23;

};

################################################################################
# Global Unit Checkstop FIR
################################################################################

rule rGLOBAL_UCS_FIR
{
  UNIT_CS:
    GLOBAL_UCS_FIR;
};

group gGLOBAL_UCS_FIR attntype UNIT_CS filter singlebit
{
    /** GLOBAL_UCS_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(2)) ? analyze(gN0_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(3)) ? analyze(gN1_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[4]
     *  Attention from N2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(4)) ? analyze(gN2_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[5]
     *  Attention from N3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(5)) ? analyze(gN3_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[6]
     *  Attention from XB chiplet
     */
    (rGLOBAL_UCS_FIR, bit(6)) ? analyze(gXB_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[7]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(7)) ? analyzeConnectedMCBIST0;

    /** GLOBAL_UCS_FIR[8]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(8)) ? analyzeConnectedMCBIST1;

    /** GLOBAL_UCS_FIR[9]
     *  Attention from OB 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(9)) ? analyzeConnectedOBUS0;

    /** GLOBAL_UCS_FIR[12]
     *  Attention from OB 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(12)) ? analyzeConnectedOBUS3;

    /** GLOBAL_UCS_FIR[32]
     *  Attention from EC 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(32)) ? analyzeConnectedEC0;

    /** GLOBAL_UCS_FIR[33]
     *  Attention from EC 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(33)) ? analyzeConnectedEC1;

    /** GLOBAL_UCS_FIR[34]
     *  Attention from EC 2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(34)) ? analyzeConnectedEC2;

    /** GLOBAL_UCS_FIR[35]
     *  Attention from EC 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(35)) ? analyzeConnectedEC3;

    /** GLOBAL_UCS_FIR[36]
     *  Attention from EC 4 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(36)) ? analyzeConnectedEC4;

    /** GLOBAL_UCS_FIR[37]
     *  Attention from EC 5 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(37)) ? analyzeConnectedEC5;

    /** GLOBAL_UCS_FIR[38]
     *  Attention from EC 6 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(38)) ? analyzeConnectedEC6;

    /** GLOBAL_UCS_FIR[39]
     *  Attention from EC 7 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(39)) ? analyzeConnectedEC7;

    /** GLOBAL_UCS_FIR[40]
     *  Attention from EC 8 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(40)) ? analyzeConnectedEC8;

    /** GLOBAL_UCS_FIR[41]
     *  Attention from EC 9 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(41)) ? analyzeConnectedEC9;

    /** GLOBAL_UCS_FIR[42]
     *  Attention from EC 10 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(42)) ? analyzeConnectedEC10;

    /** GLOBAL_UCS_FIR[43]
     *  Attention from EC 11 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(43)) ? analyzeConnectedEC11;

    /** GLOBAL_UCS_FIR[44]
     *  Attention from EC 12 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(44)) ? analyzeConnectedEC12;

    /** GLOBAL_UCS_FIR[45]
     *  Attention from EC 13 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(45)) ? analyzeConnectedEC13;

    /** GLOBAL_UCS_FIR[46]
     *  Attention from EC 14 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(46)) ? analyzeConnectedEC14;

    /** GLOBAL_UCS_FIR[47]
     *  Attention from EC 15 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(47)) ? analyzeConnectedEC15;

    /** GLOBAL_UCS_FIR[48]
     *  Attention from EC 16 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(48)) ? analyzeConnectedEC16;

    /** GLOBAL_UCS_FIR[49]
     *  Attention from EC 17 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(49)) ? analyzeConnectedEC17;

    /** GLOBAL_UCS_FIR[50]
     *  Attention from EC 18 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(50)) ? analyzeConnectedEC18;

    /** GLOBAL_UCS_FIR[51]
     *  Attention from EC 19 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(51)) ? analyzeConnectedEC19;

    /** GLOBAL_UCS_FIR[52]
     *  Attention from EC 20 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(52)) ? analyzeConnectedEC20;

    /** GLOBAL_UCS_FIR[53]
     *  Attention from EC 21 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(53)) ? analyzeConnectedEC21;

    /** GLOBAL_UCS_FIR[54]
     *  Attention from EC 22 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(54)) ? analyzeConnectedEC22;

    /** GLOBAL_UCS_FIR[55]
     *  Attention from EC 23 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(55)) ? analyzeConnectedEC23;

};

################################################################################
# Global Host Attention FIR
################################################################################

rule rGLOBAL_HA_FIR
{
  HOST_ATTN:
    GLOBAL_HA_FIR;
};

group gGLOBAL_HA_FIR attntype HOST_ATTN filter singlebit
{
    /** GLOBAL_HA_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(3)) ? analyze(gN1_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[5]
     *  Attention from N3 chiplet
     */
    (rGLOBAL_HA_FIR, bit(5)) ? analyze(gN3_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[7]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(7)) ? analyzeConnectedMCBIST0;

    /** GLOBAL_HA_FIR[8]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(8)) ? analyzeConnectedMCBIST1;

};

################################################################################
# TP Chiplet FIR
################################################################################

rule rTP_CHIPLET_FIR
{
  CHECK_STOP:
     TP_CHIPLET_CS_FIR       & ~TP_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (TP_CHIPLET_RE_FIR >> 2) & ~TP_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gTP_CHIPLET_FIR filter singlebit
{
    /** TP_CHIPLET_FIR[3]
     *  Attention from TP_LFIR
     */
    (rTP_CHIPLET_FIR, bit(3)) ? analyze(gTP_LFIR);

    /** TP_CHIPLET_FIR[4]
     *  Attention from OCCFIR
     */
    (rTP_CHIPLET_FIR, bit(4)) ? analyze(gOCCFIR);

};

################################################################################
# P9 chip TP_LFIR
################################################################################

rule rTP_LFIR
{
  CHECK_STOP:
    TP_LFIR & ~TP_LFIR_MASK & ~TP_LFIR_ACT0 & ~TP_LFIR_ACT1;
  RECOVERABLE:
    TP_LFIR & ~TP_LFIR_MASK & ~TP_LFIR_ACT0 &  TP_LFIR_ACT1;
};

group gTP_LFIR filter singlebit, cs_root_cause
{
    /** TP_LFIR[0]
     *  CFIR internal parity error
     */
    (rTP_LFIR, bit(0)) ? self_th_32perDay;

    /** TP_LFIR[1]
     *  GPIO: PCB error during CC access
     */
    (rTP_LFIR, bit(1)) ? self_th_32perDay;

    /** TP_LFIR[2]
     *  CC: PCB error during CC access
     */
    (rTP_LFIR, bit(2)) ? self_th_32perDay;

    /** TP_LFIR[3]
     *  CC local error
     */
    (rTP_LFIR, bit(3)) ? self_th_32perDay;

    /** TP_LFIR[4]
     *  local errors from PSC (PCB error)
     */
    (rTP_LFIR, bit(4)) ? defaultMaskedError;

    /** TP_LFIR[5]
     *  local errors from PSC (parity error)
     */
    (rTP_LFIR, bit(5)) ? defaultMaskedError;

    /** TP_LFIR[6]
     *  local errors from Thermal (parity error)
     */
    (rTP_LFIR, bit(6)) ? defaultMaskedError;

    /** TP_LFIR[7]
     *  local errors from Thermal (PCB error)
     */
    (rTP_LFIR, bit(7)) ? defaultMaskedError;

    /** TP_LFIR[8]
     *  trip critical error from thermal
     */
    (rTP_LFIR, bit(8)) ? defaultMaskedError;

    /** TP_LFIR[9]
     *  trip fatal error from thermal
     */
    (rTP_LFIR, bit(9)) ? defaultMaskedError;

    /** TP_LFIR[10]
     *  therm volttrip error
     */
    (rTP_LFIR, bit(10)) ? defaultMaskedError;

    /** TP_LFIR[11]
     *  local errors from Debug ( error)
     */
    (rTP_LFIR, bit(11)) ? defaultMaskedError;

    /** TP_LFIR[12]
     *  local errors from Trace Array ( error)
     */
    (rTP_LFIR, bit(12)) ? defaultMaskedError;

    /** TP_LFIR[13]
     *  scom trace array error
     */
    (rTP_LFIR, bit(13)) ? defaultMaskedError;

    /** TP_LFIR[14]
     *  ITR local error
     */
    (rTP_LFIR, bit(14)) ? defaultMaskedError;

    /** TP_LFIR[15]
     *  ITR local error
     */
    (rTP_LFIR, bit(15)) ? defaultMaskedError;

    /** TP_LFIR[16]
     *  local error from PCB
     */
    (rTP_LFIR, bit(16)) ? defaultMaskedError;

    /** TP_LFIR[17]
     *  local errors from I2CM ( error)
     */
    (rTP_LFIR, bit(17)) ? self_th_1;

    /** TP_LFIR[18]
     *  local errors from TOD ( error)
     */
    (rTP_LFIR, bit(18)) ? defaultMaskedError;

    /** TP_LFIR[19]
     *  local errors from TOD ( error)
     */
    (rTP_LFIR, bit(19)) ? defaultMaskedError;

    /** TP_LFIR[20]
     *  local errors from TOD ( error)
     */
    (rTP_LFIR, bit(20)) ? defaultMaskedError;

    /** TP_LFIR[21]
     *  local errors from PORT2 ( error)
     */
    (rTP_LFIR, bit(21)) ? pcb_slave_internal_parity;

    /** TP_LFIR[22]
     *  FIR error from SBE
     */
    (rTP_LFIR, bit(22)) ? self_th_1;

    /** TP_LFIR[23]
     *  FIR error from SBE
     */
    (rTP_LFIR, bit(23)) ? self_th_1;

    /** TP_LFIR[24]
     *  FIR error from SBE
     */
    (rTP_LFIR, bit(24)) ? self_th_1;

    /** TP_LFIR[25]
     *  FIR_IN25: FIR error from SBE
     */
    (rTP_LFIR, bit(25)) ? self_th_1;

    /** TP_LFIR[26]
     *  FIR_IN26: FIR error from SBE
     */
    (rTP_LFIR, bit(26)) ? defaultMaskedError;

    /** TP_LFIR[27]
     *  FIR_IN27: FIR error from SBE
     */
    (rTP_LFIR, bit(27)) ? self_th_1;

    /** TP_LFIR[28]
     *  FIR_IN28: FIR error from SBE
     */
    (rTP_LFIR, bit(28)) ? defaultMaskedError;

    /** TP_LFIR[29]
     *  FIR_IN29: FIR error from SBE
     */
    (rTP_LFIR, bit(29)) ? self_th_1;

    /** TP_LFIR[30]
     *  FIR_IN30: FIR error from SBE
     */
    (rTP_LFIR, bit(30)) ? defaultMaskedError;

    /** TP_LFIR[31]
     *  FIR_IN31: local error from OTP
     */
    (rTP_LFIR, bit(31)) ? defaultMaskedError;

    /** TP_LFIR[32]
     *  FIR_IN32: local error from Ext trigger
     */
    (rTP_LFIR, bit(32)) ? defaultMaskedError;

    /** TP_LFIR[33]
     *  FIR_IN33: Fast xstop fir error
     */
    (rTP_LFIR, bit(33)) ? defaultMaskedError;

    /** TP_LFIR[34]
     *  FIR_IN34: PCB mcast grp err
     */
    (rTP_LFIR, bit(34)) ? defaultMaskedError;

    /** TP_LFIR[35]
     *  FIR_IN35: PCB parity err
     */
    (rTP_LFIR, bit(35)) ? defaultMaskedError;

    /** TP_LFIR[36]
     *  FIR_IN36: Osc Sw fir error
     */
    (rTP_LFIR, bit(36)) ? defaultMaskedError;

    /** TP_LFIR[37]
     *  FIR_IN37: Osc Sw fir error
     */
    (rTP_LFIR, bit(37)) ? defaultMaskedError;

    /** TP_LFIR[38]
     *  local errors from pibmem
     */
    (rTP_LFIR, bit(38)) ? self_th_1;

    /** TP_LFIR[39]
     *  local errors from pibmem
     */
    (rTP_LFIR, bit(39)) ? self_th_1;

    /** TP_LFIR[40]
     *  otp uncorrectable error
     */
    (rTP_LFIR, bit(40)) ? self_th_1;

    /** TP_LFIR[41]
     *  xstop in another chiplet
     */
    (rTP_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip OCCFIR
################################################################################

rule rOCCFIR
{
  CHECK_STOP:
    OCCFIR & ~OCCFIR_MASK & ~OCCFIR_ACT0 & ~OCCFIR_ACT1;
  RECOVERABLE:
    OCCFIR & ~OCCFIR_MASK & ~OCCFIR_ACT0 &  OCCFIR_ACT1;
};

group gOCCFIR filter singlebit, cs_root_cause
{
    /** OCCFIR[0]
     *  OCC_FW0
     */
    (rOCCFIR, bit(0)) ? defaultMaskedError;

    /** OCCFIR[1]
     *  OCC_FW1
     */
    (rOCCFIR, bit(1)) ? defaultMaskedError;

    /** OCCFIR[2]
     *  OCC_CME_ERROR_NOTIFY
     */
    (rOCCFIR, bit(2)) ? defaultMaskedError;

    /** OCCFIR[3]
     *  STOP_RECOVERY_NOTIFY_PRD
     */
    (rOCCFIR, bit(3)) ? threshold_and_mask;

    /** OCCFIR[4]
     *  OCC_HB_ERROR
     */
    (rOCCFIR, bit(4)) ? defaultMaskedError;

    /** OCCFIR[5]
     *  GPE0_WATCHDOG_TIMEOUT
     */
    (rOCCFIR, bit(5)) ? defaultMaskedError;

    /** OCCFIR[6]
     *  GPE0 watchdog timeout condition
     */
    (rOCCFIR, bit(6)) ? defaultMaskedError;

    /** OCCFIR[7]
     *  GPE1  watchdog timeout condition
     */
    (rOCCFIR, bit(7)) ? defaultMaskedError;

    /** OCCFIR[8]
     *  GPE2 watchdog timeout condition
     */
    (rOCCFIR, bit(8)) ? defaultMaskedError;

    /** OCCFIR[9]
     *  GPE0 asserted an error condition
     */
    (rOCCFIR, bit(9)) ? threshold_and_mask;

    /** OCCFIR[10]
     *  GPE1 asserted an error condition
     */
    (rOCCFIR, bit(10)) ? threshold_and_mask;

    /** OCCFIR[11]
     *  GPE2 asserted an error condition
     */
    (rOCCFIR, bit(11)) ? defaultMaskedError;

    /** OCCFIR[12]
     *  GPE3 asserted an error condition
     */
    (rOCCFIR, bit(12)) ? defaultMaskedError;

    /** OCCFIR[13]
     *  OCB_ERROR
     */
    (rOCCFIR, bit(13)) ? defaultMaskedError;

    /** OCCFIR[14]
     *  SRAM Unrecoverable Error
     */
    (rOCCFIR, bit(14)) ? self_th_1;

    /** OCCFIR[15]
     *  SRAM CE
     */
    (rOCCFIR, bit(15)) ? threshold_and_mask;

    /** OCCFIR[16]
     *  SRAM Read Error
     */
    (rOCCFIR, bit(16)) ? threshold_and_mask;

    /** OCCFIR[17]
     *  SRAM Write error
     */
    (rOCCFIR, bit(17)) ? threshold_and_mask;

    /** OCCFIR[18]
     *  SRAM ctrl detected pe on tank read data
     */
    (rOCCFIR, bit(18)) ? threshold_and_mask;

    /** OCCFIR[19]
     *  SRAM cntrl  detected OCI write data pe
     */
    (rOCCFIR, bit(19)) ? threshold_and_mask;

    /** OCCFIR[20]
     *  SRAM cntrl detected OCI byte enable PE
     */
    (rOCCFIR, bit(20)) ? threshold_and_mask;

    /** OCCFIR[21]
     *  SRAM controller detected OCI address PE
     */
    (rOCCFIR, bit(21)) ? threshold_and_mask;

    /** OCCFIR[22]
     *  GPE0_HALTED:
     */
    (rOCCFIR, bit(22)) ? defaultMaskedError;

    /** OCCFIR[23]
     *  GPE1_HALTED:
     */
    (rOCCFIR, bit(23)) ? defaultMaskedError;

    /** OCCFIR[24]
     *  GPE2_HALTED:
     */
    (rOCCFIR, bit(24)) ? defaultMaskedError;

    /** OCCFIR[25]
     *  GPE3_HALTED:
     */
    (rOCCFIR, bit(25)) ? defaultMaskedError;

    /** OCCFIR[26]
     *  EXTERNAL_TRAP:
     */
    (rOCCFIR, bit(26)) ? defaultMaskedError;

    /** OCCFIR[27]
     *  PPC405_CORE_RESET
     */
    (rOCCFIR, bit(27)) ? defaultMaskedError;

    /** OCCFIR[28]
     *  PPC405_CHIP_RESET
     */
    (rOCCFIR, bit(28)) ? defaultMaskedError;

    /** OCCFIR[29]
     *  PPC405_SYSTEM_RESET
     */
    (rOCCFIR, bit(29)) ? defaultMaskedError;

    /** OCCFIR[30]
     *  PPC405_DBGMSRWE
     */
    (rOCCFIR, bit(30)) ? defaultMaskedError;

    /** OCCFIR[31]
     *  PPC405_DBGSTOPACK
     */
    (rOCCFIR, bit(31)) ? defaultMaskedError;

    /** OCCFIR[32]
     *  OCB_DB_OCI_TIMEOUT
     */
    (rOCCFIR, bit(32)) ? threshold_and_mask;

    /** OCCFIR[33]
     *  OCB_DB_OCI_READ_DATA_PARITY
     */
    (rOCCFIR, bit(33)) ? threshold_and_mask;

    /** OCCFIR[34]
     *  OCB_DB_OCI_SLAVE_ERROR
     */
    (rOCCFIR, bit(34)) ? threshold_and_mask;

    /** OCCFIR[35]
     *  OCB_PIB_ADDR_PARITY_ERR
     */
    (rOCCFIR, bit(35)) ? threshold_and_mask;

    /** OCCFIR[36]
     *  OCB_PIB_DATA_PARITY_ERR
     */
    (rOCCFIR, bit(36)) ? threshold_and_mask;

    /** OCCFIR[37]
     *  OCB_IDC0_ERROR
     */
    (rOCCFIR, bit(37)) ? threshold_and_mask;

    /** OCCFIR[38]
     *  OCB_IDC1_ERROR
     */
    (rOCCFIR, bit(38)) ? threshold_and_mask;

    /** OCCFIR[39]
     *  OCB_IDC2_ERROR
     */
    (rOCCFIR, bit(39)) ? threshold_and_mask;

    /** OCCFIR[40]
     *  OCB_IDC3_ERROR
     */
    (rOCCFIR, bit(40)) ? threshold_and_mask;

    /** OCCFIR[41]
     *  SRT_FSM_ERR
     */
    (rOCCFIR, bit(41)) ? threshold_and_mask;

    /** OCCFIR[42]
     *  JTAGACC_ERR
     */
    (rOCCFIR, bit(42)) ? threshold_and_mask;

    /** OCCFIR[43]
     *  spare
     */
    (rOCCFIR, bit(43)) ? defaultMaskedError;

    /** OCCFIR[44]
     *  C405_ECC_UE
     */
    (rOCCFIR, bit(44)) ? threshold_and_mask;

    /** OCCFIR[45]
     *  C405_ECC_CE
     */
    (rOCCFIR, bit(45)) ? self_th_1;

    /** OCCFIR[46]
     *  C405_OCI_MACHINECHECK
     */
    (rOCCFIR, bit(46)) ? threshold_and_mask;

    /** OCCFIR[47]
     *  SRAM_SPARE_DIRECT_ERROR0
     */
    (rOCCFIR, bit(47)) ? threshold_and_mask;

    /** OCCFIR[48]
     *  SRAM_SPARE_DIRECT_ERROR1
     */
    (rOCCFIR, bit(48)) ? threshold_and_mask;

    /** OCCFIR[49]
     *  SRAM_SPARE_DIRECT_ERROR2
     */
    (rOCCFIR, bit(49)) ? threshold_and_mask;

    /** OCCFIR[50]
     *  SRAM_SPARE_DIRECT_ERROR3
     */
    (rOCCFIR, bit(50)) ? threshold_and_mask;

    /** OCCFIR[51]
     *  GPE0_OCISLV_ERR
     */
    (rOCCFIR, bit(51)) ? threshold_and_mask;

    /** OCCFIR[52]
     *  GPE1_OCISLV_ERR
     */
    (rOCCFIR, bit(52)) ? threshold_and_mask;

    /** OCCFIR[53]
     *  GPE2_OCISLV_ERR
     */
    (rOCCFIR, bit(53)) ? threshold_and_mask;

    /** OCCFIR[54]
     *  GPE3_OCISLV_ERR
     */
    (rOCCFIR, bit(54)) ? threshold_and_mask;

    /** OCCFIR[55]
     *  C405ICU_M_TIMEOUT
     */
    (rOCCFIR, bit(55)) ? threshold_and_mask;

    /** OCCFIR[56]
     *  C405DCU_M_TIMEOUT
     */
    (rOCCFIR, bit(56)) ? threshold_and_mask;

    /** OCCFIR[57]
     *  OCC_COMPLEX_FAULT
     */
    (rOCCFIR, bit(57)) ? threshold_and_mask;

    /** OCCFIR[58]
     *  OCC_COMPLEX_NOTIFY
     */
    (rOCCFIR, bit(58)) ? threshold_and_mask;

    /** OCCFIR[59:61]
     *  spare
     */
    (rOCCFIR, bit(59|60|61)) ? defaultMaskedError;

    /** OCCFIR[62]
     *  scom
     */
    (rOCCFIR, bit(62)) ? defaultMaskedError;

    /** OCCFIR[63]
     *  scom error
     */
    (rOCCFIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# N0 Chiplet FIR
################################################################################

rule rN0_CHIPLET_FIR
{
  CHECK_STOP:
     N0_CHIPLET_CS_FIR       & ~N0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N0_CHIPLET_RE_FIR >> 2) & ~N0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN0_CHIPLET_FIR filter singlebit
{
    /** N0_CHIPLET_FIR[3]
     *  Attention from N0_LFIR
     */
    (rN0_CHIPLET_FIR, bit(3)) ? analyze(gN0_LFIR);

    /** N0_CHIPLET_FIR[4]
     *  Attention from NXDMAENGFIR
     */
    (rN0_CHIPLET_FIR, bit(4)) ? analyze(gNXDMAENGFIR);

    /** N0_CHIPLET_FIR[5]
     *  Attention from NXCQFIR
     */
    (rN0_CHIPLET_FIR, bit(5)) ? analyze(gNXCQFIR);

    /** N0_CHIPLET_FIR[6]
     *  Attention from CXAFIR 0
     */
    (rN0_CHIPLET_FIR, bit(6)) ? analyzeConnectedCAPP0;

};

################################################################################
# N0 Chiplet Unit Checkstop FIR
################################################################################

rule rN0_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N0_CHIPLET_UCS_FIR & ~N0_CHIPLET_UCS_FIR_MASK & `7fffffffffffffff`;
};

group gN0_CHIPLET_UCS_FIR filter singlebit
{
    /** N0_CHIPLET_UCS_FIR[1]
     *  Attention from NXDMAENGFIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(1)) ? analyze(gNXDMAENGFIR);

    /** N0_CHIPLET_UCS_FIR[2]
     *  Attention from NXCQFIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(2)) ? analyze(gNXCQFIR);

    /** N0_CHIPLET_UCS_FIR[3]
     *  Attention from CXAFIR 0
     */
    (rN0_CHIPLET_UCS_FIR, bit(3)) ? analyzeConnectedCAPP0;

};

################################################################################
# P9 chip N0_LFIR
################################################################################

rule rN0_LFIR
{
  CHECK_STOP:
    N0_LFIR & ~N0_LFIR_MASK & ~N0_LFIR_ACT0 & ~N0_LFIR_ACT1;
  RECOVERABLE:
    N0_LFIR & ~N0_LFIR_MASK & ~N0_LFIR_ACT0 &  N0_LFIR_ACT1;
};

group gN0_LFIR filter singlebit, cs_root_cause
{
    /** N0_LFIR[0]
     *  CFIR internal parity error
     */
    (rN0_LFIR, bit(0)) ? self_th_32perDay;

    /** N0_LFIR[1]
     *  Errors from Control
     */
    (rN0_LFIR, bit(1)) ? self_th_32perDay;

    /** N0_LFIR[2]
     *  local errors from CC (PCB error)
     */
    (rN0_LFIR, bit(2)) ? self_th_32perDay;

    /** N0_LFIR[3]
     *  local errors from CC
     */
    (rN0_LFIR, bit(3)) ? self_th_32perDay;

    /** N0_LFIR[4]
     *  local errors from PSC (PCB error)
     */
    (rN0_LFIR, bit(4)) ? defaultMaskedError;

    /** N0_LFIR[5]
     *  local errors from PSC (parity error)
     */
    (rN0_LFIR, bit(5)) ? defaultMaskedError;

    /** N0_LFIR[6]
     *  local errors from Thermal (parity error)
     */
    (rN0_LFIR, bit(6)) ? defaultMaskedError;

    /** N0_LFIR[7]
     *  local errors from Thermal (PCB error
     */
    (rN0_LFIR, bit(7)) ? defaultMaskedError;

    /** N0_LFIR[8]
     *  critical level Thermal error
     */
    (rN0_LFIR, bit(8)) ? defaultMaskedError;

    /** N0_LFIR[9]
     *  fatal level Thermal error
     */
    (rN0_LFIR, bit(9)) ? defaultMaskedError;

    /** N0_LFIR[10]
     *  therm volttrip error
     */
    (rN0_LFIR, bit(10)) ? defaultMaskedError;

    /** N0_LFIR[11]
     *  local errors from Debug ( error)
     */
    (rN0_LFIR, bit(11)) ? defaultMaskedError;

    /** N0_LFIR[12]
     *  local errors from Trace Array0
     */
    (rN0_LFIR, bit(12)) ? defaultMaskedError;

    /** N0_LFIR[13]
     *  local errors from Trace Array0
     */
    (rN0_LFIR, bit(13)) ? defaultMaskedError;

    /** N0_LFIR[14]
     *  local errors from Trace Array1
     */
    (rN0_LFIR, bit(14)) ? defaultMaskedError;

    /** N0_LFIR[15]
     *  local errors from Trace Array1
     */
    (rN0_LFIR, bit(15)) ? defaultMaskedError;

    /** N0_LFIR[16:23]
     *  spare
     */
    (rN0_LFIR, bit(16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** N0_LFIR[24]
     *  spare
     */
    (rN0_LFIR, bit(24)) ? defaultMaskedError;

    /** N0_LFIR[25]
     *  Errors from Bsense IO
     */
    (rN0_LFIR, bit(25)) ? defaultMaskedError;

    /** N0_LFIR[26:40]
     *  spare
     */
    (rN0_LFIR, bit(26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** N0_LFIR[41]
     *  Malf-alert Broadcast via OOB
     */
    (rN0_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip NXCQFIR
################################################################################

rule rNXCQFIR
{
  CHECK_STOP:
    NXCQFIR & ~NXCQFIR_MASK & ~NXCQFIR_ACT0 & ~NXCQFIR_ACT1;
  RECOVERABLE:
    NXCQFIR & ~NXCQFIR_MASK & ~NXCQFIR_ACT0 &  NXCQFIR_ACT1;
  UNIT_CS:
    NXCQFIR & ~NXCQFIR_MASK &  NXCQFIR_ACT0 &  NXCQFIR_ACT1;
};

group gNXCQFIR filter singlebit, cs_root_cause
{
    /** NXCQFIR[0]
     *  PBI internal parity error
     */
    (rNXCQFIR, bit(0)) ? nx_th_1;

    /** NXCQFIR[1]
     *  PowerBus CE error
     */
    (rNXCQFIR, bit(1)) ? nx_th_32perDay;

    /** NXCQFIR[2]
     *  PowerBus UE error
     */
    (rNXCQFIR, bit(2)) ? nx_th_1;

    /** NXCQFIR[3]
     *  PBUS_ECC_SUE_FIR: PowerBus SUE error
     */
    (rNXCQFIR, bit(3)) ? defaultMaskedError;

    /** NXCQFIR[4]
     *  Inbound array CE error
     */
    (rNXCQFIR, bit(4)) ? nx_th_32perDay;

    /** NXCQFIR[5]
     *  Inbound array UE error
     */
    (rNXCQFIR, bit(5)) ? nx_th_1;

    /** NXCQFIR[6]
     *  PASTE_REJECT_FIR: Paste request rejected
     */
    (rNXCQFIR, bit(6)) ? level2_th_1;

    /** NXCQFIR[7]
     *  PowerBus command hang error
     */
    (rNXCQFIR, bit(7)) ? defaultMaskedError;

    /** NXCQFIR[8]
     *  PowerBus read address error
     */
    (rNXCQFIR, bit(8)) ? nx_th_1;

    /** NXCQFIR[9]
     *  PowerBus write address error
     */
    (rNXCQFIR, bit(9)) ? nx_th_1;

    /** NXCQFIR[10]
     *  PowerBus miscellaneous error
     */
    (rNXCQFIR, bit(10)) ? nx_th_1;

    /** NXCQFIR[11]
     *  MMIO_BAR_PE_FIR: MMIO BAR parity error
     */
    (rNXCQFIR, bit(11)) ? nx_th_1;

    /** NXCQFIR[12]
     *  UMAC detected UE on WC Interrupt
     */
    (rNXCQFIR, bit(12)) ? nx_th_1;

    /** NXCQFIR[13]
     *  ACK_DEAD cresp received by read command
     */
    (rNXCQFIR, bit(13)) ? defaultMaskedError;

    /** NXCQFIR[14]
     *  ACK_DEAD cresp received by write command
     */
    (rNXCQFIR, bit(14)) ? defaultMaskedError;

    /** NXCQFIR[15]
     *  Link check aborted while waiting on data
     */
    (rNXCQFIR, bit(15)) ? defaultMaskedError;

    /** NXCQFIR[16]
     *  internal transfer hang poll time expired
     */
    (rNXCQFIR, bit(16)) ? nx_th_1;

    /** NXCQFIR[17]
     *  Parity error on ERAT arrays
     */
    (rNXCQFIR, bit(17)) ? nx_th_1;

    /** NXCQFIR[18]
     *  Correctable error on ERAT arrays
     */
    (rNXCQFIR, bit(18)) ? nx_th_32perDay;

    /** NXCQFIR[19]
     *  Uncorrectable error on ERAT arrays
     */
    (rNXCQFIR, bit(19)) ? nx_th_32perDay;

    /** NXCQFIR[20]
     *  SUE on ERAT arrays
     */
    (rNXCQFIR, bit(20)) ? nx_th_1_SUE;

    /** NXCQFIR[21]
     *  NMMU hang on checkin/checkout request
     */
    (rNXCQFIR, bit(21)) ? level2_th_1;

    /** NXCQFIR[22]
     *  ERAT control logic error
     */
    (rNXCQFIR, bit(22)) ? nx_th_1;

    /** NXCQFIR[23]
     *  UEon the Powerbus data for xlate
     */
    (rNXCQFIR, bit(23)) ? nx_th_1;

    /** NXCQFIR[24]
     *  SUE on the Powerbus data for xlate
     */
    (rNXCQFIR, bit(24)) ? nx_th_1_SUE;

    /** NXCQFIR[25]
     *  ACK_DEAD cresp received by UMAC read
     */
    (rNXCQFIR, bit(25)) ? defaultMaskedError;

    /** NXCQFIR[26]
     *  Link check aborted waiting on UMAC data
     */
    (rNXCQFIR, bit(26)) ? defaultMaskedError;

    /** NXCQFIR[27]
     *  UE on CRB QW0/4
     */
    (rNXCQFIR, bit(27)) ? nx_th_1;

    /** NXCQFIR[28]
     *  SUE on CRB QW0/4
     */
    (rNXCQFIR, bit(28)) ? nx_th_1_SUE;

    /** NXCQFIR[29]
     *  UMAC has detected a control logic error
     */
    (rNXCQFIR, bit(29)) ? nx_th_1;

    /** NXCQFIR[30]
     *  Reserved fieldUMAC_SCOM_sat_err)
     */
    (rNXCQFIR, bit(30)) ? defaultMaskedError;

    /** NXCQFIR[31]
     *  Write to RNG SCOM when writes disabled
     */
    (rNXCQFIR, bit(31)) ? defaultMaskedError;

    /** NXCQFIR[32]
     *  first noise source in the RNG has failed
     */
    (rNXCQFIR, bit(32)) ? nx_th_32perDay;

    /** NXCQFIR[33]
     *  second noise source in the RNG failed
     */
    (rNXCQFIR, bit(33)) ? nx_th_32perDay;

    /** NXCQFIR[34]
     *  RNG has detected a control logic error
     */
    (rNXCQFIR, bit(34)) ? nx_th_1;

    /** NXCQFIR[35]
     *  NMMU has signaled local checkstop
     */
    (rNXCQFIR, bit(35)) ? nx_th_1;

    /** NXCQFIR[36]
     *  VAS has signaled local checkstop
     */
    (rNXCQFIR, bit(36)) ? nx_th_1;

    /** NXCQFIR[37]
     *  PBCQ has detected a control logic error
     */
    (rNXCQFIR, bit(37)) ? nx_th_1;

    /** NXCQFIR[38]
     *  PBCQ detected failed link
     */
    (rNXCQFIR, bit(38)) ? defaultMaskedError;

    /** NXCQFIR[39]
     *  UMAC detected SUE on WC Interrupt
     */
    (rNXCQFIR, bit(39)) ? nx_th_1_SUE;

    /** NXCQFIR[40]
     *  SMF address bit = 1 error
     */
    (rNXCQFIR, bit(40)) ? defaultMaskedError;

    /** NXCQFIR[41]
     *  Reserved
     */
    (rNXCQFIR, bit(41)) ? defaultMaskedError;

    /** NXCQFIR[42]
     *  scom error
     */
    (rNXCQFIR, bit(42)) ? defaultMaskedError;

    /** NXCQFIR[43]
     *  scom error
     */
    (rNXCQFIR, bit(43)) ? defaultMaskedError;

};

################################################################################
# P9 chip NXDMAENGFIR
################################################################################

rule rNXDMAENGFIR
{
  CHECK_STOP:
    NXDMAENGFIR & ~NXDMAENGFIR_MASK & ~NXDMAENGFIR_ACT0 & ~NXDMAENGFIR_ACT1;
  RECOVERABLE:
    NXDMAENGFIR & ~NXDMAENGFIR_MASK & ~NXDMAENGFIR_ACT0 &  NXDMAENGFIR_ACT1;
  UNIT_CS:
    NXDMAENGFIR & ~NXDMAENGFIR_MASK &  NXDMAENGFIR_ACT0 &  NXDMAENGFIR_ACT1;
};

group gNXDMAENGFIR filter singlebit, cs_root_cause
{
    /** NXDMAENGFIR[0]
     *  DMA hang timer expired
     */
    (rNXDMAENGFIR, bit(0)) ? nx_th_1;

    /** NXDMAENGFIR[1]
     *  SHM invalid state
     */
    (rNXDMAENGFIR, bit(1)) ? nx_th_1;

    /** NXDMAENGFIR[2:3]
     *  spare
     */
    (rNXDMAENGFIR, bit(2|3)) ? defaultMaskedError;

    /** NXDMAENGFIR[4]
     *  Channel 0 842 engine ECC CE error
     */
    (rNXDMAENGFIR, bit(4)) ? nx_th_32perDay;

    /** NXDMAENGFIR[5]
     *  Channel 0 842 engine ECC UE error
     */
    (rNXDMAENGFIR, bit(5)) ? nx_th_1;

    /** NXDMAENGFIR[6]
     *  Channel 1 842 engine ECC CE error
     */
    (rNXDMAENGFIR, bit(6)) ? nx_th_32perDay;

    /** NXDMAENGFIR[7]
     *  Channel 1 842 engine ECC UE error
     */
    (rNXDMAENGFIR, bit(7)) ? nx_th_1;

    /** NXDMAENGFIR[8]
     *  DMA Non-zero CSB CC detected
     */
    (rNXDMAENGFIR, bit(8)) ? defaultMaskedError;

    /** NXDMAENGFIR[9]
     *  DMA array ECC CE error
     */
    (rNXDMAENGFIR, bit(9)) ? nx_th_32perDay;

    /** NXDMAENGFIR[10]
     *  DMA outWR/inRD ECC CE error
     */
    (rNXDMAENGFIR, bit(10)) ? nx_th_32perDay;

    /** NXDMAENGFIR[11]
     *  Channel 4 GZIP ECC CE
     */
    (rNXDMAENGFIR, bit(11)) ? nx_th_32perDay;

    /** NXDMAENGFIR[12]
     *  Channel 4 GZIP ECC UE
     */
    (rNXDMAENGFIR, bit(12)) ? nx_th_1;

    /** NXDMAENGFIR[13]
     *  Channel 4 GZIP ECC PE
     */
    (rNXDMAENGFIR, bit(13)) ? nx_th_1;

    /** NXDMAENGFIR[14]
     *  SCOM error from other satellites
     */
    (rNXDMAENGFIR, bit(14)) ? defaultMaskedError;

    /** NXDMAENGFIR[15]
     *  DMA invalid state error (unrecoverable)
     */
    (rNXDMAENGFIR, bit(15)) ? nx_th_1;

    /** NXDMAENGFIR[16]
     *  DMA invalid state error (unrecoverable)
     */
    (rNXDMAENGFIR, bit(16)) ? nx_th_1;

    /** NXDMAENGFIR[17]
     *  DMA array ECC UE error
     */
    (rNXDMAENGFIR, bit(17)) ? nx_th_1;

    /** NXDMAENGFIR[18]
     *  DMA outWR/inRD ECC UE error
     */
    (rNXDMAENGFIR, bit(18)) ? nx_th_1;

    /** NXDMAENGFIR[19]
     *  DMA inRD done error
     */
    (rNXDMAENGFIR, bit(19)) ? defaultMaskedError;

    /** NXDMAENGFIR[20]
     *  Channel 0 invalid state error
     */
    (rNXDMAENGFIR, bit(20)) ? nx_th_1;

    /** NXDMAENGFIR[21]
     *  Channel 1 invalid state error
     */
    (rNXDMAENGFIR, bit(21)) ? nx_th_1;

    /** NXDMAENGFIR[22]
     *  Channel 2 invalid state error
     */
    (rNXDMAENGFIR, bit(22)) ? nx_th_1;

    /** NXDMAENGFIR[23]
     *  Channel 3 invalid state error
     */
    (rNXDMAENGFIR, bit(23)) ? nx_th_1;

    /** NXDMAENGFIR[24]
     *  Channel 4 invalid state error
     */
    (rNXDMAENGFIR, bit(24)) ? nx_th_1;

    /** NXDMAENGFIR[25:30]
     *  spare
     */
    (rNXDMAENGFIR, bit(25|26|27|28|29|30)) ? defaultMaskedError;

    /** NXDMAENGFIR[31]
     *  CRB UE, on CSB/CCB
     */
    (rNXDMAENGFIR, bit(31)) ? nx_th_1;

    /** NXDMAENGFIR[32]
     *  CRB SUE, on CSB/CCB
     */
    (rNXDMAENGFIR, bit(32)) ? nx_th_1_SUE;

    /** NXDMAENGFIR[33]
     *  DMA outWR/inRD ECC SUE error
     */
    (rNXDMAENGFIR, bit(33)) ? defaultMaskedError;

    /** NXDMAENGFIR[34]
     *  Channel 0 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(34)) ? nx_th_32perDay;

    /** NXDMAENGFIR[35]
     *  Channel 1 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(35)) ? nx_th_32perDay;

    /** NXDMAENGFIR[36]
     *  Channel 2 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(36)) ? nx_th_32perDay;

    /** NXDMAENGFIR[37]
     *  Channel 3 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(37)) ? nx_th_32perDay;

    /** NXDMAENGFIR[38]
     *  Hypervisor local checkstop
     */
    (rNXDMAENGFIR, bit(38)) ? nx_th_1;

    /** NXDMAENGFIR[39]
     *  Channel 4 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(39)) ? nx_th_32perDay;

    /** NXDMAENGFIR[40:47]
     *  spare
     */
    (rNXDMAENGFIR, bit(40|41|42|43|44|45|46|47)) ? defaultMaskedError;

    /** NXDMAENGFIR[48]
     *  scom error
     */
    (rNXDMAENGFIR, bit(48)) ? defaultMaskedError;

    /** NXDMAENGFIR[49]
     *  scom error
     */
    (rNXDMAENGFIR, bit(49)) ? defaultMaskedError;

};

################################################################################
# N1 Chiplet FIR
################################################################################

rule rN1_CHIPLET_FIR
{
  CHECK_STOP:
     N1_CHIPLET_CS_FIR       & ~N1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N1_CHIPLET_RE_FIR >> 2) & ~N1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN1_CHIPLET_FIR filter singlebit
{
    /** N1_CHIPLET_FIR[3]
     *  Attention from N1_LFIR
     */
    (rN1_CHIPLET_FIR, bit(3)) ? analyze(gN1_LFIR);

    /** N1_CHIPLET_FIR[4]
     *  Attention from MCFIR 2
     */
    (rN1_CHIPLET_FIR, bit(4)) ? analyzeConnectedMCS2;

    /** N1_CHIPLET_FIR[5]
     *  Attention from MCFIR 3
     */
    (rN1_CHIPLET_FIR, bit(5)) ? analyzeConnectedMCS3;

    /** N1_CHIPLET_FIR[6]
     *  Attention from MCDFIR
     */
    (rN1_CHIPLET_FIR, bit(6)) ? analyze(gMCDFIR_0);

    /** N1_CHIPLET_FIR[7]
     *  Attention from MCDFIR
     */
    (rN1_CHIPLET_FIR, bit(7)) ? analyze(gMCDFIR_1);

    /** N1_CHIPLET_FIR[8]
     *  Attention from VASFIR
     */
    (rN1_CHIPLET_FIR, bit(8)) ? analyze(gVASFIR);

};

################################################################################
# N1 Chiplet Unit Checkstop FIR
################################################################################

rule rN1_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N1_CHIPLET_UCS_FIR & ~N1_CHIPLET_UCS_FIR_MASK & `7fffffffffffffff`;
};

group gN1_CHIPLET_UCS_FIR filter singlebit
{
    /** N1_CHIPLET_UCS_FIR[1]
     *  Attention from MCFIR 2
     */
    (rN1_CHIPLET_UCS_FIR, bit(1)) ? analyzeConnectedMCS2;

    /** N1_CHIPLET_UCS_FIR[2]
     *  Attention from MCFIR 3
     */
    (rN1_CHIPLET_UCS_FIR, bit(2)) ? analyzeConnectedMCS3;

    /** N1_CHIPLET_UCS_FIR[5]
     *  Attention from VASFIR
     */
    (rN1_CHIPLET_UCS_FIR, bit(5)) ? analyze(gVASFIR);

};

################################################################################
# N1 Chiplet Host Attention FIR
################################################################################

rule rN1_CHIPLET_HA_FIR
{
  HOST_ATTN:
    N1_CHIPLET_HA_FIR & ~N1_CHIPLET_HA_FIR_MASK & `7fffffffffffffff`;
};

group gN1_CHIPLET_HA_FIR filter singlebit
{
    /** N1_CHIPLET_HA_FIR[1]
     *  Attention from MCFIR 2
     */
    (rN1_CHIPLET_HA_FIR, bit(1)) ? analyzeConnectedMCS2;

    /** N1_CHIPLET_HA_FIR[2]
     *  Attention from MCFIR 3
     */
    (rN1_CHIPLET_HA_FIR, bit(2)) ? analyzeConnectedMCS3;

};

################################################################################
# P9 chip N1_LFIR
################################################################################

rule rN1_LFIR
{
  CHECK_STOP:
    N1_LFIR & ~N1_LFIR_MASK & ~N1_LFIR_ACT0 & ~N1_LFIR_ACT1;
  RECOVERABLE:
    N1_LFIR & ~N1_LFIR_MASK & ~N1_LFIR_ACT0 &  N1_LFIR_ACT1;
};

group gN1_LFIR filter singlebit, cs_root_cause
{
    /** N1_LFIR[0]
     *  cir internal parity error
     */
    (rN1_LFIR, bit(0)) ? self_th_32perDay;

    /** N1_LFIR[1]
     *  local errors from GPIO
     */
    (rN1_LFIR, bit(1)) ? self_th_32perDay;

    /** N1_LFIR[2]
     *  local errors from CC
     */
    (rN1_LFIR, bit(2)) ? self_th_32perDay;

    /** N1_LFIR[3]
     *  local errors from cc
     */
    (rN1_LFIR, bit(3)) ? self_th_32perDay;

    /** N1_LFIR[4]
     *  pcb error from psc
     */
    (rN1_LFIR, bit(4)) ? defaultMaskedError;

    /** N1_LFIR[5]
     *  PE local errors from PSC
     */
    (rN1_LFIR, bit(5)) ? defaultMaskedError;

    /** N1_LFIR[6]
     *  parity error from thermal
     */
    (rN1_LFIR, bit(6)) ? defaultMaskedError;

    /** N1_LFIR[7]
     *  PCM error from thermal
     */
    (rN1_LFIR, bit(7)) ? defaultMaskedError;

    /** N1_LFIR[8]
     *  trip critical error from thermal
     */
    (rN1_LFIR, bit(8)) ? defaultMaskedError;

    /** N1_LFIR[9]
     *  trip fatal error from thermal
     */
    (rN1_LFIR, bit(9)) ? defaultMaskedError;

    /** N1_LFIR[10]
     *  therm volttrip eror
     */
    (rN1_LFIR, bit(10)) ? defaultMaskedError;

    /** N1_LFIR[11]
     *  local errors from debug
     */
    (rN1_LFIR, bit(11)) ? defaultMaskedError;

    /** N1_LFIR[12]
     *  scom error from trace array0
     */
    (rN1_LFIR, bit(12)) ? defaultMaskedError;

    /** N1_LFIR[13]
     *  local errors from trace array0
     */
    (rN1_LFIR, bit(13)) ? defaultMaskedError;

    /** N1_LFIR[14]
     *  scom error from trace array1
     */
    (rN1_LFIR, bit(14)) ? defaultMaskedError;

    /** N1_LFIR[15]
     *  local errors from trace array1
     */
    (rN1_LFIR, bit(15)) ? defaultMaskedError;

    /** N1_LFIR[16]
     *  scom errors from trace array2
     */
    (rN1_LFIR, bit(16)) ? defaultMaskedError;

    /** N1_LFIR[17]
     *  local errors from trace array2
     */
    (rN1_LFIR, bit(17)) ? defaultMaskedError;

    /** N1_LFIR[18]
     *  local errors from trace array3
     */
    (rN1_LFIR, bit(18)) ? defaultMaskedError;

    /** N1_LFIR[19]
     *  local errors from trace array3
     */
    (rN1_LFIR, bit(19)) ? defaultMaskedError;

    /** N1_LFIR[20]
     *  local errors from trace array4
     */
    (rN1_LFIR, bit(20)) ? defaultMaskedError;

    /** N1_LFIR[21]
     *  local errors from trace array4
     */
    (rN1_LFIR, bit(21)) ? defaultMaskedError;

    /** N1_LFIR[22:23]
     *  spare
     */
    (rN1_LFIR, bit(22|23)) ? defaultMaskedError;

    /** N1_LFIR[24]
     *  spare
     */
    (rN1_LFIR, bit(24)) ? defaultMaskedError;

    /** N1_LFIR[25]
     *  Errors from Bsense IO
     */
    (rN1_LFIR, bit(25)) ? defaultMaskedError;

    /** N1_LFIR[26:40]
     *  spare
     */
    (rN1_LFIR, bit(26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** N1_LFIR[41]
     *  malfunction alert broadcast via OOB
     */
    (rN1_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip MCDFIR 0
################################################################################

rule rMCDFIR_0
{
  CHECK_STOP:
    MCDFIR_0 & ~MCDFIR_0_MASK & ~MCDFIR_0_ACT0 & ~MCDFIR_0_ACT1;
  RECOVERABLE:
    MCDFIR_0 & ~MCDFIR_0_MASK & ~MCDFIR_0_ACT0 &  MCDFIR_0_ACT1;
};

group gMCDFIR_0 filter singlebit, cs_root_cause
{
    /** MCDFIR_0[0]
     *  MCD array had a unrecoverable ECC error
     */
    (rMCDFIR_0, bit(0)) ? self_th_32perDay;

    /** MCDFIR_0[1]
     *  MCD array had a correctable ECC error
     */
    (rMCDFIR_0, bit(1)) ? defaultMaskedError;

    /** MCDFIR_0[2]
     *  PowerBus address Parity Error
     */
    (rMCDFIR_0, bit(2)) ? self_th_1;

    /** MCDFIR_0[3]
     *  Register bit flip in State Machine Logic
     */
    (rMCDFIR_0, bit(3)) ? self_th_1;

    /** MCDFIR_0[4]
     *  cl_probe command hung
     */
    (rMCDFIR_0, bit(4)) ? defaultMaskedError;

    /** MCDFIR_0[5]
     *  cResp for cl_probe is address error.
     */
    (rMCDFIR_0, bit(5)) ? defaultMaskedError;

    /** MCDFIR_0[6]
     *  Unsolicited cresp received
     */
    (rMCDFIR_0, bit(6)) ? self_th_1;

    /** MCDFIR_0[7]
     *  PowerBus ttag Parity Error
     */
    (rMCDFIR_0, bit(7)) ? self_th_1;

    /** MCDFIR_0[8]
     *  MCD scom register update error
     */
    (rMCDFIR_0, bit(8)) ? self_th_1;

    /** MCDFIR_0[9]
     *  ack_dead_cresp received
     */
    (rMCDFIR_0, bit(9)) ? defaultMaskedError;

    /** MCDFIR_0[10]
     *  Internal SCOM error
     */
    (rMCDFIR_0, bit(10)) ? defaultMaskedError;

    /** MCDFIR_0[11]
     *  Internal SCOM error
     */
    (rMCDFIR_0, bit(11)) ? defaultMaskedError;

};

################################################################################
# P9 chip MCDFIR 1
################################################################################

rule rMCDFIR_1
{
  CHECK_STOP:
    MCDFIR_1 & ~MCDFIR_1_MASK & ~MCDFIR_1_ACT0 & ~MCDFIR_1_ACT1;
  RECOVERABLE:
    MCDFIR_1 & ~MCDFIR_1_MASK & ~MCDFIR_1_ACT0 &  MCDFIR_1_ACT1;
};

group gMCDFIR_1 filter singlebit, cs_root_cause
{
    /** MCDFIR_1[0]
     *  MCD array had a unrecoverable ECC error
     */
    (rMCDFIR_1, bit(0)) ? self_th_32perDay;

    /** MCDFIR_1[1]
     *  MCD array had a correctable ECC error
     */
    (rMCDFIR_1, bit(1)) ? defaultMaskedError;

    /** MCDFIR_1[2]
     *  PowerBus address Parity Error
     */
    (rMCDFIR_1, bit(2)) ? self_th_1;

    /** MCDFIR_1[3]
     *  Register bit flip in State Machine Logic
     */
    (rMCDFIR_1, bit(3)) ? self_th_1;

    /** MCDFIR_1[4]
     *  cl_probe command hung
     */
    (rMCDFIR_1, bit(4)) ? defaultMaskedError;

    /** MCDFIR_1[5]
     *  cResp for cl_probe is address error.
     */
    (rMCDFIR_1, bit(5)) ? defaultMaskedError;

    /** MCDFIR_1[6]
     *  Unsolicited cresp received
     */
    (rMCDFIR_1, bit(6)) ? self_th_1;

    /** MCDFIR_1[7]
     *  PowerBus ttag Parity Error
     */
    (rMCDFIR_1, bit(7)) ? self_th_1;

    /** MCDFIR_1[8]
     *  MCD scom register update error
     */
    (rMCDFIR_1, bit(8)) ? self_th_1;

    /** MCDFIR_1[9]
     *  ack_dead_cresp received
     */
    (rMCDFIR_1, bit(9)) ? defaultMaskedError;

    /** MCDFIR_1[10]
     *  Internal SCOM error
     */
    (rMCDFIR_1, bit(10)) ? defaultMaskedError;

    /** MCDFIR_1[11]
     *  Internal SCOM error
     */
    (rMCDFIR_1, bit(11)) ? defaultMaskedError;

};

################################################################################
# P9 chip VASFIR
################################################################################

rule rVASFIR
{
  CHECK_STOP:
    VASFIR & ~VASFIR_MASK & ~VASFIR_ACT0 & ~VASFIR_ACT1;
  RECOVERABLE:
    VASFIR & ~VASFIR_MASK & ~VASFIR_ACT0 &  VASFIR_ACT1;
  UNIT_CS:
    VASFIR & ~VASFIR_MASK &  VASFIR_ACT0 &  VASFIR_ACT1;
};

group gVASFIR filter singlebit, cs_root_cause
{
    /** VASFIR[0]
     *  Egress Hardware Error
     */
    (rVASFIR, bit(0)) ? self_th_1; # NIMBUS_10

    /** VASFIR[1]
     *  Ingress Hardware Error
     */
    (rVASFIR, bit(1)) ? self_th_1; # NIMBUS_10

    /** VASFIR[2]
     *  PowerBus (CQ) Hardware Error
     */
    (rVASFIR, bit(2)) ? self_th_1; # NIMBUS_10

    /** VASFIR[3]
     *  Window Context Cache Hardware Error
     */
    (rVASFIR, bit(3)) ? self_th_1; # NIMBUS_10

    /** VASFIR[4]
     *  Register/MMIO Hardware Error
     */
    (rVASFIR, bit(4)) ? self_th_1; # NIMBUS_10

    /** VASFIR[5]
     *  PowerBus (CQ) Interface Parity Error
     */
    (rVASFIR, bit(5)) ? self_th_1;

    /** VASFIR[6]
     *  PB(CQ) Addr Error CRESP on Read
     */
    (rVASFIR, bit(6)) ? self_th_1;

    /** VASFIR[7]
     *  PB (CQ) Address Error CRESP on Read
     */
    (rVASFIR, bit(7)) ? self_th_1;

    /** VASFIR[8]
     *  Egress Correctable ECC Error
     */
    (rVASFIR, bit(8)) ? self_th_5perHour;

    /** VASFIR[9]
     *  Ingress Correctable ECC Error
     */
    (rVASFIR, bit(9)) ? self_th_5perHour;

    /** VASFIR[10]
     *  PB (CQ) CE on inbound/array data
     */
    (rVASFIR, bit(10)) ? defaultMaskedError;

    /** VASFIR[11]
     *  WC Correctable ECC Error
     */
    (rVASFIR, bit(11)) ? self_th_5perHour;

    /** VASFIR[12]
     *  Register/MMIO Correctable ECC Error
     */
    (rVASFIR, bit(12)) ? self_th_5perHour;

    /** VASFIR[13]
     *  PB Correctable Error on outbound data
     */
    (rVASFIR, bit(13)) ? self_th_5perHour;

    /** VASFIR[14]
     *  PB Uncorrectable  Error on outbound data
     */
    (rVASFIR, bit(14)) ? self_th_1;

    /** VASFIR[15]
     *  PB Master State Machine Hang
     */
    (rVASFIR, bit(15)) ? self_th_1;

    /** VASFIR[16]
     *  EG Uncorrectable ECC Error
     */
    (rVASFIR, bit(16)) ? self_th_1; # NIMBUS_10

    /** VASFIR[17]
     *  IN Uncorrectable ECC Error
     */
    (rVASFIR, bit(17)) ? self_th_1; # NIMBUS_10

    /** VASFIR[18]
     *  PB UE on inbound array data
     */
    (rVASFIR, bit(18)) ? self_th_1; # NIMBUS_10

    /** VASFIR[19]
     *  WC Uncorrectable ECC Error
     */
    (rVASFIR, bit(19)) ? self_th_1; # NIMBUS_10

    /** VASFIR[20]
     *  RG/MMIO Uncorrectable ECC Error
     */
    (rVASFIR, bit(20)) ? self_th_1; # NIMBUS_10

    /** VASFIR[21]
     *  IN CAM Parity Error
     */
    (rVASFIR, bit(21)) ? self_th_1; # NIMBUS_10

    /** VASFIR[22]
     *  IN software castout to active window
     */
    (rVASFIR, bit(22)) ? self_th_1;

    /** VASFIR[23]
     *  spare
     */
    (rVASFIR, bit(23)) ? defaultMaskedError;

    /** VASFIR[24]
     *  EG Special UE (SUE) Error
     */
    (rVASFIR, bit(24)) ? self_th_1_SUE; # NIMBUS_10

    /** VASFIR[25]
     *  IN SUE Error
     */
    (rVASFIR, bit(25)) ? self_th_1_SUE; # NIMBUS_10

    /** VASFIR[26]
     *  PB SUE Error
     */
    (rVASFIR, bit(26)) ? self_th_1_SUE; # NIMBUS_10

    /** VASFIR[27]
     *  WC SUE Error
     */
    (rVASFIR, bit(27)) ? self_th_1_SUE; # NIMBUS_10

    /** VASFIR[28]
     *  RG/MMIO SUE Error
     */
    (rVASFIR, bit(28)) ? self_th_1_SUE; # NIMBUS_10

    /** VASFIR[29]
     *  PB Link Error on Read
     */
    (rVASFIR, bit(29)) ? self_th_1; # NIMBUS_10

    /** VASFIR[30]
     *  PB Link Error on Write
     */
    (rVASFIR, bit(30)) ? defaultMaskedError;

    /** VASFIR[31]
     *  PB Link Abort Op Received
     */
    (rVASFIR, bit(31)) ? self_th_1;

    /** VASFIR[32]
     *  MMIO Read to Unimplemented Reg (HYP)
     */
    (rVASFIR, bit(32)) ? self_th_1;

    /** VASFIR[33]
     *  MMIO Read to Unimplemented Reg (OS)
     */
    (rVASFIR, bit(33)) ? self_th_1;

    /** VASFIR[34]
     *  MMIO Write to Unimplemented Reg (HYP)
     */
    (rVASFIR, bit(34)) ? self_th_1; # NIMBUS_10

    /** VASFIR[35]
     *  MMIO Write to Unimplemented Reg (OS)
     */
    (rVASFIR, bit(35)) ? self_th_1; # NIMBUS_10

    /** VASFIR[36]
     *  non-8B MMIO Detected (HYP)
     */
    (rVASFIR, bit(36)) ? self_th_1; # NIMBUS_10

    /** VASFIR[37]
     *  non-8B MMIO Detected (OS)
     */
    (rVASFIR, bit(37)) ? self_th_1; # NIMBUS_10

    /** VASFIR[38]
     *  Write Monitor Op to non-open Window
     */
    (rVASFIR, bit(38)) ? self_th_1; # NIMBUS_10

    /** VASFIR[39]
     *  Multiple Wr Mon Register Match
     */
    (rVASFIR, bit(39)) ? self_th_1; # NIMBUS_10

    /** VASFIR[40]
     *  Page Migration Requested but not enabled
     */
    (rVASFIR, bit(40)) ? self_th_1; # NIMBUS_10

    /** VASFIR[41]
     *  Page Migration size != FIFO size
     */
    (rVASFIR, bit(41)) ? self_th_1; # NIMBUS_10

    /** VASFIR[42]
     *  ASB Notify not claimed
     */
    (rVASFIR, bit(42)) ? self_th_1; # NIMBUS_10

    /** VASFIR[43]
     *  Write Monitor Op error
     */
    (rVASFIR, bit(43)) ? self_th_1; # NIMBUS_10

    /** VASFIR[44]
     *  VAS rejected a paste command
     */
    (rVASFIR, bit(44)) ? defaultMaskedError;

    /** VASFIR[45]
     *  Data Hang
     */
    (rVASFIR, bit(45)) ? defaultMaskedError;

    /** VASFIR[46]
     *  Incoming PB Parity Error
     */
    (rVASFIR, bit(46)) ? self_th_1; # NIMBUS_10

    /** VASFIR[47]
     *  Error from SCOMFIR satellite
     */
    (rVASFIR, bit(47)) ? defaultMaskedError;

    /** VASFIR[48]
     *  NX_VAS_Local_XSTOP received
     */
    (rVASFIR, bit(48)) ? self_th_1; # NIMBUS_10

    /** VASFIR[49]
     *  scom error
     */
    (rVASFIR, bit(49)) ? defaultMaskedError;

    /** VASFIR[50:51]
     *  spare
     */
    (rVASFIR, bit(50|51)) ? defaultMaskedError;

    /** VASFIR[52]
     *  scom error
     */
    (rVASFIR, bit(52)) ? defaultMaskedError;

    /** VASFIR[53]
     *  scom error
     */
    (rVASFIR, bit(53)) ? defaultMaskedError;

};

################################################################################
# N2 Chiplet FIR
################################################################################

rule rN2_CHIPLET_FIR
{
  CHECK_STOP:
     N2_CHIPLET_CS_FIR       & ~N2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N2_CHIPLET_RE_FIR >> 2) & ~N2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN2_CHIPLET_FIR filter singlebit
{
    /** N2_CHIPLET_FIR[3]
     *  Attention from N2_LFIR
     */
    (rN2_CHIPLET_FIR, bit(3)) ? analyze(gN2_LFIR);

    /** N2_CHIPLET_FIR[4]
     *  Attention from CXAFIR 1
     */
    (rN2_CHIPLET_FIR, bit(4)) ? analyzeConnectedCAPP1;

    /** N2_CHIPLET_FIR[5]
     *  Attention from PHBNFIR 0
     */
    (rN2_CHIPLET_FIR, bit(5)) ? analyzeConnectedPHB0;

    /** N2_CHIPLET_FIR[6]
     *  Attention from PHBNFIR 1
     */
    (rN2_CHIPLET_FIR, bit(6)) ? analyzeConnectedPHB1;

    /** N2_CHIPLET_FIR[7]
     *  Attention from PHBNFIR 3
     */
    (rN2_CHIPLET_FIR, bit(7)) ? analyzeConnectedPHB3;

    /** N2_CHIPLET_FIR[8]
     *  Attention from PHBNFIR 2
     */
    (rN2_CHIPLET_FIR, bit(8)) ? analyzeConnectedPHB2;

    /** N2_CHIPLET_FIR[9]
     *  Attention from PHBNFIR 4
     */
    (rN2_CHIPLET_FIR, bit(9)) ? analyzeConnectedPHB4;

    /** N2_CHIPLET_FIR[10]
     *  Attention from PHBNFIR 5
     */
    (rN2_CHIPLET_FIR, bit(10)) ? analyzeConnectedPHB5;

    /** N2_CHIPLET_FIR[11]
     *  Attention from PSIFIR
     */
    (rN2_CHIPLET_FIR, bit(11)) ? analyze(gPSIFIR);

};

################################################################################
# N2 Chiplet Unit Checkstop FIR
################################################################################

rule rN2_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N2_CHIPLET_UCS_FIR & ~N2_CHIPLET_UCS_FIR_MASK & `7fffffffffffffff`;
};

group gN2_CHIPLET_UCS_FIR filter singlebit
{
    /** N2_CHIPLET_UCS_FIR[1]
     *  Attention from CXAFIR 1
     */
    (rN2_CHIPLET_UCS_FIR, bit(1)) ? analyzeConnectedCAPP1;

};

################################################################################
# P9 chip N2_LFIR
################################################################################

rule rN2_LFIR
{
  CHECK_STOP:
    N2_LFIR & ~N2_LFIR_MASK & ~N2_LFIR_ACT0 & ~N2_LFIR_ACT1;
  RECOVERABLE:
    N2_LFIR & ~N2_LFIR_MASK & ~N2_LFIR_ACT0 &  N2_LFIR_ACT1;
};

group gN2_LFIR filter singlebit, cs_root_cause
{
    /** N2_LFIR[0]
     *  cir internal parity error
     */
    (rN2_LFIR, bit(0)) ? self_th_32perDay;

    /** N2_LFIR[1]
     *  local errors from GPIO
     */
    (rN2_LFIR, bit(1)) ? self_th_32perDay;

    /** N2_LFIR[2]
     *  local errors from CC
     */
    (rN2_LFIR, bit(2)) ? self_th_32perDay;

    /** N2_LFIR[3]
     *  local errors from cc
     */
    (rN2_LFIR, bit(3)) ? self_th_32perDay;

    /** N2_LFIR[4]
     *  pcb error from psc
     */
    (rN2_LFIR, bit(4)) ? defaultMaskedError;

    /** N2_LFIR[5]
     *  PE local errors from PSC
     */
    (rN2_LFIR, bit(5)) ? defaultMaskedError;

    /** N2_LFIR[6]
     *  parity error from thermal
     */
    (rN2_LFIR, bit(6)) ? defaultMaskedError;

    /** N2_LFIR[7]
     *  PCM error from thermal
     */
    (rN2_LFIR, bit(7)) ? defaultMaskedError;

    /** N2_LFIR[8]
     *  trip critical error from thermal
     */
    (rN2_LFIR, bit(8)) ? defaultMaskedError;

    /** N2_LFIR[9]
     *  trip fatal error from thermal
     */
    (rN2_LFIR, bit(9)) ? defaultMaskedError;

    /** N2_LFIR[10]
     *  therm volttrip eror
     */
    (rN2_LFIR, bit(10)) ? defaultMaskedError;

    /** N2_LFIR[11]
     *  local errors from debug
     */
    (rN2_LFIR, bit(11)) ? defaultMaskedError;

    /** N2_LFIR[12]
     *  scom error from trace array0
     */
    (rN2_LFIR, bit(12)) ? defaultMaskedError;

    /** N2_LFIR[13]
     *  local errors from trace array0
     */
    (rN2_LFIR, bit(13)) ? defaultMaskedError;

    /** N2_LFIR[14:23]
     *  spare
     */
    (rN2_LFIR, bit(14|15|16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** N2_LFIR[24]
     *  spare
     */
    (rN2_LFIR, bit(24)) ? defaultMaskedError;

    /** N2_LFIR[25]
     *  Errors from Bsense IO
     */
    (rN2_LFIR, bit(25)) ? defaultMaskedError;

    /** N2_LFIR[26:40]
     *  spare
     */
    (rN2_LFIR, bit(26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** N2_LFIR[41]
     *  malfunction alert broadcast via OOB
     */
    (rN2_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip PSIFIR
################################################################################

rule rPSIFIR
{
  CHECK_STOP:
    PSIFIR & ~PSIFIR_MASK & ~PSIFIR_ACT0 & ~PSIFIR_ACT1;
  RECOVERABLE:
    PSIFIR & ~PSIFIR_MASK & ~PSIFIR_ACT0 &  PSIFIR_ACT1;
};

group gPSIFIR filter singlebit, cs_root_cause
{
    /** PSIFIR[0:4]
     *  spare
     */
    (rPSIFIR, bit(0|1|2|3|4)) ? defaultMaskedError;

    /** PSIFIR[5]
     *  scom error
     */
    (rPSIFIR, bit(5)) ? defaultMaskedError;

    /** PSIFIR[6]
     *  scom error
     */
    (rPSIFIR, bit(6)) ? defaultMaskedError;

};

################################################################################
# N3 Chiplet FIR
################################################################################

rule rN3_CHIPLET_FIR
{
  CHECK_STOP:
     N3_CHIPLET_CS_FIR       & ~N3_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N3_CHIPLET_RE_FIR >> 2) & ~N3_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN3_CHIPLET_FIR filter singlebit
{
    /** N3_CHIPLET_FIR[3]
     *  Attention from N3_LFIR
     */
    (rN3_CHIPLET_FIR, bit(3)) ? analyze(gN3_LFIR);

    /** N3_CHIPLET_FIR[4]
     *  Attention from MCFIR 0
     */
    (rN3_CHIPLET_FIR, bit(4)) ? analyzeConnectedMCS0;

    /** N3_CHIPLET_FIR[5]
     *  Attention from MCFIR 1
     */
    (rN3_CHIPLET_FIR, bit(5)) ? analyzeConnectedMCS1;

    /** N3_CHIPLET_FIR[6]
     *  Attention from PBWESTFIR
     */
    (rN3_CHIPLET_FIR, bit(6)) ? analyze(gPBWESTFIR);

    /** N3_CHIPLET_FIR[7]
     *  Attention from PBCENTFIR
     */
    (rN3_CHIPLET_FIR, bit(7)) ? analyze(gPBCENTFIR);

    /** N3_CHIPLET_FIR[8]
     *  Attention from PBEASTFIR
     */
    (rN3_CHIPLET_FIR, bit(8)) ? analyze(gPBEASTFIR);

    /** N3_CHIPLET_FIR[9]
     *  Attention from ENHCAFIR
     */
    (rN3_CHIPLET_FIR, bit(9)) ? analyze(gENHCAFIR); # DD1.0 only

    /** N3_CHIPLET_FIR[10]
     *  Attention from NPU0FIR
     */
    (rN3_CHIPLET_FIR, bit(10)) ? analyzeNPU0FIR;

    /** N3_CHIPLET_FIR[11]
     *  Attention from NPU1FIR
     */
    (rN3_CHIPLET_FIR, bit(11)) ? analyzeNPU1FIR;

    /** N3_CHIPLET_FIR[12]
     *  Attention from NMMUCQFIR
     */
    (rN3_CHIPLET_FIR, bit(12)) ? analyze(gNMMUCQFIR);

    /** N3_CHIPLET_FIR[13]
     *  Attention from NMMUFIR
     */
    (rN3_CHIPLET_FIR, bit(13)) ? analyze(gNMMUFIR);

    /** N3_CHIPLET_FIR[14]
     *  Attention from PBPPEFIR
     */
    (rN3_CHIPLET_FIR, bit(14)) ? analyze(gPBPPEFIR);

    /** N3_CHIPLET_FIR[15]
     *  Attention from PBIOEFIR
     */
    (rN3_CHIPLET_FIR, bit(15)) ? analyze(gPBIOEFIR);

    /** N3_CHIPLET_FIR[16]
     *  Attention from PBIOOFIR
     */
    (rN3_CHIPLET_FIR, bit(16)) ? analyze(gPBIOOFIR);

    /** N3_CHIPLET_FIR[17]
     *  Attention from INTCQFIR
     */
    (rN3_CHIPLET_FIR, bit(17)) ? analyze(gINTCQFIR);

    /** N3_CHIPLET_FIR[18]
     *  Attention from PBAFIR
     */
    (rN3_CHIPLET_FIR, bit(18)) ? analyze(gPBAFIR);

    /** N3_CHIPLET_FIR[19]
     *  Attention from PSIHBFIR
     */
    (rN3_CHIPLET_FIR, bit(19)) ? analyze(gPSIHBFIR);

    /** N3_CHIPLET_FIR[20]
     *  Attention from PBAMFIR
     */
    (rN3_CHIPLET_FIR, bit(20)) ? analyze(gPBAMFIR);

    /** N3_CHIPLET_FIR[22]
     *  Attention from ENHCAFIR
     */
    (rN3_CHIPLET_FIR, bit(22)) ? analyze(gENHCAFIR); # DD2.0+

};

################################################################################
# N3 Chiplet Unit Checkstop FIR
################################################################################

rule rN3_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N3_CHIPLET_UCS_FIR & ~N3_CHIPLET_UCS_FIR_MASK & `7fffffffffffffff`;
};

group gN3_CHIPLET_UCS_FIR filter singlebit
{
    /** N3_CHIPLET_UCS_FIR[1]
     *  Attention from MCFIR 0
     */
    (rN3_CHIPLET_UCS_FIR, bit(1)) ? analyzeConnectedMCS0;

    /** N3_CHIPLET_UCS_FIR[2]
     *  Attention from MCFIR 1
     */
    (rN3_CHIPLET_UCS_FIR, bit(2)) ? analyzeConnectedMCS1;

    /** N3_CHIPLET_UCS_FIR[7]
     *  Attention from NPU0FIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(7)) ? analyzeNPU0FIR;

    /** N3_CHIPLET_UCS_FIR[8]
     *  Attention from NPU1FIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(8)) ? analyzeNPU1FIR;

    /** N3_CHIPLET_UCS_FIR[9]
     *  Attention from NMMUCQFIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(9)) ? analyze(gNMMUCQFIR);

    /** N3_CHIPLET_UCS_FIR[10]
     *  Attention from NMMUFIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(10)) ? analyze(gNMMUFIR);

};

################################################################################
# N3 Chiplet Host Attention FIR
################################################################################

rule rN3_CHIPLET_HA_FIR
{
  HOST_ATTN:
    N3_CHIPLET_HA_FIR & ~N3_CHIPLET_HA_FIR_MASK & `7fffffffffffffff`;
};

group gN3_CHIPLET_HA_FIR filter singlebit
{
    /** N3_CHIPLET_HA_FIR[1]
     *  Attention from MCFIR 0
     */
    (rN3_CHIPLET_HA_FIR, bit(1)) ? analyzeConnectedMCS0;

    /** N3_CHIPLET_HA_FIR[2]
     *  Attention from MCFIR 1
     */
    (rN3_CHIPLET_HA_FIR, bit(2)) ? analyzeConnectedMCS1;

};

################################################################################
# P9 chip N3_LFIR
################################################################################

rule rN3_LFIR
{
  CHECK_STOP:
    N3_LFIR & ~N3_LFIR_MASK & ~N3_LFIR_ACT0 & ~N3_LFIR_ACT1;
  RECOVERABLE:
    N3_LFIR & ~N3_LFIR_MASK & ~N3_LFIR_ACT0 &  N3_LFIR_ACT1;
};

group gN3_LFIR filter singlebit, cs_root_cause
{
    /** N3_LFIR[0]
     *  CFIR internal parity error
     */
    (rN3_LFIR, bit(0)) ? self_th_32perDay;

    /** N3_LFIR[1]
     *  Errors from Control
     */
    (rN3_LFIR, bit(1)) ? self_th_32perDay;

    /** N3_LFIR[2]
     *  local err from CC (PCB error)
     */
    (rN3_LFIR, bit(2)) ? self_th_32perDay;

    /** N3_LFIR[3]
     *  local err from CC
     */
    (rN3_LFIR, bit(3)) ? self_th_32perDay;

    /** N3_LFIR[4]
     *  local err from PSC
     */
    (rN3_LFIR, bit(4)) ? defaultMaskedError;

    /** N3_LFIR[5]
     *  local err from PSC (parity error)
     */
    (rN3_LFIR, bit(5)) ? defaultMaskedError;

    /** N3_LFIR[6]
     *  local err from Thermal (parity error)
     */
    (rN3_LFIR, bit(6)) ? defaultMaskedError;

    /** N3_LFIR[7]
     *  local err from Thermal (PCB error
     */
    (rN3_LFIR, bit(7)) ? defaultMaskedError;

    /** N3_LFIR[8]
     *  trip critical thermal local err
     */
    (rN3_LFIR, bit(8)) ? defaultMaskedError;

    /** N3_LFIR[9]
     *  trip fatal thermal local error
     */
    (rN3_LFIR, bit(9)) ? defaultMaskedError;

    /** N3_LFIR[10]
     *  therm volttrip error
     */
    (rN3_LFIR, bit(10)) ? defaultMaskedError;

    /** N3_LFIR[11]
     *  local err from Debug ( error)
     */
    (rN3_LFIR, bit(11)) ? defaultMaskedError;

    /** N3_LFIR[12]
     *  local err from trace array 0
     */
    (rN3_LFIR, bit(12)) ? defaultMaskedError;

    /** N3_LFIR[13]
     *  local err from trace array 0
     */
    (rN3_LFIR, bit(13)) ? defaultMaskedError;

    /** N3_LFIR[14]
     *  local err from trace array 1
     */
    (rN3_LFIR, bit(14)) ? defaultMaskedError;

    /** N3_LFIR[15]
     *  local err from trace array 1
     */
    (rN3_LFIR, bit(15)) ? defaultMaskedError;

    /** N3_LFIR[16]
     *  local err from trace array 2
     */
    (rN3_LFIR, bit(16)) ? defaultMaskedError;

    /** N3_LFIR[17]
     *  local err from trace array 2
     */
    (rN3_LFIR, bit(17)) ? defaultMaskedError;

    /** N3_LFIR[18]
     *  local err from trace array 3
     */
    (rN3_LFIR, bit(18)) ? defaultMaskedError;

    /** N3_LFIR[19]
     *  local err from trace array 3
     */
    (rN3_LFIR, bit(19)) ? defaultMaskedError;

    /** N3_LFIR[20]
     *  local err from trace array 4
     */
    (rN3_LFIR, bit(20)) ? defaultMaskedError;

    /** N3_LFIR[21]
     *  local err from trace array 4
     */
    (rN3_LFIR, bit(21)) ? defaultMaskedError;

    /** N3_LFIR[22]
     *  local err from trace array 5
     */
    (rN3_LFIR, bit(22)) ? defaultMaskedError;

    /** N3_LFIR[23]
     *  local err from trace array 5
     */
    (rN3_LFIR, bit(23)) ? defaultMaskedError;

    /** N3_LFIR[24]
     *  spare
     */
    (rN3_LFIR, bit(24)) ? defaultMaskedError;

    /** N3_LFIR[25]
     *  Errors from Bsense IO
     */
    (rN3_LFIR, bit(25)) ? defaultMaskedError;

    /** N3_LFIR[26:31]
     *  spare
     */
    (rN3_LFIR, bit(26|27|28|29|30|31)) ? defaultMaskedError;

    /** N3_LFIR[32]
     *  deadman timer expired
     */
    (rN3_LFIR, bit(32)) ? self_th_1;

    /** N3_LFIR[33]
     *  system quiesce failed
     */
    (rN3_LFIR, bit(33)) ? self_th_1;

    /** N3_LFIR[34]
     *  chip quiesce failed
     */
    (rN3_LFIR, bit(34)) ? self_th_1;

    /** N3_LFIR[35:40]
     *  spare
     */
    (rN3_LFIR, bit(35|36|37|38|39|40)) ? defaultMaskedError;

    /** N3_LFIR[41]
     *  Malfunction Alert broadcast via OOB
     */
    (rN3_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU0FIR
################################################################################

rule rNPU0FIR_NDD10
{
  CHECK_STOP:
    NPU0FIR_NDD10 & ~NPU0FIR_MASK_NDD10 & ~NPU0FIR_ACT0_NDD10 & ~NPU0FIR_ACT1_NDD10;
  RECOVERABLE:
    NPU0FIR_NDD10 & ~NPU0FIR_MASK_NDD10 & ~NPU0FIR_ACT0_NDD10 &  NPU0FIR_ACT1_NDD10;
  UNIT_CS:
    NPU0FIR_NDD10 & ~NPU0FIR_MASK_NDD10 &  NPU0FIR_ACT0_NDD10 &  NPU0FIR_ACT1_NDD10;
};

group gNPU0FIR_NDD10 filter singlebit, cs_root_cause
{
    /** NPU0FIR[0]
     *  NTL array CE
     */
    (rNPU0FIR_NDD10, bit(0)) ? self_th_32perDay;

    /** NPU0FIR[1]
     *  NTL header array UE
     */
    (rNPU0FIR_NDD10, bit(1)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[2]
     *  NTL Data Array UE
     */
    (rNPU0FIR_NDD10, bit(2)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[3]
     *  NTL NVLInk Control/Header/AE PE
     */
    (rNPU0FIR_NDD10, bit(3)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[4]
     *  NTL NVLink Data Parity error
     */
    (rNPU0FIR_NDD10, bit(4)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[5]
     *  NTL NVLink Malformed Packet
     */
    (rNPU0FIR_NDD10, bit(5)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[6]
     *  NTL NVLink Unsupported Packet
     */
    (rNPU0FIR_NDD10, bit(6)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[7]
     *  NTL NVLink Config errors
     */
    (rNPU0FIR_NDD10, bit(7)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[8]
     *  NTL NVLink CRC errors or LMD=Stomp
     */
    (rNPU0FIR_NDD10, bit(8)) ? defaultMaskedError;

    /** NPU0FIR[9]
     *  NTL PRI errors
     */
    (rNPU0FIR_NDD10, bit(9)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[10]
     *  NTL logic error
     */
    (rNPU0FIR_NDD10, bit(10)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[11]
     *  NTL LMD=Data Posion
     */
    (rNPU0FIR_NDD10, bit(11)) ? defaultMaskedError;

    /** NPU0FIR[12]
     *  NTL data array SUE
     */
    (rNPU0FIR_NDD10, bit(12)) ? defaultMaskedError;

    /** NPU0FIR[13]
     *  CQ CTL/SM ASBE Array single-bit CE
     */
    (rNPU0FIR_NDD10, bit(13)) ? self_th_32perDay;

    /** NPU0FIR[14]
     *  CQ CTL/SM PBR PowerBus Recoverable err
     */
    (rNPU0FIR_NDD10, bit(14)) ? defaultMaskedError;

    /** NPU0FIR[15]
     *  CQ CTL/SM REG Register ring error
     */
    (rNPU0FIR_NDD10, bit(15)) ? self_th_32perDay;

    /** NPU0FIR[16]
     *  Data UE for MMIO store data
     */
    (rNPU0FIR_NDD10, bit(16)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[17]
     *  spare
     */
    (rNPU0FIR_NDD10, bit(17)) ? defaultMaskedError;

    /** NPU0FIR[18]
     *  CQ CTL/SM NCF NVLink config error
     */
    (rNPU0FIR_NDD10, bit(18)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[19]
     *  CQ CTL/SM NVF NVLink fatal error
     */
    (rNPU0FIR_NDD10, bit(19)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[20]
     *  spare
     */
    (rNPU0FIR_NDD10, bit(20)) ? defaultMaskedError;

    /** NPU0FIR[21]
     *  CQ CTL/SM AUE Array UE
     */
    (rNPU0FIR_NDD10, bit(21)) ? self_th_1;

    /** NPU0FIR[22]
     *  CQ CTL/SM PBP PowerBus parity error
     */
    (rNPU0FIR_NDD10, bit(22)) ? self_th_1;

    /** NPU0FIR[23]
     *  CQ CTL/SM PBF PowerBus Fatal Error
     */
    (rNPU0FIR_NDD10, bit(23)) ? level2_M_self_L_th_1;

    /** NPU0FIR[24]
     *  PowerBus configuration error
     */
    (rNPU0FIR_NDD10, bit(24)) ? level2_M_self_L_th_1;

    /** NPU0FIR[25]
     *  CQ CTL/SM FWD Forward-Progress error
     */
    (rNPU0FIR_NDD10, bit(25)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[26]
     *  CQ CTL/SM NLG NPU Logic error
     */
    (rNPU0FIR_NDD10, bit(26)) ? self_th_1;

    /** NPU0FIR[27]
     *  CQ CTL/SM  UT=1 to frozen PE error
     */
    (rNPU0FIR_NDD10, bit(27)) ? defaultMaskedError;

    /** NPU0FIR[28]
     *  spare
     */
    (rNPU0FIR_NDD10, bit(28)) ? defaultMaskedError;

    /** NPU0FIR[29]
     *  CQ DAT ECC UE/SUE on data/BE arrays
     */
    (rNPU0FIR_NDD10, bit(29)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[30]
     *  CQ DAT ECC CE on data/BE arrays
     */
    (rNPU0FIR_NDD10, bit(30)) ? self_M_level2_L_th_32perDay;

    /** NPU0FIR[31]
     *  CQ DAT parity error on data/BE latches
     */
    (rNPU0FIR_NDD10, bit(31)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[32]
     *  CQ DAT parity errs on config regs
     */
    (rNPU0FIR_NDD10, bit(32)) ? self_th_1;

    /** NPU0FIR[33]
     *  CQ DAT parity errs/PowerBus rtag
     */
    (rNPU0FIR_NDD10, bit(33)) ? self_th_1;

    /** NPU0FIR[34]
     *  CQ DAT parity errs nternal state latches
     */
    (rNPU0FIR_NDD10, bit(34)) ? self_th_1;

    /** NPU0FIR[35]
     *  CQ DAT logic error
     */
    (rNPU0FIR_NDD10, bit(35)) ? self_th_1;

    /** NPU0FIR[36]
     *  Future SUE
     */
    (rNPU0FIR_NDD10, bit(36)) ? defaultMaskedError;

    /** NPU0FIR[37]
     *  ECC SUE on PB received data
     */
    (rNPU0FIR_NDD10, bit(37)) ? defaultMaskedError;

    /** NPU0FIR[38:39]
     *  spare
     */
    (rNPU0FIR_NDD10, bit(38|39)) ? defaultMaskedError;

    /** NPU0FIR[40]
     *  XTS internal logic error
     */
    (rNPU0FIR_NDD10, bit(40)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[41]
     *  XTS correctable errs in XTS SRAM
     */
    (rNPU0FIR_NDD10, bit(41)) ? self_M_level2_L_th_32perDay;

    /** NPU0FIR[42]
     *  XTS Ues in XTS internal SRAM
     */
    (rNPU0FIR_NDD10, bit(42)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[43]
     *  XTS CE on incoming stack transactions
     */
    (rNPU0FIR_NDD10, bit(43)) ? self_M_level2_L_th_32perDay;

    /** NPU0FIR[44]
     *  XTS  errs incoming stack transaction
     */
    (rNPU0FIR_NDD10, bit(44)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[45]
     *  XTS errs on incoming PBUS transaction
     */
    (rNPU0FIR_NDD10, bit(45)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[46]
     *  XTS Translate Request Fail
     */
    (rNPU0FIR_NDD10, bit(46)) ? self_th_1; # NIMBUS_10

    /** NPU0FIR[47:59]
     *  spare
     */
    (rNPU0FIR_NDD10, bit(47|48|49|50|51|52|53|54|55|56|57|58|59)) ? defaultMaskedError;

    /** NPU0FIR[60]
     *  MISC Pervasive SCOM satellite err
     */
    (rNPU0FIR_NDD10, bit(60)) ? defaultMaskedError;

    /** NPU0FIR[61]
     *  MISC Pervasive SCOM satellite err
     */
    (rNPU0FIR_NDD10, bit(61)) ? defaultMaskedError;

    /** NPU0FIR[62]
     *  Local FIR Parity Error RAS duplicate
     */
    (rNPU0FIR_NDD10, bit(62)) ? defaultMaskedError;

    /** NPU0FIR[63]
     *  Local FIR Parity Err
     */
    (rNPU0FIR_NDD10, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU1FIR
################################################################################

rule rNPU1FIR_NDD10
{
  CHECK_STOP:
    NPU1FIR_NDD10 & ~NPU1FIR_MASK_NDD10 & ~NPU1FIR_ACT0_NDD10 & ~NPU1FIR_ACT1_NDD10;
  RECOVERABLE:
    NPU1FIR_NDD10 & ~NPU1FIR_MASK_NDD10 & ~NPU1FIR_ACT0_NDD10 &  NPU1FIR_ACT1_NDD10;
  UNIT_CS:
    NPU1FIR_NDD10 & ~NPU1FIR_MASK_NDD10 &  NPU1FIR_ACT0_NDD10 &  NPU1FIR_ACT1_NDD10;
};

group gNPU1FIR_NDD10 filter singlebit, cs_root_cause
{
    /** NPU1FIR[0]
     *  NDL Brick0 stall
     */
    (rNPU1FIR_NDD10, bit(0)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[1]
     *  NDL Brick0 nostall
     */
    (rNPU1FIR_NDD10, bit(1)) ? defaultMaskedError;

    /** NPU1FIR[2]
     *  NDL Brick1 stall
     */
    (rNPU1FIR_NDD10, bit(2)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[3]
     *  NDL Brick1 nostall
     */
    (rNPU1FIR_NDD10, bit(3)) ? defaultMaskedError;

    /** NPU1FIR[4]
     *  NDL Brick2 stall
     */
    (rNPU1FIR_NDD10, bit(4)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[5]
     *  NDL Brick2 nostall
     */
    (rNPU1FIR_NDD10, bit(5)) ? defaultMaskedError;

    /** NPU1FIR[6]
     *  NDL Brick3 stall
     */
    (rNPU1FIR_NDD10, bit(6)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[7]
     *  NDL Brick3 nostall
     */
    (rNPU1FIR_NDD10, bit(7)) ? defaultMaskedError;

    /** NPU1FIR[8]
     *  NDL Brick4 stall
     */
    (rNPU1FIR_NDD10, bit(8)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[9]
     *  NDL Brick4 nostall
     */
    (rNPU1FIR_NDD10, bit(9)) ? defaultMaskedError;

    /** NPU1FIR[10]
     *  NDL Brick5 stall
     */
    (rNPU1FIR_NDD10, bit(10)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[11]
     *  NDL Brick5 nostall
     */
    (rNPU1FIR_NDD10, bit(11)) ? defaultMaskedError;

    /** NPU1FIR[12]
     *  MISC Register ring error (ie noack)
     */
    (rNPU1FIR_NDD10, bit(12)) ? self_th_32perDay;

    /** NPU1FIR[13]
     *  MISC Parity error from ibr addr regi
     */
    (rNPU1FIR_NDD10, bit(13)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[14]
     *  MISC Parity error on SCOM D/A addr reg
     */
    (rNPU1FIR_NDD10, bit(14)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[15]
     *  MISC Parity error on MISC Cntrl reg
     */
    (rNPU1FIR_NDD10, bit(15)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[16]
     *  MISC NMMU signaled Local Checkstop
     */
    (rNPU1FIR_NDD10, bit(16)) ? defaultMaskedError;

    /** NPU1FIR[17]
     *  ATS Invalid TVT entry
     */
    (rNPU1FIR_NDD10, bit(17)) ? defaultMaskedError;

    /** NPU1FIR[18]
     *  ATS TVT Address range error
     */
    (rNPU1FIR_NDD10, bit(18)) ? defaultMaskedError;

    /** NPU1FIR[19]
     *  ATS TCE Page access error
     */
    (rNPU1FIR_NDD10, bit(19)) ? defaultMaskedError;

    /** NPU1FIR[20]
     *  ATS Effective Address hit multiple TCE
     */
    (rNPU1FIR_NDD10, bit(20)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[21]
     *  ATS TCE Page access error
     */
    (rNPU1FIR_NDD10, bit(21)) ? defaultMaskedError;

    /** NPU1FIR[22]
     *  ATS Timeout on TCE tree walk
     */
    (rNPU1FIR_NDD10, bit(22)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[23]
     *  ATS Parity error on TCE cache dir array
     */
    (rNPU1FIR_NDD10, bit(23)) ? self_th_32perDay;

    /** NPU1FIR[24]
     *  ATS Parity error on TCE cache data array
     */
    (rNPU1FIR_NDD10, bit(24)) ? self_th_32perDay;

    /** NPU1FIR[25]
     *  ATS ECC UE on Effective Address array
     */
    (rNPU1FIR_NDD10, bit(25)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[26]
     *  ATS ECC CE on Effective Address array
     */
    (rNPU1FIR_NDD10, bit(26)) ? self_th_32perDay;

    /** NPU1FIR[27]
     *  ATS ECC UE on TDRmem array
     */
    (rNPU1FIR_NDD10, bit(27)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[28]
     *  ATS ECC CE on TDRmem array
     */
    (rNPU1FIR_NDD10, bit(28)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[29]
     *  ATS ECC UE on CQ CTL DMA Read
     */
    (rNPU1FIR_NDD10, bit(29)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[30]
     *  ATS ECC CE on CQ CTL DMA Read
     */
    (rNPU1FIR_NDD10, bit(30)) ? self_th_32perDay;

    /** NPU1FIR[31]
     *  ATS Parity error on TVT entry
     */
    (rNPU1FIR_NDD10, bit(31)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[32]
     *  ATS Parity err on IODA Address Reg
     */
    (rNPU1FIR_NDD10, bit(32)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[33]
     *  ATS Parity error on ATS Control Register
     */
    (rNPU1FIR_NDD10, bit(33)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[34]
     *  ATS Parity error on ATS reg
     */
    (rNPU1FIR_NDD10, bit(34)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[35]
     *  ATS Invalid IODA Table Select entry
     */
    (rNPU1FIR_NDD10, bit(35)) ? self_th_1; # NIMBUS_10

    /** NPU1FIR[36:61]
     *  Reserved
     */
    (rNPU1FIR_NDD10, bit(36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60|61)) ? defaultMaskedError;

    /** NPU1FIR[62]
     *  scom error
     */
    (rNPU1FIR_NDD10, bit(62)) ? defaultMaskedError;

    /** NPU1FIR[63]
     *  scom error
     */
    (rNPU1FIR_NDD10, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBWESTFIR
################################################################################

rule rPBWESTFIR
{
  CHECK_STOP:
    PBWESTFIR & ~PBWESTFIR_MASK & ~PBWESTFIR_ACT0 & ~PBWESTFIR_ACT1;
  RECOVERABLE:
    PBWESTFIR & ~PBWESTFIR_MASK & ~PBWESTFIR_ACT0 &  PBWESTFIR_ACT1;
};

group gPBWESTFIR filter singlebit, cs_root_cause
{
    /** PBWESTFIR[0]
     *  pbeq0 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(0)) ? self_th_1;

    /** PBWESTFIR[1]
     *  pbeq0 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(1)) ? self_th_1;

    /** PBWESTFIR[2]
     *  pbieq0_pbh_protocol_error
     */
    (rPBWESTFIR, bit(2)) ? self_th_1;

    /** PBWESTFIR[3]
     *  pbieq0_pbh_overflow_error
     */
    (rPBWESTFIR, bit(3)) ? self_th_1;

    /** PBWESTFIR[4]
     *  pbeq1 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(4)) ? self_th_1;

    /** PBWESTFIR[5]
     *  pbeq1 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(5)) ? self_th_1;

    /** PBWESTFIR[6]
     *  pbieq1_pbh_protocol_error
     */
    (rPBWESTFIR, bit(6)) ? self_th_1;

    /** PBWESTFIR[7]
     *  pbieq1_pbh_overflow_error
     */
    (rPBWESTFIR, bit(7)) ? self_th_1;

    /** PBWESTFIR[8]
     *  pbeq2 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(8)) ? self_th_1;

    /** PBWESTFIR[9]
     *  pbeq2 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(9)) ? self_th_1;

    /** PBWESTFIR[10]
     *  pbieq2_pbh_protocol_error
     */
    (rPBWESTFIR, bit(10)) ? self_th_1;

    /** PBWESTFIR[11]
     *  pbieq2_pbh_overflow_error
     */
    (rPBWESTFIR, bit(11)) ? self_th_1;

    /** PBWESTFIR[12]
     *  pbeq3 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(12)) ? self_th_1;

    /** PBWESTFIR[13]
     *  pbeq3 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(13)) ? self_th_1;

    /** PBWESTFIR[14]
     *  pbieq3_pbh_protocol_error
     */
    (rPBWESTFIR, bit(14)) ? self_th_1;

    /** PBWESTFIR[15]
     *  pbieq3_pbh_overflow_error
     */
    (rPBWESTFIR, bit(15)) ? self_th_1;

    /** PBWESTFIR[16:31]
     *  spare
     */
    (rPBWESTFIR, bit(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)) ? defaultMaskedError;

    /** PBWESTFIR[32]
     *  scom error
     */
    (rPBWESTFIR, bit(32)) ? defaultMaskedError;

    /** PBWESTFIR[33]
     *  scom error
     */
    (rPBWESTFIR, bit(33)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBCENTFIR
################################################################################

rule rPBCENTFIR
{
  CHECK_STOP:
    PBCENTFIR & ~PBCENTFIR_MASK & ~PBCENTFIR_ACT0 & ~PBCENTFIR_ACT1;
  RECOVERABLE:
    PBCENTFIR & ~PBCENTFIR_MASK & ~PBCENTFIR_ACT0 &  PBCENTFIR_ACT1;
};

group gPBCENTFIR filter singlebit, cs_root_cause
{
    /** PBCENTFIR[0]
     *  pb protocol_error
     */
    (rPBCENTFIR, bit(0)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[1]
     *  pb overflow error
     */
    (rPBCENTFIR, bit(1)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[2]
     *  pw hw parity error
     */
    (rPBCENTFIR, bit(2)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[3]
     *  spare
     */
    (rPBCENTFIR, bit(3)) ? defaultMaskedError;

    /** PBCENTFIR[4]
     *  pb coherency error
     */
    (rPBCENTFIR, bit(4)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[5]
     *  pb cresp addr error
     */
    (rPBCENTFIR, bit(5)) ? threshold_and_mask;

    /** PBCENTFIR[6]
     *  pb cresp error
     */
    (rPBCENTFIR, bit(6)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[7]
     *  pb hang recovery limit error
     */
    (rPBCENTFIR, bit(7)) ? defaultMaskedError;

    /** PBCENTFIR[8]
     *  pb data_route_error
     */
    (rPBCENTFIR, bit(8)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[9]
     *  pb hang_recovery_gte_level1
     */
    (rPBCENTFIR, bit(9)) ? pb_cent_hang_recovery_gte;

    /** PBCENTFIR[10]
     *  pb fsp checkstop
     */
    (rPBCENTFIR, bit(10)) ? level2_dump_SW;

    /** PBCENTFIR[11:15]
     *  spare
     */
    (rPBCENTFIR, bit(11|12|13|14|15)) ? defaultMaskedError;

    /** PBCENTFIR[16]
     *  scom error
     */
    (rPBCENTFIR, bit(16)) ? defaultMaskedError;

    /** PBCENTFIR[17]
     *  scom error
     */
    (rPBCENTFIR, bit(17)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBEASTFIR
################################################################################

rule rPBEASTFIR
{
  CHECK_STOP:
    PBEASTFIR & ~PBEASTFIR_MASK & ~PBEASTFIR_ACT0 & ~PBEASTFIR_ACT1;
  RECOVERABLE:
    PBEASTFIR & ~PBEASTFIR_MASK & ~PBEASTFIR_ACT0 &  PBEASTFIR_ACT1;
};

group gPBEASTFIR filter singlebit, cs_root_cause
{
    /** PBEASTFIR[0]
     *  pbieq4_pbh_hw1_error
     */
    (rPBEASTFIR, bit(0)) ? self_th_1;

    /** PBEASTFIR[1]
     *  pbieq4_pbh_hw2_error
     */
    (rPBEASTFIR, bit(1)) ? self_th_1;

    /** PBEASTFIR[2]
     *  pbieq4_pbh_protocol_error
     */
    (rPBEASTFIR, bit(2)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[3]
     *  pbieq4_pbh_overflow_error
     */
    (rPBEASTFIR, bit(3)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[4]
     *  pbieq5_pbh_hw1_error
     */
    (rPBEASTFIR, bit(4)) ? self_th_1;

    /** PBEASTFIR[5]
     *  pbieq5_pbh_hw2_error
     */
    (rPBEASTFIR, bit(5)) ? self_th_1;

    /** PBEASTFIR[6]
     *  pbieq5_pbh_protocol_error
     */
    (rPBEASTFIR, bit(6)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[7]
     *  pbieq5_pbh_overflow_error
     */
    (rPBEASTFIR, bit(7)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[8:15]
     *  spare
     */
    (rPBEASTFIR, bit(8|9|10|11|12|13|14|15)) ? defaultMaskedError;

    /** PBEASTFIR[16]
     *  pb data_overflow_error
     */
    (rPBEASTFIR, bit(16)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[17]
     *  pb data_protocol_error
     */
    (rPBEASTFIR, bit(17)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[18]
     *  pb data_route_error
     */
    (rPBEASTFIR, bit(18)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[19:31]
     *  spare
     */
    (rPBEASTFIR, bit(19|20|21|22|23|24|25|26|27|28|29|30|31)) ? defaultMaskedError;

    /** PBEASTFIR[32]
     *  scom error
     */
    (rPBEASTFIR, bit(32)) ? defaultMaskedError;

    /** PBEASTFIR[33]
     *  scom error
     */
    (rPBEASTFIR, bit(33)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBPPEFIR
################################################################################

rule rPBPPEFIR
{
  CHECK_STOP:
    PBPPEFIR & ~PBPPEFIR_MASK & ~PBPPEFIR_ACT0 & ~PBPPEFIR_ACT1;
  RECOVERABLE:
    PBPPEFIR & ~PBPPEFIR_MASK & ~PBPPEFIR_ACT0 &  PBPPEFIR_ACT1;
};

group gPBPPEFIR filter singlebit, cs_root_cause
{
    /** PBPPEFIR[0]
     *  PPE asserted an internally detected err
     */
    (rPBPPEFIR, bit(0)) ? threshold_and_mask;

    /** PBPPEFIR[1]
     *  PPE err on ext interface to the Mem
     */
    (rPBPPEFIR, bit(1)) ? threshold_and_mask;

    /** PBPPEFIR[2]
     *  PPE halted due to lack of progress.
     */
    (rPBPPEFIR, bit(2)) ? threshold_and_mask;

    /** PBPPEFIR[3]
     *  PPE halted on breakpoint event.
     */
    (rPBPPEFIR, bit(3)) ? threshold_and_mask;

    /** PBPPEFIR[4]
     *  PPE watchdog expired
     */
    (rPBPPEFIR, bit(4)) ? defaultMaskedError;

    /** PBPPEFIR[5]
     *  PPE halt
     */
    (rPBPPEFIR, bit(5)) ? defaultMaskedError;

    /** PBPPEFIR[6]
     *  PPE debug trigger
     */
    (rPBPPEFIR, bit(6)) ? defaultMaskedError;

    /** PBPPEFIR[7]
     *  SRAM uncorrectable error
     */
    (rPBPPEFIR, bit(7)) ? threshold_and_mask;

    /** PBPPEFIR[8]
     *  SRM correctable error
     */
    (rPBPPEFIR, bit(8)) ? threshold_and_mask;

    /** PBPPEFIR[9]
     *  Scrub timer tick while scrub pending
     */
    (rPBPPEFIR, bit(9)) ? threshold_and_mask;

    /** PBPPEFIR[10]
     *  reserved
     */
    (rPBPPEFIR, bit(10)) ? defaultMaskedError;

    /** PBPPEFIR[11]
     *  spare
     */
    (rPBPPEFIR, bit(11)) ? defaultMaskedError;

    /** PBPPEFIR[12]
     *  scom error
     */
    (rPBPPEFIR, bit(12)) ? defaultMaskedError;

    /** PBPPEFIR[13]
     *  scom error
     */
    (rPBPPEFIR, bit(13)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBAFIR
################################################################################

rule rPBAFIR
{
  CHECK_STOP:
    PBAFIR & ~PBAFIR_MASK & ~PBAFIR_ACT0 & ~PBAFIR_ACT1;
  RECOVERABLE:
    PBAFIR & ~PBAFIR_MASK & ~PBAFIR_ACT0 &  PBAFIR_ACT1;
};

group gPBAFIR filter singlebit, cs_root_cause
{
    /** PBAFIR[0]
     *  PBA OCI Addr PE err
     */
    (rPBAFIR, bit(0)) ? self_th_1;

    /** PBAFIR[1]
     *  PBA CRESP Addr Error
     */
    (rPBAFIR, bit(1)) ? defaultMaskedError;

    /** PBAFIR[2]
     *  PBA Read Data Timeout
     */
    (rPBAFIR, bit(2)) ? defaultMaskedError;

    /** PBAFIR[3]
     *  PBA Read Data SUE Error
     */
    (rPBAFIR, bit(3)) ? defaultMaskedError;

    /** PBAFIR[4]
     *  PBA Read Data UE Erro
     */
    (rPBAFIR, bit(4)) ? self_th_1;

    /** PBAFIR[5]
     *  PBA Read Data CE Error
     */
    (rPBAFIR, bit(5)) ? self_th_32perDay;

    /** PBAFIR[6]
     *  PBA OCI Slave Initialization Error
     */
    (rPBAFIR, bit(6)) ? level2_th_1;

    /** PBAFIR[7]
     *  OCI Write Data Parity Error
     */
    (rPBAFIR, bit(7)) ? self_th_1;

    /** PBAFIR[8]
     *  spare
     */
    (rPBAFIR, bit(8)) ? defaultMaskedError;

    /** PBAFIR[9]
     *  PBA Unexpected CRESP
     */
    (rPBAFIR, bit(9)) ? level2_th_1;

    /** PBAFIR[10]
     *  PBA Unexpected Data PB data received
     */
    (rPBAFIR, bit(10)) ? level2_th_1;

    /** PBAFIR[11]
     *  PBA Tag parity Error
     */
    (rPBAFIR, bit(11)) ? self_th_1;

    /** PBAFIR[12]
     *  PBA CRESP Addr Error
     */
    (rPBAFIR, bit(12)) ? self_th_1;

    /** PBAFIR[13]
     *  PBA Invalid CRESP
     */
    (rPBAFIR, bit(13)) ? self_th_1;

    /** PBAFIR[14]
     *  PBA CRESP ACK Dead response r
     */
    (rPBAFIR, bit(14)) ? defaultMaskedError;

    /** PBAFIR[15]
     *  PBA OPERATIONAL Timeout detected
     */
    (rPBAFIR, bit(15)) ? self_th_1;

    /** PBAFIR[16]
     *  BCUE Setup Error
     */
    (rPBAFIR, bit(16)) ? level2_th_1;

    /** PBAFIR[17]
     *  BCUE PowerBus Link
     */
    (rPBAFIR, bit(17)) ? defaultMaskedError;

    /** PBAFIR[18]
     *  PBA CRESP Addr Error
     */
    (rPBAFIR, bit(18)) ? level2_th_1;

    /** PBAFIR[19]
     *  BCUE Read Data Parity Error OR MRDERR
     */
    (rPBAFIR, bit(19)) ? self_th_1;

    /** PBAFIR[20]
     *  BCDE Setup Error Block Copy Error
     */
    (rPBAFIR, bit(20)) ? self_th_1;

    /** PBAFIR[21]
     *  BCDE PowerBus Link error
     */
    (rPBAFIR, bit(21)) ? defaultMaskedError;

    /** PBAFIR[22]
     *  PBA CRESP Addr Error
     */
    (rPBAFIR, bit(22)) ? self_th_1;

    /** PBAFIR[23]
     *  PBA Read Data Timeout
     */
    (rPBAFIR, bit(23)) ? self_th_1;

    /** PBAFIR[24]
     *  PBA Read Data SUE Error
     */
    (rPBAFIR, bit(24)) ? defaultMaskedError;

    /** PBAFIR[25]
     *  PBA Read Data UE Error
     */
    (rPBAFIR, bit(25)) ? self_th_1;

    /** PBAFIR[26]
     *  PBA Read Data CE Error
     */
    (rPBAFIR, bit(26)) ? self_th_32perDay;

    /** PBAFIR[27]
     *  BCDE Write Data error
     */
    (rPBAFIR, bit(27)) ? self_th_1;

    /** PBAFIR[28]
     *  Internal Logic Error.
     */
    (rPBAFIR, bit(28)) ? self_th_1;

    /** PBAFIR[29]
     *  Byte count is less than full cache line
     */
    (rPBAFIR, bit(29)) ? self_th_1;

    /** PBAFIR[30]
     *  Illegal access to OCI Register.
     */
    (rPBAFIR, bit(30)) ? self_th_1;

    /** PBAFIR[31]
     *  Push Write Error.
     */
    (rPBAFIR, bit(31)) ? self_th_1;

    /** PBAFIR[32]
     *  PBAXRCV Low data before High Data
     */
    (rPBAFIR, bit(32)) ? self_th_1;

    /** PBAFIR[33]
     *  PBAXRCV low data timeout
     */
    (rPBAFIR, bit(33)) ? defaultMaskedError;

    /** PBAFIR[34]
     *  PBA Reservation timeout
     */
    (rPBAFIR, bit(34)) ? defaultMaskedError;

    /** PBAFIR[35]
     *  Illegal PBAX Flow.
     */
    (rPBAFIR, bit(35)) ? self_th_1;

    /** PBAFIR[36]
     *  PBA engine retry threshold reached
     */
    (rPBAFIR, bit(36)) ? self_th_1;

    /** PBAFIR[37]
     *  PBA engine retry threshold reached
     */
    (rPBAFIR, bit(37)) ? self_th_1;

    /** PBAFIR[38]
     *  PBAXSND Reservation Timeout
     */
    (rPBAFIR, bit(38)) ? defaultMaskedError;

    /** PBAFIR[39]
     *  PBAXSND Reservation Error.
     */
    (rPBAFIR, bit(39)) ? self_th_1;

    /** PBAFIR[40]
     *  PBA CRESP ACK Dead response
     */
    (rPBAFIR, bit(40)) ? defaultMaskedError;

    /** PBAFIR[41:43]
     *  spare
     */
    (rPBAFIR, bit(41|42|43)) ? defaultMaskedError;

    /** PBAFIR[44]
     *  Internal fir parity error duplicate
     */
    (rPBAFIR, bit(44)) ? defaultMaskedError;

    /** PBAFIR[45]
     *  Internal fir parity error
     */
    (rPBAFIR, bit(45)) ? defaultMaskedError;

};

################################################################################
# P9 chip PSIHBFIR
################################################################################

rule rPSIHBFIR
{
  CHECK_STOP:
    PSIHBFIR & ~PSIHBFIR_MASK & ~PSIHBFIR_ACT0 & ~PSIHBFIR_ACT1;
  RECOVERABLE:
    PSIHBFIR & ~PSIHBFIR_MASK & ~PSIHBFIR_ACT0 &  PSIHBFIR_ACT1;
};

group gPSIHBFIR filter singlebit, cs_root_cause
{
    /** PSIHBFIR[0]
     *  CE from PowerBus data
     */
    (rPSIHBFIR, bit(0)) ? self_th_32perDay;

    /** PSIHBFIR[1]
     *  UE from PowerBus data
     */
    (rPSIHBFIR, bit(1)) ? self_th_1;

    /** PSIHBFIR[2]
     *  SUE from PowerBus data
     */
    (rPSIHBFIR, bit(2)) ? defaultMaskedError;

    /** PSIHBFIR[3]
     *  Interrupt Condition present in PSIHB
     */
    (rPSIHBFIR, bit(3)) ? defaultMaskedError;

    /** PSIHBFIR[4]
     *  Interrupt from FSP is being processed
     */
    (rPSIHBFIR, bit(4)) ? defaultMaskedError;

    /** PSIHBFIR[5]
     *  CE from PSILL data
     */
    (rPSIHBFIR, bit(5)) ? defaultMaskedError;

    /** PSIHBFIR[6]
     *  UE from PSILL data
     */
    (rPSIHBFIR, bit(6)) ? defaultMaskedError;

    /** PSIHBFIR[7]
     *  Error bit se
     */
    (rPSIHBFIR, bit(7)) ? defaultMaskedError;

    /** PSIHBFIR[8]
     *  Invalid TType Hit on PHB or FSP bar
     */
    (rPSIHBFIR, bit(8)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[9]
     *  Invalid CResp returned
     */
    (rPSIHBFIR, bit(9)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[10]
     *  PowerBus time out waiting for data grant
     */
    (rPSIHBFIR, bit(10)) ? level2_th_1;

    /** PSIHBFIR[11]
     *  PB parity error in a tag/addr bus
     */
    (rPSIHBFIR, bit(11)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[12]
     *  FSP tried access to trusted space
     */
    (rPSIHBFIR, bit(12)) ? level2_th_1;

    /** PSIHBFIR[13]
     *  Unexpected PB CRESP or DATA
     */
    (rPSIHBFIR, bit(13)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[14]
     *  Intr. reg change witn int. pending
     */
    (rPSIHBFIR, bit(14)) ? defaultMaskedError;

    /** PSIHBFIR[15]
     *  PSI Interrupt address Error
     */
    (rPSIHBFIR, bit(15)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[16]
     *  OCC Interrupt address Error
     */
    (rPSIHBFIR, bit(16)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[17]
     *  FSI Interrupt address Error
     */
    (rPSIHBFIR, bit(17)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[18]
     *  LPC Interrupt address Error
     */
    (rPSIHBFIR, bit(18)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[19]
     *  LOCAL ERROR Interrupt address Error
     */
    (rPSIHBFIR, bit(19)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[20]
     *  HOST ERROR Interrupt address Error
     */
    (rPSIHBFIR, bit(20)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[21]
     *  PSI global error bit 0
     */
    (rPSIHBFIR, bit(21)) ? defaultMaskedError;

    /** PSIHBFIR[22]
     *  PSI global error bit 1
     */
    (rPSIHBFIR, bit(22)) ? defaultMaskedError;

    /** PSIHBFIR[23]
     *  Upstream error
     */
    (rPSIHBFIR, bit(23)) ? level2_M_self_L_th_32perDay;

    /** PSIHBFIR[24:26]
     *  spare
     */
    (rPSIHBFIR, bit(24|25|26)) ? defaultMaskedError;

    /** PSIHBFIR[27]
     *  scom error
     */
    (rPSIHBFIR, bit(27)) ? defaultMaskedError;

    /** PSIHBFIR[28]
     *  fir parity Error
     */
    (rPSIHBFIR, bit(28)) ? defaultMaskedError;

};

################################################################################
# P9 chip ENHCAFIR
################################################################################

rule rENHCAFIR
{
  CHECK_STOP:
    ENHCAFIR & ~ENHCAFIR_MASK & ~ENHCAFIR_ACT0 & ~ENHCAFIR_ACT1;
  RECOVERABLE:
    ENHCAFIR & ~ENHCAFIR_MASK & ~ENHCAFIR_ACT0 &  ENHCAFIR_ACT1;
};

group gENHCAFIR filter singlebit, cs_root_cause
{
    /** ENHCAFIR[0]
     *  PB0 data UE
     */
    (rENHCAFIR, bit(0)) ? defaultMaskedError;

    /** ENHCAFIR[1]
     *  PB0 data SUE
     */
    (rENHCAFIR, bit(1)) ? defaultMaskedError;

    /** ENHCAFIR[2]
     *  PB0 data ue
     */
    (rENHCAFIR, bit(2)) ? defaultMaskedError;

    /** ENHCAFIR[3]
     *  spare
     */
    (rENHCAFIR, bit(3)) ? defaultMaskedError;

    /** ENHCAFIR[4]
     *  Castout Drop Counter Full
     */
    (rENHCAFIR, bit(4)) ? defaultMaskedError;

    /** ENHCAFIR[5]
     *  Data Hang Detect
     */
    (rENHCAFIR, bit(5)) ? defaultMaskedError;

    /** ENHCAFIR[6]
     *  Unexpected data or cresp
     */
    (rENHCAFIR, bit(6)) ? defaultMaskedError;

    /** ENHCAFIR[7]
     *  Internal Error
     */
    (rENHCAFIR, bit(7)) ? defaultMaskedError;

    /** ENHCAFIR[8]
     *  ADU checkstop error from power bus data
     */
    (rENHCAFIR, bit(8)) ? defaultMaskedError;

    /** ENHCAFIR[9]
     *  ADU checkstop error from alter display
     */
    (rENHCAFIR, bit(9)) ? defaultMaskedError;

    /** ENHCAFIR[10]
     *  ADU checkstop error from xsco m
     */
    (rENHCAFIR, bit(10)) ? defaultMaskedError;

    /** ENHCAFIR[11]
     *  ADU checkstop from power bus cmd
     */
    (rENHCAFIR, bit(11)) ? defaultMaskedError;

    /** ENHCAFIR[12]
     *  ADU checkstop error from power bus send
     */
    (rENHCAFIR, bit(12)) ? defaultMaskedError;

    /** ENHCAFIR[13]
     *  ADU checkstop from power bus receive
     */
    (rENHCAFIR, bit(13)) ? defaultMaskedError;

    /** ENHCAFIR[14]
     *  ADU recoverable error from pb data
     */
    (rENHCAFIR, bit(14)) ? defaultMaskedError;

    /** ENHCAFIR[15]
     *  ADU recoverable error from alter display
     */
    (rENHCAFIR, bit(15)) ? defaultMaskedError;

    /** ENHCAFIR[16]
     *  ADU recoverable error from xscom
     */
    (rENHCAFIR, bit(16)) ? defaultMaskedError;

    /** ENHCAFIR[17]
     *  ADU recoverable from power bus cmd
     */
    (rENHCAFIR, bit(17)) ? defaultMaskedError;

    /** ENHCAFIR[18]
     *  ADU recoverable error from pb send
     */
    (rENHCAFIR, bit(18)) ? defaultMaskedError;

    /** ENHCAFIR[19]
     *  ADU recoverable error from pb receive
     */
    (rENHCAFIR, bit(19)) ? defaultMaskedError;

    /** ENHCAFIR[20]
     *  NHTM scom error
     */
    (rENHCAFIR, bit(20)) ? defaultMaskedError;

    /** ENHCAFIR[21]
     *  spare
     */
    (rENHCAFIR, bit(21)) ? defaultMaskedError;

    /** ENHCAFIR[22]
     *  scom error
     */
    (rENHCAFIR, bit(22)) ? defaultMaskedError;

    /** ENHCAFIR[23]
     *  scom error
     */
    (rENHCAFIR, bit(23)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBAMFIR
################################################################################

rule rPBAMFIR
{
  CHECK_STOP:
    PBAMFIR & ~PBAMFIR_MASK & ~PBAMFIR_ACT0 & ~PBAMFIR_ACT1;
  RECOVERABLE:
    PBAMFIR & ~PBAMFIR_MASK & ~PBAMFIR_ACT0 &  PBAMFIR_ACT1;
};

group gPBAMFIR filter singlebit, cs_root_cause
{
    /** PBAMFIR[0]
     *  action0_for_invalid_transfer_size
     */
    (rPBAMFIR, bit(0)) ? self_th_1;

    /** PBAMFIR[1]
     *  action0_for_invalid_command
     */
    (rPBAMFIR, bit(1)) ? self_th_1;

    /** PBAMFIR[2]
     *  action0_for_invalid_address_alignment
     */
    (rPBAMFIR, bit(2)) ? self_th_1;

    /** PBAMFIR[3]
     *  action0_for_OPB_error
     */
    (rPBAMFIR, bit(3)) ? defaultMaskedError;

    /** PBAMFIR[4]
     *  action0_for_OPB_timeout
     */
    (rPBAMFIR, bit(4)) ? defaultMaskedError;

    /** PBAMFIR[5]
     *  action0_for_OPB_master_hang_timeout
     */
    (rPBAMFIR, bit(5)) ? self_th_32perDay;

    /** PBAMFIR[6]
     *  master_cmd_buffer_parity_error
     */
    (rPBAMFIR, bit(6)) ? self_th_1;

    /** PBAMFIR[7]
     *  master_dat_buffer_parity_error
     */
    (rPBAMFIR, bit(7)) ? self_th_1;

    /** PBAMFIR[8:9]
     *  spare
     */
    (rPBAMFIR, bit(8|9)) ? defaultMaskedError;

    /** PBAMFIR[10]
     *  scom error
     */
    (rPBAMFIR, bit(10)) ? defaultMaskedError;

    /** PBAMFIR[11]
     *  scom error
     */
    (rPBAMFIR, bit(11)) ? defaultMaskedError;

};

################################################################################
# P9 chip NMMUCQFIR
################################################################################

rule rNMMUCQFIR
{
  CHECK_STOP:
    NMMUCQFIR & ~NMMUCQFIR_MASK & ~NMMUCQFIR_ACT0 & ~NMMUCQFIR_ACT1;
  RECOVERABLE:
    NMMUCQFIR & ~NMMUCQFIR_MASK & ~NMMUCQFIR_ACT0 &  NMMUCQFIR_ACT1;
  UNIT_CS:
    NMMUCQFIR & ~NMMUCQFIR_MASK &  NMMUCQFIR_ACT0 &  NMMUCQFIR_ACT1;
};

group gNMMUCQFIR filter singlebit, cs_root_cause
{
    /** NMMUCQFIR[0]
     *  PBI_PE_FIR: PBI internal parity error
     */
    (rNMMUCQFIR, bit(0)) ? self_th_1;

    /** NMMUCQFIR[1]
     *  PowerBus command hang error
     */
    (rNMMUCQFIR, bit(1)) ? level2_th_1;

    /** NMMUCQFIR[2]
     *  PowerBus read address error
     */
    (rNMMUCQFIR, bit(2)) ? level2_th_1;

    /** NMMUCQFIR[3]
     *  PowerBus write address error
     */
    (rNMMUCQFIR, bit(3)) ? level2_th_1;

    /** NMMUCQFIR[4]
     *  PowerBus miscellaneous error
     */
    (rNMMUCQFIR, bit(4)) ? self_th_1;

    /** NMMUCQFIR[5]
     *  spare
     */
    (rNMMUCQFIR, bit(5)) ? defaultMaskedError;

    /** NMMUCQFIR[6]
     *  PowerBus Xlate UE error
     */
    (rNMMUCQFIR, bit(6)) ? self_th_1;

    /** NMMUCQFIR[7]
     *  PowerBus Xlate SUE error
     */
    (rNMMUCQFIR, bit(7)) ? self_th_1_SUE;

    /** NMMUCQFIR[8]
     *  PowerBus CE error
     */
    (rNMMUCQFIR, bit(8)) ? self_th_32perDay;

    /** NMMUCQFIR[9]
     *  PowerBus UE error
     */
    (rNMMUCQFIR, bit(9)) ? self_th_1;

    /** NMMUCQFIR[10]
     *  PowerBus SUE error
     */
    (rNMMUCQFIR, bit(10)) ? self_th_1;

    /** NMMUCQFIR[11]
     *  Inbound LCO_ARRAY CE error
     */
    (rNMMUCQFIR, bit(11)) ? self_th_32perDay;

    /** NMMUCQFIR[12]
     *  Inbound LCO_ARRAY UE error
     */
    (rNMMUCQFIR, bit(12)) ? self_th_1;

    /** NMMUCQFIR[13]
     *  Inbound LCO_ARRAY SUE error
     */
    (rNMMUCQFIR, bit(13)) ? defaultMaskedError;

    /** NMMUCQFIR[14]
     *  Inbound array CE error
     */
    (rNMMUCQFIR, bit(14)) ? self_th_32perDay;

    /** NMMUCQFIR[15]
     *  Inbound array UE error
     */
    (rNMMUCQFIR, bit(15)) ? self_th_1;

    /** NMMUCQFIR[16]
     *  internal state error
     */
    (rNMMUCQFIR, bit(16)) ? self_th_1;

    /** NMMUCQFIR[17]
     *  ACK_DEAD cresp received by read command
     */
    (rNMMUCQFIR, bit(17)) ? defaultMaskedError;

    /** NMMUCQFIR[18]
     *  ACK_DEAD cresp received by write command
     */
    (rNMMUCQFIR, bit(18)) ? defaultMaskedError;

    /** NMMUCQFIR[19]
     *  Link check aborted while waiting on data
     */
    (rNMMUCQFIR, bit(19)) ? defaultMaskedError;

    /** NMMUCQFIR[20]
     *  scom error
     */
    (rNMMUCQFIR, bit(20)) ? defaultMaskedError;

    /** NMMUCQFIR[21]
     *  scom error
     */
    (rNMMUCQFIR, bit(21)) ? defaultMaskedError;

};

################################################################################
# P9 chip NMMUFIR
################################################################################

rule rNMMUFIR
{
  CHECK_STOP:
    NMMUFIR & ~NMMUFIR_MASK & ~NMMUFIR_ACT0 & ~NMMUFIR_ACT1;
  RECOVERABLE:
    NMMUFIR & ~NMMUFIR_MASK & ~NMMUFIR_ACT0 &  NMMUFIR_ACT1;
  UNIT_CS:
    NMMUFIR & ~NMMUFIR_MASK &  NMMUFIR_ACT0 &  NMMUFIR_ACT1;
};

group gNMMUFIR filter singlebit, cs_root_cause
{
    /** NMMUFIR[0]
     *  Fabric DIn xlat array CE error detected.
     */
    (rNMMUFIR, bit(0)) ? self_th_32perDay;

    /** NMMUFIR[1]
     *  Fabric DIn xlat array UE error detected.
     */
    (rNMMUFIR, bit(1)) ? self_th_1;

    /** NMMUFIR[2]
     *  Fabric DIn xlat array SUE error
     */
    (rNMMUFIR, bit(2)) ? self_th_1_SUE;

    /** NMMUFIR[3]
     *  Fabric mst rd array CE error detected.
     */
    (rNMMUFIR, bit(3)) ? self_th_32perDay;

    /** NMMUFIR[4]
     *  Fabric mst rd array UE error detected.
     */
    (rNMMUFIR, bit(4)) ? self_th_1;

    /** NMMUFIR[5]
     *  Fabric mst rd array SUE error detected.
     */
    (rNMMUFIR, bit(5)) ? self_th_1;

    /** NMMUFIR[6]
     *  Fabric xlat protocol error detected.
     */
    (rNMMUFIR, bit(6)) ? self_th_1;

    /** NMMUFIR[7]
     *  Fabric xlat op timeout detected.
     */
    (rNMMUFIR, bit(7)) ? self_th_1;

    /** NMMUFIR[8]
     *  SLB directory parity error detected.
     */
    (rNMMUFIR, bit(8)) ? self_th_1;

    /** NMMUFIR[9]
     *  SLB cache parity error detected.
     */
    (rNMMUFIR, bit(9)) ? self_th_1;

    /** NMMUFIR[10]
     *  SLB lru parity error detected.
     */
    (rNMMUFIR, bit(10)) ? self_th_1;

    /** NMMUFIR[11]
     *  SLB multi-hit error detected.
     */
    (rNMMUFIR, bit(11)) ? level2_th_1;

    /** NMMUFIR[12]
     *  TLB directory parity error detected.
     */
    (rNMMUFIR, bit(12)) ? self_th_1;

    /** NMMUFIR[13]
     *  TLB cache parity error detected.
     */
    (rNMMUFIR, bit(13)) ? self_th_1;

    /** NMMUFIR[14]
     *  TLB lru parity error detected.
     */
    (rNMMUFIR, bit(14)) ? self_th_1;

    /** NMMUFIR[15]
     *  TLB multi-hit error detected.
     */
    (rNMMUFIR, bit(15)) ? level2_th_1;

    /** NMMUFIR[16]
     *  Segment fault detected .
     */
    (rNMMUFIR, bit(16)) ? defaultMaskedError;

    /** NMMUFIR[17]
     *  Page fault detected, no matching pte.
     */
    (rNMMUFIR, bit(17)) ? defaultMaskedError;

    /** NMMUFIR[18]
     *  Page fault, basic prot chk fail.
     */
    (rNMMUFIR, bit(18)) ? defaultMaskedError;

    /** NMMUFIR[19]
     *  Page fault detected, virt prot chk fail.
     */
    (rNMMUFIR, bit(19)) ? defaultMaskedError;

    /** NMMUFIR[20]
     *  Page fault detected,seid mismatch .
     */
    (rNMMUFIR, bit(20)) ? defaultMaskedError;

    /** NMMUFIR[21]
     *  Address error cresp detected by twsm
     */
    (rNMMUFIR, bit(21)) ? level2_th_1;

    /** NMMUFIR[22]
     *  PTE update fail due to armwf mismatch.
     */
    (rNMMUFIR, bit(22)) ? defaultMaskedError;

    /** NMMUFIR[23]
     *  Address error cresp detected by twsm
     */
    (rNMMUFIR, bit(23)) ? level2_th_1;

    /** NMMUFIR[24]
     *  Unsupported radix cfg for guest-side .
     */
    (rNMMUFIR, bit(24)) ? defaultMaskedError;

    /** NMMUFIR[25]
     *  Unsupported radix cfg for host-side .
     */
    (rNMMUFIR, bit(25)) ? defaultMaskedError;

    /** NMMUFIR[26]
     *  Invalid wimg setting detected .
     */
    (rNMMUFIR, bit(26)) ? defaultMaskedError;

    /** NMMUFIR[27]
     *  Invalid radix quad access detected .
     */
    (rNMMUFIR, bit(27)) ? defaultMaskedError;

    /** NMMUFIR[28]
     *  Unexpected access to foreign addr space
     */
    (rNMMUFIR, bit(28)) ? defaultMaskedError;

    /** NMMUFIR[29]
     *  Prefetch abort/fail detected .
     */
    (rNMMUFIR, bit(29)) ? level2_th_1;

    /** NMMUFIR[30]
     *  Context cache array parity er
     */
    (rNMMUFIR, bit(30)) ? self_th_1;

    /** NMMUFIR[31]
     *  Radix pwc array parity error detected .
     */
    (rNMMUFIR, bit(31)) ? self_th_1;

    /** NMMUFIR[32]
     *  Tablewalk sm control error detected .
     */
    (rNMMUFIR, bit(32)) ? self_th_1;

    /** NMMUFIR[33]
     *  Castout sm control error detected .
     */
    (rNMMUFIR, bit(33)) ? self_th_1;

    /** NMMUFIR[34]
     *  Check-in sm control error detected .
     */
    (rNMMUFIR, bit(34)) ? self_th_1;

    /** NMMUFIR[35]
     *  Invalidate sm control error detected .
     */
    (rNMMUFIR, bit(35)) ? self_th_1;

    /** NMMUFIR[36]
     *  Tablewalk sm timeout error detected .
     */
    (rNMMUFIR, bit(36)) ? self_th_1;

    /** NMMUFIR[37]
     *  Castout sm timeout error detected .
     */
    (rNMMUFIR, bit(37)) ? self_th_1;

    /** NMMUFIR[38]
     *  Check-in sm timeout error detected .
     */
    (rNMMUFIR, bit(38)) ? self_th_1;

    /** NMMUFIR[39]
     *  Invalidate sm timeout error detected .
     */
    (rNMMUFIR, bit(39)) ? self_th_1;

    /** NMMUFIR[40]
     *  NX local checkstop error detected .
     */
    (rNMMUFIR, bit(40)) ? defaultMaskedError;

    /** NMMUFIR[41]
     *  CP0 local checkstop error detected .
     */
    (rNMMUFIR, bit(41)) ? defaultMaskedError;

    /** NMMUFIR[42]
     *  CP1 local checkstop error detected .
     */
    (rNMMUFIR, bit(42)) ? defaultMaskedError;

    /** NMMUFIR[43]
     *  NPU local checkstop error detected .
     */
    (rNMMUFIR, bit(43)) ? defaultMaskedError;

    /** NMMUFIR[44]
     *  FBC local checkstop error detected .
     */
    (rNMMUFIR, bit(44)) ? defaultMaskedError;

    /** NMMUFIR[45]
     *  FBC local checkstop error detected .
     */
    (rNMMUFIR, bit(45)) ? defaultMaskedError;

    /** NMMUFIR[46]
     *  scom error
     */
    (rNMMUFIR, bit(46)) ? defaultMaskedError;

    /** NMMUFIR[47]
     *  scom error
     */
    (rNMMUFIR, bit(47)) ? defaultMaskedError;

};

################################################################################
# P9 chip INTCQFIR
################################################################################

rule rINTCQFIR
{
  CHECK_STOP:
    INTCQFIR & ~INTCQFIR_MASK & ~INTCQFIR_ACT0 & ~INTCQFIR_ACT1;
  RECOVERABLE:
    INTCQFIR & ~INTCQFIR_MASK & ~INTCQFIR_ACT0 &  INTCQFIR_ACT1;
};

group gINTCQFIR filter singlebit, cs_root_cause
{
    /** INTCQFIR[0]
     *  INT_CQ_FIR_PI_ECC_CE:
     */
    (rINTCQFIR, bit(0)) ? self_th_32perDay;

    /** INTCQFIR[1]
     *  INT_CQ_FIR_PI_ECC_UE:
     */
    (rINTCQFIR, bit(1)) ? self_th_1;

    /** INTCQFIR[2]
     *  INT_CQ_FIR_PI_ECC_SUE:
     */
    (rINTCQFIR, bit(2)) ? self_th_1_SUE;

    /** INTCQFIR[3]
     *  INT_CQ_FIR_ST_ECC_CE:
     */
    (rINTCQFIR, bit(3)) ? self_th_32perDay;

    /** INTCQFIR[4]
     *  INT_CQ_FIR_ST_ECC_UE:
     */
    (rINTCQFIR, bit(4)) ? self_th_1;

    /** INTCQFIR[5]
     *  INT_CQ_FIR_LD_ECC_CE:
     */
    (rINTCQFIR, bit(5)) ? self_th_32perDay;

    /** INTCQFIR[6]
     *  INT_CQ_FIR_LD_ECC_UE:
     */
    (rINTCQFIR, bit(6)) ? self_th_1;

    /** INTCQFIR[7]
     *  INT_CQ_FIR_CL_ECC_CE:
     */
    (rINTCQFIR, bit(7)) ? self_th_32perDay;

    /** INTCQFIR[8]
     *  INT_CQ_FIR_CL_ECC_UE:
     */
    (rINTCQFIR, bit(8)) ? self_th_1;

    /** INTCQFIR[9]
     *  INT_CQ_FIR_WR_ECC_CE:
     */
    (rINTCQFIR, bit(9)) ? self_th_32perDay;

    /** INTCQFIR[10]
     *  INT_CQ_FIR_WR_ECC_UE:
     */
    (rINTCQFIR, bit(10)) ? self_th_1;

    /** INTCQFIR[11]
     *  INT_CQ_FIR_RD_ECC_CE:
     */
    (rINTCQFIR, bit(11)) ? self_th_32perDay;

    /** INTCQFIR[12]
     *  INT_CQ_FIR_RD_ECC_UE:
     */
    (rINTCQFIR, bit(12)) ? self_th_1;

    /** INTCQFIR[13]
     *  INT_CQ_FIR_AI_ECC_CE:
     */
    (rINTCQFIR, bit(13)) ? self_th_32perDay;

    /** INTCQFIR[14]
     *  INT_CQ_FIR_AI_ECC_UE:
     */
    (rINTCQFIR, bit(14)) ? self_th_1;

    /** INTCQFIR[15]
     *  INT_CQ_FIR_AIB_IN_CMD_CTL_PERR:
     */
    (rINTCQFIR, bit(15)) ? self_th_1;

    /** INTCQFIR[16]
     *  INT_CQ_FIR_AIB_IN_CMD_PERR:
     */
    (rINTCQFIR, bit(16)) ? self_th_1;

    /** INTCQFIR[17]
     *  INT_CQ_FIR_AIB_IN_DAT_CTL_PERR:
     */
    (rINTCQFIR, bit(17)) ? self_th_1;

    /** INTCQFIR[18]
     *  INT_CQ_FIR_PB_PARITY_ERROR:
     */
    (rINTCQFIR, bit(18)) ? self_th_1;

    /** INTCQFIR[19]
     *  INT_CQ_FIR_PB_RCMDX_CI_ERR1:
     */
    (rINTCQFIR, bit(19)) ? self_th_1;

    /** INTCQFIR[20]
     *  INT_CQ_FIR_PB_RCMDX_CI_ERR2:
     */
    (rINTCQFIR, bit(20)) ? self_th_1;

    /** INTCQFIR[21]
     *  INT_CQ_FIR_PB_RCMDX_CI_ERR3:
     */
    (rINTCQFIR, bit(21)) ? self_th_1;

    /** INTCQFIR[22]
     *  INT_CQ_FIR_RCVD_POISONED_CIST_DATA:
     */
    (rINTCQFIR, bit(22)) ? self_th_32perDay;

    /** INTCQFIR[23]
     *  INT_CQ_FIR_MRT_ERR_NOT_VALID:
     */
    (rINTCQFIR, bit(23)) ? self_th_1;

    /** INTCQFIR[24]
     *  INT_CQ_FIR_MRT_ERR_PSIZE:
     */
    (rINTCQFIR, bit(24)) ? self_th_1;

    /** INTCQFIR[25]
     *  INT_CQ_FIR_SCOM_S_ERR:
     */
    (rINTCQFIR, bit(25)) ? defaultMaskedError;

    /** INTCQFIR[26]
     *  INT_CQ_FIR_TCTXT_PRESP_ERROR:
     */
    (rINTCQFIR, bit(26)) ? self_th_1;

    /** INTCQFIR[27]
     *  INT_CQ_FIR_WRQ_OP_HANG:
     */
    (rINTCQFIR, bit(27)) ? self_th_1;

    /** INTCQFIR[28]
     *  INT_CQ_FIR_RDQ_OP_HANG:
     */
    (rINTCQFIR, bit(28)) ? self_th_1;

    /** INTCQFIR[29]
     *  INT_CQ_FIR_INTQ_OP_HANG:
     */
    (rINTCQFIR, bit(29)) ? self_th_1;

    /** INTCQFIR[30]
     *  INT_CQ_FIR_RDQ_DATA_HANG:
     */
    (rINTCQFIR, bit(30)) ? self_th_1;

    /** INTCQFIR[31]
     *  INT_CQ_FIR_STQ_DATA_HANG:
     */
    (rINTCQFIR, bit(31)) ? self_th_1;

    /** INTCQFIR[32]
     *  INT_CQ_FIR_LDQ_DATA_HANG:
     */
    (rINTCQFIR, bit(32)) ? self_th_1;

    /** INTCQFIR[33]
     *  INT_CQ_FIR_WRQ_BAD_CRESP:
     */
    (rINTCQFIR, bit(33)) ? level2_M_self_L_th_1;

    /** INTCQFIR[34]
     *  INT_CQ_FIR_RDQ_BAD_CRESP:
     */
    (rINTCQFIR, bit(34)) ? level2_M_self_L_th_1;

    /** INTCQFIR[35]
     *  INT_CQ_FIR_INTQ_BAD_CRESP:
     */
    (rINTCQFIR, bit(35)) ? level2_M_self_L_th_1;

    /** INTCQFIR[36]
     *  INT_CQ_FIR_BAD_128K_VP_OP:
     */
    (rINTCQFIR, bit(36)) ? self_th_1;

    /** INTCQFIR[37]
     *  INT_CQ_FIR_RDQ_ABORT_OP:
     */
    (rINTCQFIR, bit(37)) ? defaultMaskedError;

    /** INTCQFIR[38]
     *  INT_CQ_FIR_PC_CRD_PERR:
     */
    (rINTCQFIR, bit(38)) ? self_th_1;

    /** INTCQFIR[39]
     *  INT_CQ_FIR_PC_CRD_AVAIL_PERR:
     */
    (rINTCQFIR, bit(39)) ? self_th_1;

    /** INTCQFIR[40]
     *  INT_CQ_FIR_VC_CRD_PERR:
     */
    (rINTCQFIR, bit(40)) ? self_th_1;

    /** INTCQFIR[41]
     *  INT_CQ_FIR_VC_CRD_AVAIL_PERR:
     */
    (rINTCQFIR, bit(41)) ? self_th_1;

    /** INTCQFIR[42]
     *  INT_CQ_FIR_CMD_QX_SEVERE_ERR:
     */
    (rINTCQFIR, bit(42)) ? self_th_1;

    /** INTCQFIR[43]
     *  INT_CQ_FIR_RDQ_ABORT_TRM:
     */
    (rINTCQFIR, bit(43)) ? self_th_32perDay;

    /** INTCQFIR[44]
     *  INT_CQ_FIR_UNSOLICITED_CRESP:
     */
    (rINTCQFIR, bit(44)) ? level2_M_self_L_th_1;

    /** INTCQFIR[45]
     *  INT_CQ_FIR_UNSOLICITED_PBDATA:
     */
    (rINTCQFIR, bit(45)) ? self_th_1;

    /** INTCQFIR[46]
     *  INT_CQ_FIR_FIR_PARITY_ERR:
     */
    (rINTCQFIR, bit(46)) ? self_th_1;

    /** INTCQFIR[47]
     *  INT_CQ_FIR_PGM_DBG_ACCESS:
     */
    (rINTCQFIR, bit(47)) ? threshold_and_mask;

    /** INTCQFIR[48]
     *  spare
     */
    (rINTCQFIR, bit(48)) ? defaultMaskedError;

    /** INTCQFIR[49:51]
     *  INT_CQ_FIR_PC_FATAL_ERROR_0_2:
     */
    (rINTCQFIR, bit(49|50|51)) ? self_th_1;

    /** INTCQFIR[52:54]
     *  INT_CQ_FIR_PC_RECOV_ERROR_0_2:
     */
    (rINTCQFIR, bit(52|53|54)) ? self_th_1;

    /** INTCQFIR[55:57]
     *  INT_CQ_FIR_PC_INFO_ERROR_0_2:
     */
    (rINTCQFIR, bit(55|56|57)) ? self_th_32perDay;

    /** INTCQFIR[58:59]
     *  INT_CQ_FIR_VC_FATAL_ERROR_0_1:
     */
    (rINTCQFIR, bit(58|59)) ? self_th_1;

    /** INTCQFIR[60:61]
     *  INT_CQ_FIR_VC_RECOV_ERROR_0_1:
     */
    (rINTCQFIR, bit(60|61)) ? self_th_1;

    /** INTCQFIR[62:63]
     *  INT_CQ_FIR_VC_INFO_ERROR_0_1:
     */
    (rINTCQFIR, bit(62|63)) ? self_th_32perDay;

};

################################################################################
# P9 chip PBIOEFIR
################################################################################

rule rPBIOEFIR
{
  CHECK_STOP:
    PBIOEFIR & ~PBIOEFIR_MASK & ~PBIOEFIR_ACT0 & ~PBIOEFIR_ACT1;
  RECOVERABLE:
    PBIOEFIR & ~PBIOEFIR_MASK & ~PBIOEFIR_ACT0 &  PBIOEFIR_ACT1;
};

group gPBIOEFIR filter singlebit, cs_root_cause( 8, 11, 14 )
{
    /** PBIOEFIR[0]
     *  fmr00 trained
     */
    (rPBIOEFIR, bit(0)) ? defaultMaskedError;

    /** PBIOEFIR[1]
     *  fmr01 trained
     */
    (rPBIOEFIR, bit(1)) ? defaultMaskedError;

    /** PBIOEFIR[2]
     *  fmr02 trained
     */
    (rPBIOEFIR, bit(2)) ? defaultMaskedError;

    /** PBIOEFIR[3]
     *  fmr03 trained
     */
    (rPBIOEFIR, bit(3)) ? defaultMaskedError;

    /** PBIOEFIR[4]
     *  fmr04 trained
     */
    (rPBIOEFIR, bit(4)) ? defaultMaskedError;

    /** PBIOEFIR[5]
     *  fmr05 trained
     */
    (rPBIOEFIR, bit(5)) ? defaultMaskedError;

    /** PBIOEFIR[6:7]
     *  spare
     */
    (rPBIOEFIR, bit(6|7)) ? defaultMaskedError;

    /** PBIOEFIR[8]
     *  dob01 ue
     */
    (rPBIOEFIR, bit(8)) ? self_th_1_UERE;

    /** PBIOEFIR[9]
     *  d0b01 ce
     */
    (rPBIOEFIR, bit(9)) ? defaultMaskedError;

    /** PBIOEFIR[10]
     *  dob01 sue
     */
    (rPBIOEFIR, bit(10)) ? defaultMaskedError;

    /** PBIOEFIR[11]
     *  dob23 ue
     */
    (rPBIOEFIR, bit(11)) ? self_th_1_UERE;

    /** PBIOEFIR[12]
     *  dob23 ce
     */
    (rPBIOEFIR, bit(12)) ? defaultMaskedError;

    /** PBIOEFIR[13]
     *  dob23 sue
     */
    (rPBIOEFIR, bit(13)) ? defaultMaskedError;

    /** PBIOEFIR[14]
     *  dob45 ue
     */
    (rPBIOEFIR, bit(14)) ? self_th_1_UERE;

    /** PBIOEFIR[15]
     *  dob45 ce
     */
    (rPBIOEFIR, bit(15)) ? defaultMaskedError;

    /** PBIOEFIR[16]
     *  dob45 sue
     */
    (rPBIOEFIR, bit(16)) ? defaultMaskedError;

    /** PBIOEFIR[17]
     *  dob67 ue
     */
    (rPBIOEFIR, bit(17)) ? defaultMaskedError;

    /** PBIOEFIR[18]
     *  dob67 ce
     */
    (rPBIOEFIR, bit(18)) ? defaultMaskedError;

    /** PBIOEFIR[19]
     *  spare
     */
    (rPBIOEFIR, bit(19)) ? defaultMaskedError;

    /** PBIOEFIR[20]
     *  framer00 attn - X0 even link
     */
    (rPBIOEFIR, bit(20)) ? self_th_1;

    /** PBIOEFIR[21]
     *  framer00 attn - X0 odd link
     */
    (rPBIOEFIR, bit(21)) ? self_th_1;

    /** PBIOEFIR[22]
     *  framer00 attn - X1 even link
     */
    (rPBIOEFIR, bit(22)) ? self_th_1;

    /** PBIOEFIR[23]
     *  framer00 attn - X1 odd link
     */
    (rPBIOEFIR, bit(23)) ? self_th_1;

    /** PBIOEFIR[24]
     *  framer00 attn - X2 even link
     */
    (rPBIOEFIR, bit(24)) ? self_th_1;

    /** PBIOEFIR[25]
     *  framer00 attn - X2 odd link
     */
    (rPBIOEFIR, bit(25)) ? self_th_1;

    /** PBIOEFIR[26:27]
     *  spare
     */
    (rPBIOEFIR, bit(26|27)) ? defaultMaskedError;

    /** PBIOEFIR[28]
     *  parser00 attn
     */
    (rPBIOEFIR, bit(28)) ? self_th_1;

    /** PBIOEFIR[29]
     *  parser01 attn
     */
    (rPBIOEFIR, bit(29)) ? self_th_1;

    /** PBIOEFIR[30]
     *  parser02 attn
     */
    (rPBIOEFIR, bit(30)) ? self_th_1;

    /** PBIOEFIR[31]
     *  parser03 attn
     */
    (rPBIOEFIR, bit(31)) ? self_th_1;

    /** PBIOEFIR[32]
     *  parser04 attn
     */
    (rPBIOEFIR, bit(32)) ? self_th_1;

    /** PBIOEFIR[33]
     *  parser05 attn
     */
    (rPBIOEFIR, bit(33)) ? self_th_1;

    /** PBIOEFIR[34:35]
     *  spare
     */
    (rPBIOEFIR, bit(34|35)) ? defaultMaskedError;

    /** PBIOEFIR[36]
     *  mb0 spattn
     */
    (rPBIOEFIR, bit(36)) ? defaultMaskedError;

    /** PBIOEFIR[37]
     *  mb01 spattn
     */
    (rPBIOEFIR, bit(37)) ? defaultMaskedError;

    /** PBIOEFIR[38]
     *  mb0 spattn
     */
    (rPBIOEFIR, bit(38)) ? defaultMaskedError;

    /** PBIOEFIR[39]
     *  mb11 spattn
     */
    (rPBIOEFIR, bit(39)) ? defaultMaskedError;

    /** PBIOEFIR[40]
     *  mb20 spattn
     */
    (rPBIOEFIR, bit(40)) ? defaultMaskedError;

    /** PBIOEFIR[41]
     *  mb21 spattn
     */
    (rPBIOEFIR, bit(41)) ? defaultMaskedError;

    /** PBIOEFIR[42]
     *  mb30 spattn
     */
    (rPBIOEFIR, bit(42)) ? defaultMaskedError;

    /** PBIOEFIR[43]
     *  mb31 spattn
     */
    (rPBIOEFIR, bit(43)) ? defaultMaskedError;

    /** PBIOEFIR[44]
     *  mb40 spattn
     */
    (rPBIOEFIR, bit(44)) ? defaultMaskedError;

    /** PBIOEFIR[45]
     *  mb41 spattn
     */
    (rPBIOEFIR, bit(45)) ? defaultMaskedError;

    /** PBIOEFIR[46]
     *  mb50 spattn
     */
    (rPBIOEFIR, bit(46)) ? defaultMaskedError;

    /** PBIOEFIR[47]
     *  mb51 spattn
     */
    (rPBIOEFIR, bit(47)) ? defaultMaskedError;

    /** PBIOEFIR[48:51]
     *  spare
     */
    (rPBIOEFIR, bit(48|49|50|51)) ? defaultMaskedError;

    /** PBIOEFIR[52]
     *  links 01 data outbound switch int. err
     */
    (rPBIOEFIR, bit(52)) ? defaultMaskedError;

    /** PBIOEFIR[53]
     *  links 23 data outbound switch int. err
     */
    (rPBIOEFIR, bit(53)) ? defaultMaskedError;

    /** PBIOEFIR[54]
     *  links 45 data outbound switch int. err
     */
    (rPBIOEFIR, bit(54)) ? defaultMaskedError;

    /** PBIOEFIR[55]
     *  spare
     */
    (rPBIOEFIR, bit(55)) ? defaultMaskedError;

    /** PBIOEFIR[56]
     *  links 01 data inbound switch int. err
     */
    (rPBIOEFIR, bit(56)) ? defaultMaskedError;

    /** PBIOEFIR[57]
     *  links 23 data inbound switch int. err
     */
    (rPBIOEFIR, bit(57)) ? defaultMaskedError;

    /** PBIOEFIR[58]
     *  links 45 data inbound switch int. err
     */
    (rPBIOEFIR, bit(58)) ? defaultMaskedError;

    /** PBIOEFIR[59:61]
     *  spare
     */
    (rPBIOEFIR, bit(59|60|61)) ? defaultMaskedError;

    /** PBIOEFIR[62]
     *  scom error
     */
    (rPBIOEFIR, bit(62)) ? defaultMaskedError;

    /** PBIOEFIR[63]
     *  scom error
     */
    (rPBIOEFIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBIOOFIR
################################################################################

rule rPBIOOFIR
{
  CHECK_STOP:
    PBIOOFIR & ~PBIOOFIR_MASK & ~PBIOOFIR_ACT0 & ~PBIOOFIR_ACT1;
  RECOVERABLE:
    PBIOOFIR & ~PBIOOFIR_MASK & ~PBIOOFIR_ACT0 &  PBIOOFIR_ACT1;
};

group gPBIOOFIR filter singlebit, cs_root_cause( 8, 11, 14, 17 )
{
    /** PBIOOFIR[0]
     *  fmr00 trained
     */
    (rPBIOOFIR, bit(0)) ? defaultMaskedError;

    /** PBIOOFIR[1]
     *  fmr01 trained
     */
    (rPBIOOFIR, bit(1)) ? defaultMaskedError;

    /** PBIOOFIR[2]
     *  fmr02 trained
     */
    (rPBIOOFIR, bit(2)) ? defaultMaskedError;

    /** PBIOOFIR[3]
     *  fmr03 trained
     */
    (rPBIOOFIR, bit(3)) ? defaultMaskedError;

    /** PBIOOFIR[4]
     *  fmr04 trained
     */
    (rPBIOOFIR, bit(4)) ? defaultMaskedError;

    /** PBIOOFIR[5]
     *  fmr05 trained
     */
    (rPBIOOFIR, bit(5)) ? defaultMaskedError;

    /** PBIOOFIR[6]
     *  fmr06 trained
     */
    (rPBIOOFIR, bit(6)) ? defaultMaskedError;

    /** PBIOOFIR[7]
     *  fmr07 trained
     */
    (rPBIOOFIR, bit(7)) ? defaultMaskedError;

    /** PBIOOFIR[8]
     *  dob01 ue
     */
    (rPBIOOFIR, bit(8)) ? self_th_1_UERE;

    /** PBIOOFIR[9]
     *  dob01 ce
     */
    (rPBIOOFIR, bit(9)) ? defaultMaskedError;

    /** PBIOOFIR[10]
     *  dob01 sue
     */
    (rPBIOOFIR, bit(10)) ? defaultMaskedError;

    /** PBIOOFIR[11]
     *  dob23 ue
     */
    (rPBIOOFIR, bit(11)) ? self_th_1_UERE;

    /** PBIOOFIR[12]
     *  dob23 ce
     */
    (rPBIOOFIR, bit(12)) ? defaultMaskedError;

    /** PBIOOFIR[13]
     *  dob23 sue
     */
    (rPBIOOFIR, bit(13)) ? defaultMaskedError;

    /** PBIOOFIR[14]
     *  dob45 ue
     */
    (rPBIOOFIR, bit(14)) ? self_th_1_UERE;

    /** PBIOOFIR[15]
     *  dob45 ce
     */
    (rPBIOOFIR, bit(15)) ? defaultMaskedError;

    /** PBIOOFIR[16]
     *  dob45 sue
     */
    (rPBIOOFIR, bit(16)) ? defaultMaskedError;

    /** PBIOOFIR[17]
     *  dob67 ue
     */
    (rPBIOOFIR, bit(17)) ? self_th_1_UERE;

    /** PBIOOFIR[18]
     *  dob67 ce
     */
    (rPBIOOFIR, bit(18)) ? defaultMaskedError;

    /** PBIOOFIR[19]
     *  dob67 sue
     */
    (rPBIOOFIR, bit(19)) ? defaultMaskedError;

    /** PBIOOFIR[20]
     *  A0 even link framer error
     */
    (rPBIOOFIR, bit(20)) ? self_th_1;

    /** PBIOOFIR[21]
     *  A0 odd framer error
     */
    (rPBIOOFIR, bit(21)) ? self_th_1;

    /** PBIOOFIR[22]
     *  A1 even link framer error
     */
    (rPBIOOFIR, bit(22)) ? self_th_1;

    /** PBIOOFIR[23]
     *  A1 odd link framer error
     */
    (rPBIOOFIR, bit(23)) ? self_th_1;

    /** PBIOOFIR[24]
     *  A2 even link framer error
     */
    (rPBIOOFIR, bit(24)) ? self_th_1;

    /** PBIOOFIR[25]
     *  A2 odd link framer error
     */
    (rPBIOOFIR, bit(25)) ? self_th_1;

    /** PBIOOFIR[26]
     *  A3 even link framer error
     */
    (rPBIOOFIR, bit(26)) ? self_th_1;

    /** PBIOOFIR[27]
     *  A3 odd link framer error
     */
    (rPBIOOFIR, bit(27)) ? self_th_1;

    /** PBIOOFIR[28]
     *  parser00 attn
     */
    (rPBIOOFIR, bit(28)) ? self_th_1;

    /** PBIOOFIR[29]
     *  parser01 attn
     */
    (rPBIOOFIR, bit(29)) ? self_th_1;

    /** PBIOOFIR[30]
     *  parser02 attn
     */
    (rPBIOOFIR, bit(30)) ? self_th_1;

    /** PBIOOFIR[31]
     *  parser03 attn
     */
    (rPBIOOFIR, bit(31)) ? self_th_1;

    /** PBIOOFIR[32]
     *  parser04 attn
     */
    (rPBIOOFIR, bit(32)) ? self_th_1;

    /** PBIOOFIR[33]
     *  parser05 attn
     */
    (rPBIOOFIR, bit(33)) ? self_th_1;

    /** PBIOOFIR[34]
     *  parser06 attn
     */
    (rPBIOOFIR, bit(34)) ? self_th_1;

    /** PBIOOFIR[35]
     *  parser07 attn
     */
    (rPBIOOFIR, bit(35)) ? self_th_1;

    /** PBIOOFIR[36]
     *  mailbox 00 special attention
     */
    (rPBIOOFIR, bit(36)) ? defaultMaskedError;

    /** PBIOOFIR[37]
     *  mailbox 01 special attention
     */
    (rPBIOOFIR, bit(37)) ? defaultMaskedError;

    /** PBIOOFIR[38]
     *  mailbox 02 special attention
     */
    (rPBIOOFIR, bit(38)) ? defaultMaskedError;

    /** PBIOOFIR[39]
     *  mailbox 11 special attention
     */
    (rPBIOOFIR, bit(39)) ? defaultMaskedError;

    /** PBIOOFIR[40]
     *  mailbox 20 special attention
     */
    (rPBIOOFIR, bit(40)) ? defaultMaskedError;

    /** PBIOOFIR[41]
     *  mailbox 21 special attention
     */
    (rPBIOOFIR, bit(41)) ? defaultMaskedError;

    /** PBIOOFIR[42]
     *  mailbox 30 special attention
     */
    (rPBIOOFIR, bit(42)) ? defaultMaskedError;

    /** PBIOOFIR[43]
     *  mailbox 31 special attention
     */
    (rPBIOOFIR, bit(43)) ? defaultMaskedError;

    /** PBIOOFIR[44]
     *  mailbox 40 special attention
     */
    (rPBIOOFIR, bit(44)) ? defaultMaskedError;

    /** PBIOOFIR[45]
     *  mailbox 41 special attention
     */
    (rPBIOOFIR, bit(45)) ? defaultMaskedError;

    /** PBIOOFIR[46]
     *  mailbox 50 special attention
     */
    (rPBIOOFIR, bit(46)) ? defaultMaskedError;

    /** PBIOOFIR[47]
     *  mailbox 51 special attention
     */
    (rPBIOOFIR, bit(47)) ? defaultMaskedError;

    /** PBIOOFIR[48]
     *  mailbox 60 special attention
     */
    (rPBIOOFIR, bit(48)) ? defaultMaskedError;

    /** PBIOOFIR[49]
     *  mailbox 61 special attention
     */
    (rPBIOOFIR, bit(49)) ? defaultMaskedError;

    /** PBIOOFIR[50]
     *  mailbox 70 special attention
     */
    (rPBIOOFIR, bit(50)) ? defaultMaskedError;

    /** PBIOOFIR[51]
     *  mailbox 71 special attention
     */
    (rPBIOOFIR, bit(51)) ? defaultMaskedError;

    /** PBIOOFIR[52]
     *  data outbound switch internal-links 01
     */
    (rPBIOOFIR, bit(52)) ? defaultMaskedError;

    /** PBIOOFIR[53]
     *  data outbound switch internal - links 23
     */
    (rPBIOOFIR, bit(53)) ? defaultMaskedError;

    /** PBIOOFIR[54]
     *  data outbound switch internal-links 45
     */
    (rPBIOOFIR, bit(54)) ? defaultMaskedError;

    /** PBIOOFIR[55]
     *  data outbound switch internal-links 67
     */
    (rPBIOOFIR, bit(55)) ? defaultMaskedError;

    /** PBIOOFIR[56]
     *  data inbound switch internal-links 01
     */
    (rPBIOOFIR, bit(56)) ? defaultMaskedError;

    /** PBIOOFIR[57]
     *  data inbound switch internal-links 23
     */
    (rPBIOOFIR, bit(57)) ? defaultMaskedError;

    /** PBIOOFIR[58]
     *  data inbound switch internal-links 45
     */
    (rPBIOOFIR, bit(58)) ? defaultMaskedError;

    /** PBIOOFIR[59]
     *  data inbound switch internal-links 67
     */
    (rPBIOOFIR, bit(59)) ? defaultMaskedError;

    /** PBIOOFIR[60:61]
     *  spare
     */
    (rPBIOOFIR, bit(60|61)) ? defaultMaskedError;

    /** PBIOOFIR[62]
     *  scom error
     */
    (rPBIOOFIR, bit(62)) ? defaultMaskedError;

    /** PBIOOFIR[63]
     *  scom error
     */
    (rPBIOOFIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU0FIR
################################################################################

rule rNPU0FIR
{
  CHECK_STOP:
    NPU0FIR & ~NPU0FIR_MASK & ~NPU0FIR_ACT0 & ~NPU0FIR_ACT1;
  RECOVERABLE:
    NPU0FIR & ~NPU0FIR_MASK & ~NPU0FIR_ACT0 &  NPU0FIR_ACT1;
  UNIT_CS:
    NPU0FIR & ~NPU0FIR_MASK &  NPU0FIR_ACT0 &  NPU0FIR_ACT1;
};

group gNPU0FIR filter singlebit, cs_root_cause
{
    /** NPU0FIR[0]
     *  NTL array CE
     */
    (rNPU0FIR, bit(0)) ? self_th_32perDay;

    /** NPU0FIR[1]
     *  NTL header array UE
     */
    (rNPU0FIR, bit(1)) ? self_th_1;

    /** NPU0FIR[2]
     *  NTL Data Array UE
     */
    (rNPU0FIR, bit(2)) ? self_th_1;

    /** NPU0FIR[3]
     *  NTL NVLInk Control/Header/AE PE
     */
    (rNPU0FIR, bit(3)) ? self_th_1;

    /** NPU0FIR[4]
     *  NTL NVLink Data Parity error
     */
    (rNPU0FIR, bit(4)) ? self_th_1;

    /** NPU0FIR[5]
     *  NTL NVLink Malformed Packet
     */
    (rNPU0FIR, bit(5)) ? self_th_1;

    /** NPU0FIR[6]
     *  NTL NVLink Unsupported Packet
     */
    (rNPU0FIR, bit(6)) ? self_th_1;

    /** NPU0FIR[7]
     *  NTL NVLink Config errors
     */
    (rNPU0FIR, bit(7)) ? self_th_1;

    /** NPU0FIR[8]
     *  NTL NVLink CRC errors or LMD=Stomp
     */
    (rNPU0FIR, bit(8)) ? defaultMaskedError;

    /** NPU0FIR[9]
     *  NTL PRI errors
     */
    (rNPU0FIR, bit(9)) ? self_th_1;

    /** NPU0FIR[10]
     *  NTL logic error
     */
    (rNPU0FIR, bit(10)) ? self_th_1;

    /** NPU0FIR[11]
     *  NTL LMD=Data Posion
     */
    (rNPU0FIR, bit(11)) ? defaultMaskedError;

    /** NPU0FIR[12]
     *  NTL data array SUE
     */
    (rNPU0FIR, bit(12)) ? defaultMaskedError;

    /** NPU0FIR[13]
     *  CQ CTL/SM ASBE Array single-bit CE
     */
    (rNPU0FIR, bit(13)) ? self_th_32perDay;

    /** NPU0FIR[14]
     *  CQ CTL/SM PBR PowerBus Recoverable err
     */
    (rNPU0FIR, bit(14)) ? defaultMaskedError;

    /** NPU0FIR[15]
     *  CQ CTL/SM REG Register ring error
     */
    (rNPU0FIR, bit(15)) ? self_th_32perDay;

    /** NPU0FIR[16]
     *  Data UE for MMIO store data
     */
    (rNPU0FIR, bit(16)) ? self_th_1;

    /** NPU0FIR[17]
     *  spare
     */
    (rNPU0FIR, bit(17)) ? defaultMaskedError;

    /** NPU0FIR[18]
     *  CQ CTL/SM NCF NVLink config error
     */
    (rNPU0FIR, bit(18)) ? self_th_1;

    /** NPU0FIR[19]
     *  CQ CTL/SM NVF NVLink fatal error
     */
    (rNPU0FIR, bit(19)) ? self_th_1;

    /** NPU0FIR[20]
     *  spare
     */
    (rNPU0FIR, bit(20)) ? defaultMaskedError;

    /** NPU0FIR[21]
     *  CQ CTL/SM AUE Array UE
     */
    (rNPU0FIR, bit(21)) ? self_th_1;

    /** NPU0FIR[22]
     *  CQ CTL/SM PBP PowerBus parity error
     */
    (rNPU0FIR, bit(22)) ? self_th_1;

    /** NPU0FIR[23]
     *  CQ CTL/SM PBF PowerBus Fatal Error
     */
    (rNPU0FIR, bit(23)) ? level2_M_self_L_th_1;

    /** NPU0FIR[24]
     *  PowerBus configuration error
     */
    (rNPU0FIR, bit(24)) ? level2_M_self_L_th_1;

    /** NPU0FIR[25]
     *  CQ CTL/SM FWD Forward-Progress error
     */
    (rNPU0FIR, bit(25)) ? self_th_1;

    /** NPU0FIR[26]
     *  CQ CTL/SM NLG NPU Logic error
     */
    (rNPU0FIR, bit(26)) ? self_th_1;

    /** NPU0FIR[27]
     *  CQ CTL/SM  UT=1 to frozen PE error
     */
    (rNPU0FIR, bit(27)) ? defaultMaskedError;

    /** NPU0FIR[28]
     *  spare
     */
    (rNPU0FIR, bit(28)) ? defaultMaskedError;

    /** NPU0FIR[29]
     *  CQ DAT ECC UE/SUE on data/BE arrays
     */
    (rNPU0FIR, bit(29)) ? self_th_1;

    /** NPU0FIR[30]
     *  CQ DAT ECC CE on data/BE arrays
     */
    (rNPU0FIR, bit(30)) ? self_M_level2_L_th_32perDay;

    /** NPU0FIR[31]
     *  CQ DAT parity error on data/BE latches
     */
    (rNPU0FIR, bit(31)) ? self_th_1;

    /** NPU0FIR[32]
     *  CQ DAT parity errs on config regs
     */
    (rNPU0FIR, bit(32)) ? self_th_1;

    /** NPU0FIR[33]
     *  CQ DAT parity errs/PowerBus rtag
     */
    (rNPU0FIR, bit(33)) ? self_th_1;

    /** NPU0FIR[34]
     *  CQ DAT parity errs nternal state latches
     */
    (rNPU0FIR, bit(34)) ? self_th_1;

    /** NPU0FIR[35]
     *  CQ DAT logic error
     */
    (rNPU0FIR, bit(35)) ? self_th_1;

    /** NPU0FIR[36]
     *  Future SUE
     */
    (rNPU0FIR, bit(36)) ? defaultMaskedError;

    /** NPU0FIR[37]
     *  ECC SUE on PB received data
     */
    (rNPU0FIR, bit(37)) ? defaultMaskedError;

    /** NPU0FIR[38:39]
     *  spare
     */
    (rNPU0FIR, bit(38|39)) ? defaultMaskedError;

    /** NPU0FIR[40]
     *  XTS internal logic error
     */
    (rNPU0FIR, bit(40)) ? self_th_1;

    /** NPU0FIR[41]
     *  XTS correctable errs in XTS SRAM
     */
    (rNPU0FIR, bit(41)) ? self_M_level2_L_th_32perDay;

    /** NPU0FIR[42]
     *  XTS Ues in XTS internal SRAM
     */
    (rNPU0FIR, bit(42)) ? self_th_1;

    /** NPU0FIR[43]
     *  XTS CE on incoming stack transactions
     */
    (rNPU0FIR, bit(43)) ? self_M_level2_L_th_32perDay;

    /** NPU0FIR[44]
     *  XTS  errs incoming stack transaction
     */
    (rNPU0FIR, bit(44)) ? self_th_1;

    /** NPU0FIR[45]
     *  XTS errs on incoming PBUS transaction
     */
    (rNPU0FIR, bit(45)) ? self_th_1;

    /** NPU0FIR[46]
     *  XTS Translate Request Fail
     */
    (rNPU0FIR, bit(46)) ? self_th_1;

    /** NPU0FIR[47:59]
     *  spare
     */
    (rNPU0FIR, bit(47|48|49|50|51|52|53|54|55|56|57|58|59)) ? defaultMaskedError;

    /** NPU0FIR[60]
     *  MISC Pervasive SCOM satellite err
     */
    (rNPU0FIR, bit(60)) ? defaultMaskedError;

    /** NPU0FIR[61]
     *  MISC Pervasive SCOM satellite err
     */
    (rNPU0FIR, bit(61)) ? defaultMaskedError;

    /** NPU0FIR[62]
     *  Local FIR Parity Error RAS duplicate
     */
    (rNPU0FIR, bit(62)) ? defaultMaskedError;

    /** NPU0FIR[63]
     *  Local FIR Parity Err
     */
    (rNPU0FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU1FIR
################################################################################

rule rNPU1FIR
{
  CHECK_STOP:
    NPU1FIR & ~NPU1FIR_MASK & ~NPU1FIR_ACT0 & ~NPU1FIR_ACT1;
  RECOVERABLE:
    NPU1FIR & ~NPU1FIR_MASK & ~NPU1FIR_ACT0 &  NPU1FIR_ACT1;
  UNIT_CS:
    NPU1FIR & ~NPU1FIR_MASK &  NPU1FIR_ACT0 &  NPU1FIR_ACT1;
};

group gNPU1FIR filter singlebit, cs_root_cause
{
    /** NPU1FIR[0]
     *  NDL Brick0 stall
     */
    (rNPU1FIR, bit(0)) ? self_th_1;

    /** NPU1FIR[1]
     *  NDL Brick0 nostall
     */
    (rNPU1FIR, bit(1)) ? defaultMaskedError;

    /** NPU1FIR[2]
     *  NDL Brick1 stall
     */
    (rNPU1FIR, bit(2)) ? self_th_1;

    /** NPU1FIR[3]
     *  NDL Brick1 nostall
     */
    (rNPU1FIR, bit(3)) ? defaultMaskedError;

    /** NPU1FIR[4]
     *  NDL Brick2 stall
     */
    (rNPU1FIR, bit(4)) ? self_th_1;

    /** NPU1FIR[5]
     *  NDL Brick2 nostall
     */
    (rNPU1FIR, bit(5)) ? defaultMaskedError;

    /** NPU1FIR[6]
     *  NDL Brick3 stall
     */
    (rNPU1FIR, bit(6)) ? self_th_1;

    /** NPU1FIR[7]
     *  NDL Brick3 nostall
     */
    (rNPU1FIR, bit(7)) ? defaultMaskedError;

    /** NPU1FIR[8]
     *  NDL Brick4 stall
     */
    (rNPU1FIR, bit(8)) ? self_th_1;

    /** NPU1FIR[9]
     *  NDL Brick4 nostall
     */
    (rNPU1FIR, bit(9)) ? defaultMaskedError;

    /** NPU1FIR[10]
     *  NDL Brick5 stall
     */
    (rNPU1FIR, bit(10)) ? self_th_1;

    /** NPU1FIR[11]
     *  NDL Brick5 nostall
     */
    (rNPU1FIR, bit(11)) ? defaultMaskedError;

    /** NPU1FIR[12]
     *  MISC Register ring error (ie noack)
     */
    (rNPU1FIR, bit(12)) ? self_th_32perDay;

    /** NPU1FIR[13]
     *  MISC Parity error from ibr addr regi
     */
    (rNPU1FIR, bit(13)) ? self_th_1;

    /** NPU1FIR[14]
     *  MISC Parity error on SCOM D/A addr reg
     */
    (rNPU1FIR, bit(14)) ? self_th_1;

    /** NPU1FIR[15]
     *  MISC Parity error on MISC Cntrl reg
     */
    (rNPU1FIR, bit(15)) ? self_th_1;

    /** NPU1FIR[16]
     *  MISC NMMU signaled Local Checkstop
     */
    (rNPU1FIR, bit(16)) ? defaultMaskedError;

    /** NPU1FIR[17]
     *  ATS Invalid TVT entry
     */
    (rNPU1FIR, bit(17)) ? defaultMaskedError;

    /** NPU1FIR[18]
     *  ATS TVT Address range error
     */
    (rNPU1FIR, bit(18)) ? defaultMaskedError;

    /** NPU1FIR[19]
     *  ATS TCE Page access error
     */
    (rNPU1FIR, bit(19)) ? defaultMaskedError;

    /** NPU1FIR[20]
     *  ATS Effective Address hit multiple TCE
     */
    (rNPU1FIR, bit(20)) ? self_th_1;

    /** NPU1FIR[21]
     *  ATS TCE Page access error
     */
    (rNPU1FIR, bit(21)) ? defaultMaskedError;

    /** NPU1FIR[22]
     *  ATS Timeout on TCE tree walk
     */
    (rNPU1FIR, bit(22)) ? self_th_1;

    /** NPU1FIR[23]
     *  ATS Parity error on TCE cache dir array
     */
    (rNPU1FIR, bit(23)) ? self_th_32perDay;

    /** NPU1FIR[24]
     *  ATS Parity error on TCE cache data array
     */
    (rNPU1FIR, bit(24)) ? self_th_32perDay;

    /** NPU1FIR[25]
     *  ATS ECC UE on Effective Address array
     */
    (rNPU1FIR, bit(25)) ? self_th_1;

    /** NPU1FIR[26]
     *  ATS ECC CE on Effective Address array
     */
    (rNPU1FIR, bit(26)) ? self_th_32perDay;

    /** NPU1FIR[27]
     *  ATS ECC UE on TDRmem array
     */
    (rNPU1FIR, bit(27)) ? self_th_1;

    /** NPU1FIR[28]
     *  ATS ECC CE on TDRmem array
     */
    (rNPU1FIR, bit(28)) ? self_th_1;

    /** NPU1FIR[29]
     *  ATS ECC UE on CQ CTL DMA Read
     */
    (rNPU1FIR, bit(29)) ? self_th_1;

    /** NPU1FIR[30]
     *  ATS ECC CE on CQ CTL DMA Read
     */
    (rNPU1FIR, bit(30)) ? self_th_32perDay;

    /** NPU1FIR[31]
     *  ATS Parity error on TVT entry
     */
    (rNPU1FIR, bit(31)) ? self_th_1;

    /** NPU1FIR[32]
     *  ATS Parity err on IODA Address Reg
     */
    (rNPU1FIR, bit(32)) ? self_th_1;

    /** NPU1FIR[33]
     *  ATS Parity error on ATS Control Register
     */
    (rNPU1FIR, bit(33)) ? self_th_1;

    /** NPU1FIR[34]
     *  ATS Parity error on ATS reg
     */
    (rNPU1FIR, bit(34)) ? self_th_1;

    /** NPU1FIR[35]
     *  ATS Invalid IODA Table Select entry
     */
    (rNPU1FIR, bit(35)) ? self_th_1;

    /** NPU1FIR[36:61]
     *  Reserved
     */
    (rNPU1FIR, bit(36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58|59|60|61)) ? defaultMaskedError;

    /** NPU1FIR[62]
     *  scom error
     */
    (rNPU1FIR, bit(62)) ? defaultMaskedError;

    /** NPU1FIR[63]
     *  scom error
     */
    (rNPU1FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# XB Chiplet FIR
################################################################################

rule rXB_CHIPLET_FIR
{
  CHECK_STOP:
     XB_CHIPLET_CS_FIR       & ~XB_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (XB_CHIPLET_RE_FIR >> 2) & ~XB_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gXB_CHIPLET_FIR filter singlebit
{
    /** XB_CHIPLET_FIR[3]
     *  Attention from XB_LFIR
     */
    (rXB_CHIPLET_FIR, bit(3)) ? analyze(gXB_LFIR);

    /** XB_CHIPLET_FIR[5]
     *  Attention from IOELFIR 1
     */
    (rXB_CHIPLET_FIR, bit(5)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_FIR[6]
     *  Attention from IOELFIR 2
     */
    (rXB_CHIPLET_FIR, bit(6)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_FIR[9]
     *  Attention from IOXBFIR 1
     */
    (rXB_CHIPLET_FIR, bit(9)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_FIR[10]
     *  Attention from IOXBFIR 2
     */
    (rXB_CHIPLET_FIR, bit(10)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_FIR[11]
     *  Attention from XBPPEFIR
     */
    (rXB_CHIPLET_FIR, bit(11)) ? analyze(gXBPPEFIR);

};

################################################################################
# XB Chiplet Unit Checkstop FIR
################################################################################

rule rXB_CHIPLET_UCS_FIR
{
  UNIT_CS:
    XB_CHIPLET_UCS_FIR & ~XB_CHIPLET_UCS_FIR_MASK & `7fffffffffffffff`;
};

group gXB_CHIPLET_UCS_FIR filter singlebit
{
    /** XB_CHIPLET_UCS_FIR[2]
     *  Attention from IOELFIR 1
     */
    (rXB_CHIPLET_UCS_FIR, bit(2)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_UCS_FIR[3]
     *  Attention from IOELFIR 2
     */
    (rXB_CHIPLET_UCS_FIR, bit(3)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_UCS_FIR[6]
     *  Attention from IOXBFIR 1
     */
    (rXB_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_UCS_FIR[7]
     *  Attention from IOXBFIR 2
     */
    (rXB_CHIPLET_UCS_FIR, bit(7)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_UCS_FIR[8]
     *  Attention from XBPPEFIR
     */
    (rXB_CHIPLET_UCS_FIR, bit(8)) ? analyze(gXBPPEFIR);

};

################################################################################
# P9 chip XB_LFIR
################################################################################

rule rXB_LFIR
{
  CHECK_STOP:
    XB_LFIR & ~XB_LFIR_MASK & ~XB_LFIR_ACT0 & ~XB_LFIR_ACT1;
  RECOVERABLE:
    XB_LFIR & ~XB_LFIR_MASK & ~XB_LFIR_ACT0 &  XB_LFIR_ACT1;
};

group gXB_LFIR filter singlebit, cs_root_cause
{
    /** XB_LFIR[0]
     *  CFIR internal parity error
     */
    (rXB_LFIR, bit(0)) ? self_th_32perDay;

    /** XB_LFIR[1]
     *  local error from GPIO
     */
    (rXB_LFIR, bit(1)) ? self_th_32perDay;

    /** XB_LFIR[2]
     *  local err from CC
     */
    (rXB_LFIR, bit(2)) ? self_th_32perDay;

    /** XB_LFIR[3]
     *  local err from CC
     */
    (rXB_LFIR, bit(3)) ? self_th_32perDay;

    /** XB_LFIR[4]
     *  local err from PSC
     */
    (rXB_LFIR, bit(4)) ? defaultMaskedError;

    /** XB_LFIR[5]
     *  local err from PSC (parity error)
     */
    (rXB_LFIR, bit(5)) ? defaultMaskedError;

    /** XB_LFIR[6]
     *  local err from Thermal (parity error)
     */
    (rXB_LFIR, bit(6)) ? defaultMaskedError;

    /** XB_LFIR[7]
     *  local err from Thermal (PCB error
     */
    (rXB_LFIR, bit(7)) ? defaultMaskedError;

    /** XB_LFIR[8]
     *  trip critical thermal local err
     */
    (rXB_LFIR, bit(8)) ? defaultMaskedError;

    /** XB_LFIR[9]
     *  trip fatal thermal local error
     */
    (rXB_LFIR, bit(9)) ? defaultMaskedError;

    /** XB_LFIR[10]
     *  therm volttrip error
     */
    (rXB_LFIR, bit(10)) ? defaultMaskedError;

    /** XB_LFIR[11]
     *  local err from Debug ( error)
     */
    (rXB_LFIR, bit(11)) ? defaultMaskedError;

    /** XB_LFIR[12]
     *  local err from trace array 0
     */
    (rXB_LFIR, bit(12)) ? defaultMaskedError;

    /** XB_LFIR[13]
     *  local err from trace array 0
     */
    (rXB_LFIR, bit(13)) ? defaultMaskedError;

    /** XB_LFIR[14]
     *  local err from trace array 0
     */
    (rXB_LFIR, bit(14)) ? defaultMaskedError;

    /** XB_LFIR[15]
     *  local err from trace array 0
     */
    (rXB_LFIR, bit(15)) ? defaultMaskedError;

    /** XB_LFIR[16:40]
     *  spare
     */
    (rXB_LFIR, bit(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** XB_LFIR[41]
     *  malfunction alert broadcast via obb
     */
    (rXB_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip XBPPEFIR
################################################################################

rule rXBPPEFIR
{
  CHECK_STOP:
    XBPPEFIR & ~XBPPEFIR_MASK & ~XBPPEFIR_ACT0 & ~XBPPEFIR_ACT1;
  RECOVERABLE:
    XBPPEFIR & ~XBPPEFIR_MASK & ~XBPPEFIR_ACT0 &  XBPPEFIR_ACT1;
  UNIT_CS:
    XBPPEFIR & ~XBPPEFIR_MASK &  XBPPEFIR_ACT0 &  XBPPEFIR_ACT1;
};

group gXBPPEFIR filter singlebit, cs_root_cause
{
    /** XBPPEFIR[0]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(0)) ? threshold_and_mask;

    /** XBPPEFIR[1]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(1)) ? threshold_and_mask;

    /** XBPPEFIR[2]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(2)) ? threshold_and_mask;

    /** XBPPEFIR[3]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(3)) ? threshold_and_mask;

    /** XBPPEFIR[4]
     *  PPE halted.
     */
    (rXBPPEFIR, bit(4)) ? defaultMaskedError;

    /** XBPPEFIR[5]
     *  PPE watchdog timer timed out
     */
    (rXBPPEFIR, bit(5)) ? defaultMaskedError;

    /** XBPPEFIR[6]
     *  MMIO data in error.
     */
    (rXBPPEFIR, bit(6)) ? defaultMaskedError;

    /** XBPPEFIR[7]
     *  Arb missed scrub tick.
     */
    (rXBPPEFIR, bit(7)) ? threshold_and_mask;

    /** XBPPEFIR[8]
     *  Arb ary ue error.
     */
    (rXBPPEFIR, bit(8)) ? self_th_1;

    /** XBPPEFIR[9]
     *  Arb ary ce error.
     */
    (rXBPPEFIR, bit(9)) ? threshold_and_mask;

    /** XBPPEFIR[10]
     *  spare
     */
    (rXBPPEFIR, bit(10)) ? defaultMaskedError;

    /** XBPPEFIR[11]
     *  FIR_SCOMFIR_ERROR
     */
    (rXBPPEFIR, bit(11)) ? defaultMaskedError;

    /** XBPPEFIR[12]
     *  FIR_SCOMFIR_ERROR
     */
    (rXBPPEFIR, bit(12)) ? defaultMaskedError;

};

################################################################################
# PCI0 Chiplet FIR
################################################################################

rule rPCI0_CHIPLET_FIR
{
  CHECK_STOP:
     PCI0_CHIPLET_CS_FIR       & ~PCI0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (PCI0_CHIPLET_RE_FIR >> 2) & ~PCI0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gPCI0_CHIPLET_FIR filter singlebit
{
    /** PCI0_CHIPLET_FIR[3]
     *  Attention from PCI_LFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(3)) ? analyzeConnectedPEC0;

    /** PCI0_CHIPLET_FIR[4]
     *  Attention from ETUFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(4)) ? analyzeConnectedPHB0;

    /** PCI0_CHIPLET_FIR[5]
     *  Attention from IOPCIFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(5)) ? analyzeConnectedPEC0;

    /** PCI0_CHIPLET_FIR[6]
     *  Attention from PCIFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(6)) ? analyzeConnectedPHB0;

};

################################################################################
# PCI1 Chiplet FIR
################################################################################

rule rPCI1_CHIPLET_FIR
{
  CHECK_STOP:
     PCI1_CHIPLET_CS_FIR       & ~PCI1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (PCI1_CHIPLET_RE_FIR >> 2) & ~PCI1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gPCI1_CHIPLET_FIR filter singlebit
{
    /** PCI1_CHIPLET_FIR[3]
     *  Attention from PCI_LFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(3)) ? analyzeConnectedPEC1;

    /** PCI1_CHIPLET_FIR[4]
     *  Attention from ETUFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(4)) ? analyzeConnectedPHB1;

    /** PCI1_CHIPLET_FIR[5]
     *  Attention from ETUFIR 2
     */
    (rPCI1_CHIPLET_FIR, bit(5)) ? analyzeConnectedPHB2;

    /** PCI1_CHIPLET_FIR[6]
     *  Attention from IOPCIFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(6)) ? analyzeConnectedPEC1;

    /** PCI1_CHIPLET_FIR[7]
     *  Attention from PCIFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(7)) ? analyzeConnectedPHB1;

    /** PCI1_CHIPLET_FIR[8]
     *  Attention from PCIFIR 2
     */
    (rPCI1_CHIPLET_FIR, bit(8)) ? analyzeConnectedPHB2;

};

################################################################################
# PCI2 Chiplet FIR
################################################################################

rule rPCI2_CHIPLET_FIR
{
  CHECK_STOP:
     PCI2_CHIPLET_CS_FIR       & ~PCI2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (PCI2_CHIPLET_RE_FIR >> 2) & ~PCI2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gPCI2_CHIPLET_FIR filter singlebit
{
    /** PCI2_CHIPLET_FIR[3]
     *  Attention from PCI_LFIR 2
     */
    (rPCI2_CHIPLET_FIR, bit(3)) ? analyzeConnectedPEC2;

    /** PCI2_CHIPLET_FIR[4]
     *  Attention from ETUFIR 3
     */
    (rPCI2_CHIPLET_FIR, bit(4)) ? analyzeConnectedPHB3;

    /** PCI2_CHIPLET_FIR[5]
     *  Attention from ETUFIR 4
     */
    (rPCI2_CHIPLET_FIR, bit(5)) ? analyzeConnectedPHB4;

    /** PCI2_CHIPLET_FIR[6]
     *  Attention from ETUFIR 5
     */
    (rPCI2_CHIPLET_FIR, bit(6)) ? analyzeConnectedPHB5;

    /** PCI2_CHIPLET_FIR[7]
     *  Attention from IOPCIFIR 2
     */
    (rPCI2_CHIPLET_FIR, bit(7)) ? analyzeConnectedPEC2;

    /** PCI2_CHIPLET_FIR[8]
     *  Attention from PCIFIR 3
     */
    (rPCI2_CHIPLET_FIR, bit(8)) ? analyzeConnectedPHB3;

    /** PCI2_CHIPLET_FIR[9]
     *  Attention from PCIFIR 4
     */
    (rPCI2_CHIPLET_FIR, bit(9)) ? analyzeConnectedPHB4;

    /** PCI2_CHIPLET_FIR[10]
     *  Attention from PCIFIR 5
     */
    (rPCI2_CHIPLET_FIR, bit(10)) ? analyzeConnectedPHB5;

};

 ##############################################################################
 #                                                                            #
 #    #                                  ###                                  #
 #   # #    ##  ##### ###  ###  #   #   #   # #     #    ###   ###  ###  ###  #
 #  #   #  #  #   #    #  #   # ##  #   #     #    # #  #     #     #   #     #
 # ####### #      #    #  #   # # # #   #     #   #####  ###   ###  ##   ###  #
 # #     # #  #   #    #  #   # #  ##   #   # #   #   #     #     # #       # #
 # #     #  ##    #   ###  ###  #   #    ###  ### #   #  ###   ###  ###  ###  #
 #                                                                            #
 ##############################################################################

# Include the common action set.
.include "p9_common_actions.rule";
# Include the chip-specific action set.
.include "p9_nimbus_actions.rule";

actionclass analyzePciChipletFir0
{
    capture(PciChipletFir0);
    analyze(gPCI0_CHIPLET_FIR);
};

actionclass analyzePciChipletFir1
{
    capture(PciChipletFir1);
    analyze(gPCI1_CHIPLET_FIR);
};

actionclass analyzePciChipletFir2
{
    capture(PciChipletFir2);
    analyze(gPCI2_CHIPLET_FIR);
};

actionclass aNPU0FIR_NDD10 {capture(cNPU0FIR_NDD10); analyze(gNPU0FIR_NDD10);};
actionclass aNPU1FIR_NDD10 {capture(cNPU1FIR_NDD10); analyze(gNPU1FIR_NDD10);};
actionclass aNPU0FIR       {capture(cNPU0FIR);       analyze(gNPU0FIR);      };
actionclass aNPU1FIR       {capture(cNPU1FIR);       analyze(gNPU1FIR);      };

actionclass analyzeNPU0FIR
{
    try( funccall("checkNimbusDD10"   ), aNPU0FIR_NDD10 );
    try( funccall("checkNotNimbusDD10"), aNPU0FIR       );
};

actionclass analyzeNPU1FIR
{
    try( funccall("checkNimbusDD10"   ), aNPU1FIR_NDD10 );
    try( funccall("checkNotNimbusDD10"), aNPU1FIR       );
};

actionclass analyzeConnectedEQ0     { analyze(connected(TYPE_EQ,      0)); };
actionclass analyzeConnectedEQ1     { analyze(connected(TYPE_EQ,      1)); };
actionclass analyzeConnectedEQ2     { analyze(connected(TYPE_EQ,      2)); };
actionclass analyzeConnectedEQ3     { analyze(connected(TYPE_EQ,      3)); };
actionclass analyzeConnectedEQ4     { analyze(connected(TYPE_EQ,      4)); };
actionclass analyzeConnectedEQ5     { analyze(connected(TYPE_EQ,      5)); };
actionclass analyzeConnectedEC0     { analyze(connected(TYPE_CORE,    0)); };
actionclass analyzeConnectedEC1     { analyze(connected(TYPE_CORE,    1)); };
actionclass analyzeConnectedEC2     { analyze(connected(TYPE_CORE,    2)); };
actionclass analyzeConnectedEC3     { analyze(connected(TYPE_CORE,    3)); };
actionclass analyzeConnectedEC4     { analyze(connected(TYPE_CORE,    4)); };
actionclass analyzeConnectedEC5     { analyze(connected(TYPE_CORE,    5)); };
actionclass analyzeConnectedEC6     { analyze(connected(TYPE_CORE,    6)); };
actionclass analyzeConnectedEC7     { analyze(connected(TYPE_CORE,    7)); };
actionclass analyzeConnectedEC8     { analyze(connected(TYPE_CORE,    8)); };
actionclass analyzeConnectedEC9     { analyze(connected(TYPE_CORE,    9)); };
actionclass analyzeConnectedEC10    { analyze(connected(TYPE_CORE,   10)); };
actionclass analyzeConnectedEC11    { analyze(connected(TYPE_CORE,   11)); };
actionclass analyzeConnectedEC12    { analyze(connected(TYPE_CORE,   12)); };
actionclass analyzeConnectedEC13    { analyze(connected(TYPE_CORE,   13)); };
actionclass analyzeConnectedEC14    { analyze(connected(TYPE_CORE,   14)); };
actionclass analyzeConnectedEC15    { analyze(connected(TYPE_CORE,   15)); };
actionclass analyzeConnectedEC16    { analyze(connected(TYPE_CORE,   16)); };
actionclass analyzeConnectedEC17    { analyze(connected(TYPE_CORE,   17)); };
actionclass analyzeConnectedEC18    { analyze(connected(TYPE_CORE,   18)); };
actionclass analyzeConnectedEC19    { analyze(connected(TYPE_CORE,   19)); };
actionclass analyzeConnectedEC20    { analyze(connected(TYPE_CORE,   20)); };
actionclass analyzeConnectedEC21    { analyze(connected(TYPE_CORE,   21)); };
actionclass analyzeConnectedEC22    { analyze(connected(TYPE_CORE,   22)); };
actionclass analyzeConnectedEC23    { analyze(connected(TYPE_CORE,   23)); };
actionclass analyzeConnectedCAPP0   { analyze(connected(TYPE_CAPP,    0)); };
actionclass analyzeConnectedCAPP1   { analyze(connected(TYPE_CAPP,    1)); };
actionclass analyzeConnectedOBUS0   { analyze(connected(TYPE_OBUS,    0)); };
actionclass analyzeConnectedOBUS3   { analyze(connected(TYPE_OBUS,    3)); };
actionclass analyzeConnectedXBUS1   { analyze(connected(TYPE_XBUS,    1)); };
actionclass analyzeConnectedXBUS2   { analyze(connected(TYPE_XBUS,    2)); };
actionclass analyzeConnectedPEC0    { analyze(connected(TYPE_PEC,     0)); };
actionclass analyzeConnectedPEC1    { analyze(connected(TYPE_PEC,     1)); };
actionclass analyzeConnectedPEC2    { analyze(connected(TYPE_PEC,     2)); };
actionclass analyzeConnectedPHB0    { analyze(connected(TYPE_PHB,     0)); };
actionclass analyzeConnectedPHB1    { analyze(connected(TYPE_PHB,     1)); };
actionclass analyzeConnectedPHB2    { analyze(connected(TYPE_PHB,     2)); };
actionclass analyzeConnectedPHB3    { analyze(connected(TYPE_PHB,     3)); };
actionclass analyzeConnectedPHB4    { analyze(connected(TYPE_PHB,     4)); };
actionclass analyzeConnectedPHB5    { analyze(connected(TYPE_PHB,     5)); };
actionclass analyzeConnectedMCBIST0 { analyze(connected(TYPE_MCBIST,  0)); };
actionclass analyzeConnectedMCBIST1 { analyze(connected(TYPE_MCBIST,  1)); };
actionclass analyzeConnectedMCS0    { analyze(connected(TYPE_MCS,     0)); };
actionclass analyzeConnectedMCS1    { analyze(connected(TYPE_MCS,     1)); };
actionclass analyzeConnectedMCS2    { analyze(connected(TYPE_MCS,     2)); };
actionclass analyzeConnectedMCS3    { analyze(connected(TYPE_MCS,     3)); };
