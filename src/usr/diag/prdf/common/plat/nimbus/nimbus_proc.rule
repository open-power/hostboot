# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/nimbus/nimbus_proc.rule $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2016,2024
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

chip nimbus_proc
{
    name        "NIMBUS PROC target";
    targettype  TYPE_PROC;
    sigoff      0x9000;
    dump        DUMP_CONTENT_HW;
    scomlen     64;

# Import signatures
.include "prdfP9ProcMbCommonExtraSig.H";

 #############################################################################
 #                                                                           #
 #  ######                                                                   #
 #  #     #  ######   ####     ###    ####    #####  ######  #####    ####   #
 #  #     #  #       #    #     #    #          #    #       #    #  #       #
 #  ######   #####   #          #     ####      #    #####   #    #   ####   #
 #  #   #    #       #  ###     #         #     #    #       #####        #  #
 #  #    #   #       #    #     #    #    #     #    #       #   #   #    #  #
 #  #     #  ######   ####     ###    ####      #    ######  #    #   ####   #
 #                                                                           #
 #############################################################################

    ############################################################################
    # Global Attention FIR
    ############################################################################

    register GLOBAL_CS_FIR
    {
        name        "Global Checkstop Attention FIR";
        scomaddr    0x500F001C;
        capture     group default;
    };

    register GLOBAL_RE_FIR
    {
        name        "Global Recoverable Attention FIR";
        scomaddr    0x500F001B;
        capture     group default;
    };

    ############################################################################
    # Global Unit Checkstop FIR
    ############################################################################

    register GLOBAL_UCS_FIR
    {
        name        "Global Unit Checkstop FIR";
        scomaddr    0x50040018;
        capture     req funccall("isUcsFirAccessible");
        capture     group default;
    };

    ############################################################################
    # Global Host Attention FIR
    ############################################################################

    register GLOBAL_HA_FIR
    {
        name        "Global Host Attention FIR";
        scomaddr    0x50040009;
        capture     req funccall("isHostAttnFirAccessible");
        capture     group default;
    };

    ############################################################################
    # TP Chiplet FIR
    ############################################################################

    register TP_CHIPLET_CS_FIR
    {
        name        "TP Chiplet Checkstop FIR";
        scomaddr    0x01040000;
        capture     group default;
    };

    register TP_CHIPLET_RE_FIR
    {
        name        "TP Chiplet Recoverable FIR";
        scomaddr    0x01040001;
        capture     group default;
    };

    register TP_CHIPLET_FIR_MASK
    {
        name        "TP Chiplet FIR MASK";
        scomaddr    0x01040002;
        capture     group default;
    };

    ############################################################################
    # P9 chip TP_LFIR
    ############################################################################

    register TP_LFIR
    {
        name        "P9 chip TP_LFIR";
        scomaddr    0x0104000a;
        reset       (&, 0x0104000b);
        mask        (|, 0x0104000f);
        capture     group default;
    };

    register TP_LFIR_MASK
    {
        name        "P9 chip TP_LFIR MASK";
        scomaddr    0x0104000d;
        capture     group default;
    };

    register TP_LFIR_ACT0
    {
        name        "P9 chip TP_LFIR ACT0";
        scomaddr    0x01040010;
        capture     group default;
        capture     req nonzero("TP_LFIR");
    };

    register TP_LFIR_ACT1
    {
        name        "P9 chip TP_LFIR ACT1";
        scomaddr    0x01040011;
        capture     group default;
        capture     req nonzero("TP_LFIR");
    };

    ############################################################################
    # P9 chip OCCFIR
    ############################################################################

    register OCCFIR
    {
        name        "P9 chip OCCFIR";
        scomaddr    0x01010800;
        reset       (&, 0x01010801);
        mask        (|, 0x01010805);
        capture     group default;
    };

    register OCCFIR_MASK
    {
        name        "P9 chip OCCFIR MASK";
        scomaddr    0x01010803;
        capture     group default;
    };

    register OCCFIR_ACT0
    {
        name        "P9 chip OCCFIR ACT0";
        scomaddr    0x01010806;
        capture     group default;
        capture     req nonzero("OCCFIR");
    };

    register OCCFIR_ACT1
    {
        name        "P9 chip OCCFIR ACT1";
        scomaddr    0x01010807;
        capture     group default;
        capture     req nonzero("OCCFIR");
    };

    ############################################################################
    # N0 Chiplet FIR
    ############################################################################

    register N0_CHIPLET_CS_FIR
    {
        name        "N0 Chiplet Checkstop FIR";
        scomaddr    0x02040000;
        capture     group default;
    };

    register N0_CHIPLET_RE_FIR
    {
        name        "N0 Chiplet Recoverable FIR";
        scomaddr    0x02040001;
        capture     group default;
    };

    register N0_CHIPLET_FIR_MASK
    {
        name        "N0 Chiplet FIR MASK";
        scomaddr    0x02040002;
        capture     group default;
    };

    ############################################################################
    # N0 Chiplet Unit Checkstop FIR
    ############################################################################

    register N0_CHIPLET_UCS_FIR
    {
        name        "N0 Chiplet Unit Checkstop FIR";
        scomaddr    0x02040018;
        capture     group default;
    };

    register N0_CHIPLET_UCS_FIR_MASK
    {
        name        "N0 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x02040019;
        capture     group default;
    };

    ############################################################################
    # P9 chip N0_LFIR
    ############################################################################

    register N0_LFIR
    {
        name        "P9 chip N0_LFIR";
        scomaddr    0x0204000a;
        reset       (&, 0x0204000b);
        mask        (|, 0x0204000f);
        capture     group default;
    };

    register N0_LFIR_MASK
    {
        name        "P9 chip N0_LFIR MASK";
        scomaddr    0x0204000d;
        capture     group default;
    };

    register N0_LFIR_ACT0
    {
        name        "P9 chip N0_LFIR ACT0";
        scomaddr    0x02040010;
        capture     group default;
        capture     req nonzero("N0_LFIR");
    };

    register N0_LFIR_ACT1
    {
        name        "P9 chip N0_LFIR ACT1";
        scomaddr    0x02040011;
        capture     group default;
        capture     req nonzero("N0_LFIR");
    };

    ############################################################################
    # P9 chip NXCQFIR
    ############################################################################

    register NXCQFIR
    {
        name        "P9 chip NXCQFIR";
        scomaddr    0x02011080;
        reset       (&, 0x02011081);
        mask        (|, 0x02011085);
        capture     group default;
    };

    register NXCQFIR_MASK
    {
        name        "P9 chip NXCQFIR MASK";
        scomaddr    0x02011083;
        capture     group default;
    };

    register NXCQFIR_ACT0
    {
        name        "P9 chip NXCQFIR ACT0";
        scomaddr    0x02011086;
        capture     group default;
        capture     req nonzero("NXCQFIR");
    };

    register NXCQFIR_ACT1
    {
        name        "P9 chip NXCQFIR ACT1";
        scomaddr    0x02011087;
        capture     group default;
        capture     req nonzero("NXCQFIR");
    };

    ############################################################################
    # P9 chip NXDMAENGFIR
    ############################################################################

    register NXDMAENGFIR
    {
        name        "P9 chip NXDMAENGFIR";
        scomaddr    0x02011100;
        reset       (&, 0x02011101);
        mask        (|, 0x02011105);
        capture     group default;
    };

    register NXDMAENGFIR_MASK
    {
        name        "P9 chip NXDMAENGFIR MASK";
        scomaddr    0x02011103;
        capture     group default;
    };

    register NXDMAENGFIR_ACT0
    {
        name        "P9 chip NXDMAENGFIR ACT0";
        scomaddr    0x02011106;
        capture     group default;
        capture     req nonzero("NXDMAENGFIR");
    };

    register NXDMAENGFIR_ACT1
    {
        name        "P9 chip NXDMAENGFIR ACT1";
        scomaddr    0x02011107;
        capture     group default;
        capture     req nonzero("NXDMAENGFIR");
    };

    ############################################################################
    # N1 Chiplet FIR
    ############################################################################

    register N1_CHIPLET_CS_FIR
    {
        name        "N1 Chiplet Checkstop FIR";
        scomaddr    0x03040000;
        capture     group default;
    };

    register N1_CHIPLET_RE_FIR
    {
        name        "N1 Chiplet Recoverable FIR";
        scomaddr    0x03040001;
        capture     group default;
    };

    register N1_CHIPLET_FIR_MASK
    {
        name        "N1 Chiplet FIR MASK";
        scomaddr    0x03040002;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Unit Checkstop FIR
    ############################################################################

    register N1_CHIPLET_UCS_FIR
    {
        name        "N1 Chiplet Unit Checkstop FIR";
        scomaddr    0x03040018;
        capture     group default;
    };

    register N1_CHIPLET_UCS_FIR_MASK
    {
        name        "N1 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x03040019;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Host Attention FIR
    ############################################################################

    register N1_CHIPLET_HA_FIR
    {
        name        "N1 Chiplet Host Attention FIR";
        scomaddr    0x03040009;
        capture     group default;
    };

    register N1_CHIPLET_HA_FIR_MASK
    {
        name        "N1 Chiplet Host Attention FIR MASK";
        scomaddr    0x0304001a;
        capture     group default;
    };

    ############################################################################
    # P9 chip N1_LFIR
    ############################################################################

    register N1_LFIR
    {
        name        "P9 chip N1_LFIR";
        scomaddr    0x0304000a;
        reset       (&, 0x0304000b);
        mask        (|, 0x0304000f);
        capture     group default;
    };

    register N1_LFIR_MASK
    {
        name        "P9 chip N1_LFIR MASK";
        scomaddr    0x0304000d;
        capture     group default;
    };

    register N1_LFIR_ACT0
    {
        name        "P9 chip N1_LFIR ACT0";
        scomaddr    0x03040010;
        capture     group default;
        capture     req nonzero("N1_LFIR");
    };

    register N1_LFIR_ACT1
    {
        name        "P9 chip N1_LFIR ACT1";
        scomaddr    0x03040011;
        capture     group default;
        capture     req nonzero("N1_LFIR");
    };

    ############################################################################
    # P9 chip MCDFIR 0
    ############################################################################

    register MCDFIR_0
    {
        name        "P9 chip MCDFIR 0";
        scomaddr    0x03011000;
        reset       (&, 0x03011001);
        mask        (|, 0x03011005);
        capture     group default;
    };

    register MCDFIR_0_MASK
    {
        name        "P9 chip MCDFIR 0 MASK";
        scomaddr    0x03011003;
        capture     group default;
    };

    register MCDFIR_0_ACT0
    {
        name        "P9 chip MCDFIR 0 ACT0";
        scomaddr    0x03011006;
        capture     group default;
        capture     req nonzero("MCDFIR_0");
    };

    register MCDFIR_0_ACT1
    {
        name        "P9 chip MCDFIR 0 ACT1";
        scomaddr    0x03011007;
        capture     group default;
        capture     req nonzero("MCDFIR_0");
    };

    ############################################################################
    # P9 chip MCDFIR 1
    ############################################################################

    register MCDFIR_1
    {
        name        "P9 chip MCDFIR 1";
        scomaddr    0x03011400;
        reset       (&, 0x03011401);
        mask        (|, 0x03011405);
        capture     group default;
    };

    register MCDFIR_1_MASK
    {
        name        "P9 chip MCDFIR 1 MASK";
        scomaddr    0x03011403;
        capture     group default;
    };

    register MCDFIR_1_ACT0
    {
        name        "P9 chip MCDFIR 1 ACT0";
        scomaddr    0x03011406;
        capture     group default;
        capture     req nonzero("MCDFIR_1");
    };

    register MCDFIR_1_ACT1
    {
        name        "P9 chip MCDFIR 1 ACT1";
        scomaddr    0x03011407;
        capture     group default;
        capture     req nonzero("MCDFIR_1");
    };

    ############################################################################
    # P9 chip VASFIR
    ############################################################################

    register VASFIR
    {
        name        "P9 chip VASFIR";
        scomaddr    0x03011800;
        reset       (&, 0x03011801);
        mask        (|, 0x03011805);
        capture     group default;
    };

    register VASFIR_MASK
    {
        name        "P9 chip VASFIR MASK";
        scomaddr    0x03011803;
        capture     group default;
    };

    register VASFIR_ACT0
    {
        name        "P9 chip VASFIR ACT0";
        scomaddr    0x03011806;
        capture     group default;
        capture     req nonzero("VASFIR");
    };

    register VASFIR_ACT1
    {
        name        "P9 chip VASFIR ACT1";
        scomaddr    0x03011807;
        capture     group default;
        capture     req nonzero("VASFIR");
    };

    ############################################################################
    # N2 Chiplet FIR
    ############################################################################

    register N2_CHIPLET_CS_FIR
    {
        name        "N2 Chiplet Checkstop FIR";
        scomaddr    0x04040000;
        capture     group default;
    };

    register N2_CHIPLET_RE_FIR
    {
        name        "N2 Chiplet Recoverable FIR";
        scomaddr    0x04040001;
        capture     group default;
    };

    register N2_CHIPLET_FIR_MASK
    {
        name        "N2 Chiplet FIR MASK";
        scomaddr    0x04040002;
        capture     group default;
    };

    ############################################################################
    # N2 Chiplet Unit Checkstop FIR
    ############################################################################

    register N2_CHIPLET_UCS_FIR
    {
        name        "N2 Chiplet Unit Checkstop FIR";
        scomaddr    0x04040018;
        capture     group default;
    };

    register N2_CHIPLET_UCS_FIR_MASK
    {
        name        "N2 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x04040019;
        capture     group default;
    };

    ############################################################################
    # P9 chip N2_LFIR
    ############################################################################

    register N2_LFIR
    {
        name        "P9 chip N2_LFIR";
        scomaddr    0x0404000a;
        reset       (&, 0x0404000b);
        mask        (|, 0x0404000f);
        capture     group default;
    };

    register N2_LFIR_MASK
    {
        name        "P9 chip N2_LFIR MASK";
        scomaddr    0x0404000d;
        capture     group default;
    };

    register N2_LFIR_ACT0
    {
        name        "P9 chip N2_LFIR ACT0";
        scomaddr    0x04040010;
        capture     group default;
        capture     req nonzero("N2_LFIR");
    };

    register N2_LFIR_ACT1
    {
        name        "P9 chip N2_LFIR ACT1";
        scomaddr    0x04040011;
        capture     group default;
        capture     req nonzero("N2_LFIR");
    };

    ############################################################################
    # P9 chip PSIFIR
    ############################################################################

    register PSIFIR
    {
        name        "P9 chip PSIFIR";
        scomaddr    0x04011800;
        reset       (&, 0x04011801);
        mask        (|, 0x04011805);
        capture     group default;
    };

    register PSIFIR_MASK
    {
        name        "P9 chip PSIFIR MASK";
        scomaddr    0x04011803;
        capture     group default;
    };

    register PSIFIR_ACT0
    {
        name        "P9 chip PSIFIR ACT0";
        scomaddr    0x04011806;
        capture     group default;
        capture     req nonzero("PSIFIR");
    };

    register PSIFIR_ACT1
    {
        name        "P9 chip PSIFIR ACT1";
        scomaddr    0x04011807;
        capture     group default;
        capture     req nonzero("PSIFIR");
    };

    ############################################################################
    # N3 Chiplet FIR
    ############################################################################

    register N3_CHIPLET_CS_FIR
    {
        name        "N3 Chiplet Checkstop FIR";
        scomaddr    0x05040000;
        capture     group default;
    };

    register N3_CHIPLET_RE_FIR
    {
        name        "N3 Chiplet Recoverable FIR";
        scomaddr    0x05040001;
        capture     group default;
    };

    register N3_CHIPLET_FIR_MASK
    {
        name        "N3 Chiplet FIR MASK";
        scomaddr    0x05040002;
        capture     group default;
    };

    ############################################################################
    # N3 Chiplet Unit Checkstop FIR
    ############################################################################

    register N3_CHIPLET_UCS_FIR
    {
        name        "N3 Chiplet Unit Checkstop FIR";
        scomaddr    0x05040018;
        capture     group default;
    };

    register N3_CHIPLET_UCS_FIR_MASK
    {
        name        "N3 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x05040019;
        capture     group default;
    };

    ############################################################################
    # N3 Chiplet Host Attention FIR
    ############################################################################

    register N3_CHIPLET_HA_FIR
    {
        name        "N3 Chiplet Host Attention FIR";
        scomaddr    0x05040009;
        capture     group default;
    };

    register N3_CHIPLET_HA_FIR_MASK
    {
        name        "N3 Chiplet Host Attention FIR MASK";
        scomaddr    0x0504001a;
        capture     group default;
    };

    ############################################################################
    # P9 chip N3_LFIR
    ############################################################################

    register N3_LFIR
    {
        name        "P9 chip N3_LFIR";
        scomaddr    0x0504000a;
        reset       (&, 0x0504000b);
        mask        (|, 0x0504000f);
        capture     group default;
    };

    register N3_LFIR_MASK
    {
        name        "P9 chip N3_LFIR MASK";
        scomaddr    0x0504000d;
        capture     group default;
    };

    register N3_LFIR_ACT0
    {
        name        "P9 chip N3_LFIR ACT0";
        scomaddr    0x05040010;
        capture     group default;
        capture     req nonzero("N3_LFIR");
    };

    register N3_LFIR_ACT1
    {
        name        "P9 chip N3_LFIR ACT1";
        scomaddr    0x05040011;
        capture     group default;
        capture     req nonzero("N3_LFIR");
    };

    ############################################################################
    # P9 chip PBWESTFIR
    ############################################################################

    register PBWESTFIR
    {
        name        "P9 chip PBWESTFIR";
        scomaddr    0x05011800;
        reset       (&, 0x05011801);
        mask        (|, 0x05011805);
        capture     group default;
    };

    register PBWESTFIR_MASK
    {
        name        "P9 chip PBWESTFIR MASK";
        scomaddr    0x05011803;
        capture     group default;
    };

    register PBWESTFIR_ACT0
    {
        name        "P9 chip PBWESTFIR ACT0";
        scomaddr    0x05011806;
        capture     group default;
        capture     req nonzero("PBWESTFIR");
    };

    register PBWESTFIR_ACT1
    {
        name        "P9 chip PBWESTFIR ACT1";
        scomaddr    0x05011807;
        capture     group default;
        capture     req nonzero("PBWESTFIR");
    };

    ############################################################################
    # P9 chip PBCENTFIR
    ############################################################################

    register PBCENTFIR
    {
        name        "P9 chip PBCENTFIR";
        scomaddr    0x05011c00;
        reset       (&, 0x05011c01);
        mask        (|, 0x05011c05);
        capture     group default;
    };

    register PBCENTFIR_MASK
    {
        name        "P9 chip PBCENTFIR MASK";
        scomaddr    0x05011c03;
        capture     group default;
    };

    register PBCENTFIR_ACT0
    {
        name        "P9 chip PBCENTFIR ACT0";
        scomaddr    0x05011c06;
        capture     group default;
        capture     req nonzero("PBCENTFIR");
    };

    register PBCENTFIR_ACT1
    {
        name        "P9 chip PBCENTFIR ACT1";
        scomaddr    0x05011c07;
        capture     group default;
        capture     req nonzero("PBCENTFIR");
    };

    ############################################################################
    # P9 chip PBEASTFIR
    ############################################################################

    register PBEASTFIR
    {
        name        "P9 chip PBEASTFIR";
        scomaddr    0x05012000;
        reset       (&, 0x05012001);
        mask        (|, 0x05012005);
        capture     group default;
    };

    register PBEASTFIR_MASK
    {
        name        "P9 chip PBEASTFIR MASK";
        scomaddr    0x05012003;
        capture     group default;
    };

    register PBEASTFIR_ACT0
    {
        name        "P9 chip PBEASTFIR ACT0";
        scomaddr    0x05012006;
        capture     group default;
        capture     req nonzero("PBEASTFIR");
    };

    register PBEASTFIR_ACT1
    {
        name        "P9 chip PBEASTFIR ACT1";
        scomaddr    0x05012007;
        capture     group default;
        capture     req nonzero("PBEASTFIR");
    };

    ############################################################################
    # P9 chip PBPPEFIR
    ############################################################################

    register PBPPEFIR
    {
        name        "P9 chip PBPPEFIR";
        scomaddr    0x05012400;
        reset       (&, 0x05012401);
        mask        (|, 0x05012405);
        capture     group default;
    };

    register PBPPEFIR_MASK
    {
        name        "P9 chip PBPPEFIR MASK";
        scomaddr    0x05012403;
        capture     group default;
    };

    register PBPPEFIR_ACT0
    {
        name        "P9 chip PBPPEFIR ACT0";
        scomaddr    0x05012406;
        capture     group default;
        capture     req nonzero("PBPPEFIR");
    };

    register PBPPEFIR_ACT1
    {
        name        "P9 chip PBPPEFIR ACT1";
        scomaddr    0x05012407;
        capture     group default;
        capture     req nonzero("PBPPEFIR");
    };

    ############################################################################
    # P9 chip PBAFIR
    ############################################################################

    register PBAFIR
    {
        name        "P9 chip PBAFIR";
        scomaddr    0x05012840;
        reset       (&, 0x05012841);
        mask        (|, 0x05012845);
        capture     group default;
    };

    register PBAFIR_MASK
    {
        name        "P9 chip PBAFIR MASK";
        scomaddr    0x05012843;
        capture     group default;
    };

    register PBAFIR_ACT0
    {
        name        "P9 chip PBAFIR ACT0";
        scomaddr    0x05012846;
        capture     group default;
        capture     req nonzero("PBAFIR");
    };

    register PBAFIR_ACT1
    {
        name        "P9 chip PBAFIR ACT1";
        scomaddr    0x05012847;
        capture     group default;
        capture     req nonzero("PBAFIR");
    };

    ############################################################################
    # P9 chip PSIHBFIR
    ############################################################################

    register PSIHBFIR
    {
        name        "P9 chip PSIHBFIR";
        scomaddr    0x05012900;
        reset       (&, 0x05012901);
        mask        (|, 0x05012905);
        capture     group default;
    };

    register PSIHBFIR_MASK
    {
        name        "P9 chip PSIHBFIR MASK";
        scomaddr    0x05012903;
        capture     group default;
    };

    register PSIHBFIR_ACT0
    {
        name        "P9 chip PSIHBFIR ACT0";
        scomaddr    0x05012906;
        capture     group default;
        capture     req nonzero("PSIHBFIR");
    };

    register PSIHBFIR_ACT1
    {
        name        "P9 chip PSIHBFIR ACT1";
        scomaddr    0x05012907;
        capture     group default;
        capture     req nonzero("PSIHBFIR");
    };

    ############################################################################
    # P9 chip ENHCAFIR
    ############################################################################

    register ENHCAFIR
    {
        name        "P9 chip ENHCAFIR";
        scomaddr    0x05012940;
        reset       (&, 0x05012941);
        mask        (|, 0x05012945);
        capture     group default;
    };

    register ENHCAFIR_MASK
    {
        name        "P9 chip ENHCAFIR MASK";
        scomaddr    0x05012943;
        capture     group default;
    };

    register ENHCAFIR_ACT0
    {
        name        "P9 chip ENHCAFIR ACT0";
        scomaddr    0x05012946;
        capture     group default;
        capture     req nonzero("ENHCAFIR");
    };

    register ENHCAFIR_ACT1
    {
        name        "P9 chip ENHCAFIR ACT1";
        scomaddr    0x05012947;
        capture     group default;
        capture     req nonzero("ENHCAFIR");
    };

    ############################################################################
    # P9 chip PBAMFIR
    ############################################################################

    register PBAMFIR
    {
        name        "P9 chip PBAMFIR";
        scomaddr    0x050129c0;
        reset       (&, 0x050129c1);
        mask        (|, 0x050129c5);
        capture     group default;
    };

    register PBAMFIR_MASK
    {
        name        "P9 chip PBAMFIR MASK";
        scomaddr    0x050129c3;
        capture     group default;
    };

    register PBAMFIR_ACT0
    {
        name        "P9 chip PBAMFIR ACT0";
        scomaddr    0x050129c6;
        capture     group default;
        capture     req nonzero("PBAMFIR");
    };

    register PBAMFIR_ACT1
    {
        name        "P9 chip PBAMFIR ACT1";
        scomaddr    0x050129c7;
        capture     group default;
        capture     req nonzero("PBAMFIR");
    };

    ############################################################################
    # P9 chip NMMUCQFIR
    ############################################################################

    register NMMUCQFIR
    {
        name        "P9 chip NMMUCQFIR";
        scomaddr    0x05012c00;
        reset       (&, 0x05012c01);
        mask        (|, 0x05012c05);
        capture     group default;
    };

    register NMMUCQFIR_MASK
    {
        name        "P9 chip NMMUCQFIR MASK";
        scomaddr    0x05012c03;
        capture     group default;
    };

    register NMMUCQFIR_ACT0
    {
        name        "P9 chip NMMUCQFIR ACT0";
        scomaddr    0x05012c06;
        capture     group default;
        capture     req nonzero("NMMUCQFIR");
    };

    register NMMUCQFIR_ACT1
    {
        name        "P9 chip NMMUCQFIR ACT1";
        scomaddr    0x05012c07;
        capture     group default;
        capture     req nonzero("NMMUCQFIR");
    };

    ############################################################################
    # P9 chip NMMUFIR
    ############################################################################

    register NMMUFIR
    {
        name        "P9 chip NMMUFIR";
        scomaddr    0x05012c40;
        reset       (&, 0x05012c41);
        mask        (|, 0x05012c45);
        capture     group default;
    };

    register NMMUFIR_MASK
    {
        name        "P9 chip NMMUFIR MASK";
        scomaddr    0x05012c43;
        capture     group default;
    };

    register NMMUFIR_ACT0
    {
        name        "P9 chip NMMUFIR ACT0";
        scomaddr    0x05012c46;
        capture     group default;
        capture     req nonzero("NMMUFIR");
    };

    register NMMUFIR_ACT1
    {
        name        "P9 chip NMMUFIR ACT1";
        scomaddr    0x05012c47;
        capture     group default;
        capture     req nonzero("NMMUFIR");
    };

    ############################################################################
    # P9 chip INTCQFIR
    ############################################################################

    register INTCQFIR
    {
        name        "P9 chip INTCQFIR";
        scomaddr    0x05013030;
        reset       (&, 0x05013031);
        mask        (|, 0x05013035);
        capture     group default;
    };

    register INTCQFIR_MASK
    {
        name        "P9 chip INTCQFIR MASK";
        scomaddr    0x05013033;
        capture     group default;
    };

    register INTCQFIR_ACT0
    {
        name        "P9 chip INTCQFIR ACT0";
        scomaddr    0x05013036;
        capture     group default;
        capture     req nonzero("INTCQFIR");
    };

    register INTCQFIR_ACT1
    {
        name        "P9 chip INTCQFIR ACT1";
        scomaddr    0x05013037;
        capture     group default;
        capture     req nonzero("INTCQFIR");
    };

    ############################################################################
    # P9 chip PBIOEFIR
    ############################################################################

    register PBIOEFIR
    {
        name        "P9 chip PBIOEFIR";
        scomaddr    0x05013400;
        reset       (&, 0x05013401);
        mask        (|, 0x05013405);
        capture     group default;
    };

    register PBIOEFIR_MASK
    {
        name        "P9 chip PBIOEFIR MASK";
        scomaddr    0x05013403;
        capture     group default;
    };

    register PBIOEFIR_ACT0
    {
        name        "P9 chip PBIOEFIR ACT0";
        scomaddr    0x05013406;
        capture     group default;
        capture     req nonzero("PBIOEFIR");
    };

    register PBIOEFIR_ACT1
    {
        name        "P9 chip PBIOEFIR ACT1";
        scomaddr    0x05013407;
        capture     group default;
        capture     req nonzero("PBIOEFIR");
    };

    ############################################################################
    # P9 chip PBIOOFIR
    ############################################################################

    register PBIOOFIR
    {
        name        "P9 chip PBIOOFIR";
        scomaddr    0x05013800;
        reset       (&, 0x05013801);
        mask        (|, 0x05013805);
        capture     group default;
    };

    register PBIOOFIR_MASK
    {
        name        "P9 chip PBIOOFIR MASK";
        scomaddr    0x05013803;
        capture     group default;
    };

    register PBIOOFIR_ACT0
    {
        name        "P9 chip PBIOOFIR ACT0";
        scomaddr    0x05013806;
        capture     group default;
        capture     req nonzero("PBIOOFIR");
    };

    register PBIOOFIR_ACT1
    {
        name        "P9 chip PBIOOFIR ACT1";
        scomaddr    0x05013807;
        capture     group default;
        capture     req nonzero("PBIOOFIR");
    };

    ############################################################################
    # P9 chip NPU0FIR
    ############################################################################

    register NPU0FIR
    {
        name        "P9 chip NPU0FIR";
        scomaddr    0x05013C00;
        reset       (&, 0x05013C01);
        mask        (|, 0x05013C05);
        capture     group npu0fir_ffdc;
    };

    register NPU0FIR_MASK
    {
        name        "P9 chip NPU0FIR MASK";
        scomaddr    0x05013C03;
        capture     group npu0fir_ffdc;
    };

    register NPU0FIR_ACT0
    {
        name        "P9 chip NPU0FIR ACT0";
        scomaddr    0x05013C06;
        capture     group npu0fir_ffdc;
        capture     req nonzero("NPU0FIR");
    };

    register NPU0FIR_ACT1
    {
        name        "P9 chip NPU0FIR ACT1";
        scomaddr    0x05013C07;
        capture     group npu0fir_ffdc;
        capture     req nonzero("NPU0FIR");
    };

    ############################################################################
    # P9 chip NPU1FIR
    ############################################################################

    register NPU1FIR
    {
        name        "P9 chip NPU1FIR";
        scomaddr    0x05013C40;
        reset       (&, 0x05013C41);
        mask        (|, 0x05013C45);
        capture     group npu1fir_ffdc;
    };

    register NPU1FIR_MASK
    {
        name        "P9 chip NPU1FIR MASK";
        scomaddr    0x05013C43;
        capture     group npu1fir_ffdc;
    };

    register NPU1FIR_ACT0
    {
        name        "P9 chip NPU1FIR ACT0";
        scomaddr    0x05013C46;
        capture     group npu1fir_ffdc;
        capture     req nonzero("NPU1FIR");
    };

    register NPU1FIR_ACT1
    {
        name        "P9 chip NPU1FIR ACT1";
        scomaddr    0x05013C47;
        capture     group npu1fir_ffdc;
        capture     req nonzero("NPU1FIR");
    };

    ############################################################################
    # P9 chip NPU2FIR
    ############################################################################

    register NPU2FIR
    {
        name        "P9 chip NPU2FIR";
        scomaddr    0x05013C80;
        reset       (&, 0x05013C81);
        mask        (|, 0x05013C85);
        capture     group npu2fir_ffdc;
    };

    register NPU2FIR_MASK
    {
        name        "P9 chip NPU2FIR MASK";
        scomaddr    0x05013C83;
        capture     group npu2fir_ffdc;
    };

    register NPU2FIR_ACT0
    {
        name        "P9 chip NPU2FIR ACT0";
        scomaddr    0x05013C86;
        capture     group npu2fir_ffdc;
        capture     req nonzero("NPU2FIR");
    };

    register NPU2FIR_ACT1
    {
        name        "P9 chip NPU2FIR ACT1";
        scomaddr    0x05013C87;
        capture     group npu2fir_ffdc;
        capture     req nonzero("NPU2FIR");
    };

    ############################################################################
    # XB Chiplet FIR
    ############################################################################

    register XB_CHIPLET_CS_FIR
    {
        name        "XB Chiplet Checkstop FIR";
        scomaddr    0x06040000;
        capture     group default;
    };

    register XB_CHIPLET_RE_FIR
    {
        name        "XB Chiplet Recoverable FIR";
        scomaddr    0x06040001;
        capture     group default;
    };

    register XB_CHIPLET_FIR_MASK
    {
        name        "XB Chiplet FIR MASK";
        scomaddr    0x06040002;
        capture     group default;
    };

    ############################################################################
    # XB Chiplet Unit Checkstop FIR
    ############################################################################

    register XB_CHIPLET_UCS_FIR
    {
        name        "XB Chiplet Unit Checkstop FIR";
        scomaddr    0x06040018;
        capture     group default;
    };

    register XB_CHIPLET_UCS_FIR_MASK
    {
        name        "XB Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x06040019;
        capture     group default;
    };

    ############################################################################
    # P9 chip XB_LFIR
    ############################################################################

    register XB_LFIR
    {
        name        "P9 chip XB_LFIR";
        scomaddr    0x0604000a;
        reset       (&, 0x0604000b);
        mask        (|, 0x0604000f);
        capture     group default;
    };

    register XB_LFIR_MASK
    {
        name        "P9 chip XB_LFIR MASK";
        scomaddr    0x0604000d;
        capture     group default;
    };

    register XB_LFIR_ACT0
    {
        name        "P9 chip XB_LFIR ACT0";
        scomaddr    0x06040010;
        capture     group default;
        capture     req nonzero("XB_LFIR");
    };

    register XB_LFIR_ACT1
    {
        name        "P9 chip XB_LFIR ACT1";
        scomaddr    0x06040011;
        capture     group default;
        capture     req nonzero("XB_LFIR");
    };

    ############################################################################
    # P9 chip XBPPEFIR
    ############################################################################

    register XBPPEFIR
    {
        name        "P9 chip XBPPEFIR";
        scomaddr    0x06010840;
        reset       (&, 0x06010841);
        mask        (|, 0x06010845);
        capture     group default;
    };

    register XBPPEFIR_MASK
    {
        name        "P9 chip XBPPEFIR MASK";
        scomaddr    0x06010843;
        capture     group default;
    };

    register XBPPEFIR_ACT0
    {
        name        "P9 chip XBPPEFIR ACT0";
        scomaddr    0x06010846;
        capture     group default;
        capture     req nonzero("XBPPEFIR");
    };

    register XBPPEFIR_ACT1
    {
        name        "P9 chip XBPPEFIR ACT1";
        scomaddr    0x06010847;
        capture     group default;
        capture     req nonzero("XBPPEFIR");
    };

    ############################################################################
    # PCI0 Chiplet FIR
    ############################################################################

    register PCI0_CHIPLET_CS_FIR
    {
        name        "PCI0 Chiplet Checkstop FIR";
        scomaddr    0x0d040000;
        capture     group PciChipletFir0;
    };

    register PCI0_CHIPLET_RE_FIR
    {
        name        "PCI0 Chiplet Recoverable FIR";
        scomaddr    0x0d040001;
        capture     group PciChipletFir0;
    };

    register PCI0_CHIPLET_FIR_MASK
    {
        name        "PCI0 Chiplet FIR MASK";
        scomaddr    0x0d040002;
        capture     group PciChipletFir0;
    };

    ############################################################################
    # PCI1 Chiplet FIR
    ############################################################################

    register PCI1_CHIPLET_CS_FIR
    {
        name        "PCI1 Chiplet Checkstop FIR";
        scomaddr    0x0e040000;
        capture     group PciChipletFir1;
    };

    register PCI1_CHIPLET_RE_FIR
    {
        name        "PCI1 Chiplet Recoverable FIR";
        scomaddr    0x0e040001;
        capture     group PciChipletFir1;
    };

    register PCI1_CHIPLET_FIR_MASK
    {
        name        "PCI1 Chiplet FIR MASK";
        scomaddr    0x0e040002;
        capture     group PciChipletFir1;
    };

    ############################################################################
    # PCI2 Chiplet FIR
    ############################################################################

    register PCI2_CHIPLET_CS_FIR
    {
        name        "PCI2 Chiplet Checkstop FIR";
        scomaddr    0x0f040000;
        capture     group PciChipletFir2;
    };

    register PCI2_CHIPLET_RE_FIR
    {
        name        "PCI2 Chiplet Recoverable FIR";
        scomaddr    0x0f040001;
        capture     group PciChipletFir2;
    };

    register PCI2_CHIPLET_FIR_MASK
    {
        name        "PCI2 Chiplet FIR MASK";
        scomaddr    0x0f040002;
        capture     group PciChipletFir2;
    };

# Include registers not defined by the xml
.include "p9_common_proc_regs.rule";
.include "p9_common_npu_regs.rule";

};

 ##############################################################################
 #                                                                            #
 # ####                                 #                                     #
 # #   # #   # #    #####  ###      #  # #    ##  ##### ###  ###  #   #  ###  #
 # #   # #   # #    #     #        #  #   #  #  #   #    #  #   # ##  # #     #
 # ####  #   # #    ####   ###    #  ####### #      #    #  #   # # # #  ###  #
 # #  #  #   # #    #         #  #   #     # #  #   #    #  #   # #  ##     # #
 # #   #  ###  #### #####  ###  #    #     #  ##    #   ###  ###  #   #  ###  #
 #                                                                            #
 ##############################################################################

################################################################################
# Global Attention FIR
################################################################################

rule rGLOBAL_FIR
{
  CHECK_STOP:
    GLOBAL_CS_FIR;
  RECOVERABLE:
    GLOBAL_RE_FIR;
};

group gGLOBAL_FIR attntype CHECK_STOP, RECOVERABLE
    filter singlebit
{
    /** GLOBAL_FIR[1]
     *  Attention from TP chiplet
     */
    (rGLOBAL_FIR, bit(1)) ? analyze(gTP_CHIPLET_FIR);

    /** GLOBAL_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_FIR, bit(2)) ? analyze(gN0_CHIPLET_FIR);

    /** GLOBAL_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_FIR, bit(3)) ? analyze(gN1_CHIPLET_FIR);

    /** GLOBAL_FIR[4]
     *  Attention from N2 chiplet
     */
    (rGLOBAL_FIR, bit(4)) ? analyze(gN2_CHIPLET_FIR);

    /** GLOBAL_FIR[5]
     *  Attention from N3 chiplet
     */
    (rGLOBAL_FIR, bit(5)) ? analyze(gN3_CHIPLET_FIR);

    /** GLOBAL_FIR[6]
     *  Attention from XB chiplet
     */
    (rGLOBAL_FIR, bit(6)) ? analyze(gXB_CHIPLET_FIR);

    /** GLOBAL_FIR[7]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_FIR, bit(7)) ? analyzeConnectedMCBIST0;

    /** GLOBAL_FIR[8]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_FIR, bit(8)) ? analyzeConnectedMCBIST1;

    /** GLOBAL_FIR[9]
     *  Attention from OB 0 chiplet
     */
    (rGLOBAL_FIR, bit(9)) ? analyzeConnectedOBUS0;

    /** GLOBAL_FIR[12]
     *  Attention from OB 3 chiplet
     */
    (rGLOBAL_FIR, bit(12)) ? analyzeConnectedOBUS3;

    /** GLOBAL_FIR[13]
     *  Attention from PCI0 chiplet
     */
    (rGLOBAL_FIR, bit(13)) ? analyzePciChipletFir0;

    /** GLOBAL_FIR[14]
     *  Attention from PCI1 chiplet
     */
    (rGLOBAL_FIR, bit(14)) ? analyzePciChipletFir1;

    /** GLOBAL_FIR[15]
     *  Attention from PCI2 chiplet
     */
    (rGLOBAL_FIR, bit(15)) ? analyzePciChipletFir2;

    /** GLOBAL_FIR[16]
     *  Attention from EQ 0 chiplet
     */
    (rGLOBAL_FIR, bit(16)) ? analyzeConnectedEQ0;

    /** GLOBAL_FIR[17]
     *  Attention from EQ 1 chiplet
     */
    (rGLOBAL_FIR, bit(17)) ? analyzeConnectedEQ1;

    /** GLOBAL_FIR[18]
     *  Attention from EQ 2 chiplet
     */
    (rGLOBAL_FIR, bit(18)) ? analyzeConnectedEQ2;

    /** GLOBAL_FIR[19]
     *  Attention from EQ 3 chiplet
     */
    (rGLOBAL_FIR, bit(19)) ? analyzeConnectedEQ3;

    /** GLOBAL_FIR[20]
     *  Attention from EQ 4 chiplet
     */
    (rGLOBAL_FIR, bit(20)) ? analyzeConnectedEQ4;

    /** GLOBAL_FIR[21]
     *  Attention from EQ 5 chiplet
     */
    (rGLOBAL_FIR, bit(21)) ? analyzeConnectedEQ5;

    /** GLOBAL_FIR[32]
     *  Attention from EC 0 chiplet
     */
    (rGLOBAL_FIR, bit(32)) ? analyzeConnectedEC0;

    /** GLOBAL_FIR[33]
     *  Attention from EC 1 chiplet
     */
    (rGLOBAL_FIR, bit(33)) ? analyzeConnectedEC1;

    /** GLOBAL_FIR[34]
     *  Attention from EC 2 chiplet
     */
    (rGLOBAL_FIR, bit(34)) ? analyzeConnectedEC2;

    /** GLOBAL_FIR[35]
     *  Attention from EC 3 chiplet
     */
    (rGLOBAL_FIR, bit(35)) ? analyzeConnectedEC3;

    /** GLOBAL_FIR[36]
     *  Attention from EC 4 chiplet
     */
    (rGLOBAL_FIR, bit(36)) ? analyzeConnectedEC4;

    /** GLOBAL_FIR[37]
     *  Attention from EC 5 chiplet
     */
    (rGLOBAL_FIR, bit(37)) ? analyzeConnectedEC5;

    /** GLOBAL_FIR[38]
     *  Attention from EC 6 chiplet
     */
    (rGLOBAL_FIR, bit(38)) ? analyzeConnectedEC6;

    /** GLOBAL_FIR[39]
     *  Attention from EC 7 chiplet
     */
    (rGLOBAL_FIR, bit(39)) ? analyzeConnectedEC7;

    /** GLOBAL_FIR[40]
     *  Attention from EC 8 chiplet
     */
    (rGLOBAL_FIR, bit(40)) ? analyzeConnectedEC8;

    /** GLOBAL_FIR[41]
     *  Attention from EC 9 chiplet
     */
    (rGLOBAL_FIR, bit(41)) ? analyzeConnectedEC9;

    /** GLOBAL_FIR[42]
     *  Attention from EC 10 chiplet
     */
    (rGLOBAL_FIR, bit(42)) ? analyzeConnectedEC10;

    /** GLOBAL_FIR[43]
     *  Attention from EC 11 chiplet
     */
    (rGLOBAL_FIR, bit(43)) ? analyzeConnectedEC11;

    /** GLOBAL_FIR[44]
     *  Attention from EC 12 chiplet
     */
    (rGLOBAL_FIR, bit(44)) ? analyzeConnectedEC12;

    /** GLOBAL_FIR[45]
     *  Attention from EC 13 chiplet
     */
    (rGLOBAL_FIR, bit(45)) ? analyzeConnectedEC13;

    /** GLOBAL_FIR[46]
     *  Attention from EC 14 chiplet
     */
    (rGLOBAL_FIR, bit(46)) ? analyzeConnectedEC14;

    /** GLOBAL_FIR[47]
     *  Attention from EC 15 chiplet
     */
    (rGLOBAL_FIR, bit(47)) ? analyzeConnectedEC15;

    /** GLOBAL_FIR[48]
     *  Attention from EC 16 chiplet
     */
    (rGLOBAL_FIR, bit(48)) ? analyzeConnectedEC16;

    /** GLOBAL_FIR[49]
     *  Attention from EC 17 chiplet
     */
    (rGLOBAL_FIR, bit(49)) ? analyzeConnectedEC17;

    /** GLOBAL_FIR[50]
     *  Attention from EC 18 chiplet
     */
    (rGLOBAL_FIR, bit(50)) ? analyzeConnectedEC18;

    /** GLOBAL_FIR[51]
     *  Attention from EC 19 chiplet
     */
    (rGLOBAL_FIR, bit(51)) ? analyzeConnectedEC19;

    /** GLOBAL_FIR[52]
     *  Attention from EC 20 chiplet
     */
    (rGLOBAL_FIR, bit(52)) ? analyzeConnectedEC20;

    /** GLOBAL_FIR[53]
     *  Attention from EC 21 chiplet
     */
    (rGLOBAL_FIR, bit(53)) ? analyzeConnectedEC21;

    /** GLOBAL_FIR[54]
     *  Attention from EC 22 chiplet
     */
    (rGLOBAL_FIR, bit(54)) ? analyzeConnectedEC22;

    /** GLOBAL_FIR[55]
     *  Attention from EC 23 chiplet
     */
    (rGLOBAL_FIR, bit(55)) ? analyzeConnectedEC23;

};

################################################################################
# Global Unit Checkstop FIR
################################################################################

rule rGLOBAL_UCS_FIR
{
  UNIT_CS:
    GLOBAL_UCS_FIR;
};

group gGLOBAL_UCS_FIR attntype UNIT_CS
    filter singlebit
{
    /** GLOBAL_UCS_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(2)) ? analyze(gN0_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(3)) ? analyze(gN1_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[4]
     *  Attention from N2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(4)) ? analyze(gN2_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[5]
     *  Attention from N3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(5)) ? analyze(gN3_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[6]
     *  Attention from XB chiplet
     */
    (rGLOBAL_UCS_FIR, bit(6)) ? analyze(gXB_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[7]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(7)) ? analyzeConnectedMCBIST0;

    /** GLOBAL_UCS_FIR[8]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(8)) ? analyzeConnectedMCBIST1;

    /** GLOBAL_UCS_FIR[9]
     *  Attention from OB 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(9)) ? analyzeConnectedOBUS0;

    /** GLOBAL_UCS_FIR[12]
     *  Attention from OB 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(12)) ? analyzeConnectedOBUS3;

    /** GLOBAL_UCS_FIR[32]
     *  Attention from EC 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(32)) ? analyzeConnectedEC0;

    /** GLOBAL_UCS_FIR[33]
     *  Attention from EC 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(33)) ? analyzeConnectedEC1;

    /** GLOBAL_UCS_FIR[34]
     *  Attention from EC 2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(34)) ? analyzeConnectedEC2;

    /** GLOBAL_UCS_FIR[35]
     *  Attention from EC 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(35)) ? analyzeConnectedEC3;

    /** GLOBAL_UCS_FIR[36]
     *  Attention from EC 4 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(36)) ? analyzeConnectedEC4;

    /** GLOBAL_UCS_FIR[37]
     *  Attention from EC 5 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(37)) ? analyzeConnectedEC5;

    /** GLOBAL_UCS_FIR[38]
     *  Attention from EC 6 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(38)) ? analyzeConnectedEC6;

    /** GLOBAL_UCS_FIR[39]
     *  Attention from EC 7 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(39)) ? analyzeConnectedEC7;

    /** GLOBAL_UCS_FIR[40]
     *  Attention from EC 8 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(40)) ? analyzeConnectedEC8;

    /** GLOBAL_UCS_FIR[41]
     *  Attention from EC 9 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(41)) ? analyzeConnectedEC9;

    /** GLOBAL_UCS_FIR[42]
     *  Attention from EC 10 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(42)) ? analyzeConnectedEC10;

    /** GLOBAL_UCS_FIR[43]
     *  Attention from EC 11 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(43)) ? analyzeConnectedEC11;

    /** GLOBAL_UCS_FIR[44]
     *  Attention from EC 12 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(44)) ? analyzeConnectedEC12;

    /** GLOBAL_UCS_FIR[45]
     *  Attention from EC 13 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(45)) ? analyzeConnectedEC13;

    /** GLOBAL_UCS_FIR[46]
     *  Attention from EC 14 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(46)) ? analyzeConnectedEC14;

    /** GLOBAL_UCS_FIR[47]
     *  Attention from EC 15 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(47)) ? analyzeConnectedEC15;

    /** GLOBAL_UCS_FIR[48]
     *  Attention from EC 16 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(48)) ? analyzeConnectedEC16;

    /** GLOBAL_UCS_FIR[49]
     *  Attention from EC 17 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(49)) ? analyzeConnectedEC17;

    /** GLOBAL_UCS_FIR[50]
     *  Attention from EC 18 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(50)) ? analyzeConnectedEC18;

    /** GLOBAL_UCS_FIR[51]
     *  Attention from EC 19 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(51)) ? analyzeConnectedEC19;

    /** GLOBAL_UCS_FIR[52]
     *  Attention from EC 20 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(52)) ? analyzeConnectedEC20;

    /** GLOBAL_UCS_FIR[53]
     *  Attention from EC 21 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(53)) ? analyzeConnectedEC21;

    /** GLOBAL_UCS_FIR[54]
     *  Attention from EC 22 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(54)) ? analyzeConnectedEC22;

    /** GLOBAL_UCS_FIR[55]
     *  Attention from EC 23 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(55)) ? analyzeConnectedEC23;

};

################################################################################
# Global Host Attention FIR
################################################################################

rule rGLOBAL_HA_FIR
{
  HOST_ATTN:
    GLOBAL_HA_FIR;
};

group gGLOBAL_HA_FIR attntype HOST_ATTN
    filter singlebit
{
    /** GLOBAL_HA_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(3)) ? analyze(gN1_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[5]
     *  Attention from N3 chiplet
     */
    (rGLOBAL_HA_FIR, bit(5)) ? analyze(gN3_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[7]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(7)) ? analyzeConnectedMCBIST0;

    /** GLOBAL_HA_FIR[8]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(8)) ? analyzeConnectedMCBIST1;

};

################################################################################
# TP Chiplet FIR
################################################################################

rule rTP_CHIPLET_FIR
{
  CHECK_STOP:
     TP_CHIPLET_CS_FIR       & ~TP_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (TP_CHIPLET_RE_FIR >> 2) & ~TP_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gTP_CHIPLET_FIR
    filter singlebit
{
    /** TP_CHIPLET_FIR[3]
     *  Attention from TP_LFIR
     */
    (rTP_CHIPLET_FIR, bit(3)) ? analyzeTP_LFIR;

    /** TP_CHIPLET_FIR[4]
     *  Attention from OCCFIR
     */
    (rTP_CHIPLET_FIR, bit(4)) ? analyzeOCCFIR;

};

################################################################################
# P9 chip TP_LFIR
################################################################################

rule rTP_LFIR
{
  CHECK_STOP:
    TP_LFIR & ~TP_LFIR_MASK & ~TP_LFIR_ACT0 & ~TP_LFIR_ACT1;
  RECOVERABLE:
    TP_LFIR & ~TP_LFIR_MASK & ~TP_LFIR_ACT0 &  TP_LFIR_ACT1;
};

group gTP_LFIR
    filter singlebit,
           cs_root_cause
{
    /** TP_LFIR[0]
     *  CFIR internal parity error
     */
    (rTP_LFIR, bit(0)) ? self_th_32perDay;

    /** TP_LFIR[1]
     *  Chiplet Control Reg: PCB Access Error
     */
    (rTP_LFIR, bit(1)) ? self_th_32perDay;

    /** TP_LFIR[2]
     *  Clock Controller: PCB Access Error
     */
    (rTP_LFIR, bit(2)) ? self_th_32perDay;

    /** TP_LFIR[3]
     *  Clock Controller: Summarized Error
     */
    (rTP_LFIR, bit(3)) ? self_th_32perDay;

    /** TP_LFIR[4]
     *  PSCOM Logic: PCB Access Error
     */
    (rTP_LFIR, bit(4)) ? defaultMaskedError;

    /** TP_LFIR[5]
     *  PSCOM Logic: Summarized internal errors
     */
    (rTP_LFIR, bit(5)) ? defaultMaskedError;

    /** TP_LFIR[6]
     *  Therm Logic: Summarized internal errors
     */
    (rTP_LFIR, bit(6)) ? defaultMaskedError;

    /** TP_LFIR[7]
     *  Therm Logic: PCB Access Error
     */
    (rTP_LFIR, bit(7)) ? defaultMaskedError;

    /** TP_LFIR[8]
     *  Therm Logic: Temperature critical trip
     */
    (rTP_LFIR, bit(8)) ? defaultMaskedError;

    /** TP_LFIR[9]
     *  Therm Logic: Temperature fatal trip
     */
    (rTP_LFIR, bit(9)) ? defaultMaskedError;

    /** TP_LFIR[10]
     *  UNUSED in P9
     */
    (rTP_LFIR, bit(10)) ? defaultMaskedError;

    /** TP_LFIR[11]
     *  Debug Logic: Scom Satelite Error
     */
    (rTP_LFIR, bit(11)) ? defaultMaskedError;

    /** TP_LFIR[12]
     *  Trace Logic: Scom Satellite Error
     */
    (rTP_LFIR, bit(12)) ? defaultMaskedError;

    /** TP_LFIR[13]
     *  Trace Logic: Scom Satellite Error
     */
    (rTP_LFIR, bit(13)) ? defaultMaskedError;

    /** TP_LFIR[14]
     *  Freq Meas. Reg PE or VMEAS/KVREF timeout
     */
    (rTP_LFIR, bit(14)) ? defaultMaskedError;

    /** TP_LFIR[15]
     *  Interrupt Macro: PCB Access Error
     */
    (rTP_LFIR, bit(15)) ? defaultMaskedError;

    /** TP_LFIR[16]
     *  PCB Master Logic: PCB Timout
     */
    (rTP_LFIR, bit(16)) ? defaultMaskedError;

    /** TP_LFIR[17]
     *  I2C Master Logic: Local Bus Parity error
     */
    (rTP_LFIR, bit(17)) ? self_th_1;

    /** TP_LFIR[18]
     *  TOD Logic: Summerized internal errors
     */
    (rTP_LFIR, bit(18)) ? analyzeTodBackupTopology;

    /** TP_LFIR[19]
     *  TOD Logic: PIB Slave access errors
     */
    (rTP_LFIR, bit(19)) ? analyzePibError;

    /** TP_LFIR[20]
     *  TOD Logic: Error report from PHYP
     */
    (rTP_LFIR, bit(20)) ? analyzePhypTodError;

    /** TP_LFIR[21]
     *  PCB slave Unmasked err summary
     */
    (rTP_LFIR, bit(21)) ? pcb_slave_internal_parity;

    /** TP_LFIR[22]
     *  SBE Logic: PPE Internal State Error
     */
    (rTP_LFIR, bit(22)) ? defaultMaskedError;

    /** TP_LFIR[23]
     *  PPE interface invalid seq/protocol err
     */
    (rTP_LFIR, bit(23)) ? defaultMaskedError;

    /** TP_LFIR[24]
     *  SBE Logic: PPE Watchdog timeout
     */
    (rTP_LFIR, bit(24)) ? defaultMaskedError;

    /** TP_LFIR[25]
     *  PPE saw proc halt initiated by fw, etc.
     */
    (rTP_LFIR, bit(25)) ? defaultMaskedError;

    /** TP_LFIR[26]
     *  PPE in halt state driven by RAMDBG bit 0
     */
    (rTP_LFIR, bit(26)) ? sbe_vital_attn;

    /** TP_LFIR[27]
     *  PPE debug: Watchdog timer proc rst/halt
     */
    (rTP_LFIR, bit(27)) ? defaultMaskedError;

    /** TP_LFIR[28]
     *  SBE Logic: SEEPROM Address err etc.
     */
    (rTP_LFIR, bit(28)) ? defaultMaskedError;

    /** TP_LFIR[29]
     *  SBE Logic: Any I2C Master Error
     */
    (rTP_LFIR, bit(29)) ? defaultMaskedError;

    /** TP_LFIR[30]
     *  SBE Logic: Programmable errors
     */
    (rTP_LFIR, bit(30)) ? defaultMaskedError;

    /** TP_LFIR[31]
     *  OTP Logic: invalid reg access etc.
     */
    (rTP_LFIR, bit(31)) ? defaultMaskedError;

    /** TP_LFIR[32]
     *  Trigger from e_c4_occ_rx_alert_b input
     */
    (rTP_LFIR, bit(32)) ? defaultMaskedError;

    /** TP_LFIR[33]
     *  Unused in P9
     */
    (rTP_LFIR, bit(33)) ? defaultMaskedError;

    /** TP_LFIR[34]
     *  Multicast group: group cntr zero
     */
    (rTP_LFIR, bit(34)) ? defaultMaskedError;

    /** TP_LFIR[35]
     *  PCB Master: Receive fsm Inv. state etc.
     */
    (rTP_LFIR, bit(35)) ? defaultMaskedError;

    /** TP_LFIR[36]
     *  system ref osc switch to backup
     */
    (rTP_LFIR, bit(36)) ? sys_osc_switch_error;

    /** TP_LFIR[37]
     *  PCI osc switch to backup
     */
    (rTP_LFIR, bit(37)) ? pci_osc_switch_error;

    /** TP_LFIR[38]
     *  PIB MEM: Summarized err - PIB access ops
     */
    (rTP_LFIR, bit(38)) ? defaultMaskedError;

    /** TP_LFIR[39]
     *  PIB MEM: Summarized err-fast access ops
     */
    (rTP_LFIR, bit(39)) ? defaultMaskedError;

    /** TP_LFIR[40]
     *  OTP Logic: UE or CE counter overflow
     */
    (rTP_LFIR, bit(40)) ? defaultMaskedError;

    /** TP_LFIR[41]
     *  malfunction alert or Local Checkstop
     */
    (rTP_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip OCCFIR
################################################################################

rule rOCCFIR
{
  CHECK_STOP:
    OCCFIR & ~OCCFIR_MASK & ~OCCFIR_ACT0 & ~OCCFIR_ACT1;
  RECOVERABLE:
    OCCFIR & ~OCCFIR_MASK & ~OCCFIR_ACT0 &  OCCFIR_ACT1;
};

group gOCCFIR
    filter singlebit,
           cs_root_cause
{
    /** OCCFIR[0]
     *  OCC_FW0
     */
    (rOCCFIR, bit(0)) ? defaultMaskedError;

    /** OCCFIR[1]
     *  OCC_FW1
     */
    (rOCCFIR, bit(1)) ? defaultMaskedError;

    /** OCCFIR[2]
     *  OCC_CME_ERROR_NOTIFY
     */
    (rOCCFIR, bit(2)) ? defaultMaskedError;

    /** OCCFIR[3]
     *  STOP_RECOVERY_NOTIFY_PRD
     */
    (rOCCFIR, bit(3)) ? pmRecovery;

    /** OCCFIR[4]
     *  OCC_HB_ERROR
     */
    (rOCCFIR, bit(4)) ? defaultMaskedError;

    /** OCCFIR[5]
     *  GPE0 watchdog timeout condition
     */
    (rOCCFIR, bit(5)) ? defaultMaskedError;

    /** OCCFIR[6]
     *  GPE1 watchdog timeout condition
     */
    (rOCCFIR, bit(6)) ? defaultMaskedError;

    /** OCCFIR[7]
     *  GPE2  watchdog timeout condition
     */
    (rOCCFIR, bit(7)) ? defaultMaskedError;

    /** OCCFIR[8]
     *  GPE3 watchdog timeout condition
     */
    (rOCCFIR, bit(8)) ? defaultMaskedError;

    /** OCCFIR[9]
     *  GPE0 asserted an error condition
     */
    (rOCCFIR, bit(9)) ? threshold_and_mask_self;

    /** OCCFIR[10]
     *  GPE1 asserted an error condition
     */
    (rOCCFIR, bit(10)) ? threshold_and_mask_self;

    /** OCCFIR[11]
     *  GPE2 asserted an error condition
     */
    (rOCCFIR, bit(11)) ? defaultMaskedError;

    /** OCCFIR[12]
     *  GPE3 asserted an error condition
     */
    (rOCCFIR, bit(12)) ? defaultMaskedError;

    /** OCCFIR[13]
     *  OCB_ERROR
     */
    (rOCCFIR, bit(13)) ? defaultMaskedError;

    /** OCCFIR[14]
     *  SRAM Unrecoverable Error
     */
    (rOCCFIR, bit(14)) ? self_th_1;

    /** OCCFIR[15]
     *  SRAM CE
     */
    (rOCCFIR, bit(15)) ? threshold_and_mask_self;

    /** OCCFIR[16]
     *  SRAM Read Error
     */
    (rOCCFIR, bit(16)) ? threshold_and_mask_self;

    /** OCCFIR[17]
     *  SRAM Write error
     */
    (rOCCFIR, bit(17)) ? threshold_and_mask_self;

    /** OCCFIR[18]
     *  SRAM ctrl detected pe on tank read data
     */
    (rOCCFIR, bit(18)) ? threshold_and_mask_self;

    /** OCCFIR[19]
     *  SRAM cntrl  detected OCI write data pe
     */
    (rOCCFIR, bit(19)) ? threshold_and_mask_self;

    /** OCCFIR[20]
     *  SRAM cntrl detected OCI byte enable PE
     */
    (rOCCFIR, bit(20)) ? threshold_and_mask_self;

    /** OCCFIR[21]
     *  SRAM controller detected OCI address PE
     */
    (rOCCFIR, bit(21)) ? threshold_and_mask_self;

    /** OCCFIR[22]
     *  GPE0_HALTED:
     */
    (rOCCFIR, bit(22)) ? defaultMaskedError;

    /** OCCFIR[23]
     *  GPE1_HALTED:
     */
    (rOCCFIR, bit(23)) ? defaultMaskedError;

    /** OCCFIR[24]
     *  GPE2_HALTED:
     */
    (rOCCFIR, bit(24)) ? defaultMaskedError;

    /** OCCFIR[25]
     *  GPE3_HALTED:
     */
    (rOCCFIR, bit(25)) ? defaultMaskedError;

    /** OCCFIR[26]
     *  EXTERNAL_TRAP:
     */
    (rOCCFIR, bit(26)) ? defaultMaskedError;

    /** OCCFIR[27]
     *  PPC405_CORE_RESET
     */
    (rOCCFIR, bit(27)) ? defaultMaskedError;

    /** OCCFIR[28]
     *  PPC405_CHIP_RESET
     */
    (rOCCFIR, bit(28)) ? defaultMaskedError;

    /** OCCFIR[29]
     *  PPC405_SYSTEM_RESET
     */
    (rOCCFIR, bit(29)) ? defaultMaskedError;

    /** OCCFIR[30]
     *  PPC405_DBGMSRWE
     */
    (rOCCFIR, bit(30)) ? defaultMaskedError;

    /** OCCFIR[31]
     *  PPC405_DBGSTOPACK
     */
    (rOCCFIR, bit(31)) ? defaultMaskedError;

    /** OCCFIR[32]
     *  OCB_DB_OCI_TIMEOUT
     */
    (rOCCFIR, bit(32)) ? threshold_and_mask_self;

    /** OCCFIR[33]
     *  OCB_DB_OCI_READ_DATA_PARITY
     */
    (rOCCFIR, bit(33)) ? threshold_and_mask_self;

    /** OCCFIR[34]
     *  OCB_DB_OCI_SLAVE_ERROR
     */
    (rOCCFIR, bit(34)) ? threshold_and_mask_self;

    /** OCCFIR[35]
     *  OCB_PIB_ADDR_PARITY_ERR
     */
    (rOCCFIR, bit(35)) ? threshold_and_mask_self;

    /** OCCFIR[36]
     *  OCB_PIB_DATA_PARITY_ERR
     */
    (rOCCFIR, bit(36)) ? threshold_and_mask_self;

    /** OCCFIR[37]
     *  OCB_IDC0_ERROR
     */
    (rOCCFIR, bit(37)) ? threshold_and_mask_self;

    /** OCCFIR[38]
     *  OCB_IDC1_ERROR
     */
    (rOCCFIR, bit(38)) ? threshold_and_mask_self;

    /** OCCFIR[39]
     *  OCB_IDC2_ERROR
     */
    (rOCCFIR, bit(39)) ? threshold_and_mask_self;

    /** OCCFIR[40]
     *  OCB_IDC3_ERROR
     */
    (rOCCFIR, bit(40)) ? threshold_and_mask_self;

    /** OCCFIR[41]
     *  SRT_FSM_ERR
     */
    (rOCCFIR, bit(41)) ? threshold_and_mask_self;

    /** OCCFIR[42]
     *  JTAGACC_ERR
     */
    (rOCCFIR, bit(42)) ? threshold_and_mask_self;

    /** OCCFIR[43]
     *  spare
     */
    (rOCCFIR, bit(43)) ? defaultMaskedError;

    /** OCCFIR[44]
     *  C405_ECC_UE
     */
    (rOCCFIR, bit(44)) ? self_th_1;

    /** OCCFIR[45]
     *  C405_ECC_CE
     */
    (rOCCFIR, bit(45)) ? threshold_and_mask_self;

    /** OCCFIR[46]
     *  C405_OCI_MACHINECHECK
     */
    (rOCCFIR, bit(46)) ? threshold_and_mask_self;

    /** OCCFIR[47]
     *  SRAM_SPARE_DIRECT_ERROR0
     */
    (rOCCFIR, bit(47)) ? threshold_and_mask_self;

    /** OCCFIR[48]
     *  SRAM_SPARE_DIRECT_ERROR1
     */
    (rOCCFIR, bit(48)) ? threshold_and_mask_self;

    /** OCCFIR[49]
     *  SRAM_SPARE_DIRECT_ERROR2
     */
    (rOCCFIR, bit(49)) ? threshold_and_mask_self;

    /** OCCFIR[50]
     *  SRAM_SPARE_DIRECT_ERROR3
     */
    (rOCCFIR, bit(50)) ? threshold_and_mask_self;

    /** OCCFIR[51]
     *  GPE0_OCISLV_ERR
     */
    (rOCCFIR, bit(51)) ? threshold_and_mask_self;

    /** OCCFIR[52]
     *  GPE1_OCISLV_ERR
     */
    (rOCCFIR, bit(52)) ? threshold_and_mask_self;

    /** OCCFIR[53]
     *  GPE2_OCISLV_ERR
     */
    (rOCCFIR, bit(53)) ? threshold_and_mask_self;

    /** OCCFIR[54]
     *  GPE3_OCISLV_ERR
     */
    (rOCCFIR, bit(54)) ? threshold_and_mask_self;

    /** OCCFIR[55]
     *  C405ICU_M_TIMEOUT
     */
    (rOCCFIR, bit(55)) ? defaultMaskedError;

    /** OCCFIR[56]
     *  C405DCU_M_TIMEOUT
     */
    (rOCCFIR, bit(56)) ? threshold_and_mask_self;

    /** OCCFIR[57]
     *  OCC_COMPLEX_FAULT
     */
    (rOCCFIR, bit(57)) ? threshold_and_mask_self;

    /** OCCFIR[58]
     *  OCC_COMPLEX_NOTIFY
     */
    (rOCCFIR, bit(58)) ? threshold_and_mask_self;

    /** OCCFIR[59:61]
     *  spare
     */
    (rOCCFIR, bit(59|60|61)) ? defaultMaskedError;

    /** OCCFIR[62]
     *  scom
     */
    (rOCCFIR, bit(62)) ? defaultMaskedError;

    /** OCCFIR[63]
     *  scom error
     */
    (rOCCFIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# N0 Chiplet FIR
################################################################################

rule rN0_CHIPLET_FIR
{
  CHECK_STOP:
     N0_CHIPLET_CS_FIR       & ~N0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N0_CHIPLET_RE_FIR >> 2) & ~N0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN0_CHIPLET_FIR
    filter singlebit
{
    /** N0_CHIPLET_FIR[3]
     *  Attention from N0_LFIR
     */
    (rN0_CHIPLET_FIR, bit(3)) ? analyzeN0_LFIR;

    /** N0_CHIPLET_FIR[4]
     *  Attention from NXDMAENGFIR
     */
    (rN0_CHIPLET_FIR, bit(4)) ? analyzeNXDMAENGFIR;

    /** N0_CHIPLET_FIR[5]
     *  Attention from NXCQFIR
     */
    (rN0_CHIPLET_FIR, bit(5)) ? analyzeNXCQFIR;

    /** N0_CHIPLET_FIR[6]
     *  Attention from CXAFIR 0
     */
    (rN0_CHIPLET_FIR, bit(6)) ? analyzeConnectedCAPP0;

};

################################################################################
# N0 Chiplet Unit Checkstop FIR
################################################################################

rule rN0_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N0_CHIPLET_UCS_FIR & ~(N0_CHIPLET_UCS_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gN0_CHIPLET_UCS_FIR
    filter singlebit
{
    /** N0_CHIPLET_UCS_FIR[1]
     *  Attention from NXDMAENGFIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(1)) ? analyzeNXDMAENGFIR;

    /** N0_CHIPLET_UCS_FIR[2]
     *  Attention from NXCQFIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(2)) ? analyzeNXCQFIR;

    /** N0_CHIPLET_UCS_FIR[3]
     *  Attention from CXAFIR 0
     */
    (rN0_CHIPLET_UCS_FIR, bit(3)) ? analyzeConnectedCAPP0;

};

################################################################################
# P9 chip N0_LFIR
################################################################################

rule rN0_LFIR
{
  CHECK_STOP:
    N0_LFIR & ~N0_LFIR_MASK & ~N0_LFIR_ACT0 & ~N0_LFIR_ACT1;
  RECOVERABLE:
    N0_LFIR & ~N0_LFIR_MASK & ~N0_LFIR_ACT0 &  N0_LFIR_ACT1;
};

group gN0_LFIR
    filter singlebit,
           cs_root_cause
{
    /** N0_LFIR[0]
     *  CFIR internal parity error
     */
    (rN0_LFIR, bit(0)) ? self_th_32perDay;

    /** N0_LFIR[1]
     *  Chiplet Control Reg: PCB Access Error
     */
    (rN0_LFIR, bit(1)) ? self_th_32perDay;

    /** N0_LFIR[2]
     *  Clock Controller: PCB Access Error
     */
    (rN0_LFIR, bit(2)) ? self_th_32perDay;

    /** N0_LFIR[3]
     *  Clock Controller: Summarized Error
     */
    (rN0_LFIR, bit(3)) ? self_th_32perDay;

    /** N0_LFIR[4]
     *  PSCOM Logic: PCB Access Error
     */
    (rN0_LFIR, bit(4)) ? defaultMaskedError;

    /** N0_LFIR[5]
     *  PSCOM Logic: Summarized internal errors
     */
    (rN0_LFIR, bit(5)) ? defaultMaskedError;

    /** N0_LFIR[6]
     *  Therm Logic: Summarized internal errors
     */
    (rN0_LFIR, bit(6)) ? defaultMaskedError;

    /** N0_LFIR[7]
     *  Therm Logic: PCB Access Error
     */
    (rN0_LFIR, bit(7)) ? defaultMaskedError;

    /** N0_LFIR[8]
     *  Therm Logic: Temperature critical trip
     */
    (rN0_LFIR, bit(8)) ? defaultMaskedError;

    /** N0_LFIR[9]
     *  Therm Logic: Temperature fatal trip
     */
    (rN0_LFIR, bit(9)) ? defaultMaskedError;

    /** N0_LFIR[10]
     *  UNUSED in P9
     */
    (rN0_LFIR, bit(10)) ? defaultMaskedError;

    /** N0_LFIR[11]
     *  Debug Logic: Scom Satellite Error
     */
    (rN0_LFIR, bit(11)) ? defaultMaskedError;

    /** N0_LFIR[12]
     *  Scom Satellite Error - Trace0
     */
    (rN0_LFIR, bit(12)) ? defaultMaskedError;

    /** N0_LFIR[13]
     *  Scom Satellite Error - Trace0
     */
    (rN0_LFIR, bit(13)) ? defaultMaskedError;

    /** N0_LFIR[14]
     *  Scom Satellite Error - Trace1
     */
    (rN0_LFIR, bit(14)) ? defaultMaskedError;

    /** N0_LFIR[15]
     *  Scom Satellite Error - Trace1
     */
    (rN0_LFIR, bit(15)) ? defaultMaskedError;

    /** N0_LFIR[16:23]
     *  spare
     */
    (rN0_LFIR, bit(16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** N0_LFIR[24]
     *  Unused
     */
    (rN0_LFIR, bit(24)) ? defaultMaskedError;

    /** N0_LFIR[25]
     *  Unused
     */
    (rN0_LFIR, bit(25)) ? defaultMaskedError;

    /** N0_LFIR[26:40]
     *  spare
     */
    (rN0_LFIR, bit(26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** N0_LFIR[41]
     *  Malfunction Alert or Local Checkstop
     */
    (rN0_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip NXCQFIR
################################################################################

rule rNXCQFIR
{
  CHECK_STOP:
    NXCQFIR & ~NXCQFIR_MASK & ~NXCQFIR_ACT0 & ~NXCQFIR_ACT1;
  RECOVERABLE:
    NXCQFIR & ~NXCQFIR_MASK & ~NXCQFIR_ACT0 &  NXCQFIR_ACT1;
  UNIT_CS:
    NXCQFIR & ~NXCQFIR_MASK &  NXCQFIR_ACT0 &  NXCQFIR_ACT1;
};

group gNXCQFIR
    filter singlebit,
           cs_root_cause
{
    /** NXCQFIR[0]
     *  PBI internal parity error
     */
    (rNXCQFIR, bit(0)) ? nx_th_1;

    /** NXCQFIR[1]
     *  PowerBus CE error
     */
    (rNXCQFIR, bit(1)) ? nx_th_32perDay;

    /** NXCQFIR[2]
     *  PowerBus UE error
     */
    (rNXCQFIR, bit(2)) ? nx_th_1;

    /** NXCQFIR[3]
     *  PBUS_ECC_SUE_FIR: PowerBus SUE error
     */
    (rNXCQFIR, bit(3)) ? defaultMaskedError;

    /** NXCQFIR[4]
     *  Inbound array CE error
     */
    (rNXCQFIR, bit(4)) ? nx_th_32perDay;

    /** NXCQFIR[5]
     *  Inbound array UE error
     */
    (rNXCQFIR, bit(5)) ? nx_th_1;

    /** NXCQFIR[6]
     *  PASTE_REJECT_FIR: Paste request rejected
     */
    (rNXCQFIR, bit(6)) ? level2_th_1;

    /** NXCQFIR[7]
     *  PowerBus command hang error
     */
    (rNXCQFIR, bit(7)) ? defaultMaskedError;

    /** NXCQFIR[8]
     *  PowerBus read address error
     */
    (rNXCQFIR, bit(8)) ? nx_th_1;

    /** NXCQFIR[9]
     *  PowerBus write address error
     */
    (rNXCQFIR, bit(9)) ? nx_th_1;

    /** NXCQFIR[10]
     *  PowerBus miscellaneous error
     */
    (rNXCQFIR, bit(10)) ? nx_th_1;

    /** NXCQFIR[11]
     *  MMIO_BAR_PE_FIR: MMIO BAR parity error
     */
    (rNXCQFIR, bit(11)) ? nx_th_1;

    /** NXCQFIR[12]
     *  UMAC detected UE on WC Interrupt
     */
    (rNXCQFIR, bit(12)) ? nx_th_1;

    /** NXCQFIR[13]
     *  ACK_DEAD cresp received by read command
     */
    (rNXCQFIR, bit(13)) ? defaultMaskedError;

    /** NXCQFIR[14]
     *  ACK_DEAD cresp received by write command
     */
    (rNXCQFIR, bit(14)) ? defaultMaskedError;

    /** NXCQFIR[15]
     *  Link check aborted while waiting on data
     */
    (rNXCQFIR, bit(15)) ? defaultMaskedError;

    /** NXCQFIR[16]
     *  internal transfer hang poll time expired
     */
    (rNXCQFIR, bit(16)) ? nx_th_1;

    /** NXCQFIR[17]
     *  Parity error on ERAT arrays
     */
    (rNXCQFIR, bit(17)) ? nx_th_1;

    /** NXCQFIR[18]
     *  Correctable error on ERAT arrays
     */
    (rNXCQFIR, bit(18)) ? nx_th_32perDay;

    /** NXCQFIR[19]
     *  Uncorrectable error on ERAT arrays
     */
    (rNXCQFIR, bit(19)) ? nx_th_1;

    /** NXCQFIR[20]
     *  SUE on ERAT arrays
     */
    (rNXCQFIR, bit(20)) ? nx_th_1_SUE;

    /** NXCQFIR[21]
     *  NMMU hang on checkin/checkout request
     */
    (rNXCQFIR, bit(21)) ? level2_th_1;

    /** NXCQFIR[22]
     *  ERAT control logic error
     */
    (rNXCQFIR, bit(22)) ? nx_th_1;

    /** NXCQFIR[23]
     *  UE on the Powerbus data for xlate
     */
    (rNXCQFIR, bit(23)) ? nx_th_1;

    /** NXCQFIR[24]
     *  SUE on the Powerbus data for xlate
     */
    (rNXCQFIR, bit(24)) ? nx_th_1_SUE;

    /** NXCQFIR[25]
     *  ACK_DEAD cresp received by UMAC read
     */
    (rNXCQFIR, bit(25)) ? defaultMaskedError;

    /** NXCQFIR[26]
     *  Link check aborted waiting on UMAC data
     */
    (rNXCQFIR, bit(26)) ? defaultMaskedError;

    /** NXCQFIR[27]
     *  UE on CRB QW0/4
     */
    (rNXCQFIR, bit(27)) ? nx_th_1;

    /** NXCQFIR[28]
     *  SUE on CRB QW0/4
     */
    (rNXCQFIR, bit(28)) ? nx_th_1_SUE;

    /** NXCQFIR[29]
     *  UMAC has detected a control logic error
     */
    (rNXCQFIR, bit(29)) ? nx_th_1;

    /** NXCQFIR[30]
     *  Reserved fieldUMAC_SCOM_sat_err)
     */
    (rNXCQFIR, bit(30)) ? defaultMaskedError;

    /** NXCQFIR[31]
     *  Write to RNG SCOM when writes disabled
     */
    (rNXCQFIR, bit(31)) ? defaultMaskedError;

    /** NXCQFIR[32]
     *  first noise source in the RNG has failed
     */
    (rNXCQFIR, bit(32)) ? nx_th_32perDay;

    /** NXCQFIR[33]
     *  second noise source in the RNG failed
     */
    (rNXCQFIR, bit(33)) ? nx_th_32perDay;

    /** NXCQFIR[34]
     *  RNG has detected a control logic error
     */
    (rNXCQFIR, bit(34)) ? nx_th_1;

    /** NXCQFIR[35]
     *  NMMU has signaled local checkstop
     */
    (rNXCQFIR, bit(35)) ? nx_th_1;

    /** NXCQFIR[36]
     *  VAS has signaled local checkstop
     */
    (rNXCQFIR, bit(36)) ? nx_th_1;

    /** NXCQFIR[37]
     *  PBCQ has detected a control logic error
     */
    (rNXCQFIR, bit(37)) ? nx_th_1;

    /** NXCQFIR[38]
     *  PBCQ detected failed link
     */
    (rNXCQFIR, bit(38)) ? defaultMaskedError;

    /** NXCQFIR[39]
     *  UMAC detected SUE on WC Interrupt
     */
    (rNXCQFIR, bit(39)) ? nx_th_1_SUE;

    /** NXCQFIR[40]
     *  SMF address bit = 1 error
     */
    (rNXCQFIR, bit(40)) ? defaultMaskedError;

    /** NXCQFIR[41]
     *  Spare
     */
    (rNXCQFIR, bit(41)) ? defaultMaskedError;

    /** NXCQFIR[42]
     *  scom error
     */
    (rNXCQFIR, bit(42)) ? defaultMaskedError;

    /** NXCQFIR[43]
     *  scom error
     */
    (rNXCQFIR, bit(43)) ? defaultMaskedError;

};

################################################################################
# P9 chip NXDMAENGFIR
################################################################################

rule rNXDMAENGFIR
{
  CHECK_STOP:
    NXDMAENGFIR & ~NXDMAENGFIR_MASK & ~NXDMAENGFIR_ACT0 & ~NXDMAENGFIR_ACT1;
  RECOVERABLE:
    NXDMAENGFIR & ~NXDMAENGFIR_MASK & ~NXDMAENGFIR_ACT0 &  NXDMAENGFIR_ACT1;
  UNIT_CS:
    NXDMAENGFIR & ~NXDMAENGFIR_MASK &  NXDMAENGFIR_ACT0 &  NXDMAENGFIR_ACT1;
};

group gNXDMAENGFIR
    filter singlebit,
           cs_root_cause
{
    /** NXDMAENGFIR[0]
     *  DMA hang timer expired
     */
    (rNXDMAENGFIR, bit(0)) ? nx_th_1;

    /** NXDMAENGFIR[1]
     *  SHM invalid state
     */
    (rNXDMAENGFIR, bit(1)) ? nx_th_1;

    /** NXDMAENGFIR[2:3]
     *  spare
     */
    (rNXDMAENGFIR, bit(2|3)) ? defaultMaskedError;

    /** NXDMAENGFIR[4]
     *  Channel 0 842 engine ECC CE error
     */
    (rNXDMAENGFIR, bit(4)) ? nx_th_32perDay;

    /** NXDMAENGFIR[5]
     *  Channel 0 842 engine ECC UE error
     */
    (rNXDMAENGFIR, bit(5)) ? nx_th_1;

    /** NXDMAENGFIR[6]
     *  Channel 1 842 engine ECC CE error
     */
    (rNXDMAENGFIR, bit(6)) ? nx_th_32perDay;

    /** NXDMAENGFIR[7]
     *  Channel 1 842 engine ECC UE error
     */
    (rNXDMAENGFIR, bit(7)) ? nx_th_1;

    /** NXDMAENGFIR[8]
     *  DMA Non-zero CSB CC detected
     */
    (rNXDMAENGFIR, bit(8)) ? defaultMaskedError;

    /** NXDMAENGFIR[9]
     *  DMA array ECC CE error
     */
    (rNXDMAENGFIR, bit(9)) ? nx_th_32perDay;

    /** NXDMAENGFIR[10]
     *  DMA outWR/inRD ECC CE error
     */
    (rNXDMAENGFIR, bit(10)) ? nx_th_32perDay;

    /** NXDMAENGFIR[11]
     *  Channel 4 GZIP ECC CE
     */
    (rNXDMAENGFIR, bit(11)) ? nx_th_32perDay;

    /** NXDMAENGFIR[12]
     *  Channel 4 GZIP ECC UE
     */
    (rNXDMAENGFIR, bit(12)) ? nx_th_1;

    /** NXDMAENGFIR[13]
     *  Channel 4 GZIP ECC PE
     */
    (rNXDMAENGFIR, bit(13)) ? nx_th_1;

    /** NXDMAENGFIR[14]
     *  SCOM error from other satellites
     */
    (rNXDMAENGFIR, bit(14)) ? defaultMaskedError;

    /** NXDMAENGFIR[15]
     *  DMA invalid state error (unrecoverable)
     */
    (rNXDMAENGFIR, bit(15)) ? nx_th_1;

    /** NXDMAENGFIR[16]
     *  DMA invalid state error (unrecoverable)
     */
    (rNXDMAENGFIR, bit(16)) ? nx_th_1;

    /** NXDMAENGFIR[17]
     *  DMA array ECC UE error
     */
    (rNXDMAENGFIR, bit(17)) ? nx_th_1;

    /** NXDMAENGFIR[18]
     *  DMA outWR/inRD ECC UE error
     */
    (rNXDMAENGFIR, bit(18)) ? nx_th_1;

    /** NXDMAENGFIR[19]
     *  DMA inRD done error
     */
    (rNXDMAENGFIR, bit(19)) ? defaultMaskedError;

    /** NXDMAENGFIR[20]
     *  Channel 0 invalid state error
     */
    (rNXDMAENGFIR, bit(20)) ? nx_th_1;

    /** NXDMAENGFIR[21]
     *  Channel 1 invalid state error
     */
    (rNXDMAENGFIR, bit(21)) ? nx_th_1;

    /** NXDMAENGFIR[22]
     *  Channel 2 invalid state error
     */
    (rNXDMAENGFIR, bit(22)) ? nx_th_1;

    /** NXDMAENGFIR[23]
     *  Channel 3 invalid state error
     */
    (rNXDMAENGFIR, bit(23)) ? nx_th_1;

    /** NXDMAENGFIR[24]
     *  Channel 4 invalid state error
     */
    (rNXDMAENGFIR, bit(24)) ? nx_th_1;

    /** NXDMAENGFIR[25:30]
     *  spare
     */
    (rNXDMAENGFIR, bit(25|26|27|28|29|30)) ? defaultMaskedError;

    /** NXDMAENGFIR[31]
     *  CRB UE, on CSB/CCB
     */
    (rNXDMAENGFIR, bit(31)) ? nx_th_1;

    /** NXDMAENGFIR[32]
     *  CRB SUE, on CSB/CCB
     */
    (rNXDMAENGFIR, bit(32)) ? nx_th_1_SUE;

    /** NXDMAENGFIR[33]
     *  DMA outWR/inRD ECC SUE error
     */
    (rNXDMAENGFIR, bit(33)) ? defaultMaskedError;

    /** NXDMAENGFIR[34]
     *  Channel 0 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(34)) ? nx_th_32perDay;

    /** NXDMAENGFIR[35]
     *  Channel 1 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(35)) ? nx_th_32perDay;

    /** NXDMAENGFIR[36]
     *  Channel 2 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(36)) ? nx_th_32perDay;

    /** NXDMAENGFIR[37]
     *  Channel 3 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(37)) ? nx_th_32perDay;

    /** NXDMAENGFIR[38]
     *  Hypervisor local checkstop
     */
    (rNXDMAENGFIR, bit(38)) ? nx_th_1;

    /** NXDMAENGFIR[39]
     *  Channel 4 watchdog timer expired
     */
    (rNXDMAENGFIR, bit(39)) ? nx_th_32perDay;

    /** NXDMAENGFIR[40:47]
     *  spare
     */
    (rNXDMAENGFIR, bit(40|41|42|43|44|45|46|47)) ? defaultMaskedError;

    /** NXDMAENGFIR[48]
     *  scom error
     */
    (rNXDMAENGFIR, bit(48)) ? defaultMaskedError;

    /** NXDMAENGFIR[49]
     *  scom error
     */
    (rNXDMAENGFIR, bit(49)) ? defaultMaskedError;

};

################################################################################
# N1 Chiplet FIR
################################################################################

rule rN1_CHIPLET_FIR
{
  CHECK_STOP:
     N1_CHIPLET_CS_FIR       & ~N1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N1_CHIPLET_RE_FIR >> 2) & ~N1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN1_CHIPLET_FIR
    filter singlebit
{
    /** N1_CHIPLET_FIR[3]
     *  Attention from N1_LFIR
     */
    (rN1_CHIPLET_FIR, bit(3)) ? analyzeN1_LFIR;

    /** N1_CHIPLET_FIR[4]
     *  Attention from MCFIR 2
     */
    (rN1_CHIPLET_FIR, bit(4)) ? analyzeConnectedMCS2;

    /** N1_CHIPLET_FIR[5]
     *  Attention from MCFIR 3
     */
    (rN1_CHIPLET_FIR, bit(5)) ? analyzeConnectedMCS3;

    /** N1_CHIPLET_FIR[6]
     *  Attention from MCDFIR
     */
    (rN1_CHIPLET_FIR, bit(6)) ? analyzeMCDFIR_0;

    /** N1_CHIPLET_FIR[7]
     *  Attention from MCDFIR
     */
    (rN1_CHIPLET_FIR, bit(7)) ? analyzeMCDFIR_1;

    /** N1_CHIPLET_FIR[8]
     *  Attention from VASFIR
     */
    (rN1_CHIPLET_FIR, bit(8)) ? analyzeVASFIR;

};

################################################################################
# N1 Chiplet Unit Checkstop FIR
################################################################################

rule rN1_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N1_CHIPLET_UCS_FIR & ~(N1_CHIPLET_UCS_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gN1_CHIPLET_UCS_FIR
    filter singlebit
{
    /** N1_CHIPLET_UCS_FIR[1]
     *  Attention from MCFIR 2
     */
    (rN1_CHIPLET_UCS_FIR, bit(1)) ? analyzeConnectedMCS2;

    /** N1_CHIPLET_UCS_FIR[2]
     *  Attention from MCFIR 3
     */
    (rN1_CHIPLET_UCS_FIR, bit(2)) ? analyzeConnectedMCS3;

    /** N1_CHIPLET_UCS_FIR[5]
     *  Attention from VASFIR
     */
    (rN1_CHIPLET_UCS_FIR, bit(5)) ? analyzeVASFIR;

};

################################################################################
# N1 Chiplet Host Attention FIR
################################################################################

rule rN1_CHIPLET_HA_FIR
{
  HOST_ATTN:
    N1_CHIPLET_HA_FIR & ~(N1_CHIPLET_HA_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gN1_CHIPLET_HA_FIR
    filter singlebit
{
    /** N1_CHIPLET_HA_FIR[1]
     *  Attention from MCFIR 2
     */
    (rN1_CHIPLET_HA_FIR, bit(1)) ? analyzeConnectedMCS2;

    /** N1_CHIPLET_HA_FIR[2]
     *  Attention from MCFIR 3
     */
    (rN1_CHIPLET_HA_FIR, bit(2)) ? analyzeConnectedMCS3;

};

################################################################################
# P9 chip N1_LFIR
################################################################################

rule rN1_LFIR
{
  CHECK_STOP:
    N1_LFIR & ~N1_LFIR_MASK & ~N1_LFIR_ACT0 & ~N1_LFIR_ACT1;
  RECOVERABLE:
    N1_LFIR & ~N1_LFIR_MASK & ~N1_LFIR_ACT0 &  N1_LFIR_ACT1;
};

group gN1_LFIR
    filter singlebit,
           cs_root_cause
{
    /** N1_LFIR[0]
     *  CFIR internal parity error
     */
    (rN1_LFIR, bit(0)) ? self_th_32perDay;

    /** N1_LFIR[1]
     *  Chiplet Control Reg: PCB Access Error
     */
    (rN1_LFIR, bit(1)) ? self_th_32perDay;

    /** N1_LFIR[2]
     *  Clock Controller: PCB Access Error
     */
    (rN1_LFIR, bit(2)) ? self_th_32perDay;

    /** N1_LFIR[3]
     *  Clock Controller: Summarized Error
     */
    (rN1_LFIR, bit(3)) ? self_th_32perDay;

    /** N1_LFIR[4]
     *  PSCOM Logic: PCB Access Error
     */
    (rN1_LFIR, bit(4)) ? defaultMaskedError;

    /** N1_LFIR[5]
     *  PSCOM Logic: Summarized internal errors
     */
    (rN1_LFIR, bit(5)) ? defaultMaskedError;

    /** N1_LFIR[6]
     *  Therm Logic: Summarized internal errors
     */
    (rN1_LFIR, bit(6)) ? defaultMaskedError;

    /** N1_LFIR[7]
     *  Therm Logic: PCB Access Error
     */
    (rN1_LFIR, bit(7)) ? defaultMaskedError;

    /** N1_LFIR[8]
     *  Therm Logic: Temperature critical trip
     */
    (rN1_LFIR, bit(8)) ? defaultMaskedError;

    /** N1_LFIR[9]
     *  Therm Logic: Temperature fatal trip
     */
    (rN1_LFIR, bit(9)) ? defaultMaskedError;

    /** N1_LFIR[10]
     *  UNUSED in P9
     */
    (rN1_LFIR, bit(10)) ? defaultMaskedError;

    /** N1_LFIR[11]
     *  Debug Logic: Scom Satellite Error
     */
    (rN1_LFIR, bit(11)) ? defaultMaskedError;

    /** N1_LFIR[12]
     *  Scom Satellite Error - Trace0
     */
    (rN1_LFIR, bit(12)) ? defaultMaskedError;

    /** N1_LFIR[13]
     *  Scom Satellite Error - Trace0
     */
    (rN1_LFIR, bit(13)) ? defaultMaskedError;

    /** N1_LFIR[14]
     *  Scom Satellite Error - Trace1
     */
    (rN1_LFIR, bit(14)) ? defaultMaskedError;

    /** N1_LFIR[15]
     *  Scom Satellite Error - Trace1
     */
    (rN1_LFIR, bit(15)) ? defaultMaskedError;

    /** N1_LFIR[16:23]
     *  spare
     */
    (rN1_LFIR, bit(16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** N1_LFIR[24]
     *  Unused
     */
    (rN1_LFIR, bit(24)) ? defaultMaskedError;

    /** N1_LFIR[25]
     *  Unused
     */
    (rN1_LFIR, bit(25)) ? defaultMaskedError;

    /** N1_LFIR[26:40]
     *  spare
     */
    (rN1_LFIR, bit(26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** N1_LFIR[41]
     *  Malfunction Alert or Local Checkstop
     */
    (rN1_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip MCDFIR 0
################################################################################

rule rMCDFIR_0
{
  CHECK_STOP:
    MCDFIR_0 & ~MCDFIR_0_MASK & ~MCDFIR_0_ACT0 & ~MCDFIR_0_ACT1;
  RECOVERABLE:
    MCDFIR_0 & ~MCDFIR_0_MASK & ~MCDFIR_0_ACT0 &  MCDFIR_0_ACT1;
};

group gMCDFIR_0
    filter singlebit,
           cs_root_cause
{
    /** MCDFIR_0[0]
     *  MCD array had a unrecoverable ECC error
     */
    (rMCDFIR_0, bit(0)) ? self_th_32perDay;

    /** MCDFIR_0[1]
     *  MCD array had a correctable ECC error
     */
    (rMCDFIR_0, bit(1)) ? defaultMaskedError;

    /** MCDFIR_0[2]
     *  PowerBus address Parity Error
     */
    (rMCDFIR_0, bit(2)) ? self_th_1;

    /** MCDFIR_0[3]
     *  Register bit flip in State Machine Logic
     */
    (rMCDFIR_0, bit(3)) ? self_th_1;

    /** MCDFIR_0[4]
     *  cl_probe command hung
     */
    (rMCDFIR_0, bit(4)) ? defaultMaskedError;

    /** MCDFIR_0[5]
     *  cResp for cl_probe is address error.
     */
    (rMCDFIR_0, bit(5)) ? defaultMaskedError;

    /** MCDFIR_0[6]
     *  Unsolicited cresp received
     */
    (rMCDFIR_0, bit(6)) ? self_th_1;

    /** MCDFIR_0[7]
     *  PowerBus ttag Parity Error
     */
    (rMCDFIR_0, bit(7)) ? self_th_1;

    /** MCDFIR_0[8]
     *  MCD scom register update error
     */
    (rMCDFIR_0, bit(8)) ? self_th_1;

    /** MCDFIR_0[9]
     *  ack_dead_cresp received
     */
    (rMCDFIR_0, bit(9)) ? defaultMaskedError;

    /** MCDFIR_0[10]
     *  Internal SCOM error
     */
    (rMCDFIR_0, bit(10)) ? defaultMaskedError;

    /** MCDFIR_0[11]
     *  Internal SCOM error
     */
    (rMCDFIR_0, bit(11)) ? defaultMaskedError;

};

################################################################################
# P9 chip MCDFIR 1
################################################################################

rule rMCDFIR_1
{
  CHECK_STOP:
    MCDFIR_1 & ~MCDFIR_1_MASK & ~MCDFIR_1_ACT0 & ~MCDFIR_1_ACT1;
  RECOVERABLE:
    MCDFIR_1 & ~MCDFIR_1_MASK & ~MCDFIR_1_ACT0 &  MCDFIR_1_ACT1;
};

group gMCDFIR_1
    filter singlebit,
           cs_root_cause
{
    /** MCDFIR_1[0]
     *  MCD array had a unrecoverable ECC error
     */
    (rMCDFIR_1, bit(0)) ? self_th_32perDay;

    /** MCDFIR_1[1]
     *  MCD array had a correctable ECC error
     */
    (rMCDFIR_1, bit(1)) ? defaultMaskedError;

    /** MCDFIR_1[2]
     *  PowerBus address Parity Error
     */
    (rMCDFIR_1, bit(2)) ? self_th_1;

    /** MCDFIR_1[3]
     *  Register bit flip in State Machine Logic
     */
    (rMCDFIR_1, bit(3)) ? self_th_1;

    /** MCDFIR_1[4]
     *  cl_probe command hung
     */
    (rMCDFIR_1, bit(4)) ? defaultMaskedError;

    /** MCDFIR_1[5]
     *  cResp for cl_probe is address error.
     */
    (rMCDFIR_1, bit(5)) ? defaultMaskedError;

    /** MCDFIR_1[6]
     *  Unsolicited cresp received
     */
    (rMCDFIR_1, bit(6)) ? self_th_1;

    /** MCDFIR_1[7]
     *  PowerBus ttag Parity Error
     */
    (rMCDFIR_1, bit(7)) ? self_th_1;

    /** MCDFIR_1[8]
     *  MCD scom register update error
     */
    (rMCDFIR_1, bit(8)) ? self_th_1;

    /** MCDFIR_1[9]
     *  ack_dead_cresp received
     */
    (rMCDFIR_1, bit(9)) ? defaultMaskedError;

    /** MCDFIR_1[10]
     *  Internal SCOM error
     */
    (rMCDFIR_1, bit(10)) ? defaultMaskedError;

    /** MCDFIR_1[11]
     *  Internal SCOM error
     */
    (rMCDFIR_1, bit(11)) ? defaultMaskedError;

};

################################################################################
# P9 chip VASFIR
################################################################################

rule rVASFIR
{
  CHECK_STOP:
    VASFIR & ~VASFIR_MASK & ~VASFIR_ACT0 & ~VASFIR_ACT1;
  RECOVERABLE:
    VASFIR & ~VASFIR_MASK & ~VASFIR_ACT0 &  VASFIR_ACT1;
  UNIT_CS:
    VASFIR & ~VASFIR_MASK &  VASFIR_ACT0 &  VASFIR_ACT1;
};

group gVASFIR
    filter singlebit,
           cs_root_cause
{
    /** VASFIR[0]
     *  Egress Hardware Error
     */
    (rVASFIR, bit(0)) ? self_th_1;

    /** VASFIR[1]
     *  Ingress Hardware Error
     */
    (rVASFIR, bit(1)) ? self_th_1;

    /** VASFIR[2]
     *  PowerBus (CQ) Hardware Error
     */
    (rVASFIR, bit(2)) ? self_th_1;

    /** VASFIR[3]
     *  Window Context Cache Hardware Error
     */
    (rVASFIR, bit(3)) ? self_th_1;

    /** VASFIR[4]
     *  Register/MMIO Hardware Error
     */
    (rVASFIR, bit(4)) ? self_th_1;

    /** VASFIR[5]
     *  PowerBus (CQ) Interface Parity Error
     */
    (rVASFIR, bit(5)) ? self_th_1;

    /** VASFIR[6]
     *  PB(CQ) Addr Error CRESP on Read
     */
    (rVASFIR, bit(6)) ? self_M_level2_L_th_1;

    /** VASFIR[7]
     *  PB (CQ) Address Error CRESP on Write
     */
    (rVASFIR, bit(7)) ? self_M_level2_L_th_1;

    /** VASFIR[8]
     *  Egress Correctable ECC Error
     */
    (rVASFIR, bit(8)) ? self_th_5perHour;

    /** VASFIR[9]
     *  Ingress Correctable ECC Error
     */
    (rVASFIR, bit(9)) ? self_th_5perHour;

    /** VASFIR[10]
     *  PB (CQ) CE on inbound/array data
     */
    (rVASFIR, bit(10)) ? defaultMaskedError;

    /** VASFIR[11]
     *  WC Correctable ECC Error
     */
    (rVASFIR, bit(11)) ? self_th_5perHour;

    /** VASFIR[12]
     *  Register/MMIO Correctable ECC Error
     */
    (rVASFIR, bit(12)) ? self_th_5perHour;

    /** VASFIR[13]
     *  PB Correctable Error on outbound data
     */
    (rVASFIR, bit(13)) ? self_th_5perHour;

    /** VASFIR[14]
     *  PB Uncorrectable  Error on outbound data
     */
    (rVASFIR, bit(14)) ? self_th_1;

    /** VASFIR[15]
     *  PB Master State Machine Hang
     */
    (rVASFIR, bit(15)) ? defaultMaskedError;

    /** VASFIR[16]
     *  EG Uncorrectable ECC Error
     */
    (rVASFIR, bit(16)) ? self_th_1;

    /** VASFIR[17]
     *  IN Uncorrectable ECC Error
     */
    (rVASFIR, bit(17)) ? self_th_1;

    /** VASFIR[18]
     *  PB UE on inbound array data
     */
    (rVASFIR, bit(18)) ? self_th_1;

    /** VASFIR[19]
     *  WC Uncorrectable ECC Error
     */
    (rVASFIR, bit(19)) ? self_th_1;

    /** VASFIR[20]
     *  RG/MMIO Uncorrectable ECC Error
     */
    (rVASFIR, bit(20)) ? self_th_1;

    /** VASFIR[21]
     *  IN CAM Parity Error
     */
    (rVASFIR, bit(21)) ? self_th_1;

    /** VASFIR[22]
     *  IN software castout to active window
     */
    (rVASFIR, bit(22)) ? self_th_1;

    /** VASFIR[23]
     *  spare
     */
    (rVASFIR, bit(23)) ? defaultMaskedError;

    /** VASFIR[24]
     *  EG Special UE (SUE) Error
     */
    (rVASFIR, bit(24)) ? self_th_1_SUE;

    /** VASFIR[25]
     *  IN SUE Error
     */
    (rVASFIR, bit(25)) ? self_th_1_SUE;

    /** VASFIR[26]
     *  PB SUE Error
     */
    (rVASFIR, bit(26)) ? self_th_1_SUE;

    /** VASFIR[27]
     *  WC SUE Error
     */
    (rVASFIR, bit(27)) ? self_th_1_SUE;

    /** VASFIR[28]
     *  RG/MMIO SUE Error
     */
    (rVASFIR, bit(28)) ? self_th_1_SUE;

    /** VASFIR[29]
     *  PB Link Error on Read
     */
    (rVASFIR, bit(29)) ? self_th_1;

    /** VASFIR[30]
     *  PB Link Error on Write
     */
    (rVASFIR, bit(30)) ? defaultMaskedError;

    /** VASFIR[31]
     *  PB Link Abort Op Received
     */
    (rVASFIR, bit(31)) ? self_th_1;

    /** VASFIR[32]
     *  MMIO Read to Unimplemented Reg (HYP)
     */
    (rVASFIR, bit(32)) ? self_th_1;

    /** VASFIR[33]
     *  MMIO Read to Unimplemented Reg (OS)
     */
    (rVASFIR, bit(33)) ? defaultMaskedError;

    /** VASFIR[34]
     *  MMIO Write to Unimplemented Reg (HYP)
     */
    (rVASFIR, bit(34)) ? self_th_1;

    /** VASFIR[35]
     *  MMIO Write to Unimplemented Reg (OS)
     */
    (rVASFIR, bit(35)) ? defaultMaskedError;

    /** VASFIR[36]
     *  non-8B MMIO Detected (HYP)
     */
    (rVASFIR, bit(36)) ? self_th_1;

    /** VASFIR[37]
     *  non-8B MMIO Detected (OS)
     */
    (rVASFIR, bit(37)) ? defaultMaskedError;

    /** VASFIR[38]
     *  Write Monitor Op to non-open Window
     */
    (rVASFIR, bit(38)) ? self_th_1;

    /** VASFIR[39]
     *  Multiple Wr Mon Register Match
     */
    (rVASFIR, bit(39)) ? self_th_1;

    /** VASFIR[40]
     *  Page Migration Requested but not enabled
     */
    (rVASFIR, bit(40)) ? self_th_1;

    /** VASFIR[41]
     *  Page Migration size != FIFO size
     */
    (rVASFIR, bit(41)) ? self_th_1;

    /** VASFIR[42]
     *  ASB Notify not claimed
     */
    (rVASFIR, bit(42)) ? self_th_1;

    /** VASFIR[43]
     *  Write Monitor Op error
     */
    (rVASFIR, bit(43)) ? self_th_1;

    /** VASFIR[44]
     *  VAS rejected a paste command
     */
    (rVASFIR, bit(44)) ? defaultMaskedError;

    /** VASFIR[45]
     *  Data Hang
     */
    (rVASFIR, bit(45)) ? defaultMaskedError;

    /** VASFIR[46]
     *  Incoming PB Parity Error
     */
    (rVASFIR, bit(46)) ? self_th_1;

    /** VASFIR[47]
     *  Error from SCOMFIR satellite
     */
    (rVASFIR, bit(47)) ? defaultMaskedError;

    /** VASFIR[48]
     *  NX_VAS_Local_XSTOP received
     */
    (rVASFIR, bit(48)) ? self_th_1;

    /** VASFIR[49]
     *  scom error
     */
    (rVASFIR, bit(49)) ? defaultMaskedError;

    /** VASFIR[50:51]
     *  spare
     */
    (rVASFIR, bit(50|51)) ? defaultMaskedError;

    /** VASFIR[52]
     *  scom error
     */
    (rVASFIR, bit(52)) ? defaultMaskedError;

    /** VASFIR[53]
     *  scom error
     */
    (rVASFIR, bit(53)) ? defaultMaskedError;

};

################################################################################
# N2 Chiplet FIR
################################################################################

rule rN2_CHIPLET_FIR
{
  CHECK_STOP:
     N2_CHIPLET_CS_FIR       & ~N2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N2_CHIPLET_RE_FIR >> 2) & ~N2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN2_CHIPLET_FIR
    filter singlebit
{
    /** N2_CHIPLET_FIR[3]
     *  Attention from N2_LFIR
     */
    (rN2_CHIPLET_FIR, bit(3)) ? analyzeN2_LFIR;

    /** N2_CHIPLET_FIR[4]
     *  Attention from CXAFIR 1
     */
    (rN2_CHIPLET_FIR, bit(4)) ? analyzeConnectedCAPP1;

    /** N2_CHIPLET_FIR[5]
     *  Attention from PHBNFIR 0
     */
    (rN2_CHIPLET_FIR, bit(5)) ? analyzeConnectedPHB0;

    /** N2_CHIPLET_FIR[6]
     *  Attention from PHBNFIR 1
     */
    (rN2_CHIPLET_FIR, bit(6)) ? analyzeConnectedPHB1;

    /** N2_CHIPLET_FIR[7]
     *  Attention from PHBNFIR 3
     */
    (rN2_CHIPLET_FIR, bit(7)) ? analyzeConnectedPHB3;

    /** N2_CHIPLET_FIR[8]
     *  Attention from PHBNFIR 2
     */
    (rN2_CHIPLET_FIR, bit(8)) ? analyzeConnectedPHB2;

    /** N2_CHIPLET_FIR[9]
     *  Attention from PHBNFIR 4
     */
    (rN2_CHIPLET_FIR, bit(9)) ? analyzeConnectedPHB4;

    /** N2_CHIPLET_FIR[10]
     *  Attention from PHBNFIR 5
     */
    (rN2_CHIPLET_FIR, bit(10)) ? analyzeConnectedPHB5;

    /** N2_CHIPLET_FIR[11]
     *  Attention from PSIFIR
     */
    (rN2_CHIPLET_FIR, bit(11)) ? analyzePSIFIR;

};

################################################################################
# N2 Chiplet Unit Checkstop FIR
################################################################################

rule rN2_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N2_CHIPLET_UCS_FIR & ~(N2_CHIPLET_UCS_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gN2_CHIPLET_UCS_FIR
    filter singlebit
{
    /** N2_CHIPLET_UCS_FIR[1]
     *  Attention from CXAFIR 1
     */
    (rN2_CHIPLET_UCS_FIR, bit(1)) ? analyzeConnectedCAPP1;

};

################################################################################
# P9 chip N2_LFIR
################################################################################

rule rN2_LFIR
{
  CHECK_STOP:
    N2_LFIR & ~N2_LFIR_MASK & ~N2_LFIR_ACT0 & ~N2_LFIR_ACT1;
  RECOVERABLE:
    N2_LFIR & ~N2_LFIR_MASK & ~N2_LFIR_ACT0 &  N2_LFIR_ACT1;
};

group gN2_LFIR
    filter singlebit,
           cs_root_cause
{
    /** N2_LFIR[0]
     *  CFIR internal parity error
     */
    (rN2_LFIR, bit(0)) ? self_th_32perDay;

    /** N2_LFIR[1]
     *  Chiplet Control Reg: PCB Access Error
     */
    (rN2_LFIR, bit(1)) ? self_th_32perDay;

    /** N2_LFIR[2]
     *  Clock Controller: PCB Access Error
     */
    (rN2_LFIR, bit(2)) ? self_th_32perDay;

    /** N2_LFIR[3]
     *  Clock Controller: Summarized Error
     */
    (rN2_LFIR, bit(3)) ? self_th_32perDay;

    /** N2_LFIR[4]
     *  PSCOM Logic: PCB Access Error
     */
    (rN2_LFIR, bit(4)) ? defaultMaskedError;

    /** N2_LFIR[5]
     *  PSCOM Logic: Summarized internal errors
     */
    (rN2_LFIR, bit(5)) ? defaultMaskedError;

    /** N2_LFIR[6]
     *  Therm Logic: Summarized internal errors
     */
    (rN2_LFIR, bit(6)) ? defaultMaskedError;

    /** N2_LFIR[7]
     *  Therm Logic: PCB Access Error
     */
    (rN2_LFIR, bit(7)) ? defaultMaskedError;

    /** N2_LFIR[8]
     *  Therm Logic: Temperature critical trip
     */
    (rN2_LFIR, bit(8)) ? defaultMaskedError;

    /** N2_LFIR[9]
     *  Therm Logic: Temperature fatal trip
     */
    (rN2_LFIR, bit(9)) ? defaultMaskedError;

    /** N2_LFIR[10]
     *  UNUSED in P9
     */
    (rN2_LFIR, bit(10)) ? defaultMaskedError;

    /** N2_LFIR[11]
     *  Debug Logic: Scom Satellite Error
     */
    (rN2_LFIR, bit(11)) ? defaultMaskedError;

    /** N2_LFIR[12]
     *  Scom Satellite Error - Trace0
     */
    (rN2_LFIR, bit(12)) ? defaultMaskedError;

    /** N2_LFIR[13]
     *  Scom Satellite Error - Trace0
     */
    (rN2_LFIR, bit(13)) ? defaultMaskedError;

    /** N2_LFIR[14]
     *  Scom Satellite Error - Trace1
     */
    (rN2_LFIR, bit(14)) ? defaultMaskedError;

    /** N2_LFIR[15]
     *  Scom Satellite Error - Trace1
     */
    (rN2_LFIR, bit(15)) ? defaultMaskedError;

    /** N2_LFIR[16:23]
     *  spare
     */
    (rN2_LFIR, bit(16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** N2_LFIR[24]
     *  Unused
     */
    (rN2_LFIR, bit(24)) ? defaultMaskedError;

    /** N2_LFIR[25]
     *  Unused
     */
    (rN2_LFIR, bit(25)) ? defaultMaskedError;

    /** N2_LFIR[26:40]
     *  spare
     */
    (rN2_LFIR, bit(26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** N2_LFIR[41]
     *  Malfunction Alert or Local Checkstop
     */
    (rN2_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip PSIFIR
################################################################################

rule rPSIFIR
{
  CHECK_STOP:
    PSIFIR & ~PSIFIR_MASK & ~PSIFIR_ACT0 & ~PSIFIR_ACT1;
  RECOVERABLE:
    PSIFIR & ~PSIFIR_MASK & ~PSIFIR_ACT0 &  PSIFIR_ACT1;
};

group gPSIFIR
    filter singlebit,
           cs_root_cause
{
    /** PSIFIR[0:4]
     *  spare
     */
    (rPSIFIR, bit(0|1|2|3|4)) ? defaultMaskedError;

    /** PSIFIR[5]
     *  scom error
     */
    (rPSIFIR, bit(5)) ? defaultMaskedError;

    /** PSIFIR[6]
     *  scom error
     */
    (rPSIFIR, bit(6)) ? defaultMaskedError;

};

################################################################################
# N3 Chiplet FIR
################################################################################

rule rN3_CHIPLET_FIR
{
  CHECK_STOP:
     N3_CHIPLET_CS_FIR       & ~N3_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (N3_CHIPLET_RE_FIR >> 2) & ~N3_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gN3_CHIPLET_FIR
    filter singlebit
{
    /** N3_CHIPLET_FIR[3]
     *  Attention from N3_LFIR
     */
    (rN3_CHIPLET_FIR, bit(3)) ? analyzeN3_LFIR;

    /** N3_CHIPLET_FIR[4]
     *  Attention from MCFIR 0
     */
    (rN3_CHIPLET_FIR, bit(4)) ? analyzeConnectedMCS0;

    /** N3_CHIPLET_FIR[5]
     *  Attention from MCFIR 1
     */
    (rN3_CHIPLET_FIR, bit(5)) ? analyzeConnectedMCS1;

    /** N3_CHIPLET_FIR[6]
     *  Attention from PBWESTFIR
     */
    (rN3_CHIPLET_FIR, bit(6)) ? analyzePBWESTFIR;

    /** N3_CHIPLET_FIR[7]
     *  Attention from PBCENTFIR
     */
    (rN3_CHIPLET_FIR, bit(7)) ? analyzePBCENTFIR;

    /** N3_CHIPLET_FIR[8]
     *  Attention from PBEASTFIR
     */
    (rN3_CHIPLET_FIR, bit(8)) ? analyzePBEASTFIR;

    /** N3_CHIPLET_FIR[10]
     *  Attention from NPU0FIR
     */
    (rN3_CHIPLET_FIR, bit(10)) ? analyzeNPU0FIR;

    /** N3_CHIPLET_FIR[11]
     *  Attention from NPU1FIR
     */
    (rN3_CHIPLET_FIR, bit(11)) ? analyzeNPU1FIR;

    /** N3_CHIPLET_FIR[12]
     *  Attention from NMMUCQFIR
     */
    (rN3_CHIPLET_FIR, bit(12)) ? analyzeNMMUCQFIR;

    /** N3_CHIPLET_FIR[13]
     *  Attention from NMMUFIR
     */
    (rN3_CHIPLET_FIR, bit(13)) ? analyzeNMMUFIR;

    /** N3_CHIPLET_FIR[14]
     *  Attention from PBPPEFIR
     */
    (rN3_CHIPLET_FIR, bit(14)) ? analyzePBPPEFIR;

    /** N3_CHIPLET_FIR[15]
     *  Attention from PBIOEFIR
     */
    (rN3_CHIPLET_FIR, bit(15)) ? analyzePBIOEFIR;

    /** N3_CHIPLET_FIR[16]
     *  Attention from PBIOOFIR
     */
    (rN3_CHIPLET_FIR, bit(16)) ? analyzePBIOOFIR;

    /** N3_CHIPLET_FIR[17]
     *  Attention from INTCQFIR
     */
    (rN3_CHIPLET_FIR, bit(17)) ? analyzeINTCQFIR;

    /** N3_CHIPLET_FIR[18]
     *  Attention from PBAFIR
     */
    (rN3_CHIPLET_FIR, bit(18)) ? analyzePBAFIR;

    /** N3_CHIPLET_FIR[19]
     *  Attention from PSIHBFIR
     */
    (rN3_CHIPLET_FIR, bit(19)) ? analyzePSIHBFIR;

    /** N3_CHIPLET_FIR[20]
     *  Attention from PBAMFIR
     */
    (rN3_CHIPLET_FIR, bit(20)) ? analyzePBAMFIR;

    /** N3_CHIPLET_FIR[22]
     *  Attention from ENHCAFIR
     */
    (rN3_CHIPLET_FIR, bit(22)) ? analyzeENHCAFIR;

    /** N3_CHIPLET_FIR[23]
     *  Attention from NPU2FIR
     */
    (rN3_CHIPLET_FIR, bit(23)) ? analyzeNPU2FIR;

};

################################################################################
# N3 Chiplet Unit Checkstop FIR
################################################################################

rule rN3_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N3_CHIPLET_UCS_FIR & ~(N3_CHIPLET_UCS_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gN3_CHIPLET_UCS_FIR
    filter singlebit
{
    /** N3_CHIPLET_UCS_FIR[1]
     *  Attention from MCFIR 0
     */
    (rN3_CHIPLET_UCS_FIR, bit(1)) ? analyzeConnectedMCS0;

    /** N3_CHIPLET_UCS_FIR[2]
     *  Attention from MCFIR 1
     */
    (rN3_CHIPLET_UCS_FIR, bit(2)) ? analyzeConnectedMCS1;

    /** N3_CHIPLET_UCS_FIR[6]
     *  Attention from NPU2FIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(6)) ? analyzeNPU2FIR;

    /** N3_CHIPLET_UCS_FIR[7]
     *  Attention from NPU0FIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(7)) ? analyzeNPU0FIR;

    /** N3_CHIPLET_UCS_FIR[8]
     *  Attention from NPU1FIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(8)) ? analyzeNPU1FIR;

    /** N3_CHIPLET_UCS_FIR[9]
     *  Attention from NMMUCQFIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(9)) ? analyzeNMMUCQFIR;

    /** N3_CHIPLET_UCS_FIR[10]
     *  Attention from NMMUFIR
     */
    (rN3_CHIPLET_UCS_FIR, bit(10)) ? analyzeNMMUFIR;

};

################################################################################
# N3 Chiplet Host Attention FIR
################################################################################

rule rN3_CHIPLET_HA_FIR
{
  HOST_ATTN:
    N3_CHIPLET_HA_FIR & ~(N3_CHIPLET_HA_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gN3_CHIPLET_HA_FIR
    filter singlebit
{
    /** N3_CHIPLET_HA_FIR[1]
     *  Attention from MCFIR 0
     */
    (rN3_CHIPLET_HA_FIR, bit(1)) ? analyzeConnectedMCS0;

    /** N3_CHIPLET_HA_FIR[2]
     *  Attention from MCFIR 1
     */
    (rN3_CHIPLET_HA_FIR, bit(2)) ? analyzeConnectedMCS1;

};

################################################################################
# P9 chip N3_LFIR
################################################################################

rule rN3_LFIR
{
  CHECK_STOP:
    N3_LFIR & ~N3_LFIR_MASK & ~N3_LFIR_ACT0 & ~N3_LFIR_ACT1;
  RECOVERABLE:
    N3_LFIR & ~N3_LFIR_MASK & ~N3_LFIR_ACT0 &  N3_LFIR_ACT1;
};

group gN3_LFIR
    filter singlebit,
           cs_root_cause
{
    /** N3_LFIR[0]
     *  CFIR internal parity error
     */
    (rN3_LFIR, bit(0)) ? self_th_32perDay;

    /** N3_LFIR[1]
     *  Chiplet Control Reg: PCB Access Error
     */
    (rN3_LFIR, bit(1)) ? self_th_32perDay;

    /** N3_LFIR[2]
     *  Clock Controller: PCB Access Error
     */
    (rN3_LFIR, bit(2)) ? self_th_32perDay;

    /** N3_LFIR[3]
     *  Clock Controller: Summarized Error
     */
    (rN3_LFIR, bit(3)) ? self_th_32perDay;

    /** N3_LFIR[4]
     *  PSCOM Logic: PCB Access Error
     */
    (rN3_LFIR, bit(4)) ? defaultMaskedError;

    /** N3_LFIR[5]
     *  PSCOM Logic: Summarized internal errors
     */
    (rN3_LFIR, bit(5)) ? defaultMaskedError;

    /** N3_LFIR[6]
     *  Therm Logic: Summarized internal errors
     */
    (rN3_LFIR, bit(6)) ? defaultMaskedError;

    /** N3_LFIR[7]
     *  Therm Logic: PCB Access Error
     */
    (rN3_LFIR, bit(7)) ? defaultMaskedError;

    /** N3_LFIR[8]
     *  Therm Logic: Temperature critical trip
     */
    (rN3_LFIR, bit(8)) ? defaultMaskedError;

    /** N3_LFIR[9]
     *  Therm Logic: Temperature fatal trip
     */
    (rN3_LFIR, bit(9)) ? defaultMaskedError;

    /** N3_LFIR[10]
     *  UNUSED in P9
     */
    (rN3_LFIR, bit(10)) ? defaultMaskedError;

    /** N3_LFIR[11]
     *  Debug Logic: Scom Satellite Error
     */
    (rN3_LFIR, bit(11)) ? defaultMaskedError;

    /** N3_LFIR[12]
     *  Scom Satellite Error - Trace0
     */
    (rN3_LFIR, bit(12)) ? defaultMaskedError;

    /** N3_LFIR[13]
     *  Scom Satellite Error - Trace0
     */
    (rN3_LFIR, bit(13)) ? defaultMaskedError;

    /** N3_LFIR[14]
     *  Scom Satellite Error - Trace1
     */
    (rN3_LFIR, bit(14)) ? defaultMaskedError;

    /** N3_LFIR[15]
     *  Scom Satellite Error - Trace1
     */
    (rN3_LFIR, bit(15)) ? defaultMaskedError;

    /** N3_LFIR[16:23]
     *  spare
     */
    (rN3_LFIR, bit(16|17|18|19|20|21|22|23)) ? defaultMaskedError;

    /** N3_LFIR[24]
     *  Unused
     */
    (rN3_LFIR, bit(24)) ? defaultMaskedError;

    /** N3_LFIR[25]
     *  Unused
     */
    (rN3_LFIR, bit(25)) ? defaultMaskedError;

    /** N3_LFIR[26:31]
     *  spare
     */
    (rN3_LFIR, bit(26|27|28|29|30|31)) ? defaultMaskedError;

    /** N3_LFIR[32]
     *  deadman timer expired
     */
    (rN3_LFIR, bit(32)) ? deadmanTimer;

    /** N3_LFIR[33]
     *  system quiesce failed
     */
    (rN3_LFIR, bit(33)) ? self_th_1;

    /** N3_LFIR[34]
     *  chip quiesce failed
     */
    (rN3_LFIR, bit(34)) ? self_th_1;

    /** N3_LFIR[35:40]
     *  spare
     */
    (rN3_LFIR, bit(35|36|37|38|39|40)) ? defaultMaskedError;

    /** N3_LFIR[41]
     *  Malfunction Alert or Local Checkstop
     */
    (rN3_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBWESTFIR
################################################################################

rule rPBWESTFIR
{
  CHECK_STOP:
    PBWESTFIR & ~PBWESTFIR_MASK & ~PBWESTFIR_ACT0 & ~PBWESTFIR_ACT1;
  RECOVERABLE:
    PBWESTFIR & ~PBWESTFIR_MASK & ~PBWESTFIR_ACT0 &  PBWESTFIR_ACT1;
};

group gPBWESTFIR
    filter singlebit,
           cs_root_cause
{
    /** PBWESTFIR[0]
     *  pbeq0 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(0)) ? self_th_1;

    /** PBWESTFIR[1]
     *  pbeq0 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(1)) ? self_th_1;

    /** PBWESTFIR[2]
     *  pbieq0_pbh_protocol_error
     */
    (rPBWESTFIR, bit(2)) ? self_th_1;

    /** PBWESTFIR[3]
     *  pbieq0_pbh_overflow_error
     */
    (rPBWESTFIR, bit(3)) ? self_th_1;

    /** PBWESTFIR[4]
     *  pbeq1 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(4)) ? self_th_1;

    /** PBWESTFIR[5]
     *  pbeq1 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(5)) ? self_th_1;

    /** PBWESTFIR[6]
     *  pbieq1_pbh_protocol_error
     */
    (rPBWESTFIR, bit(6)) ? self_th_1;

    /** PBWESTFIR[7]
     *  pbieq1_pbh_overflow_error
     */
    (rPBWESTFIR, bit(7)) ? self_th_1;

    /** PBWESTFIR[8]
     *  pbeq2 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(8)) ? self_th_1;

    /** PBWESTFIR[9]
     *  pbeq2 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(9)) ? self_th_1;

    /** PBWESTFIR[10]
     *  pbieq2_pbh_protocol_error
     */
    (rPBWESTFIR, bit(10)) ? self_th_1;

    /** PBWESTFIR[11]
     *  pbieq2_pbh_overflow_error
     */
    (rPBWESTFIR, bit(11)) ? self_th_1;

    /** PBWESTFIR[12]
     *  pbeq3 hw1 error, PE in custom array
     */
    (rPBWESTFIR, bit(12)) ? self_th_1;

    /** PBWESTFIR[13]
     *  pbeq3 hw2 error, PE in custom array
     */
    (rPBWESTFIR, bit(13)) ? self_th_1;

    /** PBWESTFIR[14]
     *  pbieq3_pbh_protocol_error
     */
    (rPBWESTFIR, bit(14)) ? self_th_1;

    /** PBWESTFIR[15]
     *  pbieq3_pbh_overflow_error
     */
    (rPBWESTFIR, bit(15)) ? self_th_1;

    /** PBWESTFIR[16:31]
     *  spare
     */
    (rPBWESTFIR, bit(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31)) ? defaultMaskedError;

    /** PBWESTFIR[32]
     *  scom error
     */
    (rPBWESTFIR, bit(32)) ? defaultMaskedError;

    /** PBWESTFIR[33]
     *  scom error
     */
    (rPBWESTFIR, bit(33)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBCENTFIR
################################################################################

rule rPBCENTFIR
{
  CHECK_STOP:
    PBCENTFIR & ~PBCENTFIR_MASK & ~PBCENTFIR_ACT0 & ~PBCENTFIR_ACT1;
  RECOVERABLE:
    PBCENTFIR & ~PBCENTFIR_MASK & ~PBCENTFIR_ACT0 &  PBCENTFIR_ACT1;
};

group gPBCENTFIR
    filter singlebit,
           cs_root_cause
{
    /** PBCENTFIR[0]
     *  pb protocol_error
     */
    (rPBCENTFIR, bit(0)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[1]
     *  pb overflow error
     */
    (rPBCENTFIR, bit(1)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[2]
     *  pw hw parity error
     */
    (rPBCENTFIR, bit(2)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[3]
     *  spare
     */
    (rPBCENTFIR, bit(3)) ? defaultMaskedError;

    /** PBCENTFIR[4]
     *  pb coherency error
     */
    (rPBCENTFIR, bit(4)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[5]
     *  pb cresp addr error
     */
    (rPBCENTFIR, bit(5)) ? defaultMaskedError;

    /** PBCENTFIR[6]
     *  pb cresp error
     */
    (rPBCENTFIR, bit(6)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[7]
     *  pb hang recovery limit error
     */
    (rPBCENTFIR, bit(7)) ? defaultMaskedError;

    /** PBCENTFIR[8]
     *  pb data_route_error
     */
    (rPBCENTFIR, bit(8)) ? level2_M_self_L_th_1;

    /** PBCENTFIR[9]
     *  pb hang_recovery_gte_level1
     */
    (rPBCENTFIR, bit(9)) ? pb_cent_hang_recovery_gte;

    /** PBCENTFIR[10]
     *  pb fsp checkstop
     */
    (rPBCENTFIR, bit(10)) ? level2_dump_SW;

    /** PBCENTFIR[11:15]
     *  spare
     */
    (rPBCENTFIR, bit(11|12|13|14|15)) ? defaultMaskedError;

    /** PBCENTFIR[16]
     *  scom error
     */
    (rPBCENTFIR, bit(16)) ? defaultMaskedError;

    /** PBCENTFIR[17]
     *  scom error
     */
    (rPBCENTFIR, bit(17)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBEASTFIR
################################################################################

rule rPBEASTFIR
{
  CHECK_STOP:
    PBEASTFIR & ~PBEASTFIR_MASK & ~PBEASTFIR_ACT0 & ~PBEASTFIR_ACT1;
  RECOVERABLE:
    PBEASTFIR & ~PBEASTFIR_MASK & ~PBEASTFIR_ACT0 &  PBEASTFIR_ACT1;
};

group gPBEASTFIR
    filter singlebit,
           cs_root_cause
{
    /** PBEASTFIR[0]
     *  pbieq4_pbh_hw1_error
     */
    (rPBEASTFIR, bit(0)) ? self_th_1;

    /** PBEASTFIR[1]
     *  pbieq4_pbh_hw2_error
     */
    (rPBEASTFIR, bit(1)) ? self_th_1;

    /** PBEASTFIR[2]
     *  pbieq4_pbh_protocol_error
     */
    (rPBEASTFIR, bit(2)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[3]
     *  pbieq4_pbh_overflow_error
     */
    (rPBEASTFIR, bit(3)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[4]
     *  pbieq5_pbh_hw1_error
     */
    (rPBEASTFIR, bit(4)) ? self_th_1;

    /** PBEASTFIR[5]
     *  pbieq5_pbh_hw2_error
     */
    (rPBEASTFIR, bit(5)) ? self_th_1;

    /** PBEASTFIR[6]
     *  pbieq5_pbh_protocol_error
     */
    (rPBEASTFIR, bit(6)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[7]
     *  pbieq5_pbh_overflow_error
     */
    (rPBEASTFIR, bit(7)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[8:15]
     *  spare
     */
    (rPBEASTFIR, bit(8|9|10|11|12|13|14|15)) ? defaultMaskedError;

    /** PBEASTFIR[16]
     *  pb data_overflow_error
     */
    (rPBEASTFIR, bit(16)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[17]
     *  pb data_protocol_error
     */
    (rPBEASTFIR, bit(17)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[18]
     *  pb data_route_error
     */
    (rPBEASTFIR, bit(18)) ? level2_M_self_L_th_1;

    /** PBEASTFIR[19:30]
     *  spare
     */
    (rPBEASTFIR, bit(19|20|21|22|23|24|25|26|27|28|29|30)) ? defaultMaskedError;

    /** PBEASTFIR[31]
     *  Hypervisor initiated checkstop for TI
     */
    (rPBEASTFIR, bit(31)) ? level2_th_1;

    /** PBEASTFIR[32]
     *  scom error
     */
    (rPBEASTFIR, bit(32)) ? defaultMaskedError;

    /** PBEASTFIR[33]
     *  scom error
     */
    (rPBEASTFIR, bit(33)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBPPEFIR
################################################################################

rule rPBPPEFIR
{
  CHECK_STOP:
    PBPPEFIR & ~PBPPEFIR_MASK & ~PBPPEFIR_ACT0 & ~PBPPEFIR_ACT1;
  RECOVERABLE:
    PBPPEFIR & ~PBPPEFIR_MASK & ~PBPPEFIR_ACT0 &  PBPPEFIR_ACT1;
};

group gPBPPEFIR
    filter singlebit,
           cs_root_cause
{
    /** PBPPEFIR[0]
     *  PPE asserted an internally detected err
     */
    (rPBPPEFIR, bit(0)) ? threshold_and_mask_self;

    /** PBPPEFIR[1]
     *  PPE err on ext interface to the Mem
     */
    (rPBPPEFIR, bit(1)) ? threshold_and_mask_self;

    /** PBPPEFIR[2]
     *  PPE halted due to lack of progress.
     */
    (rPBPPEFIR, bit(2)) ? threshold_and_mask_self;

    /** PBPPEFIR[3]
     *  PPE halted on breakpoint event.
     */
    (rPBPPEFIR, bit(3)) ? threshold_and_mask_self;

    /** PBPPEFIR[4]
     *  PPE watchdog expired
     */
    (rPBPPEFIR, bit(4)) ? defaultMaskedError;

    /** PBPPEFIR[5]
     *  PPE halt
     */
    (rPBPPEFIR, bit(5)) ? defaultMaskedError;

    /** PBPPEFIR[6]
     *  PPE debug trigger
     */
    (rPBPPEFIR, bit(6)) ? defaultMaskedError;

    /** PBPPEFIR[7]
     *  SRAM uncorrectable error
     */
    (rPBPPEFIR, bit(7)) ? threshold_and_mask_self;

    /** PBPPEFIR[8]
     *  SRM correctable error
     */
    (rPBPPEFIR, bit(8)) ? threshold_and_mask_self;

    /** PBPPEFIR[9]
     *  Scrub timer tick while scrub pending
     */
    (rPBPPEFIR, bit(9)) ? threshold_and_mask_self;

    /** PBPPEFIR[10]
     *  reserved
     */
    (rPBPPEFIR, bit(10)) ? defaultMaskedError;

    /** PBPPEFIR[11]
     *  spare
     */
    (rPBPPEFIR, bit(11)) ? defaultMaskedError;

    /** PBPPEFIR[12]
     *  scom error
     */
    (rPBPPEFIR, bit(12)) ? defaultMaskedError;

    /** PBPPEFIR[13]
     *  scom error
     */
    (rPBPPEFIR, bit(13)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBAFIR
################################################################################

rule rPBAFIR
{
  CHECK_STOP:
    PBAFIR & ~PBAFIR_MASK & ~PBAFIR_ACT0 & ~PBAFIR_ACT1;
  RECOVERABLE:
    PBAFIR & ~PBAFIR_MASK & ~PBAFIR_ACT0 &  PBAFIR_ACT1;
};

group gPBAFIR
    filter singlebit,
           cs_root_cause
{
    /** PBAFIR[0]
     *  PBA OCI Addr PE err
     */
    (rPBAFIR, bit(0)) ? self_th_1;

    /** PBAFIR[1]
     *  PBA CRESP Addr Error for Read
     */
    (rPBAFIR, bit(1)) ? defaultMaskedError;

    /** PBAFIR[2]
     *  PBA Read Data Timeout
     */
    (rPBAFIR, bit(2)) ? defaultMaskedError;

    /** PBAFIR[3]
     *  PBA Read Data SUE Error
     */
    (rPBAFIR, bit(3)) ? defaultMaskedError;

    /** PBAFIR[4]
     *  PBA Read Data UE Error
     */
    (rPBAFIR, bit(4)) ? self_th_1;

    /** PBAFIR[5]
     *  PBA Read Data CE Error
     */
    (rPBAFIR, bit(5)) ? self_th_32perDay;

    /** PBAFIR[6]
     *  PBA OCI Slave Initialization Error
     */
    (rPBAFIR, bit(6)) ? level2_dump_SW;

    /** PBAFIR[7]
     *  OCI Write Data Parity Error
     */
    (rPBAFIR, bit(7)) ? self_th_1;

    /** PBAFIR[8]
     *  spare
     */
    (rPBAFIR, bit(8)) ? defaultMaskedError;

    /** PBAFIR[9]
     *  PBA Unexpected CRESP
     */
    (rPBAFIR, bit(9)) ? level2_th_1;

    /** PBAFIR[10]
     *  PBA Unexpected Data PB data received
     */
    (rPBAFIR, bit(10)) ? level2_th_1;

    /** PBAFIR[11]
     *  PBA Tag parity Error
     */
    (rPBAFIR, bit(11)) ? self_th_1;

    /** PBAFIR[12]
     *  PBA CRESP Addr Error for Write
     */
    (rPBAFIR, bit(12)) ? level2_th_1;

    /** PBAFIR[13]
     *  PBA Invalid CRESP
     */
    (rPBAFIR, bit(13)) ? level2_th_1;

    /** PBAFIR[14]
     *  PBA CRESP ACK Dead response r
     */
    (rPBAFIR, bit(14)) ? defaultMaskedError;

    /** PBAFIR[15]
     *  PBA OPERATIONAL Timeout detected
     */
    (rPBAFIR, bit(15)) ? level2_th_1;

    /** PBAFIR[16]
     *  BCUE Setup Error
     */
    (rPBAFIR, bit(16)) ? defaultMaskedError;

    /** PBAFIR[17]
     *  BCUE PowerBus Link
     */
    (rPBAFIR, bit(17)) ? defaultMaskedError;

    /** PBAFIR[18]
     *  PBA CRESP Addr Error for BC Write
     */
    (rPBAFIR, bit(18)) ? defaultMaskedError;

    /** PBAFIR[19]
     *  BCUE Read Data Parity Error OR MRDERR
     */
    (rPBAFIR, bit(19)) ? defaultMaskedError;

    /** PBAFIR[20]
     *  BCDE Setup Error Block Copy Error
     */
    (rPBAFIR, bit(20)) ? defaultMaskedError;

    /** PBAFIR[21]
     *  BCDE PowerBus Link error
     */
    (rPBAFIR, bit(21)) ? defaultMaskedError;

    /** PBAFIR[22]
     *  PBA CRESP Addr Error for BC Read
     */
    (rPBAFIR, bit(22)) ? defaultMaskedError;

    /** PBAFIR[23]
     *  PBA Read Data Timeout
     */
    (rPBAFIR, bit(23)) ? defaultMaskedError;

    /** PBAFIR[24]
     *  PBA Read Data SUE Error
     */
    (rPBAFIR, bit(24)) ? defaultMaskedError;

    /** PBAFIR[25]
     *  PBA Read Data UE Error
     */
    (rPBAFIR, bit(25)) ? defaultMaskedError;

    /** PBAFIR[26]
     *  PBA Read Data CE Error
     */
    (rPBAFIR, bit(26)) ? defaultMaskedError;

    /** PBAFIR[27]
     *  BCDE Write Data error
     */
    (rPBAFIR, bit(27)) ? defaultMaskedError;

    /** PBAFIR[28]
     *  Internal Logic Error.
     */
    (rPBAFIR, bit(28)) ? self_th_1;

    /** PBAFIR[29]
     *  Byte count is less than full cache line
     */
    (rPBAFIR, bit(29)) ? level2_dump_SW;

    /** PBAFIR[30]
     *  Illegal access to OCI Register.
     */
    (rPBAFIR, bit(30)) ? level2_dump_SW;

    /** PBAFIR[31]
     *  Push Write Error.
     */
    (rPBAFIR, bit(31)) ? defaultMaskedError;

    /** PBAFIR[32]
     *  PBAXRCV Low data before High Data
     */
    (rPBAFIR, bit(32)) ? defaultMaskedError;

    /** PBAFIR[33]
     *  PBAXRCV low data timeout
     */
    (rPBAFIR, bit(33)) ? defaultMaskedError;

    /** PBAFIR[34]
     *  PBA Reservation timeout
     */
    (rPBAFIR, bit(34)) ? defaultMaskedError;

    /** PBAFIR[35]
     *  Illegal PBAX Flow.
     */
    (rPBAFIR, bit(35)) ? defaultMaskedError;

    /** PBAFIR[36]
     *  PBA engine retry threshold reached
     */
    (rPBAFIR, bit(36)) ? defaultMaskedError;

    /** PBAFIR[37]
     *  PBA engine retry threshold reached
     */
    (rPBAFIR, bit(37)) ? defaultMaskedError;

    /** PBAFIR[38]
     *  PBAXSND Reservation Timeout
     */
    (rPBAFIR, bit(38)) ? defaultMaskedError;

    /** PBAFIR[39]
     *  PBAXSND Reservation Error.
     */
    (rPBAFIR, bit(39)) ? defaultMaskedError;

    /** PBAFIR[40]
     *  PBA CRESP ACK Dead response
     */
    (rPBAFIR, bit(40)) ? defaultMaskedError;

    /** PBAFIR[41:43]
     *  spare
     */
    (rPBAFIR, bit(41|42|43)) ? defaultMaskedError;

    /** PBAFIR[44]
     *  Internal fir parity error duplicate
     */
    (rPBAFIR, bit(44)) ? defaultMaskedError;

    /** PBAFIR[45]
     *  Internal fir parity error
     */
    (rPBAFIR, bit(45)) ? defaultMaskedError;

};

################################################################################
# P9 chip PSIHBFIR
################################################################################

rule rPSIHBFIR
{
  CHECK_STOP:
    PSIHBFIR & ~PSIHBFIR_MASK & ~PSIHBFIR_ACT0 & ~PSIHBFIR_ACT1;
  RECOVERABLE:
    PSIHBFIR & ~PSIHBFIR_MASK & ~PSIHBFIR_ACT0 &  PSIHBFIR_ACT1;
};

group gPSIHBFIR
    filter singlebit,
           cs_root_cause
{
    /** PSIHBFIR[0]
     *  CE from PowerBus data
     */
    (rPSIHBFIR, bit(0)) ? self_th_32perDay;

    /** PSIHBFIR[1]
     *  UE from PowerBus data
     */
    (rPSIHBFIR, bit(1)) ? self_th_1;

    /** PSIHBFIR[2]
     *  SUE from PowerBus data
     */
    (rPSIHBFIR, bit(2)) ? defaultMaskedError;

    /** PSIHBFIR[3]
     *  Interrupt Condition present in PSIHB
     */
    (rPSIHBFIR, bit(3)) ? defaultMaskedError;

    /** PSIHBFIR[4]
     *  Interrupt from FSP is being processed
     */
    (rPSIHBFIR, bit(4)) ? defaultMaskedError;

    /** PSIHBFIR[5]
     *  CE from PSILL data
     */
    (rPSIHBFIR, bit(5)) ? defaultMaskedError;

    /** PSIHBFIR[6]
     *  UE from PSILL data
     */
    (rPSIHBFIR, bit(6)) ? defaultMaskedError;

    /** PSIHBFIR[7]
     *  Error bit se
     */
    (rPSIHBFIR, bit(7)) ? defaultMaskedError;

    /** PSIHBFIR[8]
     *  Invalid TType Hit on PHB or FSP bar
     */
    (rPSIHBFIR, bit(8)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[9]
     *  Invalid CResp returned
     */
    (rPSIHBFIR, bit(9)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[10]
     *  PowerBus time out waiting for data grant
     */
    (rPSIHBFIR, bit(10)) ? level2_th_1;

    /** PSIHBFIR[11]
     *  PB parity error in a tag/addr bus
     */
    (rPSIHBFIR, bit(11)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[12]
     *  FSP tried access to trusted space
     */
    (rPSIHBFIR, bit(12)) ? level2_th_1;

    /** PSIHBFIR[13]
     *  Unexpected PB CRESP or DATA
     */
    (rPSIHBFIR, bit(13)) ? level2_M_self_L_th_1;

    /** PSIHBFIR[14]
     *  Intr. reg change witn int. pending
     */
    (rPSIHBFIR, bit(14)) ? defaultMaskedError;

    /** PSIHBFIR[15]
     *  PSI Interrupt address Error
     */
    (rPSIHBFIR, bit(15)) ? self_M_level2_L_th_1;

    /** PSIHBFIR[16]
     *  OCC Interrupt address Error
     */
    (rPSIHBFIR, bit(16)) ? self_M_level2_L_th_1;

    /** PSIHBFIR[17]
     *  FSI Interrupt address Error
     */
    (rPSIHBFIR, bit(17)) ? self_M_level2_L_th_1;

    /** PSIHBFIR[18]
     *  LPC Interrupt address Error
     */
    (rPSIHBFIR, bit(18)) ? self_M_level2_L_th_1;

    /** PSIHBFIR[19]
     *  LOCAL ERROR Interrupt address Error
     */
    (rPSIHBFIR, bit(19)) ? self_M_level2_L_th_1;

    /** PSIHBFIR[20]
     *  HOST ERROR Interrupt address Error
     */
    (rPSIHBFIR, bit(20)) ? self_M_level2_L_th_1;

    /** PSIHBFIR[21]
     *  PSI global error bit 0
     */
    (rPSIHBFIR, bit(21)) ? defaultMaskedError;

    /** PSIHBFIR[22]
     *  PSI global error bit 1
     */
    (rPSIHBFIR, bit(22)) ? defaultMaskedError;

    /** PSIHBFIR[23]
     *  Upstream error
     */
    (rPSIHBFIR, bit(23)) ? level2_M_self_L_th_32perDay;

    /** PSIHBFIR[24:26]
     *  spare
     */
    (rPSIHBFIR, bit(24|25|26)) ? defaultMaskedError;

    /** PSIHBFIR[27]
     *  scom error
     */
    (rPSIHBFIR, bit(27)) ? defaultMaskedError;

    /** PSIHBFIR[28]
     *  fir parity Error
     */
    (rPSIHBFIR, bit(28)) ? defaultMaskedError;

};

################################################################################
# P9 chip ENHCAFIR
################################################################################

rule rENHCAFIR
{
  CHECK_STOP:
    ENHCAFIR & ~ENHCAFIR_MASK & ~ENHCAFIR_ACT0 & ~ENHCAFIR_ACT1;
  RECOVERABLE:
    ENHCAFIR & ~ENHCAFIR_MASK & ~ENHCAFIR_ACT0 &  ENHCAFIR_ACT1;
};

group gENHCAFIR
    filter singlebit,
           cs_root_cause
{
    /** ENHCAFIR[0]
     *  PB0 data UE
     */
    (rENHCAFIR, bit(0)) ? defaultMaskedError;

    /** ENHCAFIR[1]
     *  PB0 data SUE
     */
    (rENHCAFIR, bit(1)) ? defaultMaskedError;

    /** ENHCAFIR[2]
     *  PB0 data ue
     */
    (rENHCAFIR, bit(2)) ? defaultMaskedError;

    /** ENHCAFIR[3]
     *  spare
     */
    (rENHCAFIR, bit(3)) ? defaultMaskedError;

    /** ENHCAFIR[4]
     *  Castout Drop Counter Full
     */
    (rENHCAFIR, bit(4)) ? defaultMaskedError;

    /** ENHCAFIR[5]
     *  Data Hang Detect
     */
    (rENHCAFIR, bit(5)) ? defaultMaskedError;

    /** ENHCAFIR[6]
     *  Unexpected data or cresp
     */
    (rENHCAFIR, bit(6)) ? defaultMaskedError;

    /** ENHCAFIR[7]
     *  Internal Error
     */
    (rENHCAFIR, bit(7)) ? defaultMaskedError;

    /** ENHCAFIR[8]
     *  ADU checkstop error from power bus data
     */
    (rENHCAFIR, bit(8)) ? defaultMaskedError;

    /** ENHCAFIR[9]
     *  ADU checkstop error from alter display
     */
    (rENHCAFIR, bit(9)) ? defaultMaskedError;

    /** ENHCAFIR[10]
     *  ADU checkstop error from xsco m
     */
    (rENHCAFIR, bit(10)) ? defaultMaskedError;

    /** ENHCAFIR[11]
     *  ADU checkstop from power bus cmd
     */
    (rENHCAFIR, bit(11)) ? defaultMaskedError;

    /** ENHCAFIR[12]
     *  ADU checkstop error from power bus send
     */
    (rENHCAFIR, bit(12)) ? defaultMaskedError;

    /** ENHCAFIR[13]
     *  ADU checkstop from power bus receive
     */
    (rENHCAFIR, bit(13)) ? defaultMaskedError;

    /** ENHCAFIR[14]
     *  ADU recoverable error from pb data
     */
    (rENHCAFIR, bit(14)) ? defaultMaskedError;

    /** ENHCAFIR[15]
     *  ADU recoverable error from alter display
     */
    (rENHCAFIR, bit(15)) ? defaultMaskedError;

    /** ENHCAFIR[16]
     *  ADU recoverable error from xscom
     */
    (rENHCAFIR, bit(16)) ? defaultMaskedError;

    /** ENHCAFIR[17]
     *  ADU recoverable from power bus cmd
     */
    (rENHCAFIR, bit(17)) ? defaultMaskedError;

    /** ENHCAFIR[18]
     *  ADU recoverable error from pb send
     */
    (rENHCAFIR, bit(18)) ? defaultMaskedError;

    /** ENHCAFIR[19]
     *  ADU recoverable error from pb receive
     */
    (rENHCAFIR, bit(19)) ? defaultMaskedError;

    /** ENHCAFIR[20]
     *  NHTM scom error
     */
    (rENHCAFIR, bit(20)) ? defaultMaskedError;

    /** ENHCAFIR[21]
     *  spare
     */
    (rENHCAFIR, bit(21)) ? defaultMaskedError;

    /** ENHCAFIR[22]
     *  scom error
     */
    (rENHCAFIR, bit(22)) ? defaultMaskedError;

    /** ENHCAFIR[23]
     *  scom error
     */
    (rENHCAFIR, bit(23)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBAMFIR
################################################################################

rule rPBAMFIR
{
  CHECK_STOP:
    PBAMFIR & ~PBAMFIR_MASK & ~PBAMFIR_ACT0 & ~PBAMFIR_ACT1;
  RECOVERABLE:
    PBAMFIR & ~PBAMFIR_MASK & ~PBAMFIR_ACT0 &  PBAMFIR_ACT1;
};

group gPBAMFIR
    filter singlebit,
           cs_root_cause
{
    /** PBAMFIR[0]
     *  action0_for_invalid_transfer_size
     */
    (rPBAMFIR, bit(0)) ? self_th_1;

    /** PBAMFIR[1]
     *  action0_for_invalid_command
     */
    (rPBAMFIR, bit(1)) ? self_th_1;

    /** PBAMFIR[2]
     *  action0_for_invalid_address_alignment
     */
    (rPBAMFIR, bit(2)) ? self_th_1;

    /** PBAMFIR[3]
     *  action0_for_OPB_error
     */
    (rPBAMFIR, bit(3)) ? defaultMaskedError;

    /** PBAMFIR[4]
     *  action0_for_OPB_timeout
     */
    (rPBAMFIR, bit(4)) ? defaultMaskedError;

    /** PBAMFIR[5]
     *  action0_for_OPB_master_hang_timeout
     */
    (rPBAMFIR, bit(5)) ? self_th_32perDay;

    /** PBAMFIR[6]
     *  master_cmd_buffer_parity_error
     */
    (rPBAMFIR, bit(6)) ? self_th_1;

    /** PBAMFIR[7]
     *  master_dat_buffer_parity_error
     */
    (rPBAMFIR, bit(7)) ? self_th_1;

    /** PBAMFIR[8:9]
     *  spare
     */
    (rPBAMFIR, bit(8|9)) ? defaultMaskedError;

    /** PBAMFIR[10]
     *  scom error
     */
    (rPBAMFIR, bit(10)) ? defaultMaskedError;

    /** PBAMFIR[11]
     *  scom error
     */
    (rPBAMFIR, bit(11)) ? defaultMaskedError;

};

################################################################################
# P9 chip NMMUCQFIR
################################################################################

rule rNMMUCQFIR
{
  CHECK_STOP:
    NMMUCQFIR & ~NMMUCQFIR_MASK & ~NMMUCQFIR_ACT0 & ~NMMUCQFIR_ACT1;
  RECOVERABLE:
    NMMUCQFIR & ~NMMUCQFIR_MASK & ~NMMUCQFIR_ACT0 &  NMMUCQFIR_ACT1;
  UNIT_CS:
    NMMUCQFIR & ~NMMUCQFIR_MASK &  NMMUCQFIR_ACT0 &  NMMUCQFIR_ACT1;
};

group gNMMUCQFIR
    filter singlebit,
           cs_root_cause
{
    /** NMMUCQFIR[0]
     *  PBI_PE_FIR: PBI internal parity error
     */
    (rNMMUCQFIR, bit(0)) ? self_th_1;

    /** NMMUCQFIR[1]
     *  PowerBus command hang error
     */
    (rNMMUCQFIR, bit(1)) ? defaultMaskedError;

    /** NMMUCQFIR[2]
     *  PowerBus read address error
     */
    (rNMMUCQFIR, bit(2)) ? self_M_level2_L_th_1;

    /** NMMUCQFIR[3]
     *  PowerBus write address error
     */
    (rNMMUCQFIR, bit(3)) ? self_M_level2_L_th_1;

    /** NMMUCQFIR[4]
     *  PowerBus miscellaneous error
     */
    (rNMMUCQFIR, bit(4)) ? self_th_1;

    /** NMMUCQFIR[5]
     *  spare
     */
    (rNMMUCQFIR, bit(5)) ? defaultMaskedError;

    /** NMMUCQFIR[6]
     *  PowerBus Xlate UE error
     */
    (rNMMUCQFIR, bit(6)) ? self_th_1;

    /** NMMUCQFIR[7]
     *  PowerBus Xlate SUE error
     */
    (rNMMUCQFIR, bit(7)) ? self_th_1_SUE;

    /** NMMUCQFIR[8]
     *  PowerBus CE error
     */
    (rNMMUCQFIR, bit(8)) ? self_th_32perDay;

    /** NMMUCQFIR[9]
     *  PowerBus UE error
     */
    (rNMMUCQFIR, bit(9)) ? self_th_1;

    /** NMMUCQFIR[10]
     *  PowerBus SUE error
     */
    (rNMMUCQFIR, bit(10)) ? defaultMaskedError;

    /** NMMUCQFIR[11]
     *  Inbound LCO_ARRAY CE error
     */
    (rNMMUCQFIR, bit(11)) ? self_th_32perDay;

    /** NMMUCQFIR[12]
     *  Inbound LCO_ARRAY UE error
     */
    (rNMMUCQFIR, bit(12)) ? self_th_1;

    /** NMMUCQFIR[13]
     *  Inbound LCO_ARRAY SUE error
     */
    (rNMMUCQFIR, bit(13)) ? defaultMaskedError;

    /** NMMUCQFIR[14]
     *  Inbound array CE error
     */
    (rNMMUCQFIR, bit(14)) ? self_th_32perDay;

    /** NMMUCQFIR[15]
     *  Inbound array UE error
     */
    (rNMMUCQFIR, bit(15)) ? self_th_1;

    /** NMMUCQFIR[16]
     *  internal state error
     */
    (rNMMUCQFIR, bit(16)) ? self_th_1;

    /** NMMUCQFIR[17]
     *  ACK_DEAD cresp received by read command
     */
    (rNMMUCQFIR, bit(17)) ? defaultMaskedError;

    /** NMMUCQFIR[18]
     *  ACK_DEAD cresp received by write command
     */
    (rNMMUCQFIR, bit(18)) ? defaultMaskedError;

    /** NMMUCQFIR[19]
     *  Link check aborted while waiting on data
     */
    (rNMMUCQFIR, bit(19)) ? defaultMaskedError;

    /** NMMUCQFIR[20]
     *  scom error
     */
    (rNMMUCQFIR, bit(20)) ? defaultMaskedError;

    /** NMMUCQFIR[21]
     *  scom error
     */
    (rNMMUCQFIR, bit(21)) ? defaultMaskedError;

};

################################################################################
# P9 chip NMMUFIR
################################################################################

rule rNMMUFIR
{
  CHECK_STOP:
    NMMUFIR & ~NMMUFIR_MASK & ~NMMUFIR_ACT0 & ~NMMUFIR_ACT1;
  RECOVERABLE:
    NMMUFIR & ~NMMUFIR_MASK & ~NMMUFIR_ACT0 &  NMMUFIR_ACT1;
  UNIT_CS:
    NMMUFIR & ~NMMUFIR_MASK &  NMMUFIR_ACT0 &  NMMUFIR_ACT1;
};

group gNMMUFIR
    filter singlebit,
           cs_root_cause
{
    /** NMMUFIR[0]
     *  Fabric DIn xlat array CE error detected.
     */
    (rNMMUFIR, bit(0)) ? self_th_32perDay;

    /** NMMUFIR[1]
     *  Fabric DIn xlat array UE error detected.
     */
    (rNMMUFIR, bit(1)) ? self_th_1;

    /** NMMUFIR[2]
     *  Fabric DIn xlat array SUE error
     */
    (rNMMUFIR, bit(2)) ? self_th_1_SUE;

    /** NMMUFIR[3]
     *  Fabric mst rd array CE error detected.
     */
    (rNMMUFIR, bit(3)) ? self_th_32perDay;

    /** NMMUFIR[4]
     *  Fabric mst rd array UE error detected.
     */
    (rNMMUFIR, bit(4)) ? self_th_1;

    /** NMMUFIR[5]
     *  Fabric mst rd array SUE error detected.
     */
    (rNMMUFIR, bit(5)) ? defaultMaskedError;

    /** NMMUFIR[6]
     *  Fabric xlat protocol error detected.
     */
    (rNMMUFIR, bit(6)) ? self_th_1;

    /** NMMUFIR[7]
     *  Fabric xlat op timeout detected.
     */
    (rNMMUFIR, bit(7)) ? defaultMaskedError;

    /** NMMUFIR[8]
     *  SLB directory parity error detected.
     */
    (rNMMUFIR, bit(8)) ? self_th_1;

    /** NMMUFIR[9]
     *  SLB cache parity error detected.
     */
    (rNMMUFIR, bit(9)) ? self_th_1;

    /** NMMUFIR[10]
     *  SLB lru parity error detected.
     */
    (rNMMUFIR, bit(10)) ? self_th_1;

    /** NMMUFIR[11]
     *  SLB multi-hit error detected.
     */
    (rNMMUFIR, bit(11)) ? threshold_and_mask_self;

    /** NMMUFIR[12]
     *  TLB directory parity error detected.
     */
    (rNMMUFIR, bit(12)) ? self_th_1;

    /** NMMUFIR[13]
     *  TLB cache parity error detected.
     */
    (rNMMUFIR, bit(13)) ? self_th_1;

    /** NMMUFIR[14]
     *  TLB lru parity error detected.
     */
    (rNMMUFIR, bit(14)) ? self_th_1;

    /** NMMUFIR[15]
     *  TLB multi-hit error detected.
     */
    (rNMMUFIR, bit(15)) ? threshold_and_mask_self;

    /** NMMUFIR[16]
     *  Segment fault detected .
     */
    (rNMMUFIR, bit(16)) ? defaultMaskedError;

    /** NMMUFIR[17]
     *  Page fault detected, no matching pte.
     */
    (rNMMUFIR, bit(17)) ? defaultMaskedError;

    /** NMMUFIR[18]
     *  Page fault, basic prot chk fail.
     */
    (rNMMUFIR, bit(18)) ? defaultMaskedError;

    /** NMMUFIR[19]
     *  Page fault detected, virt prot chk fail.
     */
    (rNMMUFIR, bit(19)) ? defaultMaskedError;

    /** NMMUFIR[20]
     *  Page fault detected,seid mismatch .
     */
    (rNMMUFIR, bit(20)) ? defaultMaskedError;

    /** NMMUFIR[21]
     *  Address error cresp detected by twsm
     */
    (rNMMUFIR, bit(21)) ? self_M_level2_L_th_1;

    /** NMMUFIR[22]
     *  PTE update fail due to armwf mismatch.
     */
    (rNMMUFIR, bit(22)) ? defaultMaskedError;

    /** NMMUFIR[23]
     *  Address error cresp detected by twsm
     */
    (rNMMUFIR, bit(23)) ? self_M_level2_L_th_1;

    /** NMMUFIR[24]
     *  Unsupported radix cfg for guest-side .
     */
    (rNMMUFIR, bit(24)) ? defaultMaskedError;

    /** NMMUFIR[25]
     *  Unsupported radix cfg for host-side .
     */
    (rNMMUFIR, bit(25)) ? defaultMaskedError;

    /** NMMUFIR[26]
     *  Invalid wimg setting detected .
     */
    (rNMMUFIR, bit(26)) ? defaultMaskedError;

    /** NMMUFIR[27]
     *  Invalid radix quad access detected .
     */
    (rNMMUFIR, bit(27)) ? defaultMaskedError;

    /** NMMUFIR[28]
     *  Unexpected access to foreign addr space
     */
    (rNMMUFIR, bit(28)) ? defaultMaskedError;

    /** NMMUFIR[29]
     *  Prefetch abort/fail detected .
     */
    (rNMMUFIR, bit(29)) ? defaultMaskedError;

    /** NMMUFIR[30]
     *  Context cache array parity er
     */
    (rNMMUFIR, bit(30)) ? self_th_1;

    /** NMMUFIR[31]
     *  Radix pwc array parity error detected .
     */
    (rNMMUFIR, bit(31)) ? self_th_1;

    /** NMMUFIR[32]
     *  Tablewalk sm control error detected .
     */
    (rNMMUFIR, bit(32)) ? self_th_1;

    /** NMMUFIR[33]
     *  Castout sm control error detected .
     */
    (rNMMUFIR, bit(33)) ? self_th_1;

    /** NMMUFIR[34]
     *  Check-in sm control error detected .
     */
    (rNMMUFIR, bit(34)) ? self_th_1;

    /** NMMUFIR[35]
     *  Invalidate sm control error detected .
     */
    (rNMMUFIR, bit(35)) ? self_th_1;

    /** NMMUFIR[36]
     *  Tablewalk sm timeout error detected .
     */
    (rNMMUFIR, bit(36)) ? defaultMaskedError;

    /** NMMUFIR[37]
     *  Castout sm timeout error detected .
     */
    (rNMMUFIR, bit(37)) ? defaultMaskedError;

    /** NMMUFIR[38]
     *  Check-in sm timeout error detected .
     */
    (rNMMUFIR, bit(38)) ? defaultMaskedError;

    /** NMMUFIR[39]
     *  Invalidate sm timeout error detected .
     */
    (rNMMUFIR, bit(39)) ? defaultMaskedError;

    /** NMMUFIR[40]
     *  NX local checkstop error detected .
     */
    (rNMMUFIR, bit(40)) ? defaultMaskedError;

    /** NMMUFIR[41]
     *  CP0 local checkstop error detected .
     */
    (rNMMUFIR, bit(41)) ? defaultMaskedError;

    /** NMMUFIR[42]
     *  CP1 local checkstop error detected .
     */
    (rNMMUFIR, bit(42)) ? defaultMaskedError;

    /** NMMUFIR[43]
     *  NPU local checkstop error detected .
     */
    (rNMMUFIR, bit(43)) ? defaultMaskedError;

    /** NMMUFIR[44]
     *  FBC local checkstop error detected .
     */
    (rNMMUFIR, bit(44)) ? defaultMaskedError;

    /** NMMUFIR[45]
     *  Snoop invalidate filter overflow .
     */
    (rNMMUFIR, bit(45)) ? defaultMaskedError;

    /** NMMUFIR[46]
     *  scom error
     */
    (rNMMUFIR, bit(46)) ? defaultMaskedError;

    /** NMMUFIR[47]
     *  scom error
     */
    (rNMMUFIR, bit(47)) ? defaultMaskedError;

};

################################################################################
# P9 chip INTCQFIR
################################################################################

rule rINTCQFIR
{
  CHECK_STOP:
    INTCQFIR & ~INTCQFIR_MASK & ~INTCQFIR_ACT0 & ~INTCQFIR_ACT1;
  RECOVERABLE:
    INTCQFIR & ~INTCQFIR_MASK & ~INTCQFIR_ACT0 &  INTCQFIR_ACT1;
};

group gINTCQFIR
    filter singlebit,
           cs_root_cause
{
    /** INTCQFIR[0]
     *  INT_CQ_FIR_PI_ECC_CE:
     */
    (rINTCQFIR, bit(0)) ? self_th_32perDay;

    /** INTCQFIR[1]
     *  INT_CQ_FIR_PI_ECC_UE:
     */
    (rINTCQFIR, bit(1)) ? self_th_1;

    /** INTCQFIR[2]
     *  INT_CQ_FIR_PI_ECC_SUE:
     */
    (rINTCQFIR, bit(2)) ? self_th_1_SUE;

    /** INTCQFIR[3]
     *  INT_CQ_FIR_ST_ECC_CE:
     */
    (rINTCQFIR, bit(3)) ? self_th_32perDay;

    /** INTCQFIR[4]
     *  INT_CQ_FIR_ST_ECC_UE:
     */
    (rINTCQFIR, bit(4)) ? self_th_1;

    /** INTCQFIR[5]
     *  INT_CQ_FIR_LD_ECC_CE:
     */
    (rINTCQFIR, bit(5)) ? self_th_32perDay;

    /** INTCQFIR[6]
     *  INT_CQ_FIR_LD_ECC_UE:
     */
    (rINTCQFIR, bit(6)) ? self_th_1;

    /** INTCQFIR[7]
     *  INT_CQ_FIR_CL_ECC_CE:
     */
    (rINTCQFIR, bit(7)) ? self_th_32perDay;

    /** INTCQFIR[8]
     *  INT_CQ_FIR_CL_ECC_UE:
     */
    (rINTCQFIR, bit(8)) ? self_th_1;

    /** INTCQFIR[9]
     *  INT_CQ_FIR_WR_ECC_CE:
     */
    (rINTCQFIR, bit(9)) ? self_th_32perDay;

    /** INTCQFIR[10]
     *  INT_CQ_FIR_WR_ECC_UE:
     */
    (rINTCQFIR, bit(10)) ? self_th_1;

    /** INTCQFIR[11]
     *  INT_CQ_FIR_RD_ECC_CE:
     */
    (rINTCQFIR, bit(11)) ? self_th_32perDay;

    /** INTCQFIR[12]
     *  INT_CQ_FIR_RD_ECC_UE:
     */
    (rINTCQFIR, bit(12)) ? self_th_1;

    /** INTCQFIR[13]
     *  INT_CQ_FIR_AI_ECC_CE:
     */
    (rINTCQFIR, bit(13)) ? self_th_32perDay;

    /** INTCQFIR[14]
     *  INT_CQ_FIR_AI_ECC_UE:
     */
    (rINTCQFIR, bit(14)) ? self_th_1;

    /** INTCQFIR[15]
     *  INT_CQ_FIR_AIB_IN_CMD_CTL_PERR:
     */
    (rINTCQFIR, bit(15)) ? self_th_1;

    /** INTCQFIR[16]
     *  INT_CQ_FIR_AIB_IN_CMD_PERR:
     */
    (rINTCQFIR, bit(16)) ? self_th_1;

    /** INTCQFIR[17]
     *  INT_CQ_FIR_AIB_IN_DAT_CTL_PERR:
     */
    (rINTCQFIR, bit(17)) ? self_th_1;

    /** INTCQFIR[18]
     *  INT_CQ_FIR_PB_PARITY_ERROR:
     */
    (rINTCQFIR, bit(18)) ? self_th_1;

    /** INTCQFIR[19]
     *  INT_CQ_FIR_PB_RCMDX_CI_ERR1:
     */
    (rINTCQFIR, bit(19)) ? self_th_1;

    /** INTCQFIR[20]
     *  INT_CQ_FIR_PB_RCMDX_CI_ERR2:
     */
    (rINTCQFIR, bit(20)) ? self_th_1;

    /** INTCQFIR[21]
     *  INT_CQ_FIR_PB_RCMDX_CI_ERR3:
     */
    (rINTCQFIR, bit(21)) ? self_th_1;

    /** INTCQFIR[22]
     *  INT_CQ_FIR_RCVD_POISONED_CIST_DATA:
     */
    (rINTCQFIR, bit(22)) ? self_th_32perDay;

    /** INTCQFIR[23]
     *  INT_CQ_FIR_MRT_ERR_NOT_VALID:
     */
    (rINTCQFIR, bit(23)) ? self_th_1;

    /** INTCQFIR[24]
     *  INT_CQ_FIR_MRT_ERR_PSIZE:
     */
    (rINTCQFIR, bit(24)) ? self_th_1;

    /** INTCQFIR[25]
     *  INT_CQ_FIR_SCOM_S_ERR:
     */
    (rINTCQFIR, bit(25)) ? defaultMaskedError;

    /** INTCQFIR[26]
     *  INT_CQ_FIR_TCTXT_PRESP_ERROR:
     */
    (rINTCQFIR, bit(26)) ? self_th_1;

    /** INTCQFIR[27]
     *  INT_CQ_FIR_WRQ_OP_HANG:
     */
    (rINTCQFIR, bit(27)) ? defaultMaskedError;

    /** INTCQFIR[28]
     *  INT_CQ_FIR_RDQ_OP_HANG:
     */
    (rINTCQFIR, bit(28)) ? defaultMaskedError;

    /** INTCQFIR[29]
     *  INT_CQ_FIR_INTQ_OP_HANG:
     */
    (rINTCQFIR, bit(29)) ? defaultMaskedError;

    /** INTCQFIR[30]
     *  INT_CQ_FIR_RDQ_DATA_HANG:
     */
    (rINTCQFIR, bit(30)) ? self_th_1;

    /** INTCQFIR[31]
     *  INT_CQ_FIR_STQ_DATA_HANG:
     */
    (rINTCQFIR, bit(31)) ? self_th_1;

    /** INTCQFIR[32]
     *  INT_CQ_FIR_LDQ_DATA_HANG:
     */
    (rINTCQFIR, bit(32)) ? self_th_1;

    /** INTCQFIR[33]
     *  INT_CQ_FIR_WRQ_BAD_CRESP:
     */
    (rINTCQFIR, bit(33)) ? self_M_level2_L_th_1;

    /** INTCQFIR[34]
     *  INT_CQ_FIR_RDQ_BAD_CRESP:
     */
    (rINTCQFIR, bit(34)) ? self_M_level2_L_th_1;

    /** INTCQFIR[35]
     *  INT_CQ_FIR_INTQ_BAD_CRESP:
     */
    (rINTCQFIR, bit(35)) ? self_M_level2_L_th_1;

    /** INTCQFIR[36]
     *  INT_CQ_FIR_BAD_128K_VP_OP:
     */
    (rINTCQFIR, bit(36)) ? self_th_1;

    /** INTCQFIR[37]
     *  INT_CQ_FIR_RDQ_ABORT_OP:
     */
    (rINTCQFIR, bit(37)) ? defaultMaskedError;

    /** INTCQFIR[38]
     *  INT_CQ_FIR_PC_CRD_PERR:
     */
    (rINTCQFIR, bit(38)) ? self_th_1;

    /** INTCQFIR[39]
     *  INT_CQ_FIR_PC_CRD_AVAIL_PERR:
     */
    (rINTCQFIR, bit(39)) ? self_th_1;

    /** INTCQFIR[40]
     *  INT_CQ_FIR_VC_CRD_PERR:
     */
    (rINTCQFIR, bit(40)) ? self_th_1;

    /** INTCQFIR[41]
     *  INT_CQ_FIR_VC_CRD_AVAIL_PERR:
     */
    (rINTCQFIR, bit(41)) ? self_th_1;

    /** INTCQFIR[42]
     *  INT_CQ_FIR_CMD_QX_SEVERE_ERR:
     */
    (rINTCQFIR, bit(42)) ? self_th_1;

    /** INTCQFIR[43]
     *  INT_CQ_FIR_RDQ_ABORT_TRM:
     */
    (rINTCQFIR, bit(43)) ? self_th_32perDay;

    /** INTCQFIR[44]
     *  INT_CQ_FIR_UNSOLICITED_CRESP:
     */
    (rINTCQFIR, bit(44)) ? level2_M_self_L_th_1;

    /** INTCQFIR[45]
     *  INT_CQ_FIR_UNSOLICITED_PBDATA:
     */
    (rINTCQFIR, bit(45)) ? self_th_1;

    /** INTCQFIR[46]
     *  INT_CQ_FIR_FIR_PARITY_ERR:
     */
    (rINTCQFIR, bit(46)) ? self_th_1;

    /** INTCQFIR[47]
     *  INT_CQ_FIR_PGM_DBG_ACCESS:
     */
    (rINTCQFIR, bit(47)) ? threshold_and_mask_self;

    /** INTCQFIR[48]
     *  spare
     */
    (rINTCQFIR, bit(48)) ? defaultMaskedError;

    /** INTCQFIR[49:51]
     *  INT_CQ_FIR_PC_FATAL_ERROR_0_2:
     */
    (rINTCQFIR, bit(49|50|51)) ? self_th_1;

    /** INTCQFIR[52:54]
     *  INT_CQ_FIR_PC_RECOV_ERROR_0_2:
     */
    (rINTCQFIR, bit(52|53|54)) ? analyzeIntCqFirPcRecovError;

    /** INTCQFIR[55:57]
     *  INT_CQ_FIR_PC_INFO_ERROR_0_2:
     */
    (rINTCQFIR, bit(55|56|57)) ? defaultMaskedError;

    /** INTCQFIR[58:59]
     *  INT_CQ_FIR_VC_FATAL_ERROR_0_1:
     */
    (rINTCQFIR, bit(58|59)) ? self_th_1;

    /** INTCQFIR[60:61]
     *  INT_CQ_FIR_VC_RECOV_ERROR_0_1:
     */
    (rINTCQFIR, bit(60|61)) ? level2_M_self_L_th_1;

    /** INTCQFIR[62:63]
     *  INT_CQ_FIR_VC_INFO_ERROR_0_1:
     */
    (rINTCQFIR, bit(62|63)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBIOEFIR
################################################################################

rule rPBIOEFIR
{
  CHECK_STOP:
    PBIOEFIR & ~PBIOEFIR_MASK & ~PBIOEFIR_ACT0 & ~PBIOEFIR_ACT1;
  RECOVERABLE:
    PBIOEFIR & ~PBIOEFIR_MASK & ~PBIOEFIR_ACT0 &  PBIOEFIR_ACT1;
};

group gPBIOEFIR
    filter singlebit,
           cs_root_cause(8,11,14)
{
    /** PBIOEFIR[0]
     *  fmr00 trained
     */
    (rPBIOEFIR, bit(0)) ? defaultMaskedError;

    /** PBIOEFIR[1]
     *  fmr01 trained
     */
    (rPBIOEFIR, bit(1)) ? defaultMaskedError;

    /** PBIOEFIR[2]
     *  fmr02 trained
     */
    (rPBIOEFIR, bit(2)) ? defaultMaskedError;

    /** PBIOEFIR[3]
     *  fmr03 trained
     */
    (rPBIOEFIR, bit(3)) ? defaultMaskedError;

    /** PBIOEFIR[4]
     *  fmr04 trained
     */
    (rPBIOEFIR, bit(4)) ? defaultMaskedError;

    /** PBIOEFIR[5]
     *  fmr05 trained
     */
    (rPBIOEFIR, bit(5)) ? defaultMaskedError;

    /** PBIOEFIR[6:7]
     *  spare
     */
    (rPBIOEFIR, bit(6|7)) ? defaultMaskedError;

    /** PBIOEFIR[8]
     *  dob01 ue
     */
    (rPBIOEFIR, bit(8)) ? self_th_1_UERE;

    /** PBIOEFIR[9]
     *  d0b01 ce
     */
    (rPBIOEFIR, bit(9)) ? self_th_32perDay;

    /** PBIOEFIR[10]
     *  dob01 sue
     */
    (rPBIOEFIR, bit(10)) ? defaultMaskedError;

    /** PBIOEFIR[11]
     *  dob23 ue
     */
    (rPBIOEFIR, bit(11)) ? self_th_1_UERE;

    /** PBIOEFIR[12]
     *  dob23 ce
     */
    (rPBIOEFIR, bit(12)) ? self_th_32perDay;

    /** PBIOEFIR[13]
     *  dob23 sue
     */
    (rPBIOEFIR, bit(13)) ? defaultMaskedError;

    /** PBIOEFIR[14]
     *  dob45 ue
     */
    (rPBIOEFIR, bit(14)) ? self_th_1_UERE;

    /** PBIOEFIR[15]
     *  dob45 ce
     */
    (rPBIOEFIR, bit(15)) ? self_th_32perDay;

    /** PBIOEFIR[16]
     *  dob45 sue
     */
    (rPBIOEFIR, bit(16)) ? defaultMaskedError;

    /** PBIOEFIR[17]
     *  spare
     */
    (rPBIOEFIR, bit(17)) ? defaultMaskedError;

    /** PBIOEFIR[18]
     *  spare
     */
    (rPBIOEFIR, bit(18)) ? defaultMaskedError;

    /** PBIOEFIR[19]
     *  spare
     */
    (rPBIOEFIR, bit(19)) ? defaultMaskedError;

    /** PBIOEFIR[20]
     *  X0 even link framer or outbnd switch err
     */
    (rPBIOEFIR, bit(20)) ? self_th_1;

    /** PBIOEFIR[21]
     *  X0 odd internal framer err
     */
    (rPBIOEFIR, bit(21)) ? self_th_1;

    /** PBIOEFIR[22]
     *  X1 even link framer or outbnd switch err
     */
    (rPBIOEFIR, bit(22)) ? self_th_1;

    /** PBIOEFIR[23]
     *  X1 odd internal framer err
     */
    (rPBIOEFIR, bit(23)) ? self_th_1;

    /** PBIOEFIR[24]
     *  X2 even link framer or outbnd switch err
     */
    (rPBIOEFIR, bit(24)) ? self_th_1;

    /** PBIOEFIR[25]
     *  X2 odd internal framer err
     */
    (rPBIOEFIR, bit(25)) ? self_th_1;

    /** PBIOEFIR[26:27]
     *  spare
     */
    (rPBIOEFIR, bit(26|27)) ? defaultMaskedError;

    /** PBIOEFIR[28]
     *  parser00 attn or X0evn link down
     */
    (rPBIOEFIR, bit(28)) ? calloutBusInterface_xbus0_th_1;

    /** PBIOEFIR[29]
     *  parser01 attn or X0odd link down
     */
    (rPBIOEFIR, bit(29)) ? calloutBusInterface_xbus0_th_1;

    /** PBIOEFIR[30]
     *  parser02 attn or X1evn link down
     */
    (rPBIOEFIR, bit(30)) ? calloutBusInterface_xbus1_th_1;

    /** PBIOEFIR[31]
     *  parser03 attn or X1odd link down
     */
    (rPBIOEFIR, bit(31)) ? calloutBusInterface_xbus1_th_1;

    /** PBIOEFIR[32]
     *  parser04 attn or X2evn link down
     */
    (rPBIOEFIR, bit(32)) ? calloutBusInterface_xbus2_th_1;

    /** PBIOEFIR[33]
     *  parser05 attn or X2odd link down
     */
    (rPBIOEFIR, bit(33)) ? calloutBusInterface_xbus2_th_1;

    /** PBIOEFIR[34:35]
     *  spare
     */
    (rPBIOEFIR, bit(34|35)) ? defaultMaskedError;

    /** PBIOEFIR[36]
     *  mb00 spattn
     */
    (rPBIOEFIR, bit(36)) ? defaultMaskedError;

    /** PBIOEFIR[37]
     *  mb01 spattn
     */
    (rPBIOEFIR, bit(37)) ? defaultMaskedError;

    /** PBIOEFIR[38]
     *  mb10 spattn
     */
    (rPBIOEFIR, bit(38)) ? defaultMaskedError;

    /** PBIOEFIR[39]
     *  mb11 spattn
     */
    (rPBIOEFIR, bit(39)) ? defaultMaskedError;

    /** PBIOEFIR[40]
     *  mb20 spattn
     */
    (rPBIOEFIR, bit(40)) ? defaultMaskedError;

    /** PBIOEFIR[41]
     *  mb21 spattn
     */
    (rPBIOEFIR, bit(41)) ? defaultMaskedError;

    /** PBIOEFIR[42]
     *  mb30 spattn
     */
    (rPBIOEFIR, bit(42)) ? defaultMaskedError;

    /** PBIOEFIR[43]
     *  mb31 spattn
     */
    (rPBIOEFIR, bit(43)) ? defaultMaskedError;

    /** PBIOEFIR[44]
     *  mb40 spattn
     */
    (rPBIOEFIR, bit(44)) ? defaultMaskedError;

    /** PBIOEFIR[45]
     *  mb41 spattn
     */
    (rPBIOEFIR, bit(45)) ? defaultMaskedError;

    /** PBIOEFIR[46]
     *  mb50 spattn
     */
    (rPBIOEFIR, bit(46)) ? defaultMaskedError;

    /** PBIOEFIR[47]
     *  mb51 spattn
     */
    (rPBIOEFIR, bit(47)) ? defaultMaskedError;

    /** PBIOEFIR[48:51]
     *  spare
     */
    (rPBIOEFIR, bit(48|49|50|51)) ? defaultMaskedError;

    /** PBIOEFIR[52]
     *  data outbnd switch int. err-links 01
     */
    (rPBIOEFIR, bit(52)) ? calloutBusInterface_xbus0_th_1;

    /** PBIOEFIR[53]
     *  data outbnd switch int. err-links 23
     */
    (rPBIOEFIR, bit(53)) ? calloutBusInterface_xbus1_th_1;

    /** PBIOEFIR[54]
     *  data outbnd switch int. err-links 45
     */
    (rPBIOEFIR, bit(54)) ? calloutBusInterface_xbus2_th_1;

    /** PBIOEFIR[55]
     *  spare
     */
    (rPBIOEFIR, bit(55)) ? defaultMaskedError;

    /** PBIOEFIR[56]
     *  data inbnd switch int. err-links 01
     */
    (rPBIOEFIR, bit(56)) ? calloutBusInterface_xbus0_th_1;

    /** PBIOEFIR[57]
     *  data inbnd switch int. err-links 23
     */
    (rPBIOEFIR, bit(57)) ? calloutBusInterface_xbus1_th_1;

    /** PBIOEFIR[58]
     *  data inbnd switch int. err-links 45
     */
    (rPBIOEFIR, bit(58)) ? calloutBusInterface_xbus2_th_1;

    /** PBIOEFIR[59:61]
     *  spare
     */
    (rPBIOEFIR, bit(59|60|61)) ? defaultMaskedError;

    /** PBIOEFIR[62]
     *  scom error
     */
    (rPBIOEFIR, bit(62)) ? defaultMaskedError;

    /** PBIOEFIR[63]
     *  scom error
     */
    (rPBIOEFIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip PBIOOFIR
################################################################################

rule rPBIOOFIR
{
  CHECK_STOP:
    PBIOOFIR & ~PBIOOFIR_MASK & ~PBIOOFIR_ACT0 & ~PBIOOFIR_ACT1;
  RECOVERABLE:
    PBIOOFIR & ~PBIOOFIR_MASK & ~PBIOOFIR_ACT0 &  PBIOOFIR_ACT1;
};

group gPBIOOFIR
    filter singlebit,
           cs_root_cause(8,11,14,17)
{
    /** PBIOOFIR[0]
     *  fmr00 trained
     */
    (rPBIOOFIR, bit(0)) ? defaultMaskedError;

    /** PBIOOFIR[1]
     *  fmr01 trained
     */
    (rPBIOOFIR, bit(1)) ? defaultMaskedError;

    /** PBIOOFIR[2]
     *  fmr02 trained
     */
    (rPBIOOFIR, bit(2)) ? defaultMaskedError;

    /** PBIOOFIR[3]
     *  fmr03 trained
     */
    (rPBIOOFIR, bit(3)) ? defaultMaskedError;

    /** PBIOOFIR[4]
     *  fmr04 trained
     */
    (rPBIOOFIR, bit(4)) ? defaultMaskedError;

    /** PBIOOFIR[5]
     *  fmr05 trained
     */
    (rPBIOOFIR, bit(5)) ? defaultMaskedError;

    /** PBIOOFIR[6]
     *  fmr06 trained
     */
    (rPBIOOFIR, bit(6)) ? defaultMaskedError;

    /** PBIOOFIR[7]
     *  fmr07 trained
     */
    (rPBIOOFIR, bit(7)) ? defaultMaskedError;

    /** PBIOOFIR[8]
     *  dob01 ue
     */
    (rPBIOOFIR, bit(8)) ? self_th_1_UERE;

    /** PBIOOFIR[9]
     *  dob01 ce
     */
    (rPBIOOFIR, bit(9)) ? self_th_32perDay;

    /** PBIOOFIR[10]
     *  dob01 sue
     */
    (rPBIOOFIR, bit(10)) ? defaultMaskedError;

    /** PBIOOFIR[11]
     *  dob23 ue
     */
    (rPBIOOFIR, bit(11)) ? self_th_1_UERE;

    /** PBIOOFIR[12]
     *  dob23 ce
     */
    (rPBIOOFIR, bit(12)) ? self_th_32perDay;

    /** PBIOOFIR[13]
     *  dob23 sue
     */
    (rPBIOOFIR, bit(13)) ? defaultMaskedError;

    /** PBIOOFIR[14]
     *  dob45 ue
     */
    (rPBIOOFIR, bit(14)) ? self_th_1_UERE;

    /** PBIOOFIR[15]
     *  dob45 ce
     */
    (rPBIOOFIR, bit(15)) ? self_th_32perDay;

    /** PBIOOFIR[16]
     *  dob45 sue
     */
    (rPBIOOFIR, bit(16)) ? defaultMaskedError;

    /** PBIOOFIR[17]
     *  dob67 ue
     */
    (rPBIOOFIR, bit(17)) ? self_th_1_UERE;

    /** PBIOOFIR[18]
     *  dob67 ce
     */
    (rPBIOOFIR, bit(18)) ? self_th_32perDay;

    /** PBIOOFIR[19]
     *  dob67 sue
     */
    (rPBIOOFIR, bit(19)) ? defaultMaskedError;

    /** PBIOOFIR[20]
     *  A0 even link framer error
     */
    (rPBIOOFIR, bit(20)) ? self_th_1;

    /** PBIOOFIR[21]
     *  A0 odd framer error
     */
    (rPBIOOFIR, bit(21)) ? self_th_1;

    /** PBIOOFIR[22]
     *  A1 even link framer error
     */
    (rPBIOOFIR, bit(22)) ? self_th_1;

    /** PBIOOFIR[23]
     *  A1 odd link framer error
     */
    (rPBIOOFIR, bit(23)) ? self_th_1;

    /** PBIOOFIR[24]
     *  A2 even link framer error
     */
    (rPBIOOFIR, bit(24)) ? self_th_1;

    /** PBIOOFIR[25]
     *  A2 odd link framer error
     */
    (rPBIOOFIR, bit(25)) ? self_th_1;

    /** PBIOOFIR[26]
     *  A3 even link framer error
     */
    (rPBIOOFIR, bit(26)) ? self_th_1;

    /** PBIOOFIR[27]
     *  A3 odd link framer error
     */
    (rPBIOOFIR, bit(27)) ? self_th_1;

    /** PBIOOFIR[28]
     *  parser00 attn
     */
    (rPBIOOFIR, bit(28)) ? obus0SmpFailure_L0;

    /** PBIOOFIR[29]
     *  parser01 attn
     */
    (rPBIOOFIR, bit(29)) ? obus0SmpFailure_L1;

    /** PBIOOFIR[30]
     *  parser02 attn
     */
    (rPBIOOFIR, bit(30)) ? obus1SmpFailure_L0;

    /** PBIOOFIR[31]
     *  parser03 attn
     */
    (rPBIOOFIR, bit(31)) ? obus1SmpFailure_L1;

    /** PBIOOFIR[32]
     *  parser04 attn
     */
    (rPBIOOFIR, bit(32)) ? obus2SmpFailure_L0;

    /** PBIOOFIR[33]
     *  parser05 attn
     */
    (rPBIOOFIR, bit(33)) ? obus2SmpFailure_L1;

    /** PBIOOFIR[34]
     *  parser06 attn
     */
    (rPBIOOFIR, bit(34)) ? obus3SmpFailure_L0;

    /** PBIOOFIR[35]
     *  parser07 attn
     */
    (rPBIOOFIR, bit(35)) ? obus3SmpFailure_L1;

    /** PBIOOFIR[36]
     *  mailbox 00 special attention
     */
    (rPBIOOFIR, bit(36)) ? defaultMaskedError;

    /** PBIOOFIR[37]
     *  mailbox 01 special attention
     */
    (rPBIOOFIR, bit(37)) ? defaultMaskedError;

    /** PBIOOFIR[38]
     *  mailbox 02 special attention
     */
    (rPBIOOFIR, bit(38)) ? defaultMaskedError;

    /** PBIOOFIR[39]
     *  mailbox 11 special attention
     */
    (rPBIOOFIR, bit(39)) ? defaultMaskedError;

    /** PBIOOFIR[40]
     *  mailbox 20 special attention
     */
    (rPBIOOFIR, bit(40)) ? defaultMaskedError;

    /** PBIOOFIR[41]
     *  mailbox 21 special attention
     */
    (rPBIOOFIR, bit(41)) ? defaultMaskedError;

    /** PBIOOFIR[42]
     *  mailbox 30 special attention
     */
    (rPBIOOFIR, bit(42)) ? defaultMaskedError;

    /** PBIOOFIR[43]
     *  mailbox 31 special attention
     */
    (rPBIOOFIR, bit(43)) ? defaultMaskedError;

    /** PBIOOFIR[44]
     *  mailbox 40 special attention
     */
    (rPBIOOFIR, bit(44)) ? defaultMaskedError;

    /** PBIOOFIR[45]
     *  mailbox 41 special attention
     */
    (rPBIOOFIR, bit(45)) ? defaultMaskedError;

    /** PBIOOFIR[46]
     *  mailbox 50 special attention
     */
    (rPBIOOFIR, bit(46)) ? defaultMaskedError;

    /** PBIOOFIR[47]
     *  mailbox 51 special attention
     */
    (rPBIOOFIR, bit(47)) ? defaultMaskedError;

    /** PBIOOFIR[48]
     *  mailbox 60 special attention
     */
    (rPBIOOFIR, bit(48)) ? defaultMaskedError;

    /** PBIOOFIR[49]
     *  mailbox 61 special attention
     */
    (rPBIOOFIR, bit(49)) ? defaultMaskedError;

    /** PBIOOFIR[50]
     *  mailbox 70 special attention
     */
    (rPBIOOFIR, bit(50)) ? defaultMaskedError;

    /** PBIOOFIR[51]
     *  mailbox 71 special attention
     */
    (rPBIOOFIR, bit(51)) ? defaultMaskedError;

    /** PBIOOFIR[52]
     *  data outbound switch internal-links 01
     */
    (rPBIOOFIR, bit(52)) ? obus0SmpFailure_LALL;

    /** PBIOOFIR[53]
     *  data outbound switch internal - links 23
     */
    (rPBIOOFIR, bit(53)) ? obus1SmpFailure_LALL;

    /** PBIOOFIR[54]
     *  data outbound switch internal-links 45
     */
    (rPBIOOFIR, bit(54)) ? obus2SmpFailure_LALL;

    /** PBIOOFIR[55]
     *  data outbound switch internal-links 67
     */
    (rPBIOOFIR, bit(55)) ? obus3SmpFailure_LALL;

    /** PBIOOFIR[56]
     *  data inbound switch internal-links 01
     */
    (rPBIOOFIR, bit(56)) ? obus0SmpFailure_LALL;

    /** PBIOOFIR[57]
     *  data inbound switch internal-links 23
     */
    (rPBIOOFIR, bit(57)) ? obus1SmpFailure_LALL;

    /** PBIOOFIR[58]
     *  data inbound switch internal-links 45
     */
    (rPBIOOFIR, bit(58)) ? obus2SmpFailure_LALL;

    /** PBIOOFIR[59]
     *  data inbound switch internal-links 67
     */
    (rPBIOOFIR, bit(59)) ? obus3SmpFailure_LALL;

    /** PBIOOFIR[60:61]
     *  spare
     */
    (rPBIOOFIR, bit(60|61)) ? defaultMaskedError;

    /** PBIOOFIR[62]
     *  scom error
     */
    (rPBIOOFIR, bit(62)) ? defaultMaskedError;

    /** PBIOOFIR[63]
     *  scom error
     */
    (rPBIOOFIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU0FIR
################################################################################

rule rNPU0FIR
{
  CHECK_STOP:
    NPU0FIR & ~NPU0FIR_MASK & ~NPU0FIR_ACT0 & ~NPU0FIR_ACT1;
  RECOVERABLE:
    NPU0FIR & ~NPU0FIR_MASK & ~NPU0FIR_ACT0 &  NPU0FIR_ACT1;
  UNIT_CS:
    NPU0FIR & ~NPU0FIR_MASK &  NPU0FIR_ACT0 &  NPU0FIR_ACT1;
};

group gNPU0FIR
    filter singlebit,
           cs_root_cause(1,2,3,4,5,6,7,9,10,16,18,29,31,42,44)
{
    /** NPU0FIR[0]
     *  NTL array CE
     */
    (rNPU0FIR, bit(0)) ? npu_th_32perDay;

    /** NPU0FIR[1]
     *  NTL header array UE
     */
    (rNPU0FIR, bit(1)) ? npu_th_1;

    /** NPU0FIR[2]
     *  NTL Data Array UE
     */
    (rNPU0FIR, bit(2)) ? npu_th_1;

    /** NPU0FIR[3]
     *  NTL NVLInk Control/Header/AE PE
     */
    (rNPU0FIR, bit(3)) ? npu_th_1;

    /** NPU0FIR[4]
     *  NTL NVLink Data Parity error
     */
    (rNPU0FIR, bit(4)) ? npu_th_1;

    /** NPU0FIR[5]
     *  NTL NVLink Malformed Packet
     */
    (rNPU0FIR, bit(5)) ? npu_th_1;

    /** NPU0FIR[6]
     *  NTL NVLink Unsupported Packet
     */
    (rNPU0FIR, bit(6)) ? npu_th_1;

    /** NPU0FIR[7]
     *  NTL NVLink Config errors
     */
    (rNPU0FIR, bit(7)) ? npu_th_1;

    /** NPU0FIR[8]
     *  NTL NVLink CRC errors or LMD=Stomp
     */
    (rNPU0FIR, bit(8)) ? defaultMaskedError;

    /** NPU0FIR[9]
     *  NTL PRI errors
     */
    (rNPU0FIR, bit(9)) ? npu_th_1;

    /** NPU0FIR[10]
     *  NTL logic error
     */
    (rNPU0FIR, bit(10)) ? npu_th_1;

    /** NPU0FIR[11]
     *  NTL LMD=Data Posion
     */
    (rNPU0FIR, bit(11)) ? defaultMaskedError;

    /** NPU0FIR[12]
     *  NTL data array SUE
     */
    (rNPU0FIR, bit(12)) ? defaultMaskedError;

    /** NPU0FIR[13]
     *  CQ CTL/SM ASBE Array single-bit CE
     */
    (rNPU0FIR, bit(13)) ? npu_th_32perDay;

    /** NPU0FIR[14]
     *  CQ CTL/SM PBR PowerBus Recoverable err
     */
    (rNPU0FIR, bit(14)) ? defaultMaskedError;

    /** NPU0FIR[15]
     *  CQ CTL/SM REG Register ring error
     */
    (rNPU0FIR, bit(15)) ? npu_th_32perDay;

    /** NPU0FIR[16]
     *  Data UE for MMIO store data
     */
    (rNPU0FIR, bit(16)) ? npu_th_1;

    /** NPU0FIR[17]
     *  spare
     */
    (rNPU0FIR, bit(17)) ? defaultMaskedError;

    /** NPU0FIR[18]
     *  CQ CTL/SM NCF NVLink config error
     */
    (rNPU0FIR, bit(18)) ? npu_th_1;

    /** NPU0FIR[19]
     *  CQ CTL/SM NVF NVLink fatal error
     */
    (rNPU0FIR, bit(19)) ? npu_th_1;

    /** NPU0FIR[20]
     *  spare
     */
    (rNPU0FIR, bit(20)) ? defaultMaskedError;

    /** NPU0FIR[21]
     *  CQ CTL/SM AUE Array UE
     */
    (rNPU0FIR, bit(21)) ? npu_th_1;

    /** NPU0FIR[22]
     *  CQ CTL/SM PBP PowerBus parity error
     */
    (rNPU0FIR, bit(22)) ? npu_th_1;

    /** NPU0FIR[23]
     *  CQ CTL/SM PBF PowerBus Fatal Error
     */
    (rNPU0FIR, bit(23)) ? npu_M_level2_L_th_1;

    /** NPU0FIR[24]
     *  PowerBus configuration error
     */
    # No special handling required because 'self_L' is already NO_GARD.
    (rNPU0FIR, bit(24)) ? level2_M_self_L_th_1;

    /** NPU0FIR[25]
     *  CQ CTL/SM FWD Forward-Progress error
     */
    (rNPU0FIR, bit(25)) ? npu_th_1;

    /** NPU0FIR[26]
     *  CQ CTL/SM NLG NPU Logic error
     */
    (rNPU0FIR, bit(26)) ? npu_th_1;

    /** NPU0FIR[27]
     *  CQ CTL/SM  UT=1 to frozen PE error
     */
    (rNPU0FIR, bit(27)) ? defaultMaskedError;

    /** NPU0FIR[28]
     *  spare
     */
    (rNPU0FIR, bit(28)) ? defaultMaskedError;

    /** NPU0FIR[29]
     *  CQ DAT ECC UE/SUE on data/BE arrays
     */
    (rNPU0FIR, bit(29)) ? npu_th_1;

    /** NPU0FIR[30]
     *  CQ DAT ECC CE on data/BE arrays
     */
    (rNPU0FIR, bit(30)) ? npu_M_level2_L_th_32perDay;

    /** NPU0FIR[31]
     *  CQ DAT parity error on data/BE latches
     */
    (rNPU0FIR, bit(31)) ? npu_th_1;

    /** NPU0FIR[32]
     *  CQ DAT parity errs on config regs
     */
    (rNPU0FIR, bit(32)) ? npu_th_1;

    /** NPU0FIR[33]
     *  CQ DAT parity errs/PowerBus rtag
     */
    (rNPU0FIR, bit(33)) ? npu_th_1;

    /** NPU0FIR[34]
     *  CQ DAT parity errs nternal state latches
     */
    (rNPU0FIR, bit(34)) ? npu_th_1;

    /** NPU0FIR[35]
     *  CQ DAT logic error
     */
    (rNPU0FIR, bit(35)) ? npu_th_1;

    /** NPU0FIR[36]
     *  Future SUE
     */
    (rNPU0FIR, bit(36)) ? defaultMaskedError;

    /** NPU0FIR[37]
     *  ECC SUE on PB received data
     */
    (rNPU0FIR, bit(37)) ? defaultMaskedError;

    /** NPU0FIR[38:39]
     *  spare
     */
    (rNPU0FIR, bit(38|39)) ? defaultMaskedError;

    /** NPU0FIR[40]
     *  XTS internal logic error
     */
    (rNPU0FIR, bit(40)) ? npu_th_1;

    /** NPU0FIR[41]
     *  XTS correctable errs in XTS SRAM
     */
    (rNPU0FIR, bit(41)) ? npu_M_level2_L_th_32perDay;

    /** NPU0FIR[42]
     *  XTS Ues in XTS internal SRAM
     */
    (rNPU0FIR, bit(42)) ? npu_th_1;

    /** NPU0FIR[43]
     *  XTS CE on incoming stack transactions
     */
    (rNPU0FIR, bit(43)) ? npu_M_level2_L_th_32perDay;

    /** NPU0FIR[44]
     *  XTS  errs incoming stack transaction
     */
    (rNPU0FIR, bit(44)) ? npu_th_1;

    /** NPU0FIR[45]
     *  XTS errs on incoming PBUS transaction
     */
    (rNPU0FIR, bit(45)) ? npu_th_1;

    /** NPU0FIR[46]
     *  XTS Translate Request Fail
     */
    (rNPU0FIR, bit(46)) ? defaultMaskedError;

    /** NPU0FIR[47:59]
     *  spare
     */
    (rNPU0FIR, bit(47|48|49|50|51|52|53|54|55|56|57|58|59)) ? defaultMaskedError;

    /** NPU0FIR[60]
     *  MISC Pervasive SCOM satellite err
     */
    (rNPU0FIR, bit(60)) ? defaultMaskedError;

    /** NPU0FIR[61]
     *  MISC Pervasive SCOM satellite err
     */
    (rNPU0FIR, bit(61)) ? defaultMaskedError;

    /** NPU0FIR[62]
     *  Local FIR Parity Error RAS duplicate
     */
    (rNPU0FIR, bit(62)) ? defaultMaskedError;

    /** NPU0FIR[63]
     *  Local FIR Parity Err
     */
    (rNPU0FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU1FIR
################################################################################

rule rNPU1FIR
{
  CHECK_STOP:
    NPU1FIR & ~NPU1FIR_MASK & ~NPU1FIR_ACT0 & ~NPU1FIR_ACT1;
  RECOVERABLE:
    NPU1FIR & ~NPU1FIR_MASK & ~NPU1FIR_ACT0 &  NPU1FIR_ACT1;
  UNIT_CS:
    NPU1FIR & ~NPU1FIR_MASK &  NPU1FIR_ACT0 &  NPU1FIR_ACT1;
};

group gNPU1FIR
    filter singlebit,
           cs_root_cause(0,2,4,6,8,10,13,14,15,20,25,27,28,29,31,32,33,34,35)
{
    /** NPU1FIR[0]
     *  NDL Brick0 stall
     */
    (rNPU1FIR, bit(0)) ? npu_th_1;

    /** NPU1FIR[1]
     *  NDL Brick0 nostall
     */
    (rNPU1FIR, bit(1)) ? defaultMaskedError;

    /** NPU1FIR[2]
     *  NDL Brick1 stall
     */
    (rNPU1FIR, bit(2)) ? npu_th_1;

    /** NPU1FIR[3]
     *  NDL Brick1 nostall
     */
    (rNPU1FIR, bit(3)) ? defaultMaskedError;

    /** NPU1FIR[4]
     *  NDL Brick2 stall
     */
    (rNPU1FIR, bit(4)) ? npu_th_1;

    /** NPU1FIR[5]
     *  NDL Brick2 nostall
     */
    (rNPU1FIR, bit(5)) ? defaultMaskedError;

    /** NPU1FIR[6]
     *  NDL Brick3 stall
     */
    (rNPU1FIR, bit(6)) ? npu_th_1;

    /** NPU1FIR[7]
     *  NDL Brick3 nostall
     */
    (rNPU1FIR, bit(7)) ? defaultMaskedError;

    /** NPU1FIR[8]
     *  NDL Brick4 stall
     */
    (rNPU1FIR, bit(8)) ? npu_th_1;

    /** NPU1FIR[9]
     *  NDL Brick4 nostall
     */
    (rNPU1FIR, bit(9)) ? defaultMaskedError;

    /** NPU1FIR[10]
     *  NDL Brick5 stall
     */
    (rNPU1FIR, bit(10)) ? npu_th_1;

    /** NPU1FIR[11]
     *  NDL Brick5 nostall
     */
    (rNPU1FIR, bit(11)) ? defaultMaskedError;

    /** NPU1FIR[12]
     *  MISC Register ring error (ie noack)
     */
    (rNPU1FIR, bit(12)) ? npu_th_32perDay;

    /** NPU1FIR[13]
     *  MISC Parity error from ibr addr regi
     */
    (rNPU1FIR, bit(13)) ? npu_th_1;

    /** NPU1FIR[14]
     *  MISC Parity error on SCOM D/A addr reg
     */
    (rNPU1FIR, bit(14)) ? npu_th_1;

    /** NPU1FIR[15]
     *  MISC Parity error on MISC Cntrl reg
     */
    (rNPU1FIR, bit(15)) ? npu_th_1;

    /** NPU1FIR[16]
     *  MISC NMMU signaled Local Checkstop
     */
    (rNPU1FIR, bit(16)) ? defaultMaskedError;

    /** NPU1FIR[17]
     *  ATS Invalid TVT entry
     */
    (rNPU1FIR, bit(17)) ? defaultMaskedError;

    /** NPU1FIR[18]
     *  ATS TVT Address range error
     */
    (rNPU1FIR, bit(18)) ? defaultMaskedError;

    /** NPU1FIR[19]
     *  ATS TCE Page access error
     */
    (rNPU1FIR, bit(19)) ? defaultMaskedError;

    /** NPU1FIR[20]
     *  ATS Effective Address hit multiple TCE
     */
    (rNPU1FIR, bit(20)) ? npu_th_1;

    /** NPU1FIR[21]
     *  ATS TCE Page access error
     */
    (rNPU1FIR, bit(21)) ? defaultMaskedError;

    /** NPU1FIR[22]
     *  ATS Timeout on TCE tree walk
     */
    (rNPU1FIR, bit(22)) ? npu_th_1;

    /** NPU1FIR[23]
     *  ATS Parity error on TCE cache dir array
     */
    (rNPU1FIR, bit(23)) ? npu_th_32perDay;

    /** NPU1FIR[24]
     *  ATS Parity error on TCE cache data array
     */
    (rNPU1FIR, bit(24)) ? npu_th_32perDay;

    /** NPU1FIR[25]
     *  ATS ECC UE on Effective Address array
     */
    (rNPU1FIR, bit(25)) ? npu_th_1;

    /** NPU1FIR[26]
     *  ATS ECC CE on Effective Address array
     */
    (rNPU1FIR, bit(26)) ? npu_th_32perDay;

    /** NPU1FIR[27]
     *  ATS ECC UE on TDRmem array
     */
    (rNPU1FIR, bit(27)) ? npu_th_1;

    /** NPU1FIR[28]
     *  ATS ECC CE on TDRmem array
     */
    (rNPU1FIR, bit(28)) ? npu_th_1;

    /** NPU1FIR[29]
     *  ATS ECC UE on CQ CTL DMA Read
     */
    (rNPU1FIR, bit(29)) ? npu_th_1;

    /** NPU1FIR[30]
     *  ATS ECC CE on CQ CTL DMA Read
     */
    (rNPU1FIR, bit(30)) ? npu_th_32perDay;

    /** NPU1FIR[31]
     *  ATS Parity error on TVT entry
     */
    (rNPU1FIR, bit(31)) ? npu_th_1;

    /** NPU1FIR[32]
     *  ATS Parity err on IODA Address Reg
     */
    (rNPU1FIR, bit(32)) ? npu_th_1;

    /** NPU1FIR[33]
     *  ATS Parity error on ATS Control Register
     */
    (rNPU1FIR, bit(33)) ? npu_th_1;

    /** NPU1FIR[34]
     *  ATS Parity error on ATS reg
     */
    (rNPU1FIR, bit(34)) ? npu_th_1;

    /** NPU1FIR[35]
     *  ATS Invalid IODA Table Select entry
     */
    (rNPU1FIR, bit(35)) ? npu_th_1;

    /** NPU1FIR[36:58]
     *  Reserved
     */
    (rNPU1FIR, bit(36|37|38|39|40|41|42|43|44|45|46|47|48|49|50|51|52|53|54|55|56|57|58)) ? defaultMaskedError;

    /** NPU1FIR[59]
     *  Reserved
     */
    (rNPU1FIR, bit(59)) ? defaultMaskedError;

    /** NPU1FIR[60:61]
     *  Reserved
     */
    (rNPU1FIR, bit(60|61)) ? defaultMaskedError;

    /** NPU1FIR[62]
     *  scom error
     */
    (rNPU1FIR, bit(62)) ? defaultMaskedError;

    /** NPU1FIR[63]
     *  scom error
     */
    (rNPU1FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P9 chip NPU2FIR
################################################################################

rule rNPU2FIR
{
  CHECK_STOP:
    NPU2FIR & ~NPU2FIR_MASK & ~NPU2FIR_ACT0 & ~NPU2FIR_ACT1;
  RECOVERABLE:
    NPU2FIR & ~NPU2FIR_MASK & ~NPU2FIR_ACT0 &  NPU2FIR_ACT1;
  UNIT_CS:
    NPU2FIR & ~NPU2FIR_MASK &  NPU2FIR_ACT0 &  NPU2FIR_ACT1;
};

group gNPU2FIR
    filter singlebit,
           cs_root_cause
{
    /** NPU2FIR[0]
     *  OTL Brick2 translation fault
     */
    (rNPU2FIR, bit(0)) ? defaultMaskedError;

    /** NPU2FIR[1]
     *  OTL Brick3 translation fault
     */
    (rNPU2FIR, bit(1)) ? defaultMaskedError;

    /** NPU2FIR[2]
     *  OTL Brick4 translation fault
     */
    (rNPU2FIR, bit(2)) ? defaultMaskedError;

    /** NPU2FIR[3]
     *  OTL Brick5 translation fault
     */
    (rNPU2FIR, bit(3)) ? defaultMaskedError;

    /** NPU2FIR[4]
     *  OTL TL credit ctr overflow
     */
    (rNPU2FIR, bit(4)) ? npu_th_1;

    /** NPU2FIR[5]
     *  OTL RX acTag invalid
     */
    (rNPU2FIR, bit(5)) ? npu_th_1;

    /** NPU2FIR[6]
     *  OTL RX acTag points to an invalid entry.
     */
    (rNPU2FIR, bit(6)) ? npu_th_1;

    /** NPU2FIR[7]
     *  OTL RX reserved opcode used.
     */
    (rNPU2FIR, bit(7)) ? npu_th_1;

    /** NPU2FIR[8]
     *  OTL RX rtn_tl_credit cmd outside slot0.
     */
    (rNPU2FIR, bit(8)) ? npu_th_1;

    /** NPU2FIR[9]
     *  OTL RX bad opcode and template combo
     */
    (rNPU2FIR, bit(9)) ? npu_th_1;

    /** NPU2FIR[10]
     *  OTL RX unsupported template format.
     */
    (rNPU2FIR, bit(10)) ? npu_th_1;

    /** NPU2FIR[11]
     *  OTL RX bad template x00 format.
     */
    (rNPU2FIR, bit(11)) ? npu_th_1;

    /** NPU2FIR[12]
     *  OTL RX control flit overrun.
     */
    (rNPU2FIR, bit(12)) ? npu_th_1;

    /** NPU2FIR[13]
     *  OTL RX unexpected data flit.
     */
    (rNPU2FIR, bit(13)) ? npu_th_1;

    /** NPU2FIR[14]
     *  OTL RX DL link down.
     */
    (rNPU2FIR, bit(14)) ? npu_th_1;

    /** NPU2FIR[15]
     *  OTL RX bad data received on command.
     */
    (rNPU2FIR, bit(15)) ? npu_th_1;

    /** NPU2FIR[16]
     *  OTL RX bad data received on response.
     */
    (rNPU2FIR, bit(16)) ? npu_th_1;

    /** NPU2FIR[17]
     *  OTL RX AP response not allowed
     */
    (rNPU2FIR, bit(17)) ? npu_th_1;

    /** NPU2FIR[18]
     *  OR of all OTL parity errors.
     */
    (rNPU2FIR, bit(18)) ? npu_th_1;

    /** NPU2FIR[19]
     *  OR of all OTL ECC CE errors.
     */
    (rNPU2FIR, bit(19)) ? npu_th_32perDay;

    /** NPU2FIR[20]
     *  OR of all OTL ECC UE errors.
     */
    (rNPU2FIR, bit(20)) ? npu_th_1;

    /** NPU2FIR[21]
     *  RXO OP Errors.
     */
    (rNPU2FIR, bit(21)) ? npu_th_1;

    /** NPU2FIR[22]
     *  RXO Internal Errors.
     */
    (rNPU2FIR, bit(22)) ? npu_th_1;

    /** NPU2FIR[23]
     *  OTL RXI fifo overrun.
     */
    (rNPU2FIR, bit(23)) ? npu_th_1;

    /** NPU2FIR[24]
     *  OTL RXI ctrl flit data run len invalid.
     */
    (rNPU2FIR, bit(24)) ? npu_th_1;

    /** NPU2FIR[25]
     *  OTL RXI opcode specifies dL=0b00.
     */
    (rNPU2FIR, bit(25)) ? npu_th_1;

    /** NPU2FIR[26:35]
     *  spare
     */
    (rNPU2FIR, bit(26|27|28|29|30|31|32|33|34|35)) ? defaultMaskedError;

    /** NPU2FIR[36]
     *  MMIO invalidate while one in progress.
     */
    (rNPU2FIR, bit(36)) ? npu_th_1;

    /** NPU2FIR[37]
     *  Unexpected ITAG on itag completion pt 0
     */
    (rNPU2FIR, bit(37)) ? npu_th_1;

    /** NPU2FIR[38]
     *  Unexpected ITAG on itag completion pt 1
     */
    (rNPU2FIR, bit(38)) ? npu_th_1;

    /** NPU2FIR[39]
     *  Unexpected Read PEE completion.
     */
    (rNPU2FIR, bit(39)) ? npu_th_1;

    /** NPU2FIR[40]
     *  Unexpected Checkout response.
     */
    (rNPU2FIR, bit(40)) ? npu_th_1;

    /** NPU2FIR[41]
     *  Translation request but SPAP is invalid.
     */
    (rNPU2FIR, bit(41)) ? npu_th_1;

    /** NPU2FIR[42]
     *  Read a PEE which was not valid.
     */
    (rNPU2FIR, bit(42)) ? npu_th_1;

    /** NPU2FIR[43]
     *  Bloom filter protection error.
     */
    (rNPU2FIR, bit(43)) ? npu_th_1;

    /** NPU2FIR[44:45]
     *  spare
     */
    (rNPU2FIR, bit(44|45)) ? defaultMaskedError;

    /** NPU2FIR[46]
     *  correctable array error (SBE).
     */
    (rNPU2FIR, bit(46)) ? npu_th_32perDay;

    /** NPU2FIR[47]
     *  array error (UE or parity).
     */
    (rNPU2FIR, bit(47)) ? npu_th_1;

    /** NPU2FIR[48]
     *  S/TLBI buffer overflow.
     */
    (rNPU2FIR, bit(48)) ? npu_th_1;

    /** NPU2FIR[49]
     *  SBE CE on Pb cout rsp or PEE read data.
     */
    (rNPU2FIR, bit(49)) ? npu_th_32perDay;

    /** NPU2FIR[50]
     *  UE on Pb cut rsp or PEE read data.
     */
    (rNPU2FIR, bit(50)) ? npu_th_1;

    /** NPU2FIR[51]
     *  SUE on Pb chkout rsp or Pb PEE rd data.
     */
    (rNPU2FIR, bit(51)) ? npu_th_1;

    /** NPU2FIR[52]
     *  XSL Reserved, macro bit 16.
     */
    (rNPU2FIR, bit(52)) ? defaultMaskedError;

    /** NPU2FIR[53]
     *  XSL Reserved, macro bit 17.
     */
    (rNPU2FIR, bit(53)) ? defaultMaskedError;

    /** NPU2FIR[54:59]
     *  spare
     */
    (rNPU2FIR, bit(54|55|56|57|58|59)) ? defaultMaskedError;

    /** NPU2FIR[60]
     *  SCOM satellite FSM error (ring 1, sat 0)
     */
    (rNPU2FIR, bit(60)) ? defaultMaskedError;

    /** NPU2FIR[61]
     *  SCOM satellite FSM error (ring 1, sat 0)
     */
    (rNPU2FIR, bit(61)) ? defaultMaskedError;

    /** NPU2FIR[62]
     *  Local FIR PE RAS dup (ring 2, sat 2)
     */
    (rNPU2FIR, bit(62)) ? defaultMaskedError;

    /** NPU2FIR[63]
     *  Lcl PE ACTION/MASK regs (ring 2, sat 2)
     */
    (rNPU2FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# XB Chiplet FIR
################################################################################

rule rXB_CHIPLET_FIR
{
  CHECK_STOP:
     XB_CHIPLET_CS_FIR       & ~XB_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (XB_CHIPLET_RE_FIR >> 2) & ~XB_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gXB_CHIPLET_FIR
    filter singlebit
{
    /** XB_CHIPLET_FIR[3]
     *  Attention from XB_LFIR
     */
    (rXB_CHIPLET_FIR, bit(3)) ? analyzeXB_LFIR;

    /** XB_CHIPLET_FIR[5]
     *  Attention from IOELFIR 1
     */
    (rXB_CHIPLET_FIR, bit(5)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_FIR[6]
     *  Attention from IOELFIR 2
     */
    (rXB_CHIPLET_FIR, bit(6)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_FIR[9]
     *  Attention from IOXBFIR 1
     */
    (rXB_CHIPLET_FIR, bit(9)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_FIR[10]
     *  Attention from IOXBFIR 2
     */
    (rXB_CHIPLET_FIR, bit(10)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_FIR[11]
     *  Attention from XBPPEFIR
     */
    (rXB_CHIPLET_FIR, bit(11)) ? analyzeXBPPEFIR;

};

################################################################################
# XB Chiplet Unit Checkstop FIR
################################################################################

rule rXB_CHIPLET_UCS_FIR
{
  UNIT_CS:
    XB_CHIPLET_UCS_FIR & ~(XB_CHIPLET_UCS_FIR_MASK >> 1) & `7fffffffffffffff`;
};

group gXB_CHIPLET_UCS_FIR
    filter singlebit
{
    /** XB_CHIPLET_UCS_FIR[2]
     *  Attention from IOELFIR 1
     */
    (rXB_CHIPLET_UCS_FIR, bit(2)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_UCS_FIR[3]
     *  Attention from IOELFIR 2
     */
    (rXB_CHIPLET_UCS_FIR, bit(3)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_UCS_FIR[6]
     *  Attention from IOXBFIR 1
     */
    (rXB_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedXBUS1;

    /** XB_CHIPLET_UCS_FIR[7]
     *  Attention from IOXBFIR 2
     */
    (rXB_CHIPLET_UCS_FIR, bit(7)) ? analyzeConnectedXBUS2;

    /** XB_CHIPLET_UCS_FIR[8]
     *  Attention from XBPPEFIR
     */
    (rXB_CHIPLET_UCS_FIR, bit(8)) ? analyzeXBPPEFIR;

};

################################################################################
# P9 chip XB_LFIR
################################################################################

rule rXB_LFIR
{
  CHECK_STOP:
    XB_LFIR & ~XB_LFIR_MASK & ~XB_LFIR_ACT0 & ~XB_LFIR_ACT1;
  RECOVERABLE:
    XB_LFIR & ~XB_LFIR_MASK & ~XB_LFIR_ACT0 &  XB_LFIR_ACT1;
};

group gXB_LFIR
    filter singlebit,
           cs_root_cause
{
    /** XB_LFIR[0]
     *  CFIR internal parity error
     */
    (rXB_LFIR, bit(0)) ? self_th_32perDay;

    /** XB_LFIR[1]
     *  Chiplet Control Reg: PCB Access Error
     */
    (rXB_LFIR, bit(1)) ? self_th_32perDay;

    /** XB_LFIR[2]
     *  Clock Controller: PCB Access Error
     */
    (rXB_LFIR, bit(2)) ? self_th_32perDay;

    /** XB_LFIR[3]
     *  Clock Controller: Summarized Error
     */
    (rXB_LFIR, bit(3)) ? self_th_32perDay;

    /** XB_LFIR[4]
     *  PSCOM Logic: PCB Access Error
     */
    (rXB_LFIR, bit(4)) ? defaultMaskedError;

    /** XB_LFIR[5]
     *  PSCOM Logic: Summarized internal errors
     */
    (rXB_LFIR, bit(5)) ? defaultMaskedError;

    /** XB_LFIR[6]
     *  Therm Logic: Summarized internal errors
     */
    (rXB_LFIR, bit(6)) ? defaultMaskedError;

    /** XB_LFIR[7]
     *  Therm Logic: PCB Access Error
     */
    (rXB_LFIR, bit(7)) ? defaultMaskedError;

    /** XB_LFIR[8]
     *  Therm Logic: Temperature critical trip
     */
    (rXB_LFIR, bit(8)) ? defaultMaskedError;

    /** XB_LFIR[9]
     *  Therm Logic: Temperature fatal trip
     */
    (rXB_LFIR, bit(9)) ? defaultMaskedError;

    /** XB_LFIR[10]
     *  UNUSED in P9
     */
    (rXB_LFIR, bit(10)) ? defaultMaskedError;

    /** XB_LFIR[11]
     *  Debug Logic: Scom Satelite Error
     */
    (rXB_LFIR, bit(11)) ? defaultMaskedError;

    /** XB_LFIR[12]
     *  Scom Satellite Err - Trace0
     */
    (rXB_LFIR, bit(12)) ? defaultMaskedError;

    /** XB_LFIR[13]
     *  Scom Satellite Err - Trace0
     */
    (rXB_LFIR, bit(13)) ? defaultMaskedError;

    /** XB_LFIR[14]
     *  Scom Satellite Err - Trace1
     */
    (rXB_LFIR, bit(14)) ? defaultMaskedError;

    /** XB_LFIR[15]
     *  Scom Satellite Err - Trace1
     */
    (rXB_LFIR, bit(15)) ? defaultMaskedError;

    /** XB_LFIR[16:40]
     *  spare
     */
    (rXB_LFIR, bit(16|17|18|19|20|21|22|23|24|25|26|27|28|29|30|31|32|33|34|35|36|37|38|39|40)) ? defaultMaskedError;

    /** XB_LFIR[41]
     *  Malfunction Alert or Local Checkstop
     */
    (rXB_LFIR, bit(41)) ? defaultMaskedError;

};

################################################################################
# P9 chip XBPPEFIR
################################################################################

rule rXBPPEFIR
{
  CHECK_STOP:
    XBPPEFIR & ~XBPPEFIR_MASK & ~XBPPEFIR_ACT0 & ~XBPPEFIR_ACT1;
  RECOVERABLE:
    XBPPEFIR & ~XBPPEFIR_MASK & ~XBPPEFIR_ACT0 &  XBPPEFIR_ACT1;
  UNIT_CS:
    XBPPEFIR & ~XBPPEFIR_MASK &  XBPPEFIR_ACT0 &  XBPPEFIR_ACT1;
};

group gXBPPEFIR
    filter singlebit,
           cs_root_cause
{
    /** XBPPEFIR[0]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(0)) ? threshold_and_mask_self;

    /** XBPPEFIR[1]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(1)) ? threshold_and_mask_self;

    /** XBPPEFIR[2]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(2)) ? threshold_and_mask_self;

    /** XBPPEFIR[3]
     *  PPE general error.
     */
    (rXBPPEFIR, bit(3)) ? threshold_and_mask_self;

    /** XBPPEFIR[4]
     *  PPE halted.
     */
    (rXBPPEFIR, bit(4)) ? defaultMaskedError;

    /** XBPPEFIR[5]
     *  PPE watchdog timer timed out
     */
    (rXBPPEFIR, bit(5)) ? defaultMaskedError;

    /** XBPPEFIR[6]
     *  MMIO data in error.
     */
    (rXBPPEFIR, bit(6)) ? defaultMaskedError;

    /** XBPPEFIR[7]
     *  Arb missed scrub tick.
     */
    (rXBPPEFIR, bit(7)) ? threshold_and_mask_self;

    /** XBPPEFIR[8]
     *  Arb ary ue error.
     */
    (rXBPPEFIR, bit(8)) ? self_th_1;

    /** XBPPEFIR[9]
     *  Arb ary ce error.
     */
    (rXBPPEFIR, bit(9)) ? threshold_and_mask_self;

    /** XBPPEFIR[10]
     *  spare
     */
    (rXBPPEFIR, bit(10)) ? defaultMaskedError;

    /** XBPPEFIR[11]
     *  FIR_SCOMFIR_ERROR
     */
    (rXBPPEFIR, bit(11)) ? defaultMaskedError;

    /** XBPPEFIR[12]
     *  FIR_SCOMFIR_ERROR
     */
    (rXBPPEFIR, bit(12)) ? defaultMaskedError;

};

################################################################################
# PCI0 Chiplet FIR
################################################################################

rule rPCI0_CHIPLET_FIR
{
  CHECK_STOP:
     PCI0_CHIPLET_CS_FIR       & ~PCI0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (PCI0_CHIPLET_RE_FIR >> 2) & ~PCI0_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gPCI0_CHIPLET_FIR
    filter singlebit
{
    /** PCI0_CHIPLET_FIR[3]
     *  Attention from PCI_LFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(3)) ? analyzeConnectedPEC0;

    /** PCI0_CHIPLET_FIR[4]
     *  Attention from ETUFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(4)) ? analyzeConnectedPHB0;

    /** PCI0_CHIPLET_FIR[5]
     *  Attention from IOPCIFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(5)) ? analyzeConnectedPEC0;

    /** PCI0_CHIPLET_FIR[6]
     *  Attention from PCIFIR 0
     */
    (rPCI0_CHIPLET_FIR, bit(6)) ? analyzeConnectedPHB0;

};

################################################################################
# PCI1 Chiplet FIR
################################################################################

rule rPCI1_CHIPLET_FIR
{
  CHECK_STOP:
     PCI1_CHIPLET_CS_FIR       & ~PCI1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (PCI1_CHIPLET_RE_FIR >> 2) & ~PCI1_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gPCI1_CHIPLET_FIR
    filter singlebit
{
    /** PCI1_CHIPLET_FIR[3]
     *  Attention from PCI_LFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(3)) ? analyzeConnectedPEC1;

    /** PCI1_CHIPLET_FIR[4]
     *  Attention from ETUFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(4)) ? analyzeConnectedPHB1;

    /** PCI1_CHIPLET_FIR[5]
     *  Attention from ETUFIR 2
     */
    (rPCI1_CHIPLET_FIR, bit(5)) ? analyzeConnectedPHB2;

    /** PCI1_CHIPLET_FIR[6]
     *  Attention from IOPCIFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(6)) ? analyzeConnectedPEC1;

    /** PCI1_CHIPLET_FIR[7]
     *  Attention from PCIFIR 1
     */
    (rPCI1_CHIPLET_FIR, bit(7)) ? analyzeConnectedPHB1;

    /** PCI1_CHIPLET_FIR[8]
     *  Attention from PCIFIR 2
     */
    (rPCI1_CHIPLET_FIR, bit(8)) ? analyzeConnectedPHB2;

};

################################################################################
# PCI2 Chiplet FIR
################################################################################

rule rPCI2_CHIPLET_FIR
{
  CHECK_STOP:
     PCI2_CHIPLET_CS_FIR       & ~PCI2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
  RECOVERABLE:
    (PCI2_CHIPLET_RE_FIR >> 2) & ~PCI2_CHIPLET_FIR_MASK & `1fffffffffffffff`;
};

group gPCI2_CHIPLET_FIR
    filter singlebit
{
    /** PCI2_CHIPLET_FIR[3]
     *  Attention from PCI_LFIR 2
     */
    (rPCI2_CHIPLET_FIR, bit(3)) ? analyzeConnectedPEC2;

    /** PCI2_CHIPLET_FIR[4]
     *  Attention from ETUFIR 3
     */
    (rPCI2_CHIPLET_FIR, bit(4)) ? analyzeConnectedPHB3;

    /** PCI2_CHIPLET_FIR[5]
     *  Attention from ETUFIR 4
     */
    (rPCI2_CHIPLET_FIR, bit(5)) ? analyzeConnectedPHB4;

    /** PCI2_CHIPLET_FIR[6]
     *  Attention from ETUFIR 5
     */
    (rPCI2_CHIPLET_FIR, bit(6)) ? analyzeConnectedPHB5;

    /** PCI2_CHIPLET_FIR[7]
     *  Attention from IOPCIFIR 2
     */
    (rPCI2_CHIPLET_FIR, bit(7)) ? analyzeConnectedPEC2;

    /** PCI2_CHIPLET_FIR[8]
     *  Attention from PCIFIR 3
     */
    (rPCI2_CHIPLET_FIR, bit(8)) ? analyzeConnectedPHB3;

    /** PCI2_CHIPLET_FIR[9]
     *  Attention from PCIFIR 4
     */
    (rPCI2_CHIPLET_FIR, bit(9)) ? analyzeConnectedPHB4;

    /** PCI2_CHIPLET_FIR[10]
     *  Attention from PCIFIR 5
     */
    (rPCI2_CHIPLET_FIR, bit(10)) ? analyzeConnectedPHB5;

};

 ##############################################################################
 #                                                                            #
 #    #                                  ###                                  #
 #   # #    ##  ##### ###  ###  #   #   #   # #     #    ###   ###  ###  ###  #
 #  #   #  #  #   #    #  #   # ##  #   #     #    # #  #     #     #   #     #
 # ####### #      #    #  #   # # # #   #     #   #####  ###   ###  ##   ###  #
 # #     # #  #   #    #  #   # #  ##   #   # #   #   #     #     # #       # #
 # #     #  ##    #   ###  ###  #   #    ###  ### #   #  ###   ###  ###  ###  #
 #                                                                            #
 ##############################################################################

# Include the actions defined for this target
.include "p9_common_actions.rule";
.include "p9_common_proc_actions.rule";
.include "nimbus_proc_actions.rule";
.include "p9_common_npu_actions.rule";

