# IBM_PROLOG_BEGIN_TAG
# This is an automatically generated prolog.
#
# $Source: src/usr/diag/prdf/common/plat/p10/p10_proc.rule $
#
# OpenPOWER HostBoot Project
#
# Contributors Listed Below - COPYRIGHT 2020,2021
# [+] International Business Machines Corp.
#
#
# Licensed under the Apache License, Version 2.0 (the "License");
# you may not use this file except in compliance with the License.
# You may obtain a copy of the License at
#
#     http://www.apache.org/licenses/LICENSE-2.0
#
# Unless required by applicable law or agreed to in writing, software
# distributed under the License is distributed on an "AS IS" BASIS,
# WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or
# implied. See the License for the specific language governing
# permissions and limitations under the License.
#
# IBM_PROLOG_END_TAG

chip p10_proc
{
    name        "P10 PROC target";
    targettype  TYPE_PROC;
    sigoff      0x0000;
    dump        DUMP_CONTENT_HW;
    scomlen     64;

# Import signatures
.include "prdfP10ProcExtraSig.H";

 #############################################################################
 #                                                                           #
 #  ######                                                                   #
 #  #     #  ######   ####     ###    ####    #####  ######  #####    ####   #
 #  #     #  #       #    #     #    #          #    #       #    #  #       #
 #  ######   #####   #          #     ####      #    #####   #    #   ####   #
 #  #   #    #       #  ###     #         #     #    #       #####        #  #
 #  #    #   #       #    #     #    #    #     #    #       #   #   #    #  #
 #  #     #  ######   ####     ###    ####      #    ######  #    #   ####   #
 #                                                                           #
 #############################################################################

    ############################################################################
    # Global Checkstop Attention FIR
    ############################################################################

    register GLOBAL_CS_FIR
    {
        name        "Global Checkstop Attention FIR";
        scomaddr    0x570F001C;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # Global Recoverable Attention FIR
    ############################################################################

    register GLOBAL_RE_FIR
    {
        name        "Global Recoverable Attention FIR";
        scomaddr    0x570F001B;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # Global Unit Checkstop Attention FIR
    ############################################################################

    register GLOBAL_UCS_FIR
    {
        name        "Global Unit Checkstop Attention FIR";
        scomaddr    0x570F002A;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # Global Host Attention FIR
    ############################################################################

    register GLOBAL_HA_FIR
    {
        name        "Global Host Attention FIR";
        scomaddr    0x570F002B;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # TP Chiplet Checkstop FIR
    ############################################################################

    register TP_CHIPLET_CS_FIR
    {
        name        "TP Chiplet Checkstop FIR";
        scomaddr    0x01040000;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    register TP_CHIPLET_CS_FIR_MASK
    {
        name        "TP Chiplet Checkstop FIR MASK";
        scomaddr    0x01040040;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # TP Chiplet Recoverable FIR
    ############################################################################

    register TP_CHIPLET_RE_FIR
    {
        name        "TP Chiplet Recoverable FIR";
        scomaddr    0x01040001;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    register TP_CHIPLET_RE_FIR_MASK
    {
        name        "TP Chiplet Recoverable FIR MASK";
        scomaddr    0x01040041;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # TP Chiplet Unit Checkstop FIR
    ############################################################################

    register TP_CHIPLET_UCS_FIR
    {
        name        "TP Chiplet Unit Checkstop FIR";
        scomaddr    0x01040003;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    register TP_CHIPLET_UCS_FIR_MASK
    {
        name        "TP Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x01040043;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # TP Chiplet Host Attention FIR
    ############################################################################

    register TP_CHIPLET_HA_FIR
    {
        name        "TP Chiplet Host Attention FIR";
        scomaddr    0x01040004;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    register TP_CHIPLET_HA_FIR_MASK
    {
        name        "TP Chiplet Host Attention FIR MASK";
        scomaddr    0x01040044;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    ############################################################################
    # P10 chip TP_LOCAL_FIR
    ############################################################################

    register TP_LOCAL_FIR
    {
        name        "P10 chip TP_LOCAL_FIR";
        scomaddr    0x01040100;
        reset       (&, 0x01040101);
        mask        (|, 0x01040105);
        capture     group default;
        capture     group default_pll_ffdc;
    };

    register TP_LOCAL_FIR_MASK
    {
        name        "P10 chip TP_LOCAL_FIR MASK";
        scomaddr    0x01040103;
        capture     group default;
        capture     group default_pll_ffdc;
    };

    register TP_LOCAL_FIR_ACT0
    {
        name        "P10 chip TP_LOCAL_FIR ACT0";
        scomaddr    0x01040106;
        capture     group default;
        capture     group default_pll_ffdc;
        capture     req nonzero("TP_LOCAL_FIR");
    };

    register TP_LOCAL_FIR_ACT1
    {
        name        "P10 chip TP_LOCAL_FIR ACT1";
        scomaddr    0x01040107;
        capture     group default;
        capture     group default_pll_ffdc;
        capture     req nonzero("TP_LOCAL_FIR");
    };

    register TP_LOCAL_FIR_ACT2
    {
        name        "P10 chip TP_LOCAL_FIR ACT2";
        scomaddr    0x01040109;
        capture     group default;
        capture     group default_pll_ffdc;
        capture     req nonzero("TP_LOCAL_FIR");
    };

    ############################################################################
    # P10 chip OCC_FIR
    ############################################################################

    register OCC_FIR
    {
        name        "P10 chip OCC_FIR";
        scomaddr    0x01010800;
        reset       (&, 0x01010801);
        mask        (|, 0x01010805);
        capture     group default;
    };

    register OCC_FIR_MASK
    {
        name        "P10 chip OCC_FIR MASK";
        scomaddr    0x01010803;
        capture     group default;
    };

    register OCC_FIR_ACT0
    {
        name        "P10 chip OCC_FIR ACT0";
        scomaddr    0x01010806;
        capture     group default;
        capture     req nonzero("OCC_FIR");
    };

    register OCC_FIR_ACT1
    {
        name        "P10 chip OCC_FIR ACT1";
        scomaddr    0x01010807;
        capture     group default;
        capture     req nonzero("OCC_FIR");
    };

    ############################################################################
    # P10 chip PBAO_FIR
    ############################################################################

    register PBAO_FIR
    {
        name        "P10 chip PBAO_FIR";
        scomaddr    0x01010cc0;
        reset       (&, 0x01010cc1);
        mask        (|, 0x01010cc5);
        capture     group default;
    };

    register PBAO_FIR_MASK
    {
        name        "P10 chip PBAO_FIR MASK";
        scomaddr    0x01010cc3;
        capture     group default;
    };

    register PBAO_FIR_ACT0
    {
        name        "P10 chip PBAO_FIR ACT0";
        scomaddr    0x01010cc6;
        capture     group default;
        capture     req nonzero("PBAO_FIR");
    };

    register PBAO_FIR_ACT1
    {
        name        "P10 chip PBAO_FIR ACT1";
        scomaddr    0x01010cc7;
        capture     group default;
        capture     req nonzero("PBAO_FIR");
    };

    ############################################################################
    # N0 Chiplet Checkstop FIR
    ############################################################################

    register N0_CHIPLET_CS_FIR
    {
        name        "N0 Chiplet Checkstop FIR";
        scomaddr    0x02040000;
        capture     group default;
    };

    register N0_CHIPLET_CS_FIR_MASK
    {
        name        "N0 Chiplet Checkstop FIR MASK";
        scomaddr    0x02040040;
        capture     group default;
    };

    ############################################################################
    # N0 Chiplet Recoverable FIR
    ############################################################################

    register N0_CHIPLET_RE_FIR
    {
        name        "N0 Chiplet Recoverable FIR";
        scomaddr    0x02040001;
        capture     group default;
    };

    register N0_CHIPLET_RE_FIR_MASK
    {
        name        "N0 Chiplet Recoverable FIR MASK";
        scomaddr    0x02040041;
        capture     group default;
    };

    ############################################################################
    # N0 Chiplet Unit Checkstop FIR
    ############################################################################

    register N0_CHIPLET_UCS_FIR
    {
        name        "N0 Chiplet Unit Checkstop FIR";
        scomaddr    0x02040003;
        capture     group default;
    };

    register N0_CHIPLET_UCS_FIR_MASK
    {
        name        "N0 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x02040043;
        capture     group default;
    };

    ############################################################################
    # N0 Chiplet Host Attention FIR
    ############################################################################

    register N0_CHIPLET_HA_FIR
    {
        name        "N0 Chiplet Host Attention FIR";
        scomaddr    0x02040004;
        capture     group default;
    };

    register N0_CHIPLET_HA_FIR_MASK
    {
        name        "N0 Chiplet Host Attention FIR MASK";
        scomaddr    0x02040044;
        capture     group default;
    };

    ############################################################################
    # P10 chip N0_LOCAL_FIR
    ############################################################################

    register N0_LOCAL_FIR
    {
        name        "P10 chip N0_LOCAL_FIR";
        scomaddr    0x02040100;
        reset       (&, 0x02040101);
        mask        (|, 0x02040105);
        capture     group default;
    };

    register N0_LOCAL_FIR_MASK
    {
        name        "P10 chip N0_LOCAL_FIR MASK";
        scomaddr    0x02040103;
        capture     group default;
    };

    register N0_LOCAL_FIR_ACT0
    {
        name        "P10 chip N0_LOCAL_FIR ACT0";
        scomaddr    0x02040106;
        capture     group default;
        capture     req nonzero("N0_LOCAL_FIR");
    };

    register N0_LOCAL_FIR_ACT1
    {
        name        "P10 chip N0_LOCAL_FIR ACT1";
        scomaddr    0x02040107;
        capture     group default;
        capture     req nonzero("N0_LOCAL_FIR");
    };

    register N0_LOCAL_FIR_ACT2
    {
        name        "P10 chip N0_LOCAL_FIR ACT2";
        scomaddr    0x02040109;
        capture     group default;
        capture     req nonzero("N0_LOCAL_FIR");
    };

    ############################################################################
    # P10 chip INT_CQ_FIR
    ############################################################################

    register INT_CQ_FIR
    {
        name        "P10 chip INT_CQ_FIR";
        scomaddr    0x02010830;
        reset       (&, 0x02010831);
        mask        (|, 0x02010835);
        capture     group default;
    };

    register INT_CQ_FIR_MASK
    {
        name        "P10 chip INT_CQ_FIR MASK";
        scomaddr    0x02010833;
        capture     group default;
    };

    register INT_CQ_FIR_ACT0
    {
        name        "P10 chip INT_CQ_FIR ACT0";
        scomaddr    0x02010836;
        capture     group default;
        capture     req nonzero("INT_CQ_FIR");
    };

    register INT_CQ_FIR_ACT1
    {
        name        "P10 chip INT_CQ_FIR ACT1";
        scomaddr    0x02010837;
        capture     group default;
        capture     req nonzero("INT_CQ_FIR");
    };

    ############################################################################
    # P10 chip NX_CQ_FIR
    ############################################################################

    register NX_CQ_FIR
    {
        name        "P10 chip NX_CQ_FIR";
        scomaddr    0x02011080;
        reset       (&, 0x02011081);
        mask        (|, 0x02011085);
        capture     group default;
    };

    register NX_CQ_FIR_MASK
    {
        name        "P10 chip NX_CQ_FIR MASK";
        scomaddr    0x02011083;
        capture     group default;
    };

    register NX_CQ_FIR_ACT0
    {
        name        "P10 chip NX_CQ_FIR ACT0";
        scomaddr    0x02011086;
        capture     group default;
        capture     req nonzero("NX_CQ_FIR");
    };

    register NX_CQ_FIR_ACT1
    {
        name        "P10 chip NX_CQ_FIR ACT1";
        scomaddr    0x02011087;
        capture     group default;
        capture     req nonzero("NX_CQ_FIR");
    };

    ############################################################################
    # P10 chip NX_DMA_ENG_FIR
    ############################################################################

    register NX_DMA_ENG_FIR
    {
        name        "P10 chip NX_DMA_ENG_FIR";
        scomaddr    0x02011100;
        reset       (&, 0x02011101);
        mask        (|, 0x02011105);
        capture     group default;
    };

    register NX_DMA_ENG_FIR_MASK
    {
        name        "P10 chip NX_DMA_ENG_FIR MASK";
        scomaddr    0x02011103;
        capture     group default;
    };

    register NX_DMA_ENG_FIR_ACT0
    {
        name        "P10 chip NX_DMA_ENG_FIR ACT0";
        scomaddr    0x02011106;
        capture     group default;
        capture     req nonzero("NX_DMA_ENG_FIR");
    };

    register NX_DMA_ENG_FIR_ACT1
    {
        name        "P10 chip NX_DMA_ENG_FIR ACT1";
        scomaddr    0x02011107;
        capture     group default;
        capture     req nonzero("NX_DMA_ENG_FIR");
    };

    ############################################################################
    # P10 chip VAS_FIR
    ############################################################################

    register VAS_FIR
    {
        name        "P10 chip VAS_FIR";
        scomaddr    0x02011400;
        reset       (&, 0x02011401);
        mask        (|, 0x02011405);
        capture     group default;
    };

    register VAS_FIR_MASK
    {
        name        "P10 chip VAS_FIR MASK";
        scomaddr    0x02011403;
        capture     group default;
    };

    register VAS_FIR_ACT0
    {
        name        "P10 chip VAS_FIR ACT0";
        scomaddr    0x02011406;
        capture     group default;
        capture     req nonzero("VAS_FIR");
    };

    register VAS_FIR_ACT1
    {
        name        "P10 chip VAS_FIR ACT1";
        scomaddr    0x02011407;
        capture     group default;
        capture     req nonzero("VAS_FIR");
    };

    ############################################################################
    # N1 Chiplet Checkstop FIR
    ############################################################################

    register N1_CHIPLET_CS_FIR
    {
        name        "N1 Chiplet Checkstop FIR";
        scomaddr    0x03040000;
        capture     group default;
    };

    register N1_CHIPLET_CS_FIR_MASK
    {
        name        "N1 Chiplet Checkstop FIR MASK";
        scomaddr    0x03040040;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Recoverable FIR
    ############################################################################

    register N1_CHIPLET_RE_FIR
    {
        name        "N1 Chiplet Recoverable FIR";
        scomaddr    0x03040001;
        capture     group default;
    };

    register N1_CHIPLET_RE_FIR_MASK
    {
        name        "N1 Chiplet Recoverable FIR MASK";
        scomaddr    0x03040041;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Unit Checkstop FIR
    ############################################################################

    register N1_CHIPLET_UCS_FIR
    {
        name        "N1 Chiplet Unit Checkstop FIR";
        scomaddr    0x03040003;
        capture     group default;
    };

    register N1_CHIPLET_UCS_FIR_MASK
    {
        name        "N1 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x03040043;
        capture     group default;
    };

    ############################################################################
    # N1 Chiplet Host Attention FIR
    ############################################################################

    register N1_CHIPLET_HA_FIR
    {
        name        "N1 Chiplet Host Attention FIR";
        scomaddr    0x03040004;
        capture     group default;
    };

    register N1_CHIPLET_HA_FIR_MASK
    {
        name        "N1 Chiplet Host Attention FIR MASK";
        scomaddr    0x03040044;
        capture     group default;
    };

    ############################################################################
    # P10 chip N1_LOCAL_FIR
    ############################################################################

    register N1_LOCAL_FIR
    {
        name        "P10 chip N1_LOCAL_FIR";
        scomaddr    0x03040100;
        reset       (&, 0x03040101);
        mask        (|, 0x03040105);
        capture     group default;
    };

    register N1_LOCAL_FIR_MASK
    {
        name        "P10 chip N1_LOCAL_FIR MASK";
        scomaddr    0x03040103;
        capture     group default;
    };

    register N1_LOCAL_FIR_ACT0
    {
        name        "P10 chip N1_LOCAL_FIR ACT0";
        scomaddr    0x03040106;
        capture     group default;
        capture     req nonzero("N1_LOCAL_FIR");
    };

    register N1_LOCAL_FIR_ACT1
    {
        name        "P10 chip N1_LOCAL_FIR ACT1";
        scomaddr    0x03040107;
        capture     group default;
        capture     req nonzero("N1_LOCAL_FIR");
    };

    register N1_LOCAL_FIR_ACT2
    {
        name        "P10 chip N1_LOCAL_FIR ACT2";
        scomaddr    0x03040109;
        capture     group default;
        capture     req nonzero("N1_LOCAL_FIR");
    };

    ############################################################################
    # P10 chip MCD_FIR
    ############################################################################

    register MCD_FIR
    {
        name        "P10 chip MCD_FIR";
        scomaddr    0x03010800;
        reset       (&, 0x03010801);
        mask        (|, 0x03010805);
        capture     group default;
    };

    register MCD_FIR_MASK
    {
        name        "P10 chip MCD_FIR MASK";
        scomaddr    0x03010803;
        capture     group default;
    };

    register MCD_FIR_ACT0
    {
        name        "P10 chip MCD_FIR ACT0";
        scomaddr    0x03010806;
        capture     group default;
        capture     req nonzero("MCD_FIR");
    };

    register MCD_FIR_ACT1
    {
        name        "P10 chip MCD_FIR ACT1";
        scomaddr    0x03010807;
        capture     group default;
        capture     req nonzero("MCD_FIR");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 0
    ############################################################################

    register PB_STATION_FIR_EQ_0
    {
        name        "P10 chip PB_STATION_FIR_EQ 0";
        scomaddr    0x03011000;
        reset       (&, 0x03011001);
        mask        (|, 0x03011005);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_0_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 0 MASK";
        scomaddr    0x03011003;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_0_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 0 ACT0";
        scomaddr    0x03011006;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_0");
    };

    register PB_STATION_FIR_EQ_0_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 0 ACT1";
        scomaddr    0x03011007;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_0");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 1
    ############################################################################

    register PB_STATION_FIR_EQ_1
    {
        name        "P10 chip PB_STATION_FIR_EQ 1";
        scomaddr    0x03011040;
        reset       (&, 0x03011041);
        mask        (|, 0x03011045);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_1_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 1 MASK";
        scomaddr    0x03011043;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_1_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 1 ACT0";
        scomaddr    0x03011046;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_1");
    };

    register PB_STATION_FIR_EQ_1_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 1 ACT1";
        scomaddr    0x03011047;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_1");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 2
    ############################################################################

    register PB_STATION_FIR_EQ_2
    {
        name        "P10 chip PB_STATION_FIR_EQ 2";
        scomaddr    0x03011080;
        reset       (&, 0x03011081);
        mask        (|, 0x03011085);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_2_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 2 MASK";
        scomaddr    0x03011083;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_2_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 2 ACT0";
        scomaddr    0x03011086;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_2");
    };

    register PB_STATION_FIR_EQ_2_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 2 ACT1";
        scomaddr    0x03011087;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_2");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 3
    ############################################################################

    register PB_STATION_FIR_EQ_3
    {
        name        "P10 chip PB_STATION_FIR_EQ 3";
        scomaddr    0x030110c0;
        reset       (&, 0x030110c1);
        mask        (|, 0x030110c5);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_3_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 3 MASK";
        scomaddr    0x030110c3;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_3_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 3 ACT0";
        scomaddr    0x030110c6;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_3");
    };

    register PB_STATION_FIR_EQ_3_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 3 ACT1";
        scomaddr    0x030110c7;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_3");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 4
    ############################################################################

    register PB_STATION_FIR_EQ_4
    {
        name        "P10 chip PB_STATION_FIR_EQ 4";
        scomaddr    0x03011100;
        reset       (&, 0x03011101);
        mask        (|, 0x03011105);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_4_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 4 MASK";
        scomaddr    0x03011103;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_4_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 4 ACT0";
        scomaddr    0x03011106;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_4");
    };

    register PB_STATION_FIR_EQ_4_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 4 ACT1";
        scomaddr    0x03011107;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_4");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 5
    ############################################################################

    register PB_STATION_FIR_EQ_5
    {
        name        "P10 chip PB_STATION_FIR_EQ 5";
        scomaddr    0x03011140;
        reset       (&, 0x03011141);
        mask        (|, 0x03011145);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_5_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 5 MASK";
        scomaddr    0x03011143;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_5_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 5 ACT0";
        scomaddr    0x03011146;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_5");
    };

    register PB_STATION_FIR_EQ_5_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 5 ACT1";
        scomaddr    0x03011147;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_5");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 6
    ############################################################################

    register PB_STATION_FIR_EQ_6
    {
        name        "P10 chip PB_STATION_FIR_EQ 6";
        scomaddr    0x03011180;
        reset       (&, 0x03011181);
        mask        (|, 0x03011185);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_6_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 6 MASK";
        scomaddr    0x03011183;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_6_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 6 ACT0";
        scomaddr    0x03011186;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_6");
    };

    register PB_STATION_FIR_EQ_6_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 6 ACT1";
        scomaddr    0x03011187;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_6");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EQ 7
    ############################################################################

    register PB_STATION_FIR_EQ_7
    {
        name        "P10 chip PB_STATION_FIR_EQ 7";
        scomaddr    0x030111c0;
        reset       (&, 0x030111c1);
        mask        (|, 0x030111c5);
        capture     group default;
    };

    register PB_STATION_FIR_EQ_7_MASK
    {
        name        "P10 chip PB_STATION_FIR_EQ 7 MASK";
        scomaddr    0x030111c3;
        capture     group default;
    };

    register PB_STATION_FIR_EQ_7_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EQ 7 ACT0";
        scomaddr    0x030111c6;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_7");
    };

    register PB_STATION_FIR_EQ_7_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EQ 7 ACT1";
        scomaddr    0x030111c7;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EQ_7");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EN1
    ############################################################################

    register PB_STATION_FIR_EN1
    {
        name        "P10 chip PB_STATION_FIR_EN1";
        scomaddr    0x03011200;
        reset       (&, 0x03011201);
        mask        (|, 0x03011205);
        capture     group default;
    };

    register PB_STATION_FIR_EN1_MASK
    {
        name        "P10 chip PB_STATION_FIR_EN1 MASK";
        scomaddr    0x03011203;
        capture     group default;
    };

    register PB_STATION_FIR_EN1_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EN1 ACT0";
        scomaddr    0x03011206;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN1");
    };

    register PB_STATION_FIR_EN1_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EN1 ACT1";
        scomaddr    0x03011207;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN1");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EN2
    ############################################################################

    register PB_STATION_FIR_EN2
    {
        name        "P10 chip PB_STATION_FIR_EN2";
        scomaddr    0x03011240;
        reset       (&, 0x03011241);
        mask        (|, 0x03011245);
        capture     group default;
    };

    register PB_STATION_FIR_EN2_MASK
    {
        name        "P10 chip PB_STATION_FIR_EN2 MASK";
        scomaddr    0x03011243;
        capture     group default;
    };

    register PB_STATION_FIR_EN2_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EN2 ACT0";
        scomaddr    0x03011246;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN2");
    };

    register PB_STATION_FIR_EN2_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EN2 ACT1";
        scomaddr    0x03011247;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN2");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EN3
    ############################################################################

    register PB_STATION_FIR_EN3
    {
        name        "P10 chip PB_STATION_FIR_EN3";
        scomaddr    0x03011280;
        reset       (&, 0x03011281);
        mask        (|, 0x03011285);
        capture     group default;
    };

    register PB_STATION_FIR_EN3_MASK
    {
        name        "P10 chip PB_STATION_FIR_EN3 MASK";
        scomaddr    0x03011283;
        capture     group default;
    };

    register PB_STATION_FIR_EN3_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EN3 ACT0";
        scomaddr    0x03011286;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN3");
    };

    register PB_STATION_FIR_EN3_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EN3 ACT1";
        scomaddr    0x03011287;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN3");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_EN4
    ############################################################################

    register PB_STATION_FIR_EN4
    {
        name        "P10 chip PB_STATION_FIR_EN4";
        scomaddr    0x030112c0;
        reset       (&, 0x030112c1);
        mask        (|, 0x030112c5);
        capture     group default;
    };

    register PB_STATION_FIR_EN4_MASK
    {
        name        "P10 chip PB_STATION_FIR_EN4 MASK";
        scomaddr    0x030112c3;
        capture     group default;
    };

    register PB_STATION_FIR_EN4_ACT0
    {
        name        "P10 chip PB_STATION_FIR_EN4 ACT0";
        scomaddr    0x030112c6;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN4");
    };

    register PB_STATION_FIR_EN4_ACT1
    {
        name        "P10 chip PB_STATION_FIR_EN4 ACT1";
        scomaddr    0x030112c7;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_EN4");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_ES1
    ############################################################################

    register PB_STATION_FIR_ES1
    {
        name        "P10 chip PB_STATION_FIR_ES1";
        scomaddr    0x03011300;
        reset       (&, 0x03011301);
        mask        (|, 0x03011305);
        capture     group default;
    };

    register PB_STATION_FIR_ES1_MASK
    {
        name        "P10 chip PB_STATION_FIR_ES1 MASK";
        scomaddr    0x03011303;
        capture     group default;
    };

    register PB_STATION_FIR_ES1_ACT0
    {
        name        "P10 chip PB_STATION_FIR_ES1 ACT0";
        scomaddr    0x03011306;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES1");
    };

    register PB_STATION_FIR_ES1_ACT1
    {
        name        "P10 chip PB_STATION_FIR_ES1 ACT1";
        scomaddr    0x03011307;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES1");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_ES2
    ############################################################################

    register PB_STATION_FIR_ES2
    {
        name        "P10 chip PB_STATION_FIR_ES2";
        scomaddr    0x03011340;
        reset       (&, 0x03011341);
        mask        (|, 0x03011345);
        capture     group default;
    };

    register PB_STATION_FIR_ES2_MASK
    {
        name        "P10 chip PB_STATION_FIR_ES2 MASK";
        scomaddr    0x03011343;
        capture     group default;
    };

    register PB_STATION_FIR_ES2_ACT0
    {
        name        "P10 chip PB_STATION_FIR_ES2 ACT0";
        scomaddr    0x03011346;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES2");
    };

    register PB_STATION_FIR_ES2_ACT1
    {
        name        "P10 chip PB_STATION_FIR_ES2 ACT1";
        scomaddr    0x03011347;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES2");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_ES3
    ############################################################################

    register PB_STATION_FIR_ES3
    {
        name        "P10 chip PB_STATION_FIR_ES3";
        scomaddr    0x03011380;
        reset       (&, 0x03011381);
        mask        (|, 0x03011385);
        capture     group default;
    };

    register PB_STATION_FIR_ES3_MASK
    {
        name        "P10 chip PB_STATION_FIR_ES3 MASK";
        scomaddr    0x03011383;
        capture     group default;
    };

    register PB_STATION_FIR_ES3_ACT0
    {
        name        "P10 chip PB_STATION_FIR_ES3 ACT0";
        scomaddr    0x03011386;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES3");
    };

    register PB_STATION_FIR_ES3_ACT1
    {
        name        "P10 chip PB_STATION_FIR_ES3 ACT1";
        scomaddr    0x03011387;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES3");
    };

    ############################################################################
    # P10 chip PB_STATION_FIR_ES4
    ############################################################################

    register PB_STATION_FIR_ES4
    {
        name        "P10 chip PB_STATION_FIR_ES4";
        scomaddr    0x030113c0;
        reset       (&, 0x030113c1);
        mask        (|, 0x030113c5);
        capture     group default;
    };

    register PB_STATION_FIR_ES4_MASK
    {
        name        "P10 chip PB_STATION_FIR_ES4 MASK";
        scomaddr    0x030113c3;
        capture     group default;
    };

    register PB_STATION_FIR_ES4_ACT0
    {
        name        "P10 chip PB_STATION_FIR_ES4 ACT0";
        scomaddr    0x030113c6;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES4");
    };

    register PB_STATION_FIR_ES4_ACT1
    {
        name        "P10 chip PB_STATION_FIR_ES4 ACT1";
        scomaddr    0x030113c7;
        capture     group default;
        capture     req nonzero("PB_STATION_FIR_ES4");
    };

    ############################################################################
    # P10 chip PSIHB_FIR
    ############################################################################

    register PSIHB_FIR
    {
        name        "P10 chip PSIHB_FIR";
        scomaddr    0x03011d00;
        reset       (&, 0x03011d01);
        mask        (|, 0x03011d05);
        capture     group default;
    };

    register PSIHB_FIR_MASK
    {
        name        "P10 chip PSIHB_FIR MASK";
        scomaddr    0x03011d03;
        capture     group default;
    };

    register PSIHB_FIR_ACT0
    {
        name        "P10 chip PSIHB_FIR ACT0";
        scomaddr    0x03011d06;
        capture     group default;
        capture     req nonzero("PSIHB_FIR");
    };

    register PSIHB_FIR_ACT1
    {
        name        "P10 chip PSIHB_FIR ACT1";
        scomaddr    0x03011d07;
        capture     group default;
        capture     req nonzero("PSIHB_FIR");
    };

    ############################################################################
    # P10 chip HCA_FIR
    ############################################################################

    register HCA_FIR
    {
        name        "P10 chip HCA_FIR";
        scomaddr    0x03011d40;
        reset       (&, 0x03011d41);
        mask        (|, 0x03011d45);
        capture     group default;
    };

    register HCA_FIR_MASK
    {
        name        "P10 chip HCA_FIR MASK";
        scomaddr    0x03011d43;
        capture     group default;
    };

    register HCA_FIR_ACT0
    {
        name        "P10 chip HCA_FIR ACT0";
        scomaddr    0x03011d46;
        capture     group default;
        capture     req nonzero("HCA_FIR");
    };

    register HCA_FIR_ACT1
    {
        name        "P10 chip HCA_FIR ACT1";
        scomaddr    0x03011d47;
        capture     group default;
        capture     req nonzero("HCA_FIR");
    };

    ############################################################################
    # P10 chip PBAF_FIR
    ############################################################################

    register PBAF_FIR
    {
        name        "P10 chip PBAF_FIR";
        scomaddr    0x03011dc0;
        reset       (&, 0x03011dc1);
        mask        (|, 0x03011dc5);
        capture     group default;
    };

    register PBAF_FIR_MASK
    {
        name        "P10 chip PBAF_FIR MASK";
        scomaddr    0x03011dc3;
        capture     group default;
    };

    register PBAF_FIR_ACT0
    {
        name        "P10 chip PBAF_FIR ACT0";
        scomaddr    0x03011dc6;
        capture     group default;
        capture     req nonzero("PBAF_FIR");
    };

    register PBAF_FIR_ACT1
    {
        name        "P10 chip PBAF_FIR ACT1";
        scomaddr    0x03011dc7;
        capture     group default;
        capture     req nonzero("PBAF_FIR");
    };

    ############################################################################
    # P10 chip LPC_FIR
    ############################################################################

    register LPC_FIR
    {
        name        "P10 chip LPC_FIR";
        scomaddr    0x03012000;
        reset       (&, 0x03012001);
        mask        (|, 0x03012005);
        capture     group default;
    };

    register LPC_FIR_MASK
    {
        name        "P10 chip LPC_FIR MASK";
        scomaddr    0x03012003;
        capture     group default;
    };

    register LPC_FIR_ACT0
    {
        name        "P10 chip LPC_FIR ACT0";
        scomaddr    0x03012006;
        capture     group default;
        capture     req nonzero("LPC_FIR");
    };

    register LPC_FIR_ACT1
    {
        name        "P10 chip LPC_FIR ACT1";
        scomaddr    0x03012007;
        capture     group default;
        capture     req nonzero("LPC_FIR");
    };

    ############################################################################
    # PAU0 Chiplet Checkstop FIR
    ############################################################################

    register PAU0_CHIPLET_CS_FIR
    {
        name        "PAU0 Chiplet Checkstop FIR";
        scomaddr    0x10040000;
        capture     group default;
    };

    register PAU0_CHIPLET_CS_FIR_MASK
    {
        name        "PAU0 Chiplet Checkstop FIR MASK";
        scomaddr    0x10040040;
        capture     group default;
    };

    ############################################################################
    # PAU0 Chiplet Recoverable FIR
    ############################################################################

    register PAU0_CHIPLET_RE_FIR
    {
        name        "PAU0 Chiplet Recoverable FIR";
        scomaddr    0x10040001;
        capture     group default;
    };

    register PAU0_CHIPLET_RE_FIR_MASK
    {
        name        "PAU0 Chiplet Recoverable FIR MASK";
        scomaddr    0x10040041;
        capture     group default;
    };

    ############################################################################
    # PAU0 Chiplet Unit Checkstop FIR
    ############################################################################

    register PAU0_CHIPLET_UCS_FIR
    {
        name        "PAU0 Chiplet Unit Checkstop FIR";
        scomaddr    0x10040003;
        capture     group default;
    };

    register PAU0_CHIPLET_UCS_FIR_MASK
    {
        name        "PAU0 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x10040043;
        capture     group default;
    };

    ############################################################################
    # PAU0 Chiplet Host Attention FIR
    ############################################################################

    register PAU0_CHIPLET_HA_FIR
    {
        name        "PAU0 Chiplet Host Attention FIR";
        scomaddr    0x10040004;
        capture     group default;
    };

    register PAU0_CHIPLET_HA_FIR_MASK
    {
        name        "PAU0 Chiplet Host Attention FIR MASK";
        scomaddr    0x10040044;
        capture     group default;
    };

    ############################################################################
    # PAU1 Chiplet Checkstop FIR
    ############################################################################

    register PAU1_CHIPLET_CS_FIR
    {
        name        "PAU1 Chiplet Checkstop FIR";
        scomaddr    0x11040000;
        capture     group default;
    };

    register PAU1_CHIPLET_CS_FIR_MASK
    {
        name        "PAU1 Chiplet Checkstop FIR MASK";
        scomaddr    0x11040040;
        capture     group default;
    };

    ############################################################################
    # PAU1 Chiplet Recoverable FIR
    ############################################################################

    register PAU1_CHIPLET_RE_FIR
    {
        name        "PAU1 Chiplet Recoverable FIR";
        scomaddr    0x11040001;
        capture     group default;
    };

    register PAU1_CHIPLET_RE_FIR_MASK
    {
        name        "PAU1 Chiplet Recoverable FIR MASK";
        scomaddr    0x11040041;
        capture     group default;
    };

    ############################################################################
    # PAU1 Chiplet Unit Checkstop FIR
    ############################################################################

    register PAU1_CHIPLET_UCS_FIR
    {
        name        "PAU1 Chiplet Unit Checkstop FIR";
        scomaddr    0x11040003;
        capture     group default;
    };

    register PAU1_CHIPLET_UCS_FIR_MASK
    {
        name        "PAU1 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x11040043;
        capture     group default;
    };

    ############################################################################
    # PAU1 Chiplet Host Attention FIR
    ############################################################################

    register PAU1_CHIPLET_HA_FIR
    {
        name        "PAU1 Chiplet Host Attention FIR";
        scomaddr    0x11040004;
        capture     group default;
    };

    register PAU1_CHIPLET_HA_FIR_MASK
    {
        name        "PAU1 Chiplet Host Attention FIR MASK";
        scomaddr    0x11040044;
        capture     group default;
    };

    ############################################################################
    # PAU2 Chiplet Checkstop FIR
    ############################################################################

    register PAU2_CHIPLET_CS_FIR
    {
        name        "PAU2 Chiplet Checkstop FIR";
        scomaddr    0x12040000;
        capture     group default;
    };

    register PAU2_CHIPLET_CS_FIR_MASK
    {
        name        "PAU2 Chiplet Checkstop FIR MASK";
        scomaddr    0x12040040;
        capture     group default;
    };

    ############################################################################
    # PAU2 Chiplet Recoverable FIR
    ############################################################################

    register PAU2_CHIPLET_RE_FIR
    {
        name        "PAU2 Chiplet Recoverable FIR";
        scomaddr    0x12040001;
        capture     group default;
    };

    register PAU2_CHIPLET_RE_FIR_MASK
    {
        name        "PAU2 Chiplet Recoverable FIR MASK";
        scomaddr    0x12040041;
        capture     group default;
    };

    ############################################################################
    # PAU2 Chiplet Unit Checkstop FIR
    ############################################################################

    register PAU2_CHIPLET_UCS_FIR
    {
        name        "PAU2 Chiplet Unit Checkstop FIR";
        scomaddr    0x12040003;
        capture     group default;
    };

    register PAU2_CHIPLET_UCS_FIR_MASK
    {
        name        "PAU2 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x12040043;
        capture     group default;
    };

    ############################################################################
    # PAU2 Chiplet Host Attention FIR
    ############################################################################

    register PAU2_CHIPLET_HA_FIR
    {
        name        "PAU2 Chiplet Host Attention FIR";
        scomaddr    0x12040004;
        capture     group default;
    };

    register PAU2_CHIPLET_HA_FIR_MASK
    {
        name        "PAU2 Chiplet Host Attention FIR MASK";
        scomaddr    0x12040044;
        capture     group default;
    };

    ############################################################################
    # PAU3 Chiplet Checkstop FIR
    ############################################################################

    register PAU3_CHIPLET_CS_FIR
    {
        name        "PAU3 Chiplet Checkstop FIR";
        scomaddr    0x13040000;
        capture     group default;
    };

    register PAU3_CHIPLET_CS_FIR_MASK
    {
        name        "PAU3 Chiplet Checkstop FIR MASK";
        scomaddr    0x13040040;
        capture     group default;
    };

    ############################################################################
    # PAU3 Chiplet Recoverable FIR
    ############################################################################

    register PAU3_CHIPLET_RE_FIR
    {
        name        "PAU3 Chiplet Recoverable FIR";
        scomaddr    0x13040001;
        capture     group default;
    };

    register PAU3_CHIPLET_RE_FIR_MASK
    {
        name        "PAU3 Chiplet Recoverable FIR MASK";
        scomaddr    0x13040041;
        capture     group default;
    };

    ############################################################################
    # PAU3 Chiplet Unit Checkstop FIR
    ############################################################################

    register PAU3_CHIPLET_UCS_FIR
    {
        name        "PAU3 Chiplet Unit Checkstop FIR";
        scomaddr    0x13040003;
        capture     group default;
    };

    register PAU3_CHIPLET_UCS_FIR_MASK
    {
        name        "PAU3 Chiplet Unit Checkstop FIR MASK";
        scomaddr    0x13040043;
        capture     group default;
    };

    ############################################################################
    # PAU3 Chiplet Host Attention FIR
    ############################################################################

    register PAU3_CHIPLET_HA_FIR
    {
        name        "PAU3 Chiplet Host Attention FIR";
        scomaddr    0x13040004;
        capture     group default;
    };

    register PAU3_CHIPLET_HA_FIR_MASK
    {
        name        "PAU3 Chiplet Host Attention FIR MASK";
        scomaddr    0x13040044;
        capture     group default;
    };

# Include registers not defined by the xml
.include "p10_proc_regs.rule";

};

 ##############################################################################
 #                                                                            #
 # ####                                 #                                     #
 # #   # #   # #    #####  ###      #  # #    ##  ##### ###  ###  #   #  ###  #
 # #   # #   # #    #     #        #  #   #  #  #   #    #  #   # ##  # #     #
 # ####  #   # #    ####   ###    #  ####### #      #    #  #   # # # #  ###  #
 # #  #  #   # #    #         #  #   #     # #  #   #    #  #   # #  ##     # #
 # #   #  ###  #### #####  ###  #    #     #  ##    #   ###  ###  #   #  ###  #
 #                                                                            #
 ##############################################################################

################################################################################
# Global Checkstop Attention FIR
################################################################################

rule rGLOBAL_CS_FIR
{
  CHECK_STOP:
    GLOBAL_CS_FIR;
};

group gGLOBAL_CS_FIR attntype CHECK_STOP
    filter singlebit
{
    /** GLOBAL_CS_FIR[1]
     *  Attention from TP chiplet
     */
    (rGLOBAL_CS_FIR, bit(1)) ? analyze(gTP_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_CS_FIR, bit(2)) ? analyze(gN0_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_CS_FIR, bit(3)) ? analyze(gN1_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[8]
     *  Attention from PCI 0 chiplet
     */
    (rGLOBAL_CS_FIR, bit(8)) ? analyzeConnectedPEC0;

    /** GLOBAL_CS_FIR[9]
     *  Attention from PCI 1 chiplet
     */
    (rGLOBAL_CS_FIR, bit(9)) ? analyzeConnectedPEC1;

    /** GLOBAL_CS_FIR[12]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_CS_FIR, bit(12)) ? analyzeConnectedMC0;

    /** GLOBAL_CS_FIR[13]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_CS_FIR, bit(13)) ? analyzeConnectedMC1;

    /** GLOBAL_CS_FIR[14]
     *  Attention from MC 2 chiplet
     */
    (rGLOBAL_CS_FIR, bit(14)) ? analyzeConnectedMC2;

    /** GLOBAL_CS_FIR[15]
     *  Attention from MC 3 chiplet
     */
    (rGLOBAL_CS_FIR, bit(15)) ? analyzeConnectedMC3;

    /** GLOBAL_CS_FIR[16]
     *  Attention from PAU 0 chiplet
     */
    (rGLOBAL_CS_FIR, bit(16)) ? analyze(gPAU0_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[17]
     *  Attention from PAU 1 chiplet
     */
    (rGLOBAL_CS_FIR, bit(17)) ? analyze(gPAU1_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[18]
     *  Attention from PAU 2 chiplet
     */
    (rGLOBAL_CS_FIR, bit(18)) ? analyze(gPAU2_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[19]
     *  Attention from PAU 3 chiplet
     */
    (rGLOBAL_CS_FIR, bit(19)) ? analyze(gPAU3_CHIPLET_CS_FIR);

    /** GLOBAL_CS_FIR[24]
     *  Attention from IOHS 0 chiplet
     */
    (rGLOBAL_CS_FIR, bit(24)) ? analyzeConnectedIOHS0;

    /** GLOBAL_CS_FIR[25]
     *  Attention from IOHS 1 chiplet
     */
    (rGLOBAL_CS_FIR, bit(25)) ? analyzeConnectedIOHS1;

    /** GLOBAL_CS_FIR[26]
     *  Attention from IOHS 2 chiplet
     */
    (rGLOBAL_CS_FIR, bit(26)) ? analyzeConnectedIOHS2;

    /** GLOBAL_CS_FIR[27]
     *  Attention from IOHS 3 chiplet
     */
    (rGLOBAL_CS_FIR, bit(27)) ? analyzeConnectedIOHS3;

    /** GLOBAL_CS_FIR[28]
     *  Attention from IOHS 4 chiplet
     */
    (rGLOBAL_CS_FIR, bit(28)) ? analyzeConnectedIOHS4;

    /** GLOBAL_CS_FIR[29]
     *  Attention from IOHS 5 chiplet
     */
    (rGLOBAL_CS_FIR, bit(29)) ? analyzeConnectedIOHS5;

    /** GLOBAL_CS_FIR[30]
     *  Attention from IOHS 6 chiplet
     */
    (rGLOBAL_CS_FIR, bit(30)) ? analyzeConnectedIOHS6;

    /** GLOBAL_CS_FIR[31]
     *  Attention from IOHS 7 chiplet
     */
    (rGLOBAL_CS_FIR, bit(31)) ? analyzeConnectedIOHS7;

    /** GLOBAL_CS_FIR[32]
     *  Attention from EQ 0 chiplet
     */
    (rGLOBAL_CS_FIR, bit(32)) ? analyzeConnectedEQ0;

    /** GLOBAL_CS_FIR[33]
     *  Attention from EQ 1 chiplet
     */
    (rGLOBAL_CS_FIR, bit(33)) ? analyzeConnectedEQ1;

    /** GLOBAL_CS_FIR[34]
     *  Attention from EQ 2 chiplet
     */
    (rGLOBAL_CS_FIR, bit(34)) ? analyzeConnectedEQ2;

    /** GLOBAL_CS_FIR[35]
     *  Attention from EQ 3 chiplet
     */
    (rGLOBAL_CS_FIR, bit(35)) ? analyzeConnectedEQ3;

    /** GLOBAL_CS_FIR[36]
     *  Attention from EQ 4 chiplet
     */
    (rGLOBAL_CS_FIR, bit(36)) ? analyzeConnectedEQ4;

    /** GLOBAL_CS_FIR[37]
     *  Attention from EQ 5 chiplet
     */
    (rGLOBAL_CS_FIR, bit(37)) ? analyzeConnectedEQ5;

    /** GLOBAL_CS_FIR[38]
     *  Attention from EQ 6 chiplet
     */
    (rGLOBAL_CS_FIR, bit(38)) ? analyzeConnectedEQ6;

    /** GLOBAL_CS_FIR[39]
     *  Attention from EQ 7 chiplet
     */
    (rGLOBAL_CS_FIR, bit(39)) ? analyzeConnectedEQ7;

};

################################################################################
# Global Recoverable Attention FIR
################################################################################

rule rGLOBAL_RE_FIR
{
  RECOVERABLE:
    GLOBAL_RE_FIR;
};

# We need to check the PAU chiplet first because of some bits in the
# PAU_PHY_FIR that can cause side effects in FIRs in the OMIC, MCC, and OCMB.
group gGLOBAL_RE_FIR attntype RECOVERABLE
    filter priority(16,17,18,19)
{
    /** GLOBAL_RE_FIR[1]
     *  Attention from TP chiplet
     */
    (rGLOBAL_RE_FIR, bit(1)) ? analyze(gTP_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_RE_FIR, bit(2)) ? analyze(gN0_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_RE_FIR, bit(3)) ? analyze(gN1_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[8]
     *  Attention from PCI 0 chiplet
     */
    (rGLOBAL_RE_FIR, bit(8)) ? analyzeConnectedPEC0;

    /** GLOBAL_RE_FIR[9]
     *  Attention from PCI 1 chiplet
     */
    (rGLOBAL_RE_FIR, bit(9)) ? analyzeConnectedPEC1;

    /** GLOBAL_RE_FIR[12]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_RE_FIR, bit(12)) ? analyzeConnectedMC0;

    /** GLOBAL_RE_FIR[13]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_RE_FIR, bit(13)) ? analyzeConnectedMC1;

    /** GLOBAL_RE_FIR[14]
     *  Attention from MC 2 chiplet
     */
    (rGLOBAL_RE_FIR, bit(14)) ? analyzeConnectedMC2;

    /** GLOBAL_RE_FIR[15]
     *  Attention from MC 3 chiplet
     */
    (rGLOBAL_RE_FIR, bit(15)) ? analyzeConnectedMC3;

    /** GLOBAL_RE_FIR[16]
     *  Attention from PAU 0 chiplet
     */
    (rGLOBAL_RE_FIR, bit(16)) ? analyze(gPAU0_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[17]
     *  Attention from PAU 1 chiplet
     */
    (rGLOBAL_RE_FIR, bit(17)) ? analyze(gPAU1_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[18]
     *  Attention from PAU 2 chiplet
     */
    (rGLOBAL_RE_FIR, bit(18)) ? analyze(gPAU2_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[19]
     *  Attention from PAU 3 chiplet
     */
    (rGLOBAL_RE_FIR, bit(19)) ? analyze(gPAU3_CHIPLET_RE_FIR);

    /** GLOBAL_RE_FIR[24]
     *  Attention from IOHS 0 chiplet
     */
    (rGLOBAL_RE_FIR, bit(24)) ? analyzeConnectedIOHS0;

    /** GLOBAL_RE_FIR[25]
     *  Attention from IOHS 1 chiplet
     */
    (rGLOBAL_RE_FIR, bit(25)) ? analyzeConnectedIOHS1;

    /** GLOBAL_RE_FIR[26]
     *  Attention from IOHS 2 chiplet
     */
    (rGLOBAL_RE_FIR, bit(26)) ? analyzeConnectedIOHS2;

    /** GLOBAL_RE_FIR[27]
     *  Attention from IOHS 3 chiplet
     */
    (rGLOBAL_RE_FIR, bit(27)) ? analyzeConnectedIOHS3;

    /** GLOBAL_RE_FIR[28]
     *  Attention from IOHS 4 chiplet
     */
    (rGLOBAL_RE_FIR, bit(28)) ? analyzeConnectedIOHS4;

    /** GLOBAL_RE_FIR[29]
     *  Attention from IOHS 5 chiplet
     */
    (rGLOBAL_RE_FIR, bit(29)) ? analyzeConnectedIOHS5;

    /** GLOBAL_RE_FIR[30]
     *  Attention from IOHS 6 chiplet
     */
    (rGLOBAL_RE_FIR, bit(30)) ? analyzeConnectedIOHS6;

    /** GLOBAL_RE_FIR[31]
     *  Attention from IOHS 7 chiplet
     */
    (rGLOBAL_RE_FIR, bit(31)) ? analyzeConnectedIOHS7;

    /** GLOBAL_RE_FIR[32]
     *  Attention from EQ 0 chiplet
     */
    (rGLOBAL_RE_FIR, bit(32)) ? analyzeConnectedEQ0;

    /** GLOBAL_RE_FIR[33]
     *  Attention from EQ 1 chiplet
     */
    (rGLOBAL_RE_FIR, bit(33)) ? analyzeConnectedEQ1;

    /** GLOBAL_RE_FIR[34]
     *  Attention from EQ 2 chiplet
     */
    (rGLOBAL_RE_FIR, bit(34)) ? analyzeConnectedEQ2;

    /** GLOBAL_RE_FIR[35]
     *  Attention from EQ 3 chiplet
     */
    (rGLOBAL_RE_FIR, bit(35)) ? analyzeConnectedEQ3;

    /** GLOBAL_RE_FIR[36]
     *  Attention from EQ 4 chiplet
     */
    (rGLOBAL_RE_FIR, bit(36)) ? analyzeConnectedEQ4;

    /** GLOBAL_RE_FIR[37]
     *  Attention from EQ 5 chiplet
     */
    (rGLOBAL_RE_FIR, bit(37)) ? analyzeConnectedEQ5;

    /** GLOBAL_RE_FIR[38]
     *  Attention from EQ 6 chiplet
     */
    (rGLOBAL_RE_FIR, bit(38)) ? analyzeConnectedEQ6;

    /** GLOBAL_RE_FIR[39]
     *  Attention from EQ 7 chiplet
     */
    (rGLOBAL_RE_FIR, bit(39)) ? analyzeConnectedEQ7;

};

################################################################################
# Global Unit Checkstop Attention FIR
################################################################################

rule rGLOBAL_UCS_FIR
{
  UNIT_CS:
    GLOBAL_UCS_FIR;
};

# We need to check the PAU chiplet first because of some bits in the
# PAU_PHY_FIR that can cause side effects in FIRs in the OMIC, MCC, and OCMB.
group gGLOBAL_UCS_FIR attntype UNIT_CS
    filter priority(16,17,18,19)
{
    /** GLOBAL_UCS_FIR[1]
     *  Attention from TP chiplet
     */
    (rGLOBAL_UCS_FIR, bit(1)) ? analyze(gTP_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(2)) ? analyze(gN0_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(3)) ? analyze(gN1_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[8]
     *  Attention from PCI 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(8)) ? analyzeConnectedPEC0;

    /** GLOBAL_UCS_FIR[9]
     *  Attention from PCI 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(9)) ? analyzeConnectedPEC1;

    /** GLOBAL_UCS_FIR[12]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(12)) ? analyzeConnectedMC0;

    /** GLOBAL_UCS_FIR[13]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(13)) ? analyzeConnectedMC1;

    /** GLOBAL_UCS_FIR[14]
     *  Attention from MC 2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(14)) ? analyzeConnectedMC2;

    /** GLOBAL_UCS_FIR[15]
     *  Attention from MC 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(15)) ? analyzeConnectedMC3;

    /** GLOBAL_UCS_FIR[16]
     *  Attention from PAU 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(16)) ? analyze(gPAU0_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[17]
     *  Attention from PAU 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(17)) ? analyze(gPAU1_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[18]
     *  Attention from PAU 2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(18)) ? analyze(gPAU2_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[19]
     *  Attention from PAU 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(19)) ? analyze(gPAU3_CHIPLET_UCS_FIR);

    /** GLOBAL_UCS_FIR[24]
     *  Attention from IOHS 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(24)) ? analyzeConnectedIOHS0;

    /** GLOBAL_UCS_FIR[25]
     *  Attention from IOHS 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(25)) ? analyzeConnectedIOHS1;

    /** GLOBAL_UCS_FIR[26]
     *  Attention from IOHS 2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(26)) ? analyzeConnectedIOHS2;

    /** GLOBAL_UCS_FIR[27]
     *  Attention from IOHS 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(27)) ? analyzeConnectedIOHS3;

    /** GLOBAL_UCS_FIR[28]
     *  Attention from IOHS 4 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(28)) ? analyzeConnectedIOHS4;

    /** GLOBAL_UCS_FIR[29]
     *  Attention from IOHS 5 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(29)) ? analyzeConnectedIOHS5;

    /** GLOBAL_UCS_FIR[30]
     *  Attention from IOHS 6 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(30)) ? analyzeConnectedIOHS6;

    /** GLOBAL_UCS_FIR[31]
     *  Attention from IOHS 7 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(31)) ? analyzeConnectedIOHS7;

    /** GLOBAL_UCS_FIR[32]
     *  Attention from EQ 0 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(32)) ? analyzeConnectedEQ0;

    /** GLOBAL_UCS_FIR[33]
     *  Attention from EQ 1 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(33)) ? analyzeConnectedEQ1;

    /** GLOBAL_UCS_FIR[34]
     *  Attention from EQ 2 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(34)) ? analyzeConnectedEQ2;

    /** GLOBAL_UCS_FIR[35]
     *  Attention from EQ 3 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(35)) ? analyzeConnectedEQ3;

    /** GLOBAL_UCS_FIR[36]
     *  Attention from EQ 4 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(36)) ? analyzeConnectedEQ4;

    /** GLOBAL_UCS_FIR[37]
     *  Attention from EQ 5 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(37)) ? analyzeConnectedEQ5;

    /** GLOBAL_UCS_FIR[38]
     *  Attention from EQ 6 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(38)) ? analyzeConnectedEQ6;

    /** GLOBAL_UCS_FIR[39]
     *  Attention from EQ 7 chiplet
     */
    (rGLOBAL_UCS_FIR, bit(39)) ? analyzeConnectedEQ7;

};

################################################################################
# Global Host Attention FIR
################################################################################

rule rGLOBAL_HA_FIR
{
  HOST_ATTN:
    GLOBAL_HA_FIR;
};

group gGLOBAL_HA_FIR attntype HOST_ATTN
    filter singlebit
{
    /** GLOBAL_HA_FIR[1]
     *  Attention from TP chiplet
     */
    (rGLOBAL_HA_FIR, bit(1)) ? analyze(gTP_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[2]
     *  Attention from N0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(2)) ? analyze(gN0_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[3]
     *  Attention from N1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(3)) ? analyze(gN1_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[8]
     *  Attention from PCI 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(8)) ? analyzeConnectedPEC0;

    /** GLOBAL_HA_FIR[9]
     *  Attention from PCI 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(9)) ? analyzeConnectedPEC1;

    /** GLOBAL_HA_FIR[12]
     *  Attention from MC 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(12)) ? analyzeConnectedMC0;

    /** GLOBAL_HA_FIR[13]
     *  Attention from MC 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(13)) ? analyzeConnectedMC1;

    /** GLOBAL_HA_FIR[14]
     *  Attention from MC 2 chiplet
     */
    (rGLOBAL_HA_FIR, bit(14)) ? analyzeConnectedMC2;

    /** GLOBAL_HA_FIR[15]
     *  Attention from MC 3 chiplet
     */
    (rGLOBAL_HA_FIR, bit(15)) ? analyzeConnectedMC3;

    /** GLOBAL_HA_FIR[16]
     *  Attention from PAU 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(16)) ? analyze(gPAU0_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[17]
     *  Attention from PAU 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(17)) ? analyze(gPAU1_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[18]
     *  Attention from PAU 2 chiplet
     */
    (rGLOBAL_HA_FIR, bit(18)) ? analyze(gPAU2_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[19]
     *  Attention from PAU 3 chiplet
     */
    (rGLOBAL_HA_FIR, bit(19)) ? analyze(gPAU3_CHIPLET_HA_FIR);

    /** GLOBAL_HA_FIR[24]
     *  Attention from IOHS 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(24)) ? analyzeConnectedIOHS0;

    /** GLOBAL_HA_FIR[25]
     *  Attention from IOHS 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(25)) ? analyzeConnectedIOHS1;

    /** GLOBAL_HA_FIR[26]
     *  Attention from IOHS 2 chiplet
     */
    (rGLOBAL_HA_FIR, bit(26)) ? analyzeConnectedIOHS2;

    /** GLOBAL_HA_FIR[27]
     *  Attention from IOHS 3 chiplet
     */
    (rGLOBAL_HA_FIR, bit(27)) ? analyzeConnectedIOHS3;

    /** GLOBAL_HA_FIR[28]
     *  Attention from IOHS 4 chiplet
     */
    (rGLOBAL_HA_FIR, bit(28)) ? analyzeConnectedIOHS4;

    /** GLOBAL_HA_FIR[29]
     *  Attention from IOHS 5 chiplet
     */
    (rGLOBAL_HA_FIR, bit(29)) ? analyzeConnectedIOHS5;

    /** GLOBAL_HA_FIR[30]
     *  Attention from IOHS 6 chiplet
     */
    (rGLOBAL_HA_FIR, bit(30)) ? analyzeConnectedIOHS6;

    /** GLOBAL_HA_FIR[31]
     *  Attention from IOHS 7 chiplet
     */
    (rGLOBAL_HA_FIR, bit(31)) ? analyzeConnectedIOHS7;

    /** GLOBAL_HA_FIR[32]
     *  Attention from EQ 0 chiplet
     */
    (rGLOBAL_HA_FIR, bit(32)) ? analyzeConnectedEQ0;

    /** GLOBAL_HA_FIR[33]
     *  Attention from EQ 1 chiplet
     */
    (rGLOBAL_HA_FIR, bit(33)) ? analyzeConnectedEQ1;

    /** GLOBAL_HA_FIR[34]
     *  Attention from EQ 2 chiplet
     */
    (rGLOBAL_HA_FIR, bit(34)) ? analyzeConnectedEQ2;

    /** GLOBAL_HA_FIR[35]
     *  Attention from EQ 3 chiplet
     */
    (rGLOBAL_HA_FIR, bit(35)) ? analyzeConnectedEQ3;

    /** GLOBAL_HA_FIR[36]
     *  Attention from EQ 4 chiplet
     */
    (rGLOBAL_HA_FIR, bit(36)) ? analyzeConnectedEQ4;

    /** GLOBAL_HA_FIR[37]
     *  Attention from EQ 5 chiplet
     */
    (rGLOBAL_HA_FIR, bit(37)) ? analyzeConnectedEQ5;

    /** GLOBAL_HA_FIR[38]
     *  Attention from EQ 6 chiplet
     */
    (rGLOBAL_HA_FIR, bit(38)) ? analyzeConnectedEQ6;

    /** GLOBAL_HA_FIR[39]
     *  Attention from EQ 7 chiplet
     */
    (rGLOBAL_HA_FIR, bit(39)) ? analyzeConnectedEQ7;

};

################################################################################
# TP Chiplet Checkstop FIR
################################################################################

rule rTP_CHIPLET_CS_FIR
{
  CHECK_STOP:
    TP_CHIPLET_CS_FIR & ~TP_CHIPLET_CS_FIR_MASK & `0fffffffffffffff`;
};

group gTP_CHIPLET_CS_FIR
    filter singlebit
{
    /** TP_CHIPLET_CS_FIR[4]
     *  Attention from TP_LOCAL_FIR
     */
    (rTP_CHIPLET_CS_FIR, bit(4)) ? analyze(gTP_LOCAL_FIR);

    /** TP_CHIPLET_CS_FIR[5]
     *  Attention from OCC_FIR
     */
    (rTP_CHIPLET_CS_FIR, bit(5)) ? analyzeOCC_FIR;

    /** TP_CHIPLET_CS_FIR[6]
     *  Attention from PBAO_FIR
     */
    (rTP_CHIPLET_CS_FIR, bit(6)) ? analyzePBAO_FIR;

};

################################################################################
# TP Chiplet Recoverable FIR
################################################################################

rule rTP_CHIPLET_RE_FIR
{
  RECOVERABLE:
    TP_CHIPLET_RE_FIR & ~TP_CHIPLET_RE_FIR_MASK & `0fffffffffffffff`;
};

group gTP_CHIPLET_RE_FIR
    filter singlebit
{
    /** TP_CHIPLET_RE_FIR[4]
     *  Attention from TP_LOCAL_FIR
     */
    (rTP_CHIPLET_RE_FIR, bit(4)) ? analyze(gTP_LOCAL_FIR);

    /** TP_CHIPLET_RE_FIR[5]
     *  Attention from OCC_FIR
     */
    (rTP_CHIPLET_RE_FIR, bit(5)) ? analyzeOCC_FIR;

    /** TP_CHIPLET_RE_FIR[6]
     *  Attention from PBAO_FIR
     */
    (rTP_CHIPLET_RE_FIR, bit(6)) ? analyzePBAO_FIR;

};

################################################################################
# TP Chiplet Unit Checkstop FIR
################################################################################

rule rTP_CHIPLET_UCS_FIR
{
  UNIT_CS:
    TP_CHIPLET_UCS_FIR & ~TP_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gTP_CHIPLET_UCS_FIR
    filter singlebit
{
    /** TP_CHIPLET_UCS_FIR[4]
     *  Attention from TP_LOCAL_FIR
     */
    (rTP_CHIPLET_UCS_FIR, bit(4)) ? analyze(gTP_LOCAL_FIR);

};

################################################################################
# TP Chiplet Host Attention FIR
################################################################################

rule rTP_CHIPLET_HA_FIR
{
  HOST_ATTN:
    TP_CHIPLET_HA_FIR & ~TP_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gTP_CHIPLET_HA_FIR
    filter singlebit
{
    /** TP_CHIPLET_HA_FIR[4]
     *  Attention from TP_LOCAL_FIR
     */
    (rTP_CHIPLET_HA_FIR, bit(4)) ? analyze(gTP_LOCAL_FIR);

};

################################################################################
# P10 chip TP_LOCAL_FIR
################################################################################

rule rTP_LOCAL_FIR
{
  CHECK_STOP:
    TP_LOCAL_FIR & ~TP_LOCAL_FIR_MASK & ~TP_LOCAL_FIR_ACT0 & ~TP_LOCAL_FIR_ACT1 & ~TP_LOCAL_FIR_ACT2;
  HOST_ATTN:
    TP_LOCAL_FIR & ~TP_LOCAL_FIR_MASK & ~TP_LOCAL_FIR_ACT0 & ~TP_LOCAL_FIR_ACT1 &  TP_LOCAL_FIR_ACT2;
  RECOVERABLE:
    TP_LOCAL_FIR & ~TP_LOCAL_FIR_MASK & ~TP_LOCAL_FIR_ACT0 &  TP_LOCAL_FIR_ACT1 & ~TP_LOCAL_FIR_ACT2;
  UNIT_CS:
    TP_LOCAL_FIR & ~TP_LOCAL_FIR_MASK &  TP_LOCAL_FIR_ACT0 &  TP_LOCAL_FIR_ACT1 & ~TP_LOCAL_FIR_ACT2;
};

group gTP_LOCAL_FIR
    filter singlebit,
           cs_root_cause
{
    /** TP_LOCAL_FIR[0]
     *  CFIR - Parity or PCB access error
     */
    (rTP_LOCAL_FIR, bit(0)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[1]
     *  CPLT_CTRL - PCB access error
     */
    (rTP_LOCAL_FIR, bit(1)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[2]
     *  CC - PCB access error
     */
    (rTP_LOCAL_FIR, bit(2)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[3]
     *  CC - Clock Control Error
     */
    (rTP_LOCAL_FIR, bit(3)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[4]
     *  PSC - PSCOM access error
     */
    (rTP_LOCAL_FIR, bit(4)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[5]
     *  PSC - internal or ring interface error
     */
    (rTP_LOCAL_FIR, bit(5)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[6]
     *  THERM - internal error
     */
    (rTP_LOCAL_FIR, bit(6)) ? self_th_1;

    /** TP_LOCAL_FIR[7]
     *  THERM - pcb error
     */
    (rTP_LOCAL_FIR, bit(7)) ? threshold_and_mask_self;

    /** TP_LOCAL_FIR[8]
     *  THERMTRIP - Critical temperature indicator
     */
    (rTP_LOCAL_FIR, bit(8)) ? threshold_and_mask_self;

    /** TP_LOCAL_FIR[9]
     *  THERMTRIP - Fatal temperature indicator
     */
    (rTP_LOCAL_FIR, bit(9)) ? threshold_and_mask_self;

    /** TP_LOCAL_FIR[10]
     *  VOLTTRIP - Voltage sense error
     */
    (rTP_LOCAL_FIR, bit(10)) ? threshold_and_mask_self;

    /** TP_LOCAL_FIR[11]
     *  DBG - scom parity fail
     */
    (rTP_LOCAL_FIR, bit(11)) ? threshold_and_mask_self;

    /** TP_LOCAL_FIR[12]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(12)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[13]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(13)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[14]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(14)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[15]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(15)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[16]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(16)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[17]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(17)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[18]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(18)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[19]
     *  reserved
     */
    (rTP_LOCAL_FIR, bit(19)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[20]
     *  Trace00 - scom parity err
     */
    (rTP_LOCAL_FIR, bit(20)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[21]
     *  ITR - FMU error
     */
    (rTP_LOCAL_FIR, bit(21)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[22]
     *  ITR - PCB error
     */
    (rTP_LOCAL_FIR, bit(22)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[23]
     *  PCB Master - timeout
     */
    (rTP_LOCAL_FIR, bit(23)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[24]
     *  I2CM - Parity errors
     */
    (rTP_LOCAL_FIR, bit(24)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[25]
     *  TOD - any error
     */
    (rTP_LOCAL_FIR, bit(25)) ? analyzeTodBackupTopology;

    /** TP_LOCAL_FIR[26]
     *  TOD - access error PIB
     */
    (rTP_LOCAL_FIR, bit(26)) ? analyzePibError;

    /** TP_LOCAL_FIR[27]
     *  TOD - Error reported from PHYP
     */
    (rTP_LOCAL_FIR, bit(27)) ? analyzePhypTodError;

    /** TP_LOCAL_FIR[28]
     *  PCB Slave error (includes PLL unlocks)
     */
    (rTP_LOCAL_FIR, bit(28)) ? pcb_slave_internal_parity;

    /** TP_LOCAL_FIR[29]
     *  SBE - PPE int hardware error
     */
    (rTP_LOCAL_FIR, bit(29)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[30]
     *  SBE - PPE ext hardware error
     */
    (rTP_LOCAL_FIR, bit(30)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[31]
     *  SBE- PPE code error
     */
    (rTP_LOCAL_FIR, bit(31)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[32]
     *  SBE - PPE debug code breakpoint
     */
    (rTP_LOCAL_FIR, bit(32)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[33]
     *  SBE - PPE in halted state
     */
    (rTP_LOCAL_FIR, bit(33)) ? sbe_vital_attn;

    /** TP_LOCAL_FIR[34]
     *  SBE - PPE watchdog timeout
     */
    (rTP_LOCAL_FIR, bit(34)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[35]
     *  unused
     */
    (rTP_LOCAL_FIR, bit(35)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[36]
     *  unused
     */
    (rTP_LOCAL_FIR, bit(36)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[37]
     *  SBE - PPE triggers DBG
     */
    (rTP_LOCAL_FIR, bit(37)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[38]
     *  OTP - SCOM access errors and single ecc correctabl
     */
    (rTP_LOCAL_FIR, bit(38)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[39]
     *  TPIO External Trigger
     */
    (rTP_LOCAL_FIR, bit(39)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[40]
     *  PCB Master - Multicast group member count underrun
     */
    (rTP_LOCAL_FIR, bit(40)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[41]
     *  PCB Master - Parity ERR
     */
    (rTP_LOCAL_FIR, bit(41)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[42]
     *  RCS OSC error on clk A
     */
    (rTP_LOCAL_FIR, bit(42)) ? rcs_error_handling;

    /** TP_LOCAL_FIR[43]
     *  RCS OSC error on clk B
     */
    (rTP_LOCAL_FIR, bit(43)) ? rcs_error_handling;

    /** TP_LOCAL_FIR[44]
     *  RCS - Up/down counter A unlock
     */
    (rTP_LOCAL_FIR, bit(44)) ? rcs_error_handling;

    /** TP_LOCAL_FIR[45]
     *  RCS - Up/down counter B unlock
     */
    (rTP_LOCAL_FIR, bit(45)) ? rcs_error_handling;

    /** TP_LOCAL_FIR[46]
     *  PIBMEM
     */
    (rTP_LOCAL_FIR, bit(46)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[47]
     *  PIBMEM
     */
    (rTP_LOCAL_FIR, bit(47)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[48]
     *  OTP - ECC UE or CE count overflow
     */
    (rTP_LOCAL_FIR, bit(48)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[49]
     *  Nest DPLL: DCO empty
     */
    (rTP_LOCAL_FIR, bit(49)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[50]
     *  Nest DPLL: DCO full
     */
    (rTP_LOCAL_FIR, bit(50)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[51]
     *  Nest DPLL: internal error
     */
    (rTP_LOCAL_FIR, bit(51)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[52]
     *  PAU DPLL: DCO empty
     */
    (rTP_LOCAL_FIR, bit(52)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[53]
     *  PAU DPLL: DCO full
     */
    (rTP_LOCAL_FIR, bit(53)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[54]
     *  PAU DPLL: internal error
     */
    (rTP_LOCAL_FIR, bit(54)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[55]
     *  SPI Master 0 Err
     */
    (rTP_LOCAL_FIR, bit(55)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[56]
     *  SPI Master 1 Err
     */
    (rTP_LOCAL_FIR, bit(56)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[57]
     *  SPI Master 2 Err
     */
    (rTP_LOCAL_FIR, bit(57)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[58]
     *  SPI Master 3 Err
     */
    (rTP_LOCAL_FIR, bit(58)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[59]
     *  SPI Master 4 Err
     */
    (rTP_LOCAL_FIR, bit(59)) ? self_th_32perDay;

    /** TP_LOCAL_FIR[60]
     *  unused
     */
    (rTP_LOCAL_FIR, bit(60)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[61]
     *  unused
     */
    (rTP_LOCAL_FIR, bit(61)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[62]
     *  unused
     */
    (rTP_LOCAL_FIR, bit(62)) ? defaultMaskedError;

    /** TP_LOCAL_FIR[63]
     *  ext_local_xstop
     */
    (rTP_LOCAL_FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P10 chip OCC_FIR
################################################################################

rule rOCC_FIR
{
  CHECK_STOP:
    OCC_FIR & ~OCC_FIR_MASK & ~OCC_FIR_ACT0 & ~OCC_FIR_ACT1;
  RECOVERABLE:
    OCC_FIR & ~OCC_FIR_MASK & ~OCC_FIR_ACT0 &  OCC_FIR_ACT1;
};

group gOCC_FIR
    filter singlebit,
           cs_root_cause
{
    /** OCC_FIR[0]
     *  OCC_FW0
     */
    (rOCC_FIR, bit(0)) ? defaultMaskedError;

    /** OCC_FIR[1]
     *  OCC_FW1
     */
    (rOCC_FIR, bit(1)) ? defaultMaskedError;

    /** OCC_FIR[2]
     *  OCC_QME_ERROR_NOTIFY.  Set by XGPE code to indicat
     */
    (rOCC_FIR, bit(2)) ? defaultMaskedError;

    /** OCC_FIR[3]
     *  Stop recovery, notify PRD
     */
    (rOCC_FIR, bit(3)) ? pmRecovery;

    /** OCC_FIR[4]
     *  OCC Heartbeat Error
     */
    (rOCC_FIR, bit(4)) ? defaultMaskedError;

    /** OCC_FIR[5]
     *  GPE0 asserted a watchdog timeout condition
     */
    (rOCC_FIR, bit(5)) ? defaultMaskedError;

    /** OCC_FIR[6]
     *  GPE1 asserted a watchdog timeout condition
     */
    (rOCC_FIR, bit(6)) ? defaultMaskedError;

    /** OCC_FIR[7]
     *  GPE2 asserted a watchdog timeout condition
     */
    (rOCC_FIR, bit(7)) ? defaultMaskedError;

    /** OCC_FIR[8]
     *  GPE3 asserted a watchdog timeout condition
     */
    (rOCC_FIR, bit(8)) ? defaultMaskedError;

    /** OCC_FIR[9]
     *  GPE0 asserted an error condition that caused it to
     */
    (rOCC_FIR, bit(9)) ? threshold_and_mask_self;

    /** OCC_FIR[10]
     *  GPE1 asserted an error condition that caused it to
     */
    (rOCC_FIR, bit(10)) ? threshold_and_mask_self;

    /** OCC_FIR[11]
     *  GPE2 asserted an error condition that caused it to
     */
    (rOCC_FIR, bit(11)) ? defaultMaskedError;

    /** OCC_FIR[12]
     *  GPE3 asserted an error condition that caused it to
     */
    (rOCC_FIR, bit(12)) ? defaultMaskedError;

    /** OCC_FIR[13]
     *  OCB Error to PM Hcode for PM Complex Restart
     */
    (rOCC_FIR, bit(13)) ? occInterrupt;

    /** OCC_FIR[14]
     *  SRAM UE to PM Hcode for PM Complex Restart
     */
    (rOCC_FIR, bit(14)) ? occInterrupt;

    /** OCC_FIR[15]
     *  SRAM CE
     */
    (rOCC_FIR, bit(15)) ? threshold_and_mask_self;

    /** OCC_FIR[16]
     *  GPE0 asserted a halt condition. Handled by OCC Fir
     */
    (rOCC_FIR, bit(16)) ? defaultMaskedError;

    /** OCC_FIR[17]
     *  GPE1 asserted a halt condition. Handled by OCC Fir
     */
    (rOCC_FIR, bit(17)) ? defaultMaskedError;

    /** OCC_FIR[18]
     *  GPE2 asserted a halt condition. Handled by OCC Fir
     */
    (rOCC_FIR, bit(18)) ? defaultMaskedError;

    /** OCC_FIR[19]
     *  GPE3 asserted a halt condition
     */
    (rOCC_FIR, bit(19)) ? defaultMaskedError;

    /** OCC_FIR[20]
     *  GPE0 attempted to write outside the region defined
     */
    (rOCC_FIR, bit(20)) ? threshold_and_mask_self;

    /** OCC_FIR[21]
     *  GPE1 attempted to write outside the region defined
     */
    (rOCC_FIR, bit(21)) ? threshold_and_mask_self;

    /** OCC_FIR[22]
     *  GPE2 attempted to write outside the region defined
     */
    (rOCC_FIR, bit(22)) ? threshold_and_mask_self;

    /** OCC_FIR[23]
     *  GPE3 attempted to write outside the region defined
     */
    (rOCC_FIR, bit(23)) ? threshold_and_mask_self;

    /** OCC_FIR[24]
     *  Safe Mode for debug use
     */
    (rOCC_FIR, bit(24)) ? defaultMaskedError;

    /** OCC_FIR[25]
     *  Reserved
     */
    (rOCC_FIR, bit(25)) ? defaultMaskedError;

    /** OCC_FIR[26]
     *  EXTERNAL_TRAP. Handled by OCC Firmware via direct
     */
    (rOCC_FIR, bit(26)) ? defaultMaskedError;

    /** OCC_FIR[27]
     *  PPC405 Core Reset Output asserted (OCC firmware)
     */
    (rOCC_FIR, bit(27)) ? defaultMaskedError;

    /** OCC_FIR[28]
     *  PPC405 Chip Reset Output asserted (OCC firmware)
     */
    (rOCC_FIR, bit(28)) ? defaultMaskedError;

    /** OCC_FIR[29]
     *  PPC405 System Reset Output asserted (OCC firmware)
     */
    (rOCC_FIR, bit(29)) ? defaultMaskedError;

    /** OCC_FIR[30]
     *  PPC405 Wait State asserted (OCC firmware)
     */
    (rOCC_FIR, bit(30)) ? defaultMaskedError;

    /** OCC_FIR[31]
     *  PPC405 Stop Ack output asserted
     */
    (rOCC_FIR, bit(31)) ? defaultMaskedError;

    /** OCC_FIR[32]
     *  OCB Direct Bridge Error - See OCCERRRPT2[8:11] for
     */
    (rOCC_FIR, bit(32)) ? threshold_and_mask_self;

    /** OCC_FIR[33]
     *  OCB PIB Address Parity Error - (PIB read or write 
     */
    (rOCC_FIR, bit(33)) ? threshold_and_mask_self;

    /** OCC_FIR[34]
     *  Indirect Channel Error
     */
    (rOCC_FIR, bit(34)) ? threshold_and_mask_self;

    /** OCC_FIR[35]
     *  Parity error detected on OPIT interrupt bus. Inter
     */
    (rOCC_FIR, bit(35)) ? occInterrupt;

    /** OCC_FIR[36]
     *  OPIT interrupt state machine error occurred.
     */
    (rOCC_FIR, bit(36)) ? threshold_and_mask_self;

    /** OCC_FIR[37]
     *  Reserved
     */
    (rOCC_FIR, bit(37)) ? defaultMaskedError;

    /** OCC_FIR[38]
     *  Reserved
     */
    (rOCC_FIR, bit(38)) ? defaultMaskedError;

    /** OCC_FIR[39]
     *  Reserved
     */
    (rOCC_FIR, bit(39)) ? defaultMaskedError;

    /** OCC_FIR[40]
     *  Reserved
     */
    (rOCC_FIR, bit(40)) ? defaultMaskedError;

    /** OCC_FIR[41]
     *  Reserved
     */
    (rOCC_FIR, bit(41)) ? defaultMaskedError;

    /** OCC_FIR[42]
     *  JTAG accelerator error
     */
    (rOCC_FIR, bit(42)) ? threshold_and_mask_self;

    /** OCC_FIR[43]
     *  Any OCI Slave error occurred
     */
    (rOCC_FIR, bit(43)) ? threshold_and_mask_self;

    /** OCC_FIR[44]
     *  PPC405 cache UE to PM Hcode for PM Complex Restart
     */
    (rOCC_FIR, bit(44)) ? occInterrupt;

    /** OCC_FIR[45]
     *  PPC405 cache CE
     */
    (rOCC_FIR, bit(45)) ? self_th_1;

    /** OCC_FIR[46]
     *  PPC405 Machine Check
     */
    (rOCC_FIR, bit(46)) ? threshold_and_mask_self;

    /** OCC_FIR[47]
     *  SRAM spare direct error Summary
     */
    (rOCC_FIR, bit(47)) ? threshold_and_mask_self;

    /** OCC_FIR[48]
     *  Read, write, or parity error in the SRAM tank cont
     */
    (rOCC_FIR, bit(48)) ? threshold_and_mask_self;

    /** OCC_FIR[49]
     *  Reserved
     */
    (rOCC_FIR, bit(49)) ? defaultMaskedError;

    /** OCC_FIR[50]
     *  Reserved
     */
    (rOCC_FIR, bit(50)) ? defaultMaskedError;

    /** OCC_FIR[51]
     *  OCI slave error for GPE0
     */
    (rOCC_FIR, bit(51)) ? threshold_and_mask_self;

    /** OCC_FIR[52]
     *  OCI slave error for GPE1
     */
    (rOCC_FIR, bit(52)) ? threshold_and_mask_self;

    /** OCC_FIR[53]
     *  OCI slave error for GPE2 (see OCCERRPT for details
     */
    (rOCC_FIR, bit(53)) ? threshold_and_mask_self;

    /** OCC_FIR[54]
     *  OCI slave error for GPE3
     */
    (rOCC_FIR, bit(54)) ? threshold_and_mask_self;

    /** OCC_FIR[55]
     *  PPC405 ICU timeout on OCI request
     */
    (rOCC_FIR, bit(55)) ? threshold_and_mask_self;

    /** OCC_FIR[56]
     *  PPC405 DCU timeout on OCI request
     */
    (rOCC_FIR, bit(56)) ? threshold_and_mask_self;

    /** OCC_FIR[57]
     *  OCC fault occurred (to achieve safe mode)
     */
    (rOCC_FIR, bit(57)) ? threshold_and_mask_self;

    /** OCC_FIR[58]
     *  Read by HYP as part of the communication of a Powe
     */
    (rOCC_FIR, bit(58)) ? defaultMaskedError;

    /** OCC_FIR[59]
     *  reserved
     */
    (rOCC_FIR, bit(59)) ? defaultMaskedError;

    /** OCC_FIR[60]
     *  Reserved
     */
    (rOCC_FIR, bit(60)) ? defaultMaskedError;

    /** OCC_FIR[61]
     *  Reserved
     */
    (rOCC_FIR, bit(61)) ? defaultMaskedError;

};

################################################################################
# P10 chip PBAO_FIR
################################################################################

rule rPBAO_FIR
{
  CHECK_STOP:
    PBAO_FIR & ~PBAO_FIR_MASK & ~PBAO_FIR_ACT0 & ~PBAO_FIR_ACT1;
  RECOVERABLE:
    PBAO_FIR & ~PBAO_FIR_MASK & ~PBAO_FIR_ACT0 &  PBAO_FIR_ACT1;
};

group gPBAO_FIR
    filter singlebit,
           cs_root_cause
{
    /** PBAO_FIR[0]
     *  OCI Address Parity Error Det
     */
    (rPBAO_FIR, bit(0)) ? threshold_and_mask_self;

    /** PBAO_FIR[1]
     *  PBA OCI Slave Initialization Error
     */
    (rPBAO_FIR, bit(1)) ? threshold_and_mask_self;

    /** PBAO_FIR[2]
     *  OCI Write Data Parity Error Detected
     */
    (rPBAO_FIR, bit(2)) ? threshold_and_mask_self;

    /** PBAO_FIR[3]
     *  Spare -was OCI Re-Request Timeout
     */
    (rPBAO_FIR, bit(3)) ? defaultMaskedError;

    /** PBAO_FIR[4]
     *  BCUE Setup Error
     */
    (rPBAO_FIR, bit(4)) ? threshold_and_mask_self;

    /** PBAO_FIR[5]
     *  BCUE Read Data Parity Error OR MRDERR Asserted
     */
    (rPBAO_FIR, bit(5)) ? threshold_and_mask_self;

    /** PBAO_FIR[6]
     *  BCDE Setup Error
     */
    (rPBAO_FIR, bit(6)) ? threshold_and_mask_self;

    /** PBAO_FIR[7]
     *  BCDE Write Data error indicated by OCI Slave
     */
    (rPBAO_FIR, bit(7)) ? threshold_and_mask_self;

    /** PBAO_FIR[8]
     *  Internal Logic Error.  See PBAERRRPT2 for more det
     */
    (rPBAO_FIR, bit(8)) ? threshold_and_mask_self;

    /** PBAO_FIR[9]
     *  Illegal access to OCI Register
     */
    (rPBAO_FIR, bit(9)) ? defaultMaskedError;

    /** PBAO_FIR[10]
     *  Push Write Error.
     */
    (rPBAO_FIR, bit(10)) ? threshold_and_mask_self;

    /** PBAO_FIR[11]
     *  Push Write Error.
     */
    (rPBAO_FIR, bit(11)) ? threshold_and_mask_self;

    /** PBAO_FIR[12]
     *  Illegal PBAX Flow.
     */
    (rPBAO_FIR, bit(12)) ? threshold_and_mask_self;

    /** PBAO_FIR[13]
     *  Illegal PBAX Flow.
     */
    (rPBAO_FIR, bit(13)) ? threshold_and_mask_self;

    /** PBAO_FIR[14]
     *  PBAXSND Reservation Error.
     */
    (rPBAO_FIR, bit(14)) ? threshold_and_mask_self;

    /** PBAO_FIR[15]
     *  PBAXISND Reservation Error.
     */
    (rPBAO_FIR, bit(15)) ? threshold_and_mask_self;

    /** PBAO_FIR[16]
     *  The htm fifo interface fequency variation error
     */
    (rPBAO_FIR, bit(16)) ? threshold_and_mask_self;

    /** PBAO_FIR[17]
     *  The PBA has been configured to use the PowerBus To
     */
    (rPBAO_FIR, bit(17)) ? threshold_and_mask_self;

    /** PBAO_FIR[18]
     *  Spare
     */
    (rPBAO_FIR, bit(18)) ? defaultMaskedError;

    /** PBAO_FIR[19]
     *  Spare
     */
    (rPBAO_FIR, bit(19)) ? defaultMaskedError;

};

################################################################################
# N0 Chiplet Checkstop FIR
################################################################################

rule rN0_CHIPLET_CS_FIR
{
  CHECK_STOP:
    N0_CHIPLET_CS_FIR & ~N0_CHIPLET_CS_FIR_MASK & `0fffffffffffffff`;
};

group gN0_CHIPLET_CS_FIR
    filter singlebit
{
    /** N0_CHIPLET_CS_FIR[4]
     *  Attention from N0_LOCAL_FIR
     */
    (rN0_CHIPLET_CS_FIR, bit(4)) ? analyze(gN0_LOCAL_FIR);

    /** N0_CHIPLET_CS_FIR[5]
     *  Attention from NMMU_CQ_FIR 0
     */
    (rN0_CHIPLET_CS_FIR, bit(5)) ? analyzeConnectedNMMU0;

    /** N0_CHIPLET_CS_FIR[6]
     *  Attention from NMMU_FIR 0
     */
    (rN0_CHIPLET_CS_FIR, bit(6)) ? analyzeConnectedNMMU0;

    /** N0_CHIPLET_CS_FIR[7]
     *  Attention from INT_CQ_FIR
     */
    (rN0_CHIPLET_CS_FIR, bit(7)) ? analyzeINT_CQ_FIR;

    /** N0_CHIPLET_CS_FIR[8]
     *  Attention from VAS_FIR
     */
    (rN0_CHIPLET_CS_FIR, bit(8)) ? analyze(gVAS_FIR);

    /** N0_CHIPLET_CS_FIR[9]
     *  Attention from NX_DMA_ENG_FIR
     */
    (rN0_CHIPLET_CS_FIR, bit(9)) ? analyzeNX_DMA_ENG_FIR;

    /** N0_CHIPLET_CS_FIR[10]
     *  Attention from NX_CQ_FIR
     */
    (rN0_CHIPLET_CS_FIR, bit(10)) ? analyzeNX_CQ_FIR;

    /** N0_CHIPLET_CS_FIR[13]
     *  Attention from PCI_NEST_FIR 3
     */
    (rN0_CHIPLET_CS_FIR, bit(13)) ? analyzeConnectedPHB3;

    /** N0_CHIPLET_CS_FIR[14]
     *  Attention from PCI_NEST_FIR 4
     */
    (rN0_CHIPLET_CS_FIR, bit(14)) ? analyzeConnectedPHB4;

    /** N0_CHIPLET_CS_FIR[15]
     *  Attention from PCI_NEST_FIR 5
     */
    (rN0_CHIPLET_CS_FIR, bit(15)) ? analyzeConnectedPHB5;

};

################################################################################
# N0 Chiplet Recoverable FIR
################################################################################

rule rN0_CHIPLET_RE_FIR
{
  RECOVERABLE:
    N0_CHIPLET_RE_FIR & ~N0_CHIPLET_RE_FIR_MASK & `0fffffffffffffff`;
};

group gN0_CHIPLET_RE_FIR
    filter singlebit
{
    /** N0_CHIPLET_RE_FIR[4]
     *  Attention from N0_LOCAL_FIR
     */
    (rN0_CHIPLET_RE_FIR, bit(4)) ? analyze(gN0_LOCAL_FIR);

    /** N0_CHIPLET_RE_FIR[5]
     *  Attention from NMMU_CQ_FIR 0
     */
    (rN0_CHIPLET_RE_FIR, bit(5)) ? analyzeConnectedNMMU0;

    /** N0_CHIPLET_RE_FIR[6]
     *  Attention from NMMU_FIR 0
     */
    (rN0_CHIPLET_RE_FIR, bit(6)) ? analyzeConnectedNMMU0;

    /** N0_CHIPLET_RE_FIR[7]
     *  Attention from INT_CQ_FIR
     */
    (rN0_CHIPLET_RE_FIR, bit(7)) ? analyzeINT_CQ_FIR;

    /** N0_CHIPLET_RE_FIR[8]
     *  Attention from VAS_FIR
     */
    (rN0_CHIPLET_RE_FIR, bit(8)) ? analyze(gVAS_FIR);

    /** N0_CHIPLET_RE_FIR[9]
     *  Attention from NX_DMA_ENG_FIR
     */
    (rN0_CHIPLET_RE_FIR, bit(9)) ? analyzeNX_DMA_ENG_FIR;

    /** N0_CHIPLET_RE_FIR[10]
     *  Attention from NX_CQ_FIR
     */
    (rN0_CHIPLET_RE_FIR, bit(10)) ? analyzeNX_CQ_FIR;

    /** N0_CHIPLET_RE_FIR[13]
     *  Attention from PCI_NEST_FIR 3
     */
    (rN0_CHIPLET_RE_FIR, bit(13)) ? analyzeConnectedPHB3;

    /** N0_CHIPLET_RE_FIR[14]
     *  Attention from PCI_NEST_FIR 4
     */
    (rN0_CHIPLET_RE_FIR, bit(14)) ? analyzeConnectedPHB4;

    /** N0_CHIPLET_RE_FIR[15]
     *  Attention from PCI_NEST_FIR 5
     */
    (rN0_CHIPLET_RE_FIR, bit(15)) ? analyzeConnectedPHB5;

};

################################################################################
# N0 Chiplet Unit Checkstop FIR
################################################################################

rule rN0_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N0_CHIPLET_UCS_FIR & ~N0_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gN0_CHIPLET_UCS_FIR
    filter singlebit
{
    /** N0_CHIPLET_UCS_FIR[4]
     *  Attention from N0_LOCAL_FIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(4)) ? analyze(gN0_LOCAL_FIR);

    /** N0_CHIPLET_UCS_FIR[5]
     *  Attention from NMMU_CQ_FIR 0
     */
    (rN0_CHIPLET_UCS_FIR, bit(5)) ? analyzeConnectedNMMU0;

    /** N0_CHIPLET_UCS_FIR[6]
     *  Attention from NMMU_FIR 0
     */
    (rN0_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedNMMU0;

    /** N0_CHIPLET_UCS_FIR[8]
     *  Attention from VAS_FIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(8)) ? analyze(gVAS_FIR);

    /** N0_CHIPLET_UCS_FIR[9]
     *  Attention from NX_DMA_ENG_FIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(9)) ? analyzeNX_DMA_ENG_FIR;

    /** N0_CHIPLET_UCS_FIR[10]
     *  Attention from NX_CQ_FIR
     */
    (rN0_CHIPLET_UCS_FIR, bit(10)) ? analyzeNX_CQ_FIR;

};

################################################################################
# N0 Chiplet Host Attention FIR
################################################################################

rule rN0_CHIPLET_HA_FIR
{
  HOST_ATTN:
    N0_CHIPLET_HA_FIR & ~N0_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gN0_CHIPLET_HA_FIR
    filter singlebit
{
    /** N0_CHIPLET_HA_FIR[4]
     *  Attention from N0_LOCAL_FIR
     */
    (rN0_CHIPLET_HA_FIR, bit(4)) ? analyze(gN0_LOCAL_FIR);

};

################################################################################
# P10 chip N0_LOCAL_FIR
################################################################################

rule rN0_LOCAL_FIR
{
  CHECK_STOP:
    N0_LOCAL_FIR & ~N0_LOCAL_FIR_MASK & ~N0_LOCAL_FIR_ACT0 & ~N0_LOCAL_FIR_ACT1 & ~N0_LOCAL_FIR_ACT2;
  HOST_ATTN:
    N0_LOCAL_FIR & ~N0_LOCAL_FIR_MASK & ~N0_LOCAL_FIR_ACT0 & ~N0_LOCAL_FIR_ACT1 &  N0_LOCAL_FIR_ACT2;
  RECOVERABLE:
    N0_LOCAL_FIR & ~N0_LOCAL_FIR_MASK & ~N0_LOCAL_FIR_ACT0 &  N0_LOCAL_FIR_ACT1 & ~N0_LOCAL_FIR_ACT2;
  UNIT_CS:
    N0_LOCAL_FIR & ~N0_LOCAL_FIR_MASK &  N0_LOCAL_FIR_ACT0 &  N0_LOCAL_FIR_ACT1 & ~N0_LOCAL_FIR_ACT2;
};

group gN0_LOCAL_FIR
    filter singlebit,
           cs_root_cause
{
    /** N0_LOCAL_FIR[0]
     *  CFIR - Parity or PCB access error
     */
    (rN0_LOCAL_FIR, bit(0)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[1]
     *  CPLT_CTRL - PCB access error
     */
    (rN0_LOCAL_FIR, bit(1)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[2]
     *  CC - PCB access error
     */
    (rN0_LOCAL_FIR, bit(2)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[3]
     *  CC - Clock Control Error
     */
    (rN0_LOCAL_FIR, bit(3)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[4]
     *  PSC - PSCOM access error
     */
    (rN0_LOCAL_FIR, bit(4)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[5]
     *  PSC - internal or ring interface error
     */
    (rN0_LOCAL_FIR, bit(5)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[6]
     *  THERM  internal error
     */
    (rN0_LOCAL_FIR, bit(6)) ? threshold_and_mask_self;

    /** N0_LOCAL_FIR[7]
     *  THERM - pcb error
     */
    (rN0_LOCAL_FIR, bit(7)) ? threshold_and_mask_self;

    /** N0_LOCAL_FIR[8]
     *  THERMTRIP - Critical temperature indicator
     */
    (rN0_LOCAL_FIR, bit(8)) ? threshold_and_mask_self;

    /** N0_LOCAL_FIR[9]
     *  THERMTRIP - Fatal temperature indicator
     */
    (rN0_LOCAL_FIR, bit(9)) ? threshold_and_mask_self;

    /** N0_LOCAL_FIR[10]
     *  VOLTTRIP - Voltage sense error
     */
    (rN0_LOCAL_FIR, bit(10)) ? threshold_and_mask_self;

    /** N0_LOCAL_FIR[11]
     *  DBG scom parity fail
     */
    (rN0_LOCAL_FIR, bit(11)) ? threshold_and_mask_self;

    /** N0_LOCAL_FIR[12]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(12)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[13]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(13)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[14]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(14)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[15]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(15)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[16]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(16)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[17]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(17)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[18]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(18)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[19]
     *  reserved
     */
    (rN0_LOCAL_FIR, bit(19)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[20]
     *  Trace00 - scom parity err
     */
    (rN0_LOCAL_FIR, bit(20)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[21]
     *  Trace01 - scom parity err - Unused in Axon,PCI
     */
    (rN0_LOCAL_FIR, bit(21)) ? self_th_32perDay;

    /** N0_LOCAL_FIR[22]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(22)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[23]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(23)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[24]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(24)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[25]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(25)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[26]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(26)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[27]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(27)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[28]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(28)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[29]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(29)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[30]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(30)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[31]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(31)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[32]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(32)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[33]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(33)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[34]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(34)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[35]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(35)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[36]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(36)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[37]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(37)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[38]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(38)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[39]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(39)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[40]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(40)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[41]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(41)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[42]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(42)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[43]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(43)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[44]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(44)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[45]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(45)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[46]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(46)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[47]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(47)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[48]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(48)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[49]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(49)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[50]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(50)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[51]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(51)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[52]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(52)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[53]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(53)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[54]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(54)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[55]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(55)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[56]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(56)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[57]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(57)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[58]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(58)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[59]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(59)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[60]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(60)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[61]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(61)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[62]
     *  unused
     */
    (rN0_LOCAL_FIR, bit(62)) ? defaultMaskedError;

    /** N0_LOCAL_FIR[63]
     *  ext_local_xstop
     */
    (rN0_LOCAL_FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P10 chip INT_CQ_FIR
################################################################################

rule rINT_CQ_FIR
{
  CHECK_STOP:
    INT_CQ_FIR & ~INT_CQ_FIR_MASK & ~INT_CQ_FIR_ACT0 & ~INT_CQ_FIR_ACT1;
  RECOVERABLE:
    INT_CQ_FIR & ~INT_CQ_FIR_MASK & ~INT_CQ_FIR_ACT0 &  INT_CQ_FIR_ACT1;
};

group gINT_CQ_FIR
    filter singlebit,
           cs_root_cause
{
    /** INT_CQ_FIR[0]
     *  CE while consuming data from the PowerBus Data ram
     */
    (rINT_CQ_FIR, bit(0)) ? self_th_32perDay;

    /** INT_CQ_FIR[1]
     *  UE while consuming data from the PowerBus Data ram
     */
    (rINT_CQ_FIR, bit(1)) ? self_th_1;

    /** INT_CQ_FIR[2]
     *  SUE while consuming data from the PowerBus Data ra
     */
    (rINT_CQ_FIR, bit(2)) ? self_th_1_SUE;

    /** INT_CQ_FIR[3]
     *  CE while reading the PowerBus Data In Array
     */
    (rINT_CQ_FIR, bit(3)) ? self_th_32perDay;

    /** INT_CQ_FIR[4]
     *  UE detected while reading the PowerBus Data In Arr
     */
    (rINT_CQ_FIR, bit(4)) ? self_th_1;

    /** INT_CQ_FIR[5]
     *  CE while reading the PowerBus Data Out Array
     */
    (rINT_CQ_FIR, bit(5)) ? self_th_32perDay;

    /** INT_CQ_FIR[6]
     *  UE while reading the PowerBus Data Out Array
     */
    (rINT_CQ_FIR, bit(6)) ? self_th_1;

    /** INT_CQ_FIR[7]
     *  CE while consuming data on the AIB Data Bus
     */
    (rINT_CQ_FIR, bit(7)) ? self_th_32perDay;

    /** INT_CQ_FIR[8]
     *  UE while consuming data on the AIB Data Bus
     */
    (rINT_CQ_FIR, bit(8)) ? self_th_1;

    /** INT_CQ_FIR[9]
     *  Received an unsolicited master Combined Response
     */
    (rINT_CQ_FIR, bit(9)) ? self_th_1;

    /** INT_CQ_FIR[10]
     *  Received unsolicited PowerBus data -
     */
    (rINT_CQ_FIR, bit(10)) ? self_th_1;

    /** INT_CQ_FIR[11]
     *  Parity error detected on AIB credit signals from P
     */
    (rINT_CQ_FIR, bit(11)) ? self_th_1;

    /** INT_CQ_FIR[12]
     *  Parity error detected on AIB credit available sign
     */
    (rINT_CQ_FIR, bit(12)) ? self_th_1;

    /** INT_CQ_FIR[13]
     *  Parity error detected on AIB credit signals from V
     */
    (rINT_CQ_FIR, bit(13)) ? self_th_1;

    /** INT_CQ_FIR[14]
     *  Parity error detected on AIB credit available sign
     */
    (rINT_CQ_FIR, bit(14)) ? self_th_1;

    /** INT_CQ_FIR[15]
     *  Parity error detected on AIB Command Control
     */
    (rINT_CQ_FIR, bit(15)) ? self_th_1;

    /** INT_CQ_FIR[16]
     *  Parity error detected on AIB Command Bus
     */
    (rINT_CQ_FIR, bit(16)) ? self_th_1;

    /** INT_CQ_FIR[17]
     *  Parity error detected on AIB Data Control
     */
    (rINT_CQ_FIR, bit(17)) ? self_th_1;

    /** INT_CQ_FIR[18]
     *  Parity err detected in a PowerBus interface(Rcmdx,
     */
    (rINT_CQ_FIR, bit(18)) ? self_th_1;

    /** INT_CQ_FIR[19]
     *  Slave CI Store or CI Load to an improper location.
     */
    (rINT_CQ_FIR, bit(19)) ? self_th_1;

    /** INT_CQ_FIR[20]
     *  Slave CI Store or CI Load to an invalid Set Transl
     */
    (rINT_CQ_FIR, bit(20)) ? self_th_1;

    /** INT_CQ_FIR[21]
     *  Slave CI Store or CI Load error (targeting IC_BAR)
     */
    (rINT_CQ_FIR, bit(21)) ? self_th_1;

    /** INT_CQ_FIR[22]
     *  Slave CI Store or CI Load error (not targetting IC
     */
    (rINT_CQ_FIR, bit(22)) ? defaultMaskedError;

    /** INT_CQ_FIR[23]
     *  Migration Register Table (MRT) access - invalid en
     */
    (rINT_CQ_FIR, bit(23)) ? self_th_1;

    /** INT_CQ_FIR[24]
     *  Migration Register Table (MRT) access - size error
     */
    (rINT_CQ_FIR, bit(24)) ? self_th_1;

    /** INT_CQ_FIR[25]
     *  SCOM satellite error
     */
    (rINT_CQ_FIR, bit(25)) ? self_th_1;

    /** INT_CQ_FIR[26]
     *  Topology ID Index Translation Table Entry Invalid
     */
    (rINT_CQ_FIR, bit(26)) ? self_M_level2_L_th_1;

    /** INT_CQ_FIR[27]
     *  Master Write Queue has flagged a PowerBus operatio
     */
    (rINT_CQ_FIR, bit(27)) ? defaultMaskedError;

    /** INT_CQ_FIR[28]
     *  Master Read Queue has flagged a PowerBus operation
     */
    (rINT_CQ_FIR, bit(28)) ? defaultMaskedError;

    /** INT_CQ_FIR[29]
     *  Master Interrupt Queue has flagged a PowerBus oper
     */
    (rINT_CQ_FIR, bit(29)) ? defaultMaskedError;

    /** INT_CQ_FIR[30]
     *  Master Read Queue has flagged a PowerBus data hang
     */
    (rINT_CQ_FIR, bit(30)) ? defaultMaskedError;

    /** INT_CQ_FIR[31]
     *  CI Store Queue has flagged a PowerBus data hang
     */
    (rINT_CQ_FIR, bit(31)) ? defaultMaskedError;

    /** INT_CQ_FIR[32]
     *  CI Load Queue has flagged an AIB data hang
     */
    (rINT_CQ_FIR, bit(32)) ? defaultMaskedError;

    /** INT_CQ_FIR[33]
     *  Bad cResp received during a Master Write command.
     */
    (rINT_CQ_FIR, bit(33)) ? self_M_level2_L_th_1;

    /** INT_CQ_FIR[34]
     *  Bad cResp received during a Master Read command.
     */
    (rINT_CQ_FIR, bit(34)) ? self_M_level2_L_th_1;

    /** INT_CQ_FIR[35]
     *  Bad cResp received during a Master Interrupt comma
     */
    (rINT_CQ_FIR, bit(35)) ? self_th_1;

    /** INT_CQ_FIR[36]
     *  A Master Read machine received cResp of abort_trm 
     */
    (rINT_CQ_FIR, bit(36)) ? self_th_32perDay;

    /** INT_CQ_FIR[37]
     *  Master Interrupt Protocol Error
     */
    (rINT_CQ_FIR, bit(37)) ? self_M_level2_L_th_1;

    /** INT_CQ_FIR[38]
     *  Master Memory Op Targeted Secure Memory
     */
    (rINT_CQ_FIR, bit(38)) ? self_th_1;

    /** INT_CQ_FIR[39]
     *  AIB Fence Raised
     */
    (rINT_CQ_FIR, bit(39)) ? self_th_1;

    /** INT_CQ_FIR[40]
     *  Parity error detected on CQs configuration registe
     */
    (rINT_CQ_FIR, bit(40)) ? self_th_1;

    /** INT_CQ_FIR[41]
     *  Reserved
     */
    (rINT_CQ_FIR, bit(41)) ? defaultMaskedError;

    /** INT_CQ_FIR[42]
     *  Command Queue (FSM) severe error summary
     */
    (rINT_CQ_FIR, bit(42)) ? self_th_1;

    /** INT_CQ_FIR[43]
     *  PC fatal error summary, as indicated on pc_cq_fata
     */
    (rINT_CQ_FIR, bit(43)) ? self_th_1;

    /** INT_CQ_FIR[44]
     *  PC fatal error summary, as indicated on pc_cq_fata
     */
    (rINT_CQ_FIR, bit(44)) ? self_th_1;

    /** INT_CQ_FIR[45]
     *  PC fatal error summary, as indicated on pc_cq_fata
     */
    (rINT_CQ_FIR, bit(45)) ? self_th_1;

    /** INT_CQ_FIR[46]
     *  PC fatal error summary, as indicated on pc_cq_fata
     */
    (rINT_CQ_FIR, bit(46)) ? self_th_1;

    /** INT_CQ_FIR[47]
     *  PC recoverable error summary, as indicated on pc_c
     */
    (rINT_CQ_FIR, bit(47)) ? self_th_1;

    /** INT_CQ_FIR[48]
     *  PC recoverable error summary, as indicated on pc_c
     */
    (rINT_CQ_FIR, bit(48)) ? self_th_1;

    /** INT_CQ_FIR[49]
     *  PC recoverable error summary, as indicated on pc_c
     */
    (rINT_CQ_FIR, bit(49)) ? self_th_1;

    /** INT_CQ_FIR[50]
     *  PC recoverable error summary, as indicated on pc_c
     */
    (rINT_CQ_FIR, bit(50)) ? self_th_1;

    /** INT_CQ_FIR[51]
     *  PC informational error summary, as indicated on pc
     */
    (rINT_CQ_FIR, bit(51)) ? defaultMaskedError;

    /** INT_CQ_FIR[52]
     *  PC informational error summary, as indicated on pc
     */
    (rINT_CQ_FIR, bit(52)) ? defaultMaskedError;

    /** INT_CQ_FIR[53]
     *  PC informational error summary, as indicated on pc
     */
    (rINT_CQ_FIR, bit(53)) ? defaultMaskedError;

    /** INT_CQ_FIR[54]
     *  PC informational error summary, as indicated on pc
     */
    (rINT_CQ_FIR, bit(54)) ? defaultMaskedError;

    /** INT_CQ_FIR[55]
     *  VC fatal error summary, as indicated on vc_cq_fata
     */
    (rINT_CQ_FIR, bit(55)) ? self_th_1;

    /** INT_CQ_FIR[56]
     *  VC fatal error summary, as indicated on vc_cq_fata
     */
    (rINT_CQ_FIR, bit(56)) ? self_th_1;

    /** INT_CQ_FIR[57]
     *  VC fatal error summary, as indicated on vc_cq_fata
     */
    (rINT_CQ_FIR, bit(57)) ? self_th_1;

    /** INT_CQ_FIR[58]
     *  VC recoverable error summary, as indicated on vc_c
     */
    (rINT_CQ_FIR, bit(58)) ? level2_M_self_L_th_32perDay;

    /** INT_CQ_FIR[59]
     *  VC recoverable error summary, as indicated on vc_c
     */
    (rINT_CQ_FIR, bit(59)) ? level2_M_self_L_th_32perDay;

    /** INT_CQ_FIR[60]
     *  VC recoverable error summary, as indicated on vc_c
     */
    (rINT_CQ_FIR, bit(60)) ? level2_M_self_L_th_32perDay;

    /** INT_CQ_FIR[61]
     *  VC informational error summary, as indicated on vc
     */
    (rINT_CQ_FIR, bit(61)) ? defaultMaskedError;

    /** INT_CQ_FIR[62]
     *  VC informational error summary, as indicated on vc
     */
    (rINT_CQ_FIR, bit(62)) ? defaultMaskedError;

    /** INT_CQ_FIR[63]
     *  VC informational error summary, as indicated on vc
     */
    (rINT_CQ_FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P10 chip NX_CQ_FIR
################################################################################

rule rNX_CQ_FIR
{
  CHECK_STOP:
    NX_CQ_FIR & ~NX_CQ_FIR_MASK & ~NX_CQ_FIR_ACT0 & ~NX_CQ_FIR_ACT1;
  RECOVERABLE:
    NX_CQ_FIR & ~NX_CQ_FIR_MASK & ~NX_CQ_FIR_ACT0 &  NX_CQ_FIR_ACT1;
  UNIT_CS:
    NX_CQ_FIR & ~NX_CQ_FIR_MASK &  NX_CQ_FIR_ACT0 &  NX_CQ_FIR_ACT1;
};

group gNX_CQ_FIR
    filter singlebit,
           cs_root_cause(7,16,21)
{
    /** NX_CQ_FIR[0]
     *  PBI internal parity error
     */
    (rNX_CQ_FIR, bit(0)) ? nx_th_1;

    /** NX_CQ_FIR[1]
     *  PowerBus CE error
     */
    (rNX_CQ_FIR, bit(1)) ? nx_th_32perDay;

    /** NX_CQ_FIR[2]
     *  PowerBus UE error
     */
    (rNX_CQ_FIR, bit(2)) ? nx_th_1;

    /** NX_CQ_FIR[3]
     *  PowerBus SUE error
     */
    (rNX_CQ_FIR, bit(3)) ? defaultMaskedError;

    /** NX_CQ_FIR[4]
     *  Inbound array CE error
     */
    (rNX_CQ_FIR, bit(4)) ? nx_th_32perDay;

    /** NX_CQ_FIR[5]
     *  Inbound array UE error
     */
    (rNX_CQ_FIR, bit(5)) ? nx_th_1;

    /** NX_CQ_FIR[6]
     *  Paste request rejected
     */
    (rNX_CQ_FIR, bit(6)) ? level2_th_1;

    /** NX_CQ_FIR[7]
     *  PowerBus command hang error
     */
    (rNX_CQ_FIR, bit(7)) ? nx_th_1;

    /** NX_CQ_FIR[8]
     *  PowerBus read address error
     */
    (rNX_CQ_FIR, bit(8)) ? nx_th_1;

    /** NX_CQ_FIR[9]
     *  PowerBus write address error
     */
    (rNX_CQ_FIR, bit(9)) ? nx_th_1;

    /** NX_CQ_FIR[10]
     *  PowerBus miscellaneous error
     */
    (rNX_CQ_FIR, bit(10)) ? nx_th_1;

    /** NX_CQ_FIR[11]
     *  MMIO BAR parity error
     */
    (rNX_CQ_FIR, bit(11)) ? defaultMaskedError;

    /** NX_CQ_FIR[12]
     *  UMAC detected SUE on WC Interrupt
     */
    (rNX_CQ_FIR, bit(12)) ? nx_th_1_SUE;

    /** NX_CQ_FIR[13]
     *  ACK_DEAD cresp received by read command
     */
    (rNX_CQ_FIR, bit(13)) ? defaultMaskedError;

    /** NX_CQ_FIR[14]
     *  ACK_DEAD cresp received by write command
     */
    (rNX_CQ_FIR, bit(14)) ? defaultMaskedError;

    /** NX_CQ_FIR[15]
     *  Reserved
     */
    (rNX_CQ_FIR, bit(15)) ? defaultMaskedError;

    /** NX_CQ_FIR[16]
     *  Hang poll time expired on internal transfer
     */
    (rNX_CQ_FIR, bit(16)) ? nx_th_1;

    /** NX_CQ_FIR[17]
     *  Parity error on ERAT arrays
     */
    (rNX_CQ_FIR, bit(17)) ? nx_th_1;

    /** NX_CQ_FIR[18]
     *  Correctable error on ERAT arrays
     */
    (rNX_CQ_FIR, bit(18)) ? nx_th_32perDay;

    /** NX_CQ_FIR[19]
     *  Uncorrectable error on ERAT arrays
     */
    (rNX_CQ_FIR, bit(19)) ? nx_th_1;

    /** NX_CQ_FIR[20]
     *  Special uncorrectable error on ERAT arrays
     */
    (rNX_CQ_FIR, bit(20)) ? nx_th_1_SUE;

    /** NX_CQ_FIR[21]
     *  Hang on checkin/checkout request to NMMU
     */
    (rNX_CQ_FIR, bit(21)) ? level2_th_1;

    /** NX_CQ_FIR[22]
     *  ERAT control logic error
     */
    (rNX_CQ_FIR, bit(22)) ? nx_th_1;

    /** NX_CQ_FIR[23]
     *  Uncorrectable error on the Powerbus data for xlate
     */
    (rNX_CQ_FIR, bit(23)) ? nx_th_1;

    /** NX_CQ_FIR[24]
     *  Special uncorrectable error on the Powerbus data f
     */
    (rNX_CQ_FIR, bit(24)) ? nx_th_1_SUE;

    /** NX_CQ_FIR[25]
     *  ACK_DEAD cresp received by UMAC read command
     */
    (rNX_CQ_FIR, bit(25)) ? defaultMaskedError;

    /** NX_CQ_FIR[26]
     *  Reserved
     */
    (rNX_CQ_FIR, bit(26)) ? defaultMaskedError;

    /** NX_CQ_FIR[27]
     *  Uncorrectable error on CRB QW0/4
     */
    (rNX_CQ_FIR, bit(27)) ? nx_th_1;

    /** NX_CQ_FIR[28]
     *  Special uncorrectable error on CRB QW0/4
     */
    (rNX_CQ_FIR, bit(28)) ? nx_th_1_SUE;

    /** NX_CQ_FIR[29]
     *  UMAC has detected a control logic error
     */
    (rNX_CQ_FIR, bit(29)) ? nx_th_1;

    /** NX_CQ_FIR[30]
     *  Other SCOM satellite parity error
     */
    (rNX_CQ_FIR, bit(30)) ? defaultMaskedError;

    /** NX_CQ_FIR[31]
     *  SCOM write to RNG when not allowed
     */
    (rNX_CQ_FIR, bit(31)) ? defaultMaskedError;

    /** NX_CQ_FIR[32]
     *  A first noise source in the RNG has failed
     */
    (rNX_CQ_FIR, bit(32)) ? nx_th_32perDay;

    /** NX_CQ_FIR[33]
     *  A second noise source in the RNG has failed
     */
    (rNX_CQ_FIR, bit(33)) ? nx_th_32perDay;

    /** NX_CQ_FIR[34]
     *  RNG has detected a control logic error
     */
    (rNX_CQ_FIR, bit(34)) ? nx_th_1;

    /** NX_CQ_FIR[35]
     *  NMMU has signaled local checkstop
     */
    (rNX_CQ_FIR, bit(35)) ? nx_th_1;

    /** NX_CQ_FIR[36]
     *  VAS has signaled local checkstop
     */
    (rNX_CQ_FIR, bit(36)) ? nx_th_1;

    /** NX_CQ_FIR[37]
     *  PBCQ has detected a control logic error
     */
    (rNX_CQ_FIR, bit(37)) ? nx_th_1;

    /** NX_CQ_FIR[38]
     *  PBCQ has detected a failed link on an interrupt
     */
    (rNX_CQ_FIR, bit(38)) ? defaultMaskedError;

    /** NX_CQ_FIR[39]
     *  UMAC has detected an SUE on interrupt address
     */
    (rNX_CQ_FIR, bit(39)) ? nx_th_1_SUE;

    /** NX_CQ_FIR[40]
     *  SMF error
     */
    (rNX_CQ_FIR, bit(40)) ? defaultMaskedError;

    /** NX_CQ_FIR[41]
     *  Topology index error detected in NX
     */
    (rNX_CQ_FIR, bit(41)) ? level2_th_1;

};

################################################################################
# P10 chip NX_DMA_ENG_FIR
################################################################################

rule rNX_DMA_ENG_FIR
{
  CHECK_STOP:
    NX_DMA_ENG_FIR & ~NX_DMA_ENG_FIR_MASK & ~NX_DMA_ENG_FIR_ACT0 & ~NX_DMA_ENG_FIR_ACT1;
  RECOVERABLE:
    NX_DMA_ENG_FIR & ~NX_DMA_ENG_FIR_MASK & ~NX_DMA_ENG_FIR_ACT0 &  NX_DMA_ENG_FIR_ACT1;
  UNIT_CS:
    NX_DMA_ENG_FIR & ~NX_DMA_ENG_FIR_MASK &  NX_DMA_ENG_FIR_ACT0 &  NX_DMA_ENG_FIR_ACT1;
};

group gNX_DMA_ENG_FIR
    filter singlebit,
           cs_root_cause(0)
{
    /** NX_DMA_ENG_FIR[0]
     *  DMA hang timer expired
     */
    (rNX_DMA_ENG_FIR, bit(0)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[1]
     *  SHM invalid state
     */
    (rNX_DMA_ENG_FIR, bit(1)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[2]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(2)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[3]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(3)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[4]
     *  Channel 0 842 engine ECC CE
     */
    (rNX_DMA_ENG_FIR, bit(4)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[5]
     *  Channel 0 842 engine ECC UE
     */
    (rNX_DMA_ENG_FIR, bit(5)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[6]
     *  Channel 1 842 engine ECC CE
     */
    (rNX_DMA_ENG_FIR, bit(6)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[7]
     *  Channel 1 842 engine ECC UE
     */
    (rNX_DMA_ENG_FIR, bit(7)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[8]
     *  DMA Non-zero CSB CC detected
     */
    (rNX_DMA_ENG_FIR, bit(8)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[9]
     *  DMA array ECC CE
     */
    (rNX_DMA_ENG_FIR, bit(9)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[10]
     *  DMA outbound write/inbound read ECC CE
     */
    (rNX_DMA_ENG_FIR, bit(10)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[11]
     *  Channel 4 GZIP ECC CE
     */
    (rNX_DMA_ENG_FIR, bit(11)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[12]
     *  Channel 4 GZIP ECC UE
     */
    (rNX_DMA_ENG_FIR, bit(12)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[13]
     *  Channel 4 GZIP ECC PE
     */
    (rNX_DMA_ENG_FIR, bit(13)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[14]
     *  Error from other SCOM satellites
     */
    (rNX_DMA_ENG_FIR, bit(14)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[15]
     *  DMA invalid state error (unrecoverable)
     */
    (rNX_DMA_ENG_FIR, bit(15)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[16]
     *  DMA invalid state error (unrecoverable)
     */
    (rNX_DMA_ENG_FIR, bit(16)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[17]
     *  DMA array ECC UE
     */
    (rNX_DMA_ENG_FIR, bit(17)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[18]
     *  DMA outbound write/inbound read ECC UE
     */
    (rNX_DMA_ENG_FIR, bit(18)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[19]
     *  DMA inbound read error
     */
    (rNX_DMA_ENG_FIR, bit(19)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[20]
     *  Channel 0 842 invalid state error
     */
    (rNX_DMA_ENG_FIR, bit(20)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[21]
     *  Channel 1 842 invalid state error
     */
    (rNX_DMA_ENG_FIR, bit(21)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[22]
     *  Channel 2 SYM invalid state error
     */
    (rNX_DMA_ENG_FIR, bit(22)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[23]
     *  Channel 3 SYM invalid state error
     */
    (rNX_DMA_ENG_FIR, bit(23)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[24]
     *  Channel 4 GZIP invalid state error
     */
    (rNX_DMA_ENG_FIR, bit(24)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[25]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(25)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[26]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(26)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[27]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(27)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[28]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(28)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[29]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(29)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[30]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(30)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[31]
     *  UE error on CRB QW0 or QW4 FIR bit
     */
    (rNX_DMA_ENG_FIR, bit(31)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[32]
     *  SUE error on CRB QW0 or QW4 FIR bit
     */
    (rNX_DMA_ENG_FIR, bit(32)) ? nx_th_1_SUE;

    /** NX_DMA_ENG_FIR[33]
     *  SUE error on something other than CRB QW0 or QW4
     */
    (rNX_DMA_ENG_FIR, bit(33)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[34]
     *  Channel 0 842 watchdog timer expired
     */
    (rNX_DMA_ENG_FIR, bit(34)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[35]
     *  Channel 1 842 watchdog timer expired
     */
    (rNX_DMA_ENG_FIR, bit(35)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[36]
     *  Channel 2 SYM watchdog timer expired
     */
    (rNX_DMA_ENG_FIR, bit(36)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[37]
     *  Channel 3 SYM watchdog timer expired
     */
    (rNX_DMA_ENG_FIR, bit(37)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[38]
     *  Hypervisor local checkstop
     */
    (rNX_DMA_ENG_FIR, bit(38)) ? nx_th_1;

    /** NX_DMA_ENG_FIR[39]
     *  Channel 4 GZIP watchdog timer expired
     */
    (rNX_DMA_ENG_FIR, bit(39)) ? nx_th_32perDay;

    /** NX_DMA_ENG_FIR[40]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(40)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[41]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(41)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[42]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(42)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[43]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(43)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[44]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(44)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[45]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(45)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[46]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(46)) ? defaultMaskedError;

    /** NX_DMA_ENG_FIR[47]
     *  Reserved
     */
    (rNX_DMA_ENG_FIR, bit(47)) ? defaultMaskedError;

};

################################################################################
# P10 chip VAS_FIR
################################################################################

rule rVAS_FIR
{
  CHECK_STOP:
    VAS_FIR & ~VAS_FIR_MASK & ~VAS_FIR_ACT0 & ~VAS_FIR_ACT1;
  RECOVERABLE:
    VAS_FIR & ~VAS_FIR_MASK & ~VAS_FIR_ACT0 &  VAS_FIR_ACT1;
  UNIT_CS:
    VAS_FIR & ~VAS_FIR_MASK &  VAS_FIR_ACT0 &  VAS_FIR_ACT1;
};

group gVAS_FIR
    filter singlebit,
           cs_root_cause
{
    /** VAS_FIR[0]
     *  Hardware error detected in Egress logic
     */
    (rVAS_FIR, bit(0)) ? self_th_1;

    /** VAS_FIR[1]
     *  Hardware error detected in Ingress logic
     */
    (rVAS_FIR, bit(1)) ? self_th_1;

    /** VAS_FIR[2]
     *  Hardware error detected in CQ logic
     */
    (rVAS_FIR, bit(2)) ? self_th_1;

    /** VAS_FIR[3]
     *  Hardware error detected in WC logic
     */
    (rVAS_FIR, bit(3)) ? self_th_1;

    /** VAS_FIR[4]
     *  Hardware error detected in RG logic
     */
    (rVAS_FIR, bit(4)) ? self_th_1;

    /** VAS_FIR[5]
     *  PowerBus parity error detected on CQ logic interfa
     */
    (rVAS_FIR, bit(5)) ? self_th_1;

    /** VAS_FIR[6]
     *  CQ logic detected PowerBus address error on CRESP
     */
    (rVAS_FIR, bit(6)) ? self_M_level2_L_th_1;

    /** VAS_FIR[7]
     *  CQ logic detected PowerBus address error on CRESP
     */
    (rVAS_FIR, bit(7)) ? self_M_level2_L_th_1;

    /** VAS_FIR[8]
     *  Correctable ECC error detected in Egress logic
     */
    (rVAS_FIR, bit(8)) ? self_th_5perHour;

    /** VAS_FIR[9]
     *  Correctable ECC error detected in Ingress logic
     */
    (rVAS_FIR, bit(9)) ? self_th_5perHour;

    /** VAS_FIR[10]
     *  Correctable ECC error detected in CQ logic
     */
    (rVAS_FIR, bit(10)) ? defaultMaskedError;

    /** VAS_FIR[11]
     *  Correctable ECC error detected in WC logic
     */
    (rVAS_FIR, bit(11)) ? self_th_5perHour;

    /** VAS_FIR[12]
     *  Correctable ECC error detected in RG logic
     */
    (rVAS_FIR, bit(12)) ? self_th_5perHour;

    /** VAS_FIR[13]
     *  ECC Correctable Error detected on CQ outbound PB
     */
    (rVAS_FIR, bit(13)) ? self_th_5perHour;

    /** VAS_FIR[14]
     *  ECC UNCorrectable Error detected on CQ outbound PB
     */
    (rVAS_FIR, bit(14)) ? self_th_1;

    /** VAS_FIR[15]
     *  PowerBus state machine hang detected in CQ logic
     */
    (rVAS_FIR, bit(15)) ? defaultMaskedError;

    /** VAS_FIR[16]
     *  Uncorrectable ECC error detected in Egress logic
     */
    (rVAS_FIR, bit(16)) ? self_th_1;

    /** VAS_FIR[17]
     *  Uncorrectable ECC error detected in Ingress logic
     */
    (rVAS_FIR, bit(17)) ? self_th_1;

    /** VAS_FIR[18]
     *  Uncorrectable ECC error detected in CQ logic
     */
    (rVAS_FIR, bit(18)) ? self_th_1;

    /** VAS_FIR[19]
     *  Uncorrectable ECC error detected in WC logic
     */
    (rVAS_FIR, bit(19)) ? self_th_1;

    /** VAS_FIR[20]
     *  Uncorrectable ECC error detected in RG logic
     */
    (rVAS_FIR, bit(20)) ? self_th_1;

    /** VAS_FIR[21]
     *  Parity error detected in Ingress logic
     */
    (rVAS_FIR, bit(21)) ? self_th_1;

    /** VAS_FIR[22]
     *  Software cast error detected in Ingress logic
     */
    (rVAS_FIR, bit(22)) ? self_th_1;

    /** VAS_FIR[23]
     *  Reserved
     */
    (rVAS_FIR, bit(23)) ? defaultMaskedError;

    /** VAS_FIR[24]
     *  ECC sue error detected in Egress logic
     */
    (rVAS_FIR, bit(24)) ? self_th_1_SUE;

    /** VAS_FIR[25]
     *  ECC sue error detected in Ingress logic
     */
    (rVAS_FIR, bit(25)) ? self_th_1_SUE;

    /** VAS_FIR[26]
     *  ECC sue error detected in CQ logic
     */
    (rVAS_FIR, bit(26)) ? self_th_1_SUE;

    /** VAS_FIR[27]
     *  ECC sue error detected in WC logic
     */
    (rVAS_FIR, bit(27)) ? self_th_1_SUE;

    /** VAS_FIR[28]
     *  ECC sue error detected in RG logic
     */
    (rVAS_FIR, bit(28)) ? self_th_1_SUE;

    /** VAS_FIR[29]
     *  PowerBus link error detected on read operation in 
     */
    (rVAS_FIR, bit(29)) ? defaultMaskedError;

    /** VAS_FIR[30]
     *  PowerBus link error detected on write operation in
     */
    (rVAS_FIR, bit(30)) ? defaultMaskedError;

    /** VAS_FIR[31]
     *  PowerBus link abort operation received in CQ logic
     */
    (rVAS_FIR, bit(31)) ? defaultMaskedError;

    /** VAS_FIR[32]
     *  Address error detected on hypervisor MMIO read
     */
    (rVAS_FIR, bit(32)) ? self_th_1;

    /** VAS_FIR[33]
     *  Address error detected on OS MMIO read
     */
    (rVAS_FIR, bit(33)) ? defaultMaskedError;

    /** VAS_FIR[34]
     *  Address error detected on hypervisor MMIO write
     */
    (rVAS_FIR, bit(34)) ? self_th_1;

    /** VAS_FIR[35]
     *  Address error detected on OS MMIO write
     */
    (rVAS_FIR, bit(35)) ? defaultMaskedError;

    /** VAS_FIR[36]
     *  non-8-Byte MMIO detected by hypervisor
     */
    (rVAS_FIR, bit(36)) ? self_th_1;

    /** VAS_FIR[37]
     *  non-8-Byte MMIO detected by user or OS
     */
    (rVAS_FIR, bit(37)) ? defaultMaskedError;

    /** VAS_FIR[38]
     *  Reserved
     */
    (rVAS_FIR, bit(38)) ? defaultMaskedError;

    /** VAS_FIR[39]
     *  Reserved
     */
    (rVAS_FIR, bit(39)) ? defaultMaskedError;

    /** VAS_FIR[40]
     *  Reserved
     */
    (rVAS_FIR, bit(40)) ? defaultMaskedError;

    /** VAS_FIR[41]
     *  Reserved
     */
    (rVAS_FIR, bit(41)) ? defaultMaskedError;

    /** VAS_FIR[42]
     *  ASB_Notify sent but not claimed and interrupts wer
     */
    (rVAS_FIR, bit(42)) ? self_th_1;

    /** VAS_FIR[43]
     *  Unused - Was Write monitor operation hit a window 
     */
    (rVAS_FIR, bit(43)) ? defaultMaskedError;

    /** VAS_FIR[44]
     *  VAS rejected a PB paste command.
     */
    (rVAS_FIR, bit(44)) ? defaultMaskedError;

    /** VAS_FIR[45]
     *  VAS hung waiting for data from PowerBus
     */
    (rVAS_FIR, bit(45)) ? defaultMaskedError;

    /** VAS_FIR[46]
     *  Incoming PowerBus parity error
     */
    (rVAS_FIR, bit(46)) ? self_th_1;

    /** VAS_FIR[47]
     *  HW error from SCOM Satellite 1
     */
    (rVAS_FIR, bit(47)) ? defaultMaskedError;

    /** VAS_FIR[48]
     *  NX Local Checkstop
     */
    (rVAS_FIR, bit(48)) ? self_th_1;

    /** VAS_FIR[49]
     *  SCOM MMIO address offset error
     */
    (rVAS_FIR, bit(49)) ? defaultMaskedError;

    /** VAS_FIR[50]
     *  TopoID Error Bit
     */
    (rVAS_FIR, bit(50)) ? self_th_1;

    /** VAS_FIR[51]
     *  Unused bit
     */
    (rVAS_FIR, bit(51)) ? defaultMaskedError;

};

################################################################################
# N1 Chiplet Checkstop FIR
################################################################################

# Note that bit 33 (PB_EXT_FIR) is explicitly ignored because it simply
# indicates a checkstop originated from another processor.
rule rN1_CHIPLET_CS_FIR
{
  CHECK_STOP:
    N1_CHIPLET_CS_FIR & ~N1_CHIPLET_CS_FIR_MASK & `0fffffffbfffffff`;
};

group gN1_CHIPLET_CS_FIR
    filter singlebit
{
    /** N1_CHIPLET_CS_FIR[4]
     *  Attention from N1_LOCAL_FIR
     */
    (rN1_CHIPLET_CS_FIR, bit(4)) ? analyze(gN1_LOCAL_FIR);

    /** N1_CHIPLET_CS_FIR[5]
     *  Attention from NMMU_CQ_FIR 1
     */
    (rN1_CHIPLET_CS_FIR, bit(5)) ? analyzeConnectedNMMU1;

    /** N1_CHIPLET_CS_FIR[6]
     *  Attention from NMMU_FIR 1
     */
    (rN1_CHIPLET_CS_FIR, bit(6)) ? analyzeConnectedNMMU1;

    /** N1_CHIPLET_CS_FIR[7]
     *  Attention from MCD_FIR
     */
    (rN1_CHIPLET_CS_FIR, bit(7)) ? analyze(gMCD_FIR);

    /** N1_CHIPLET_CS_FIR[9]
     *  Attention from HCA_FIR
     */
    (rN1_CHIPLET_CS_FIR, bit(9)) ? analyzeHCA_FIR;

    /** N1_CHIPLET_CS_FIR[11]
     *  Attention from LPC_FIR
     */
    (rN1_CHIPLET_CS_FIR, bit(11)) ? analyze(gLPC_FIR);

    /** N1_CHIPLET_CS_FIR[13]
     *  Attention from PCI_NEST_FIR 0
     */
    (rN1_CHIPLET_CS_FIR, bit(13)) ? analyzeConnectedPHB0;

    /** N1_CHIPLET_CS_FIR[14]
     *  Attention from PCI_NEST_FIR 1
     */
    (rN1_CHIPLET_CS_FIR, bit(14)) ? analyzeConnectedPHB1;

    /** N1_CHIPLET_CS_FIR[15]
     *  Attention from PCI_NEST_FIR 2
     */
    (rN1_CHIPLET_CS_FIR, bit(15)) ? analyzeConnectedPHB2;

    /** N1_CHIPLET_CS_FIR[17]
     *  Attention from PB_STATION_FIR_EQ_0
     */
    (rN1_CHIPLET_CS_FIR, bit(17)) ? analyze(gPB_STATION_FIR_EQ_0);

    /** N1_CHIPLET_CS_FIR[18]
     *  Attention from PB_STATION_FIR_EQ_1
     */
    (rN1_CHIPLET_CS_FIR, bit(18)) ? analyze(gPB_STATION_FIR_EQ_1);

    /** N1_CHIPLET_CS_FIR[19]
     *  Attention from PB_STATION_FIR_EQ_2
     */
    (rN1_CHIPLET_CS_FIR, bit(19)) ? analyze(gPB_STATION_FIR_EQ_2);

    /** N1_CHIPLET_CS_FIR[20]
     *  Attention from PB_STATION_FIR_EQ_3
     */
    (rN1_CHIPLET_CS_FIR, bit(20)) ? analyze(gPB_STATION_FIR_EQ_3);

    /** N1_CHIPLET_CS_FIR[21]
     *  Attention from PB_STATION_FIR_EQ_4
     */
    (rN1_CHIPLET_CS_FIR, bit(21)) ? analyze(gPB_STATION_FIR_EQ_4);

    /** N1_CHIPLET_CS_FIR[22]
     *  Attention from PB_STATION_FIR_EQ_5
     */
    (rN1_CHIPLET_CS_FIR, bit(22)) ? analyze(gPB_STATION_FIR_EQ_5);

    /** N1_CHIPLET_CS_FIR[23]
     *  Attention from PB_STATION_FIR_EQ_6
     */
    (rN1_CHIPLET_CS_FIR, bit(23)) ? analyze(gPB_STATION_FIR_EQ_6);

    /** N1_CHIPLET_CS_FIR[24]
     *  Attention from PB_STATION_FIR_EQ_7
     */
    (rN1_CHIPLET_CS_FIR, bit(24)) ? analyze(gPB_STATION_FIR_EQ_7);

    /** N1_CHIPLET_CS_FIR[25]
     *  Attention from PB_STATION_FIR_EN1
     */
    (rN1_CHIPLET_CS_FIR, bit(25)) ? analyze(gPB_STATION_FIR_EN1);

    /** N1_CHIPLET_CS_FIR[26]
     *  Attention from PB_STATION_FIR_EN2
     */
    (rN1_CHIPLET_CS_FIR, bit(26)) ? analyze(gPB_STATION_FIR_EN2);

    /** N1_CHIPLET_CS_FIR[27]
     *  Attention from PB_STATION_FIR_EN3
     */
    (rN1_CHIPLET_CS_FIR, bit(27)) ? analyze(gPB_STATION_FIR_EN3);

    /** N1_CHIPLET_CS_FIR[28]
     *  Attention from PB_STATION_FIR_EN4
     */
    (rN1_CHIPLET_CS_FIR, bit(28)) ? analyze(gPB_STATION_FIR_EN4);

    /** N1_CHIPLET_CS_FIR[29]
     *  Attention from PB_STATION_FIR_ES1
     */
    (rN1_CHIPLET_CS_FIR, bit(29)) ? analyze(gPB_STATION_FIR_ES1);

    /** N1_CHIPLET_CS_FIR[30]
     *  Attention from PB_STATION_FIR_ES2
     */
    (rN1_CHIPLET_CS_FIR, bit(30)) ? analyze(gPB_STATION_FIR_ES2);

    /** N1_CHIPLET_CS_FIR[31]
     *  Attention from PB_STATION_FIR_ES3
     */
    (rN1_CHIPLET_CS_FIR, bit(31)) ? analyze(gPB_STATION_FIR_ES3);

    /** N1_CHIPLET_CS_FIR[32]
     *  Attention from PB_STATION_FIR_ES4
     */
    (rN1_CHIPLET_CS_FIR, bit(32)) ? analyze(gPB_STATION_FIR_ES4);

    /** N1_CHIPLET_CS_FIR[38]
     *  Attention from PSIHB_FIR
     */
    (rN1_CHIPLET_CS_FIR, bit(38)) ? analyze(gPSIHB_FIR);

    /** N1_CHIPLET_CS_FIR[39]
     *  Attention from PBAF_FIR
     */
    (rN1_CHIPLET_CS_FIR, bit(39)) ? analyzePBAF_FIR;

};

################################################################################
# N1 Chiplet Recoverable FIR
################################################################################

# Note that bit 33 (PB_EXT_FIR) is explicitly ignored because it simply
# indicates a checkstop originated from another processor.
rule rN1_CHIPLET_RE_FIR
{
  RECOVERABLE:
    N1_CHIPLET_RE_FIR & ~N1_CHIPLET_RE_FIR_MASK & `0fffffffbfffffff`;
};

group gN1_CHIPLET_RE_FIR
    filter singlebit
{
    /** N1_CHIPLET_RE_FIR[4]
     *  Attention from N1_LOCAL_FIR
     */
    (rN1_CHIPLET_RE_FIR, bit(4)) ? analyze(gN1_LOCAL_FIR);

    /** N1_CHIPLET_RE_FIR[5]
     *  Attention from NMMU_CQ_FIR 1
     */
    (rN1_CHIPLET_RE_FIR, bit(5)) ? analyzeConnectedNMMU1;

    /** N1_CHIPLET_RE_FIR[6]
     *  Attention from NMMU_FIR 1
     */
    (rN1_CHIPLET_RE_FIR, bit(6)) ? analyzeConnectedNMMU1;

    /** N1_CHIPLET_RE_FIR[7]
     *  Attention from MCD_FIR
     */
    (rN1_CHIPLET_RE_FIR, bit(7)) ? analyze(gMCD_FIR);

    /** N1_CHIPLET_RE_FIR[9]
     *  Attention from HCA_FIR
     */
    (rN1_CHIPLET_RE_FIR, bit(9)) ? analyzeHCA_FIR;

    /** N1_CHIPLET_RE_FIR[11]
     *  Attention from LPC_FIR
     */
    (rN1_CHIPLET_RE_FIR, bit(11)) ? analyze(gLPC_FIR);

    /** N1_CHIPLET_RE_FIR[13]
     *  Attention from PCI_NEST_FIR 0
     */
    (rN1_CHIPLET_RE_FIR, bit(13)) ? analyzeConnectedPHB0;

    /** N1_CHIPLET_RE_FIR[14]
     *  Attention from PCI_NEST_FIR 1
     */
    (rN1_CHIPLET_RE_FIR, bit(14)) ? analyzeConnectedPHB1;

    /** N1_CHIPLET_RE_FIR[15]
     *  Attention from PCI_NEST_FIR 2
     */
    (rN1_CHIPLET_RE_FIR, bit(15)) ? analyzeConnectedPHB2;

    /** N1_CHIPLET_RE_FIR[17]
     *  Attention from PB_STATION_FIR_EQ_0
     */
    (rN1_CHIPLET_RE_FIR, bit(17)) ? analyze(gPB_STATION_FIR_EQ_0);

    /** N1_CHIPLET_RE_FIR[18]
     *  Attention from PB_STATION_FIR_EQ_1
     */
    (rN1_CHIPLET_RE_FIR, bit(18)) ? analyze(gPB_STATION_FIR_EQ_1);

    /** N1_CHIPLET_RE_FIR[19]
     *  Attention from PB_STATION_FIR_EQ_2
     */
    (rN1_CHIPLET_RE_FIR, bit(19)) ? analyze(gPB_STATION_FIR_EQ_2);

    /** N1_CHIPLET_RE_FIR[20]
     *  Attention from PB_STATION_FIR_EQ_3
     */
    (rN1_CHIPLET_RE_FIR, bit(20)) ? analyze(gPB_STATION_FIR_EQ_3);

    /** N1_CHIPLET_RE_FIR[21]
     *  Attention from PB_STATION_FIR_EQ_4
     */
    (rN1_CHIPLET_RE_FIR, bit(21)) ? analyze(gPB_STATION_FIR_EQ_4);

    /** N1_CHIPLET_RE_FIR[22]
     *  Attention from PB_STATION_FIR_EQ_5
     */
    (rN1_CHIPLET_RE_FIR, bit(22)) ? analyze(gPB_STATION_FIR_EQ_5);

    /** N1_CHIPLET_RE_FIR[23]
     *  Attention from PB_STATION_FIR_EQ_6
     */
    (rN1_CHIPLET_RE_FIR, bit(23)) ? analyze(gPB_STATION_FIR_EQ_6);

    /** N1_CHIPLET_RE_FIR[24]
     *  Attention from PB_STATION_FIR_EQ_7
     */
    (rN1_CHIPLET_RE_FIR, bit(24)) ? analyze(gPB_STATION_FIR_EQ_7);

    /** N1_CHIPLET_RE_FIR[25]
     *  Attention from PB_STATION_FIR_EN1
     */
    (rN1_CHIPLET_RE_FIR, bit(25)) ? analyze(gPB_STATION_FIR_EN1);

    /** N1_CHIPLET_RE_FIR[26]
     *  Attention from PB_STATION_FIR_EN2
     */
    (rN1_CHIPLET_RE_FIR, bit(26)) ? analyze(gPB_STATION_FIR_EN2);

    /** N1_CHIPLET_RE_FIR[27]
     *  Attention from PB_STATION_FIR_EN3
     */
    (rN1_CHIPLET_RE_FIR, bit(27)) ? analyze(gPB_STATION_FIR_EN3);

    /** N1_CHIPLET_RE_FIR[28]
     *  Attention from PB_STATION_FIR_EN4
     */
    (rN1_CHIPLET_RE_FIR, bit(28)) ? analyze(gPB_STATION_FIR_EN4);

    /** N1_CHIPLET_RE_FIR[29]
     *  Attention from PB_STATION_FIR_ES1
     */
    (rN1_CHIPLET_RE_FIR, bit(29)) ? analyze(gPB_STATION_FIR_ES1);

    /** N1_CHIPLET_RE_FIR[30]
     *  Attention from PB_STATION_FIR_ES2
     */
    (rN1_CHIPLET_RE_FIR, bit(30)) ? analyze(gPB_STATION_FIR_ES2);

    /** N1_CHIPLET_RE_FIR[31]
     *  Attention from PB_STATION_FIR_ES3
     */
    (rN1_CHIPLET_RE_FIR, bit(31)) ? analyze(gPB_STATION_FIR_ES3);

    /** N1_CHIPLET_RE_FIR[32]
     *  Attention from PB_STATION_FIR_ES4
     */
    (rN1_CHIPLET_RE_FIR, bit(32)) ? analyze(gPB_STATION_FIR_ES4);

    /** N1_CHIPLET_RE_FIR[38]
     *  Attention from PSIHB_FIR
     */
    (rN1_CHIPLET_RE_FIR, bit(38)) ? analyze(gPSIHB_FIR);

    /** N1_CHIPLET_RE_FIR[39]
     *  Attention from PBAF_FIR
     */
    (rN1_CHIPLET_RE_FIR, bit(39)) ? analyzePBAF_FIR;

};

################################################################################
# N1 Chiplet Unit Checkstop FIR
################################################################################

rule rN1_CHIPLET_UCS_FIR
{
  UNIT_CS:
    N1_CHIPLET_UCS_FIR & ~N1_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gN1_CHIPLET_UCS_FIR
    filter singlebit
{
    /** N1_CHIPLET_UCS_FIR[4]
     *  Attention from N1_LOCAL_FIR
     */
    (rN1_CHIPLET_UCS_FIR, bit(4)) ? analyze(gN1_LOCAL_FIR);

    /** N1_CHIPLET_UCS_FIR[5]
     *  Attention from NMMU_CQ_FIR 1
     */
    (rN1_CHIPLET_UCS_FIR, bit(5)) ? analyzeConnectedNMMU1;

    /** N1_CHIPLET_UCS_FIR[6]
     *  Attention from NMMU_FIR 1
     */
    (rN1_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedNMMU1;

};

################################################################################
# N1 Chiplet Host Attention FIR
################################################################################

rule rN1_CHIPLET_HA_FIR
{
  HOST_ATTN:
    N1_CHIPLET_HA_FIR & ~N1_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gN1_CHIPLET_HA_FIR
    filter singlebit
{
    /** N1_CHIPLET_HA_FIR[4]
     *  Attention from N1_LOCAL_FIR
     */
    (rN1_CHIPLET_HA_FIR, bit(4)) ? analyze(gN1_LOCAL_FIR);

};

################################################################################
# P10 chip N1_LOCAL_FIR
################################################################################

rule rN1_LOCAL_FIR
{
  CHECK_STOP:
    N1_LOCAL_FIR & ~N1_LOCAL_FIR_MASK & ~N1_LOCAL_FIR_ACT0 & ~N1_LOCAL_FIR_ACT1 & ~N1_LOCAL_FIR_ACT2;
  HOST_ATTN:
    N1_LOCAL_FIR & ~N1_LOCAL_FIR_MASK & ~N1_LOCAL_FIR_ACT0 & ~N1_LOCAL_FIR_ACT1 &  N1_LOCAL_FIR_ACT2;
  RECOVERABLE:
    N1_LOCAL_FIR & ~N1_LOCAL_FIR_MASK & ~N1_LOCAL_FIR_ACT0 &  N1_LOCAL_FIR_ACT1 & ~N1_LOCAL_FIR_ACT2;
  UNIT_CS:
    N1_LOCAL_FIR & ~N1_LOCAL_FIR_MASK &  N1_LOCAL_FIR_ACT0 &  N1_LOCAL_FIR_ACT1 & ~N1_LOCAL_FIR_ACT2;
};

group gN1_LOCAL_FIR
    filter singlebit,
           cs_root_cause
{
    /** N1_LOCAL_FIR[0]
     *  CFIR - Parity or PCB access error
     */
    (rN1_LOCAL_FIR, bit(0)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[1]
     *  CPLT_CTRL - PCB access error
     */
    (rN1_LOCAL_FIR, bit(1)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[2]
     *  CC - PCB access error
     */
    (rN1_LOCAL_FIR, bit(2)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[3]
     *  CC - Clock Control Error
     */
    (rN1_LOCAL_FIR, bit(3)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[4]
     *  PSC - PSCOM access error
     */
    (rN1_LOCAL_FIR, bit(4)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[5]
     *  PSC - internal or ring interface error
     */
    (rN1_LOCAL_FIR, bit(5)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[6]
     *  THERM - internal error
     */
    (rN1_LOCAL_FIR, bit(6)) ? threshold_and_mask_self;

    /** N1_LOCAL_FIR[7]
     *  THERM - pcb error
     */
    (rN1_LOCAL_FIR, bit(7)) ? threshold_and_mask_self;

    /** N1_LOCAL_FIR[8]
     *  THERMTRIP - Critical temperature indicator
     */
    (rN1_LOCAL_FIR, bit(8)) ? threshold_and_mask_self;

    /** N1_LOCAL_FIR[9]
     *  THERMTRIP - Fatal temperature indicator
     */
    (rN1_LOCAL_FIR, bit(9)) ? threshold_and_mask_self;

    /** N1_LOCAL_FIR[10]
     *  VOLTTRIP - Voltage sense error
     */
    (rN1_LOCAL_FIR, bit(10)) ? threshold_and_mask_self;

    /** N1_LOCAL_FIR[11]
     *  DBG - scom parity fail
     */
    (rN1_LOCAL_FIR, bit(11)) ? threshold_and_mask_self;

    /** N1_LOCAL_FIR[12]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(12)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[13]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(13)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[14]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(14)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[15]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(15)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[16]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(16)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[17]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(17)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[18]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(18)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[19]
     *  reserved
     */
    (rN1_LOCAL_FIR, bit(19)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[20]
     *  Trace00 - scom parity err
     */
    (rN1_LOCAL_FIR, bit(20)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[21]
     *  Trace01 - scom parity err
     */
    (rN1_LOCAL_FIR, bit(21)) ? self_th_32perDay;

    /** N1_LOCAL_FIR[22]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(22)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[23]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(23)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[24]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(24)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[25]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(25)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[26]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(26)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[27]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(27)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[28]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(28)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[29]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(29)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[30]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(30)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[31]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(31)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[32]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(32)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[33]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(33)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[34]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(34)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[35]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(35)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[36]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(36)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[37]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(37)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[38]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(38)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[39]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(39)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[40]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(40)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[41]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(41)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[42]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(42)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[43]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(43)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[44]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(44)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[45]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(45)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[46]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(46)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[47]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(47)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[48]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(48)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[49]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(49)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[50]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(50)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[51]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(51)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[52]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(52)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[53]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(53)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[54]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(54)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[55]
     *  unused
     */
    (rN1_LOCAL_FIR, bit(55)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[56]
     *  Firmware signaled power bus quiesce failed
     */
    (rN1_LOCAL_FIR, bit(56)) ? self_th_1;

    /** N1_LOCAL_FIR[57]
     *  Firmware signaled power bus system quiesce failed
     */
    (rN1_LOCAL_FIR, bit(57)) ? self_th_1;

    /** N1_LOCAL_FIR[58]
     *  Firmware signaled deadman timer tigger occurred
     */
    (rN1_LOCAL_FIR, bit(58)) ? deadmanTimer;

    /** N1_LOCAL_FIR[59]
     *  Fimware signaled power bus chip quiesce failed
     */
    (rN1_LOCAL_FIR, bit(59)) ? self_th_1;

    /** N1_LOCAL_FIR[60]
     *  Hypervisor / Hostboot / OPAL initiated Terminate I
     */
    (rN1_LOCAL_FIR, bit(60)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[61]
     *  reserved for software use
     */
    (rN1_LOCAL_FIR, bit(61)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[62]
     *  reserved for software use
     */
    (rN1_LOCAL_FIR, bit(62)) ? defaultMaskedError;

    /** N1_LOCAL_FIR[63]
     *  ext_local_xstop
     */
    (rN1_LOCAL_FIR, bit(63)) ? defaultMaskedError;

};

################################################################################
# P10 chip MCD_FIR
################################################################################

rule rMCD_FIR
{
  CHECK_STOP:
    MCD_FIR & ~MCD_FIR_MASK & ~MCD_FIR_ACT0 & ~MCD_FIR_ACT1;
  RECOVERABLE:
    MCD_FIR & ~MCD_FIR_MASK & ~MCD_FIR_ACT0 &  MCD_FIR_ACT1;
};

group gMCD_FIR
    filter singlebit,
           cs_root_cause
{
    /** MCD_FIR[0]
     *  MCD array ECC uncorrectable error
     */
    (rMCD_FIR, bit(0)) ? self_th_32perDay;

    /** MCD_FIR[1]
     *  MCD array ECC uncorrectable error
     */
    (rMCD_FIR, bit(1)) ? defaultMaskedError;

    /** MCD_FIR[2]
     *  MCD PowerBus address Parity error
     */
    (rMCD_FIR, bit(2)) ? self_th_1;

    /** MCD_FIR[3]
     *  MCD invalid state error
     */
    (rMCD_FIR, bit(3)) ? self_th_1;

    /** MCD_FIR[4]
     *  Hang poll timer expired on cl_probe
     */
    (rMCD_FIR, bit(4)) ? defaultMaskedError;

    /** MCD_FIR[5]
     *  PowerBus address error cresp received
     */
    (rMCD_FIR, bit(5)) ? defaultMaskedError;

    /** MCD_FIR[6]
     *  MCD recieved a unsoliceted CRESP
     */
    (rMCD_FIR, bit(6)) ? self_th_1;

    /** MCD_FIR[7]
     *  MCD powerbus ttag parity error
     */
    (rMCD_FIR, bit(7)) ? self_th_1;

    /** MCD_FIR[8]
     *  MCD scom register update error
     */
    (rMCD_FIR, bit(8)) ? self_th_1;

    /** MCD_FIR[9]
     *  MCD recieved a ack_dead_cresp
     */
    (rMCD_FIR, bit(9)) ? defaultMaskedError;

    /** MCD_FIR[10]
     *  MCD configuration register had a parity error
     */
    (rMCD_FIR, bit(10)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 0
################################################################################

rule rPB_STATION_FIR_EQ_0
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_0 & ~PB_STATION_FIR_EQ_0_MASK & ~PB_STATION_FIR_EQ_0_ACT0 & ~PB_STATION_FIR_EQ_0_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_0 & ~PB_STATION_FIR_EQ_0_MASK & ~PB_STATION_FIR_EQ_0_ACT0 &  PB_STATION_FIR_EQ_0_ACT1;
};

group gPB_STATION_FIR_EQ_0
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_0[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_0, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_0, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_0, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_0, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_0[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_0, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_0, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_0[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_0, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_0, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_0[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_0, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_0[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_0, bit(9)) ? hang_recovery_gte_eq0;

    /** PB_STATION_FIR_EQ_0[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_0, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_0[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_0, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_0, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_0, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_0, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_0[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_0, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_0[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_0, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_0[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_0, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_0[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_0, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_0[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_0, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_0[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_0, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_0[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_0, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 1
################################################################################

rule rPB_STATION_FIR_EQ_1
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_1 & ~PB_STATION_FIR_EQ_1_MASK & ~PB_STATION_FIR_EQ_1_ACT0 & ~PB_STATION_FIR_EQ_1_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_1 & ~PB_STATION_FIR_EQ_1_MASK & ~PB_STATION_FIR_EQ_1_ACT0 &  PB_STATION_FIR_EQ_1_ACT1;
};

group gPB_STATION_FIR_EQ_1
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_1[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_1, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_1, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_1, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_1, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_1[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_1, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_1, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_1[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_1, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_1, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_1[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_1, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_1[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_1, bit(9)) ? hang_recovery_gte_eq1;

    /** PB_STATION_FIR_EQ_1[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_1, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_1[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_1, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_1, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_1, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_1, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_1[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_1, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_1[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_1, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_1[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_1, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_1[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_1, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_1[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_1, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_1[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_1, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_1[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_1, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 2
################################################################################

rule rPB_STATION_FIR_EQ_2
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_2 & ~PB_STATION_FIR_EQ_2_MASK & ~PB_STATION_FIR_EQ_2_ACT0 & ~PB_STATION_FIR_EQ_2_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_2 & ~PB_STATION_FIR_EQ_2_MASK & ~PB_STATION_FIR_EQ_2_ACT0 &  PB_STATION_FIR_EQ_2_ACT1;
};

group gPB_STATION_FIR_EQ_2
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_2[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_2, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_2, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_2, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_2, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_2[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_2, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_2, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_2[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_2, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_2, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_2[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_2, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_2[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_2, bit(9)) ? hang_recovery_gte_eq2;

    /** PB_STATION_FIR_EQ_2[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_2, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_2[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_2, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_2, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_2, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_2, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_2[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_2, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_2[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_2, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_2[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_2, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_2[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_2, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_2[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_2, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_2[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_2, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_2[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_2, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 3
################################################################################

rule rPB_STATION_FIR_EQ_3
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_3 & ~PB_STATION_FIR_EQ_3_MASK & ~PB_STATION_FIR_EQ_3_ACT0 & ~PB_STATION_FIR_EQ_3_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_3 & ~PB_STATION_FIR_EQ_3_MASK & ~PB_STATION_FIR_EQ_3_ACT0 &  PB_STATION_FIR_EQ_3_ACT1;
};

group gPB_STATION_FIR_EQ_3
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_3[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_3, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_3, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_3, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_3, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_3[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_3, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_3, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_3[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_3, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_3, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_3[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_3, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_3[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_3, bit(9)) ? hang_recovery_gte_eq3;

    /** PB_STATION_FIR_EQ_3[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_3, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_3[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_3, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_3, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_3, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_3, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_3[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_3, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_3[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_3, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_3[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_3, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_3[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_3, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_3[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_3, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_3[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_3, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_3[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_3, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 4
################################################################################

rule rPB_STATION_FIR_EQ_4
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_4 & ~PB_STATION_FIR_EQ_4_MASK & ~PB_STATION_FIR_EQ_4_ACT0 & ~PB_STATION_FIR_EQ_4_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_4 & ~PB_STATION_FIR_EQ_4_MASK & ~PB_STATION_FIR_EQ_4_ACT0 &  PB_STATION_FIR_EQ_4_ACT1;
};

group gPB_STATION_FIR_EQ_4
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_4[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_4, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_4, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_4, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_4, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_4[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_4, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_4, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_4[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_4, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_4, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_4[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_4, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_4[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_4, bit(9)) ? hang_recovery_gte_eq4;

    /** PB_STATION_FIR_EQ_4[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_4, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_4[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_4, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_4, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_4, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_4, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_4[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_4, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_4[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_4, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_4[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_4, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_4[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_4, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_4[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_4, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_4[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_4, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_4[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_4, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 5
################################################################################

rule rPB_STATION_FIR_EQ_5
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_5 & ~PB_STATION_FIR_EQ_5_MASK & ~PB_STATION_FIR_EQ_5_ACT0 & ~PB_STATION_FIR_EQ_5_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_5 & ~PB_STATION_FIR_EQ_5_MASK & ~PB_STATION_FIR_EQ_5_ACT0 &  PB_STATION_FIR_EQ_5_ACT1;
};

group gPB_STATION_FIR_EQ_5
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_5[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_5, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_5, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_5, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_5, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_5[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_5, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_5, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_5[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_5, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_5, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_5[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_5, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_5[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_5, bit(9)) ? hang_recovery_gte_eq5;

    /** PB_STATION_FIR_EQ_5[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_5, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_5[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_5, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_5, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_5, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_5, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_5[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_5, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_5[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_5, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_5[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_5, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_5[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_5, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_5[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_5, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_5[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_5, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_5[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_5, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 6
################################################################################

rule rPB_STATION_FIR_EQ_6
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_6 & ~PB_STATION_FIR_EQ_6_MASK & ~PB_STATION_FIR_EQ_6_ACT0 & ~PB_STATION_FIR_EQ_6_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_6 & ~PB_STATION_FIR_EQ_6_MASK & ~PB_STATION_FIR_EQ_6_ACT0 &  PB_STATION_FIR_EQ_6_ACT1;
};

group gPB_STATION_FIR_EQ_6
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_6[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_6, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_6, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_6, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_6, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_6[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_6, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_6, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_6[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_6, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_6, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_6[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_6, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_6[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_6, bit(9)) ? hang_recovery_gte_eq6;

    /** PB_STATION_FIR_EQ_6[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_6, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_6[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_6, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_6, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_6, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_6, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_6[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_6, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_6[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_6, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_6[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_6, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_6[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_6, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_6[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_6, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_6[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_6, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_6[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_6, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EQ 7
################################################################################

rule rPB_STATION_FIR_EQ_7
{
  CHECK_STOP:
    PB_STATION_FIR_EQ_7 & ~PB_STATION_FIR_EQ_7_MASK & ~PB_STATION_FIR_EQ_7_ACT0 & ~PB_STATION_FIR_EQ_7_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EQ_7 & ~PB_STATION_FIR_EQ_7_MASK & ~PB_STATION_FIR_EQ_7_ACT0 &  PB_STATION_FIR_EQ_7_ACT1;
};

group gPB_STATION_FIR_EQ_7
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EQ_7[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EQ_7, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EQ_7, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EQ_7, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[3]
     *  spare
     */
    (rPB_STATION_FIR_EQ_7, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_7[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EQ_7, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EQ_7, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EQ_7[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EQ_7, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EQ_7, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_7[8]
     *  spare
     */
    (rPB_STATION_FIR_EQ_7, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_7[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EQ_7, bit(9)) ? hang_recovery_gte_eq7;

    /** PB_STATION_FIR_EQ_7[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EQ_7, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EQ_7[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EQ_7, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EQ_7, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EQ_7, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[14]
     *  data route error
     */
    (rPB_STATION_FIR_EQ_7, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EQ_7[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EQ_7, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EQ_7[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EQ_7, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EQ_7[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EQ_7, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EQ_7[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EQ_7, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EQ_7[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EQ_7, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EQ_7[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EQ_7, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EQ_7[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EQ_7, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EN1
################################################################################

rule rPB_STATION_FIR_EN1
{
  CHECK_STOP:
    PB_STATION_FIR_EN1 & ~PB_STATION_FIR_EN1_MASK & ~PB_STATION_FIR_EN1_ACT0 & ~PB_STATION_FIR_EN1_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EN1 & ~PB_STATION_FIR_EN1_MASK & ~PB_STATION_FIR_EN1_ACT0 &  PB_STATION_FIR_EN1_ACT1;
};

group gPB_STATION_FIR_EN1
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EN1[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EN1, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EN1, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EN1, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[3]
     *  spare
     */
    (rPB_STATION_FIR_EN1, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN1[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EN1, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EN1, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EN1[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EN1, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EN1, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN1[8]
     *  spare
     */
    (rPB_STATION_FIR_EN1, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN1[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EN1, bit(9)) ? hang_recovery_gte_en1;

    /** PB_STATION_FIR_EN1[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EN1, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EN1[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EN1, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EN1, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EN1, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[14]
     *  data route error
     */
    (rPB_STATION_FIR_EN1, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN1[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EN1, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN1[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EN1, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EN1[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EN1, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EN1[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EN1, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EN1[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EN1, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EN1[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EN1, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EN1[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EN1, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EN2
################################################################################

rule rPB_STATION_FIR_EN2
{
  CHECK_STOP:
    PB_STATION_FIR_EN2 & ~PB_STATION_FIR_EN2_MASK & ~PB_STATION_FIR_EN2_ACT0 & ~PB_STATION_FIR_EN2_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EN2 & ~PB_STATION_FIR_EN2_MASK & ~PB_STATION_FIR_EN2_ACT0 &  PB_STATION_FIR_EN2_ACT1;
};

group gPB_STATION_FIR_EN2
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EN2[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EN2, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EN2, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EN2, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[3]
     *  spare
     */
    (rPB_STATION_FIR_EN2, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN2[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EN2, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EN2, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EN2[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EN2, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EN2, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN2[8]
     *  spare
     */
    (rPB_STATION_FIR_EN2, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN2[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EN2, bit(9)) ? hang_recovery_gte_en2;

    /** PB_STATION_FIR_EN2[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EN2, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EN2[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EN2, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EN2, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EN2, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[14]
     *  data route error
     */
    (rPB_STATION_FIR_EN2, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN2[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EN2, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN2[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EN2, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EN2[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EN2, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EN2[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EN2, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EN2[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EN2, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EN2[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EN2, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EN2[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EN2, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EN3
################################################################################

rule rPB_STATION_FIR_EN3
{
  CHECK_STOP:
    PB_STATION_FIR_EN3 & ~PB_STATION_FIR_EN3_MASK & ~PB_STATION_FIR_EN3_ACT0 & ~PB_STATION_FIR_EN3_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EN3 & ~PB_STATION_FIR_EN3_MASK & ~PB_STATION_FIR_EN3_ACT0 &  PB_STATION_FIR_EN3_ACT1;
};

group gPB_STATION_FIR_EN3
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EN3[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EN3, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EN3, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EN3, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[3]
     *  spare
     */
    (rPB_STATION_FIR_EN3, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN3[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EN3, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EN3, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EN3[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EN3, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EN3, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN3[8]
     *  spare
     */
    (rPB_STATION_FIR_EN3, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN3[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EN3, bit(9)) ? hang_recovery_gte_en3;

    /** PB_STATION_FIR_EN3[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EN3, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EN3[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EN3, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EN3, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EN3, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[14]
     *  data route error
     */
    (rPB_STATION_FIR_EN3, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN3[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EN3, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN3[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EN3, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EN3[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EN3, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EN3[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EN3, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EN3[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EN3, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EN3[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EN3, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EN3[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EN3, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_EN4
################################################################################

rule rPB_STATION_FIR_EN4
{
  CHECK_STOP:
    PB_STATION_FIR_EN4 & ~PB_STATION_FIR_EN4_MASK & ~PB_STATION_FIR_EN4_ACT0 & ~PB_STATION_FIR_EN4_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_EN4 & ~PB_STATION_FIR_EN4_MASK & ~PB_STATION_FIR_EN4_ACT0 &  PB_STATION_FIR_EN4_ACT1;
};

group gPB_STATION_FIR_EN4
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_EN4[0]
     *  protocol error
     */
    (rPB_STATION_FIR_EN4, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[1]
     *  overflow error
     */
    (rPB_STATION_FIR_EN4, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_EN4, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[3]
     *  spare
     */
    (rPB_STATION_FIR_EN4, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN4[4]
     *  coherency error
     */
    (rPB_STATION_FIR_EN4, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_EN4, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_EN4[6]
     *  cresp error
     */
    (rPB_STATION_FIR_EN4, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_EN4, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN4[8]
     *  spare
     */
    (rPB_STATION_FIR_EN4, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN4[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_EN4, bit(9)) ? hang_recovery_gte_en4;

    /** PB_STATION_FIR_EN4[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_EN4, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_EN4[11]
     *  snooper error
     */
    (rPB_STATION_FIR_EN4, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_EN4, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_EN4, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[14]
     *  data route error
     */
    (rPB_STATION_FIR_EN4, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_EN4[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_EN4, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_EN4[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_EN4, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_EN4[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_EN4, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_EN4[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_EN4, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_EN4[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_EN4, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_EN4[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_EN4, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_EN4[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_EN4, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_ES1
################################################################################

rule rPB_STATION_FIR_ES1
{
  CHECK_STOP:
    PB_STATION_FIR_ES1 & ~PB_STATION_FIR_ES1_MASK & ~PB_STATION_FIR_ES1_ACT0 & ~PB_STATION_FIR_ES1_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_ES1 & ~PB_STATION_FIR_ES1_MASK & ~PB_STATION_FIR_ES1_ACT0 &  PB_STATION_FIR_ES1_ACT1;
};

group gPB_STATION_FIR_ES1
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_ES1[0]
     *  protocol error
     */
    (rPB_STATION_FIR_ES1, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[1]
     *  overflow error
     */
    (rPB_STATION_FIR_ES1, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_ES1, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[3]
     *  spare
     */
    (rPB_STATION_FIR_ES1, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES1[4]
     *  coherency error
     */
    (rPB_STATION_FIR_ES1, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_ES1, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_ES1[6]
     *  cresp error
     */
    (rPB_STATION_FIR_ES1, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_ES1, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES1[8]
     *  spare
     */
    (rPB_STATION_FIR_ES1, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES1[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_ES1, bit(9)) ? hang_recovery_gte_es1;

    /** PB_STATION_FIR_ES1[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_ES1, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_ES1[11]
     *  snooper error
     */
    (rPB_STATION_FIR_ES1, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_ES1, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_ES1, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[14]
     *  data route error
     */
    (rPB_STATION_FIR_ES1, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES1[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_ES1, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES1[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_ES1, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_ES1[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_ES1, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_ES1[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_ES1, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_ES1[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_ES1, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_ES1[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_ES1, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_ES1[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_ES1, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_ES2
################################################################################

rule rPB_STATION_FIR_ES2
{
  CHECK_STOP:
    PB_STATION_FIR_ES2 & ~PB_STATION_FIR_ES2_MASK & ~PB_STATION_FIR_ES2_ACT0 & ~PB_STATION_FIR_ES2_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_ES2 & ~PB_STATION_FIR_ES2_MASK & ~PB_STATION_FIR_ES2_ACT0 &  PB_STATION_FIR_ES2_ACT1;
};

group gPB_STATION_FIR_ES2
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_ES2[0]
     *  protocol error
     */
    (rPB_STATION_FIR_ES2, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[1]
     *  overflow error
     */
    (rPB_STATION_FIR_ES2, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_ES2, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[3]
     *  spare
     */
    (rPB_STATION_FIR_ES2, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES2[4]
     *  coherency error
     */
    (rPB_STATION_FIR_ES2, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_ES2, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_ES2[6]
     *  cresp error
     */
    (rPB_STATION_FIR_ES2, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_ES2, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES2[8]
     *  spare
     */
    (rPB_STATION_FIR_ES2, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES2[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_ES2, bit(9)) ? hang_recovery_gte_es2;

    /** PB_STATION_FIR_ES2[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_ES2, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_ES2[11]
     *  snooper error
     */
    (rPB_STATION_FIR_ES2, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_ES2, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_ES2, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[14]
     *  data route error
     */
    (rPB_STATION_FIR_ES2, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES2[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_ES2, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES2[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_ES2, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_ES2[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_ES2, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_ES2[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_ES2, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_ES2[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_ES2, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_ES2[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_ES2, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_ES2[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_ES2, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_ES3
################################################################################

rule rPB_STATION_FIR_ES3
{
  CHECK_STOP:
    PB_STATION_FIR_ES3 & ~PB_STATION_FIR_ES3_MASK & ~PB_STATION_FIR_ES3_ACT0 & ~PB_STATION_FIR_ES3_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_ES3 & ~PB_STATION_FIR_ES3_MASK & ~PB_STATION_FIR_ES3_ACT0 &  PB_STATION_FIR_ES3_ACT1;
};

group gPB_STATION_FIR_ES3
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_ES3[0]
     *  protocol error
     */
    (rPB_STATION_FIR_ES3, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[1]
     *  overflow error
     */
    (rPB_STATION_FIR_ES3, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_ES3, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[3]
     *  inactive_link_error
     */
    (rPB_STATION_FIR_ES3, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES3[4]
     *  coherency error
     */
    (rPB_STATION_FIR_ES3, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_ES3, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_ES3[6]
     *  cresp error
     */
    (rPB_STATION_FIR_ES3, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_ES3, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES3[8]
     *  active_link_error
     */
    (rPB_STATION_FIR_ES3, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES3[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_ES3, bit(9)) ? hang_recovery_gte_es3;

    /** PB_STATION_FIR_ES3[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_ES3, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_ES3[11]
     *  snooper error
     */
    (rPB_STATION_FIR_ES3, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_ES3, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_ES3, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[14]
     *  data route error
     */
    (rPB_STATION_FIR_ES3, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES3[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_ES3, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES3[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_ES3, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_ES3[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_ES3, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_ES3[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_ES3, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_ES3[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_ES3, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_ES3[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_ES3, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_ES3[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_ES3, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PB_STATION_FIR_ES4
################################################################################

rule rPB_STATION_FIR_ES4
{
  CHECK_STOP:
    PB_STATION_FIR_ES4 & ~PB_STATION_FIR_ES4_MASK & ~PB_STATION_FIR_ES4_ACT0 & ~PB_STATION_FIR_ES4_ACT1;
  RECOVERABLE:
    PB_STATION_FIR_ES4 & ~PB_STATION_FIR_ES4_MASK & ~PB_STATION_FIR_ES4_ACT0 &  PB_STATION_FIR_ES4_ACT1;
};

group gPB_STATION_FIR_ES4
    filter singlebit,
           cs_root_cause(5)
{
    /** PB_STATION_FIR_ES4[0]
     *  protocol error
     */
    (rPB_STATION_FIR_ES4, bit(0)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[1]
     *  overflow error
     */
    (rPB_STATION_FIR_ES4, bit(1)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[2]
     *  hw parity error
     */
    (rPB_STATION_FIR_ES4, bit(2)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[3]
     *  spare
     */
    (rPB_STATION_FIR_ES4, bit(3)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES4[4]
     *  coherency error
     */
    (rPB_STATION_FIR_ES4, bit(4)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[5]
     *  cresp addr error
     */
    (rPB_STATION_FIR_ES4, bit(5)) ? self_M_level2_L_th_1;

    /** PB_STATION_FIR_ES4[6]
     *  cresp error
     */
    (rPB_STATION_FIR_ES4, bit(6)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[7]
     *  hang recovery limit error
     */
    (rPB_STATION_FIR_ES4, bit(7)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES4[8]
     *  spare
     */
    (rPB_STATION_FIR_ES4, bit(8)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES4[9]
     *  hang recovery gte level1
     */
    (rPB_STATION_FIR_ES4, bit(9)) ? hang_recovery_gte_es4;

    /** PB_STATION_FIR_ES4[10]
     *  force MP- IPL
     */
    (rPB_STATION_FIR_ES4, bit(10)) ? level2_dump_SW;

    /** PB_STATION_FIR_ES4[11]
     *  snooper error
     */
    (rPB_STATION_FIR_ES4, bit(11)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[12]
     *  data overflow error
     */
    (rPB_STATION_FIR_ES4, bit(12)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[13]
     *  data protocol error
     */
    (rPB_STATION_FIR_ES4, bit(13)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[14]
     *  data route error
     */
    (rPB_STATION_FIR_ES4, bit(14)) ? level2_M_self_L_th_1;

    /** PB_STATION_FIR_ES4[15]
     *  fir compab trigger
     */
    (rPB_STATION_FIR_ES4, bit(15)) ? defaultMaskedError;

    /** PB_STATION_FIR_ES4[16]
     *  link0 protocol error
     */
    (rPB_STATION_FIR_ES4, bit(16)) ? self_th_1;

    /** PB_STATION_FIR_ES4[17]
     *  link0 overflow error
     */
    (rPB_STATION_FIR_ES4, bit(17)) ? self_th_1;

    /** PB_STATION_FIR_ES4[18]
     *  link0 hw parity error
     */
    (rPB_STATION_FIR_ES4, bit(18)) ? self_th_1;

    /** PB_STATION_FIR_ES4[19]
     *  link1 protocol error
     */
    (rPB_STATION_FIR_ES4, bit(19)) ? self_th_1;

    /** PB_STATION_FIR_ES4[20]
     *  link1 overflow error
     */
    (rPB_STATION_FIR_ES4, bit(20)) ? self_th_1;

    /** PB_STATION_FIR_ES4[21]
     *  link1 hw parity error
     */
    (rPB_STATION_FIR_ES4, bit(21)) ? self_th_1;

};

################################################################################
# P10 chip PSIHB_FIR
################################################################################

rule rPSIHB_FIR
{
  CHECK_STOP:
    PSIHB_FIR & ~PSIHB_FIR_MASK & ~PSIHB_FIR_ACT0 & ~PSIHB_FIR_ACT1;
  RECOVERABLE:
    PSIHB_FIR & ~PSIHB_FIR_MASK & ~PSIHB_FIR_ACT0 &  PSIHB_FIR_ACT1;
};

group gPSIHB_FIR
    filter singlebit,
           cs_root_cause
{
    /** PSIHB_FIR[0]
     *  CE from PowerBus data
     */
    (rPSIHB_FIR, bit(0)) ? self_th_32perDay;

    /** PSIHB_FIR[1]
     *  UE from PowerBus data
     */
    (rPSIHB_FIR, bit(1)) ? self_th_1;

    /** PSIHB_FIR[2]
     *  SUE from PowerBus data
     */
    (rPSIHB_FIR, bit(2)) ? defaultMaskedError;

    /** PSIHB_FIR[3]
     *  Interrupt Condition present in PSIHB
     */
    (rPSIHB_FIR, bit(3)) ? defaultMaskedError;

    /** PSIHB_FIR[4]
     *  Interrupt from FSP is being processed
     */
    (rPSIHB_FIR, bit(4)) ? defaultMaskedError;

    /** PSIHB_FIR[5]
     *  CE from PSILL data
     */
    (rPSIHB_FIR, bit(5)) ? defaultMaskedError;

    /** PSIHB_FIR[6]
     *  UE from PSILL data
     */
    (rPSIHB_FIR, bit(6)) ? defaultMaskedError;

    /** PSIHB_FIR[7]
     *  Error bit set
     */
    (rPSIHB_FIR, bit(7)) ? defaultMaskedError;

    /** PSIHB_FIR[8]
     *  Invalid TType Hit on PHB or FSP bar
     */
    (rPSIHB_FIR, bit(8)) ? level2_M_self_L_th_1;

    /** PSIHB_FIR[9]
     *  Invalid CResp returned to command issued by PSIHB
     */
    (rPSIHB_FIR, bit(9)) ? level2_M_self_L_th_1;

    /** PSIHB_FIR[10]
     *  PowerBus time out waiting for data grant
     */
    (rPSIHB_FIR, bit(10)) ? level2_th_1;

    /** PSIHB_FIR[11]
     *  PB parity error in a tag/addr bus
     */
    (rPSIHB_FIR, bit(11)) ? level2_M_self_L_th_1;

    /** PSIHB_FIR[12]
     *  FSP tried access to trusted space
     */
    (rPSIHB_FIR, bit(12)) ? level2_th_1;

    /** PSIHB_FIR[13]
     *  Unexpected PB CRESP or DATA
     */
    (rPSIHB_FIR, bit(13)) ? level2_M_self_L_th_1;

    /** PSIHB_FIR[14]
     *  Interrupt register change while interrupt still pe
     */
    (rPSIHB_FIR, bit(14)) ? defaultMaskedError; # P10_10

    /** PSIHB_FIR[15]
     *  PSI Interrupt address Error
     */
    (rPSIHB_FIR, bit(15)) ? self_M_level2_L_th_1; # P10_10

    /** PSIHB_FIR[16]
     *  OCC Interrupt address Error
     */
    (rPSIHB_FIR, bit(16)) ? self_M_level2_L_th_1; # P10_10

    /** PSIHB_FIR[17]
     *  FSI Interrupt address Error
     */
    (rPSIHB_FIR, bit(17)) ? self_M_level2_L_th_1; # P10_10

    /** PSIHB_FIR[18]
     *  LPC Interrupt address Error
     */
    (rPSIHB_FIR, bit(18)) ? self_M_level2_L_th_1; # P10_10

    /** PSIHB_FIR[19]
     *  LOCAL ERROR Interrupt address Error
     */
    (rPSIHB_FIR, bit(19)) ? self_M_level2_L_th_1; # P10_10

    /** PSIHB_FIR[20]
     *  HOST ERROR Interrupt address Error
     */
    (rPSIHB_FIR, bit(20)) ? self_M_level2_L_th_1; # P10_10

    /** PSIHB_FIR[21]
     *  PSI global error bit 0
     */
    (rPSIHB_FIR, bit(21)) ? defaultMaskedError;

    /** PSIHB_FIR[22]
     *  PSI global error bit 1
     */
    (rPSIHB_FIR, bit(22)) ? defaultMaskedError;

    /** PSIHB_FIR[23]
     *  Upstream error
     */
    (rPSIHB_FIR, bit(23)) ? level2_M_self_L_th_32perDay;

    /** PSIHB_FIR[24]
     *  Spare fir
     */
    (rPSIHB_FIR, bit(24)) ? defaultMaskedError;

    /** PSIHB_FIR[25]
     *  Spare fir
     */
    (rPSIHB_FIR, bit(25)) ? defaultMaskedError;

    /** PSIHB_FIR[26]
     *  Spare fir
     */
    (rPSIHB_FIR, bit(26)) ? defaultMaskedError;

    /** PSIHB_FIR[27]
     *  fir parity Error
     */
    (rPSIHB_FIR, bit(27)) ? defaultMaskedError;

};

################################################################################
# P10 chip HCA_FIR
################################################################################

rule rHCA_FIR
{
  CHECK_STOP:
    HCA_FIR & ~HCA_FIR_MASK & ~HCA_FIR_ACT0 & ~HCA_FIR_ACT1;
  RECOVERABLE:
    HCA_FIR & ~HCA_FIR_MASK & ~HCA_FIR_ACT0 &  HCA_FIR_ACT1;
};

group gHCA_FIR
    filter singlebit,
           cs_root_cause
{
    /** HCA_FIR[0]
     *  Powerbus rcmd address parity error
     */
    (rHCA_FIR, bit(0)) ? defaultMaskedError;

    /** HCA_FIR[1]
     *  Powerbus rcmd ttag parity error
     */
    (rHCA_FIR, bit(1)) ? defaultMaskedError;

    /** HCA_FIR[2]
     *  Powerbus cresp ttag parity error
     */
    (rHCA_FIR, bit(2)) ? defaultMaskedError;

    /** HCA_FIR[3]
     *  Powerbus cresp atag parity error
     */
    (rHCA_FIR, bit(3)) ? defaultMaskedError;

    /** HCA_FIR[4]
     *  HCA updt received addr_err cresp
     */
    (rHCA_FIR, bit(4)) ? defaultMaskedError;

    /** HCA_FIR[5]
     *  HCA updt received invalid cresp
     */
    (rHCA_FIR, bit(5)) ? defaultMaskedError;

    /** HCA_FIR[6]
     *  HCA updt received unexpected cresp
     */
    (rHCA_FIR, bit(6)) ? defaultMaskedError;

    /** HCA_FIR[7]
     *  HCA detected powerbus hang
     */
    (rHCA_FIR, bit(7)) ? defaultMaskedError;

    /** HCA_FIR[8]
     *  HCA rcmd hits both BARs
     */
    (rHCA_FIR, bit(8)) ? defaultMaskedError;

    /** HCA_FIR[9]
     *  HCA cache array correctable error
     */
    (rHCA_FIR, bit(9)) ? defaultMaskedError;

    /** HCA_FIR[10]
     *  HCA cache array uncorrectable error
     */
    (rHCA_FIR, bit(10)) ? defaultMaskedError;

    /** HCA_FIR[11]
     *  HCA rcmd drop counter overflow
     */
    (rHCA_FIR, bit(11)) ? defaultMaskedError;

    /** HCA_FIR[12]
     *  HCA updt command drop counter overflow
     */
    (rHCA_FIR, bit(12)) ? defaultMaskedError;

    /** HCA_FIR[13]
     *  HCA updt lost decay request. No pbi machine availa
     */
    (rHCA_FIR, bit(13)) ? defaultMaskedError;

    /** HCA_FIR[14]
     *  ADU or PSI SMF error
     */
    (rHCA_FIR, bit(14)) ? defaultMaskedError;

    /** HCA_FIR[15]
     *  Spare FIR bit
     */
    (rHCA_FIR, bit(15)) ? defaultMaskedError;

    /** HCA_FIR[16]
     *  ADU recoverable error 0
     */
    (rHCA_FIR, bit(16)) ? defaultMaskedError;

    /** HCA_FIR[17]
     *  ADU recoverable error 1
     */
    (rHCA_FIR, bit(17)) ? defaultMaskedError;

    /** HCA_FIR[18]
     *  ADU recoverable error 2
     */
    (rHCA_FIR, bit(18)) ? defaultMaskedError;

    /** HCA_FIR[19]
     *  ADU recoverable error 3
     */
    (rHCA_FIR, bit(19)) ? defaultMaskedError;

    /** HCA_FIR[20]
     *  ADU recoverable error 4
     */
    (rHCA_FIR, bit(20)) ? defaultMaskedError;

    /** HCA_FIR[21]
     *  ADU recoverable error 5
     */
    (rHCA_FIR, bit(21)) ? defaultMaskedError;

    /** HCA_FIR[22]
     *  ADU checkstop error 0
     */
    (rHCA_FIR, bit(22)) ? defaultMaskedError;

    /** HCA_FIR[23]
     *  ADU checkstop error 1
     */
    (rHCA_FIR, bit(23)) ? defaultMaskedError;

    /** HCA_FIR[24]
     *  ADU checkstop error 2
     */
    (rHCA_FIR, bit(24)) ? defaultMaskedError;

    /** HCA_FIR[25]
     *  ADU checkstop error 3
     */
    (rHCA_FIR, bit(25)) ? defaultMaskedError;

    /** HCA_FIR[26]
     *  ADU checkstop error 4
     */
    (rHCA_FIR, bit(26)) ? defaultMaskedError;

    /** HCA_FIR[27]
     *  ADU checkstop error 5
     */
    (rHCA_FIR, bit(27)) ? defaultMaskedError;

};

################################################################################
# P10 chip PBAF_FIR
################################################################################

rule rPBAF_FIR
{
  CHECK_STOP:
    PBAF_FIR & ~PBAF_FIR_MASK & ~PBAF_FIR_ACT0 & ~PBAF_FIR_ACT1;
  RECOVERABLE:
    PBAF_FIR & ~PBAF_FIR_MASK & ~PBAF_FIR_ACT0 &  PBAF_FIR_ACT1;
};

group gPBAF_FIR
    filter singlebit,
           cs_root_cause
{
    /** PBAF_FIR[0]
     *  PB CRESP Addr Error Received for Forwarded Read Re
     */
    (rPBAF_FIR, bit(0)) ? threshold_and_mask_self;

    /** PBAF_FIR[1]
     *  PB Read Data Timeout for Forwarded Request
     */
    (rPBAF_FIR, bit(1)) ? threshold_and_mask_self;

    /** PBAF_FIR[2]
     *  PB Read Data SUE Error for Forwarded Request
     */
    (rPBAF_FIR, bit(2)) ? defaultMaskedError;

    /** PBAF_FIR[3]
     *  PB Read Data UE Error for Forwarded Request
     */
    (rPBAF_FIR, bit(3)) ? threshold_and_mask_self;

    /** PBAF_FIR[4]
     *  PB Read Data CE Error for Forwarded Request
     */
    (rPBAF_FIR, bit(4)) ? threshold_and_mask_self;

    /** PBAF_FIR[5]
     *  PB Unexpected CRESP
     */
    (rPBAF_FIR, bit(5)) ? threshold_and_mask_self;

    /** PBAF_FIR[6]
     *  PB Unexpected Data
     */
    (rPBAF_FIR, bit(6)) ? threshold_and_mask_self;

    /** PBAF_FIR[7]
     *  PB Tag parity Error Detected
     */
    (rPBAF_FIR, bit(7)) ? threshold_and_mask_self;

    /** PBAF_FIR[8]
     *  PB CRESP Addr Error Received for Forwarded Write R
     */
    (rPBAF_FIR, bit(8)) ? threshold_and_mask_self;

    /** PBAF_FIR[9]
     *  PB Invalid CRESP
     */
    (rPBAF_FIR, bit(9)) ? threshold_and_mask_self;

    /** PBAF_FIR[10]
     *  PB CRESP ACK Dead response received for Forwarded
     */
    (rPBAF_FIR, bit(10)) ? threshold_and_mask_self;

    /** PBAF_FIR[11]
     *  PB OPERATIONAL Timeout detected
     */
    (rPBAF_FIR, bit(11)) ? threshold_and_mask_self;

    /** PBAF_FIR[12]
     *  BCUE PowerBus Link Dead
     */
    (rPBAF_FIR, bit(12)) ? threshold_and_mask_self;

    /** PBAF_FIR[13]
     *  PB CRESP Addr Error Received for BCUE  Write Reque
     */
    (rPBAF_FIR, bit(13)) ? threshold_and_mask_self;

    /** PBAF_FIR[14]
     *  BCDE PowerBus Link Dead
     */
    (rPBAF_FIR, bit(14)) ? threshold_and_mask_self;

    /** PBAF_FIR[15]
     *  PB CRESP Addr Error Received for BCDE  Read Reques
     */
    (rPBAF_FIR, bit(15)) ? threshold_and_mask_self;

    /** PBAF_FIR[16]
     *  PB Read Data Timeout  for BCDE Request
     */
    (rPBAF_FIR, bit(16)) ? threshold_and_mask_self;

    /** PBAF_FIR[17]
     *  PB Read Data SUE Error  for BCDE Request
     */
    (rPBAF_FIR, bit(17)) ? threshold_and_mask_self;

    /** PBAF_FIR[18]
     *  PB Read Data UE Error  for BCDE Request
     */
    (rPBAF_FIR, bit(18)) ? threshold_and_mask_self;

    /** PBAF_FIR[19]
     *  PB Read Data CE Error  for BCDE Request
     */
    (rPBAF_FIR, bit(19)) ? threshold_and_mask_self;

    /** PBAF_FIR[20]
     *  Internal Logic Error
     */
    (rPBAF_FIR, bit(20)) ? threshold_and_mask_self;

    /** PBAF_FIR[21]
     *  Byte count is less than full cache line
     */
    (rPBAF_FIR, bit(21)) ? threshold_and_mask_self;

    /** PBAF_FIR[22]
     *  PBAXRCV Low data before High Data
     */
    (rPBAF_FIR, bit(22)) ? threshold_and_mask_self;

    /** PBAF_FIR[23]
     *  PBAXRCV Low data timeout
     */
    (rPBAF_FIR, bit(23)) ? threshold_and_mask_self;

    /** PBAF_FIR[24]
     *  PBAXRCV Reservation data timeout
     */
    (rPBAF_FIR, bit(24)) ? threshold_and_mask_self;

    /** PBAF_FIR[25]
     *  Illegal PBAX Flow.  See PBAERRRPT2 for more info
     */
    (rPBAF_FIR, bit(25)) ? threshold_and_mask_self;

    /** PBAF_FIR[26]
     *  PBAXSND engine retry threshold reached sending Pha
     */
    (rPBAF_FIR, bit(26)) ? threshold_and_mask_self;

    /** PBAF_FIR[27]
     *  PBAXSND engine retry threshold reached sending Pha
     */
    (rPBAF_FIR, bit(27)) ? threshold_and_mask_self;

    /** PBAF_FIR[28]
     *  PBAXSND Reservation Timeout
     */
    (rPBAF_FIR, bit(28)) ? threshold_and_mask_self;

    /** PBAF_FIR[29]
     *  PB CRESP ACK Dead response received
     */
    (rPBAF_FIR, bit(29)) ? threshold_and_mask_self;

    /** PBAF_FIR[30]
     *  PBAXIRCV Low data before High Data
     */
    (rPBAF_FIR, bit(30)) ? threshold_and_mask_self;

    /** PBAF_FIR[31]
     *  PBAXIRCV Low data timeout.
     */
    (rPBAF_FIR, bit(31)) ? threshold_and_mask_self;

    /** PBAF_FIR[32]
     *  PBAXIRCV Reservation data timeout
     */
    (rPBAF_FIR, bit(32)) ? threshold_and_mask_self;

    /** PBAF_FIR[33]
     *  Illegal PBAX Flow.  See PBAERRRPT2 for more info.
     */
    (rPBAF_FIR, bit(33)) ? threshold_and_mask_self;

    /** PBAF_FIR[34]
     *  PBAXISND engine retry threshold reached sending Ph
     */
    (rPBAF_FIR, bit(34)) ? threshold_and_mask_self;

    /** PBAF_FIR[35]
     *  PBAXISND engine retry threshold reached sending Ph
     */
    (rPBAF_FIR, bit(35)) ? threshold_and_mask_self;

    /** PBAF_FIR[36]
     *  PBAXISND Reservation Timeout
     */
    (rPBAF_FIR, bit(36)) ? threshold_and_mask_self;

    /** PBAF_FIR[37]
     *  Spare
     */
    (rPBAF_FIR, bit(37)) ? defaultMaskedError;

    /** PBAF_FIR[38]
     *  Spare
     */
    (rPBAF_FIR, bit(38)) ? defaultMaskedError;

    /** PBAF_FIR[39]
     *  Spare
     */
    (rPBAF_FIR, bit(39)) ? defaultMaskedError;

};

################################################################################
# P10 chip LPC_FIR
################################################################################

rule rLPC_FIR
{
  CHECK_STOP:
    LPC_FIR & ~LPC_FIR_MASK & ~LPC_FIR_ACT0 & ~LPC_FIR_ACT1;
  RECOVERABLE:
    LPC_FIR & ~LPC_FIR_MASK & ~LPC_FIR_ACT0 &  LPC_FIR_ACT1;
};

group gLPC_FIR
    filter singlebit,
           cs_root_cause
{
    /** LPC_FIR[0]
     *  OPB Master LS received transfer size unequal to 1 
     */
    (rLPC_FIR, bit(0)) ? self_th_1;

    /** LPC_FIR[1]
     *  OPB Master LS received an action 0 invalid command
     */
    (rLPC_FIR, bit(1)) ? self_th_1;

    /** LPC_FIR[2]
     *  OPB Master LS received a address not aligned to re
     */
    (rLPC_FIR, bit(2)) ? self_th_1;

    /** LPC_FIR[3]
     *  OPB Master LS detected OPB ErrAck activated by the
     */
    (rLPC_FIR, bit(3)) ? defaultMaskedError;

    /** LPC_FIR[4]
     *  The OPB arbiter activated OPB Timeout signal
     */
    (rLPC_FIR, bit(4)) ? defaultMaskedError;

    /** LPC_FIR[5]
     *  OPB Master LS not able to end requested OPB access
     */
    (rLPC_FIR, bit(5)) ? self_th_32perDay;

    /** LPC_FIR[6]
     *  A parity error was detected in the OPB Master LS c
     */
    (rLPC_FIR, bit(6)) ? self_th_1;

    /** LPC_FIR[7]
     *  A parity error was detected in the OPB Master LS d
     */
    (rLPC_FIR, bit(7)) ? self_th_1;

    /** LPC_FIR[8]
     *  reserved
     */
    (rLPC_FIR, bit(8)) ? defaultMaskedError;

    /** LPC_FIR[9]
     *  reserved
     */
    (rLPC_FIR, bit(9)) ? defaultMaskedError;

};

################################################################################
# PAU0 Chiplet Checkstop FIR
################################################################################

rule rPAU0_CHIPLET_CS_FIR
{
  CHECK_STOP:
    PAU0_CHIPLET_CS_FIR & ~PAU0_CHIPLET_CS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU0_CHIPLET_CS_FIR
    filter singlebit
{
    /** PAU0_CHIPLET_CS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(4)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_CS_FIR[5]
     *  Attention from PAU_FIR_0 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(5)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_CS_FIR[6]
     *  Attention from PAU_FIR_1 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(6)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_CS_FIR[7]
     *  Attention from PAU_FIR_2 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(7)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_CS_FIR[13]
     *  Attention from PAU_PHY_FIR 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(13)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_CS_FIR[14]
     *  Attention from PAU_DL_FIR 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(14)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_CS_FIR[16]
     *  Attention from PAU_PTL_FIR 0
     */
    (rPAU0_CHIPLET_CS_FIR, bit(16)) ? analyzeConnectedPAUC0;

};

################################################################################
# PAU0 Chiplet Recoverable FIR
################################################################################

rule rPAU0_CHIPLET_RE_FIR
{
  RECOVERABLE:
    PAU0_CHIPLET_RE_FIR & ~PAU0_CHIPLET_RE_FIR_MASK & `0fffffffffffffff`;
};

group gPAU0_CHIPLET_RE_FIR
    filter singlebit
{
    /** PAU0_CHIPLET_RE_FIR[4]
     *  Attention from PAU_LOCAL_FIR 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(4)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_RE_FIR[5]
     *  Attention from PAU_FIR_0 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(5)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_RE_FIR[6]
     *  Attention from PAU_FIR_1 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(6)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_RE_FIR[7]
     *  Attention from PAU_FIR_2 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(7)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_RE_FIR[13]
     *  Attention from PAU_PHY_FIR 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(13)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_RE_FIR[14]
     *  Attention from PAU_DL_FIR 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(14)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_RE_FIR[16]
     *  Attention from PAU_PTL_FIR 0
     */
    (rPAU0_CHIPLET_RE_FIR, bit(16)) ? analyzeConnectedPAUC0;

};

################################################################################
# PAU0 Chiplet Unit Checkstop FIR
################################################################################

rule rPAU0_CHIPLET_UCS_FIR
{
  UNIT_CS:
    PAU0_CHIPLET_UCS_FIR & ~PAU0_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU0_CHIPLET_UCS_FIR
    filter singlebit
{
    /** PAU0_CHIPLET_UCS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 0
     */
    (rPAU0_CHIPLET_UCS_FIR, bit(4)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_UCS_FIR[5]
     *  Attention from PAU_FIR_0 0
     */
    (rPAU0_CHIPLET_UCS_FIR, bit(5)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_UCS_FIR[6]
     *  Attention from PAU_FIR_1 0
     */
    (rPAU0_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_UCS_FIR[7]
     *  Attention from PAU_FIR_2 0
     */
    (rPAU0_CHIPLET_UCS_FIR, bit(7)) ? analyzeConnectedPAU0;

    /** PAU0_CHIPLET_UCS_FIR[13]
     *  Attention from PAU_PHY_FIR 0
     */
    (rPAU0_CHIPLET_UCS_FIR, bit(13)) ? analyzeConnectedPAUC0;

    /** PAU0_CHIPLET_UCS_FIR[14]
     *  Attention from PAU_DL_FIR 0
     */
    (rPAU0_CHIPLET_UCS_FIR, bit(14)) ? analyzeConnectedPAUC0;

};

################################################################################
# PAU0 Chiplet Host Attention FIR
################################################################################

rule rPAU0_CHIPLET_HA_FIR
{
  HOST_ATTN:
    PAU0_CHIPLET_HA_FIR & ~PAU0_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gPAU0_CHIPLET_HA_FIR
    filter singlebit
{
    /** PAU0_CHIPLET_HA_FIR[4]
     *  Attention from PAU_LOCAL_FIR 0
     */
    (rPAU0_CHIPLET_HA_FIR, bit(4)) ? analyzeConnectedPAUC0;

};

################################################################################
# PAU1 Chiplet Checkstop FIR
################################################################################

rule rPAU1_CHIPLET_CS_FIR
{
  CHECK_STOP:
    PAU1_CHIPLET_CS_FIR & ~PAU1_CHIPLET_CS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU1_CHIPLET_CS_FIR
    filter singlebit
{
    /** PAU1_CHIPLET_CS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 1
     */
    (rPAU1_CHIPLET_CS_FIR, bit(4)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_CS_FIR[5]
     *  Attention from PAU_FIR_0 3
     */
    (rPAU1_CHIPLET_CS_FIR, bit(5)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_CS_FIR[6]
     *  Attention from PAU_FIR_1 3
     */
    (rPAU1_CHIPLET_CS_FIR, bit(6)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_CS_FIR[7]
     *  Attention from PAU_FIR_2 3
     */
    (rPAU1_CHIPLET_CS_FIR, bit(7)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_CS_FIR[13]
     *  Attention from PAU_PHY_FIR 1
     */
    (rPAU1_CHIPLET_CS_FIR, bit(13)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_CS_FIR[14]
     *  Attention from PAU_DL_FIR 1
     */
    (rPAU1_CHIPLET_CS_FIR, bit(14)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_CS_FIR[16]
     *  Attention from PAU_PTL_FIR 1
     */
    (rPAU1_CHIPLET_CS_FIR, bit(16)) ? analyzeConnectedPAUC1;

};

################################################################################
# PAU1 Chiplet Recoverable FIR
################################################################################

rule rPAU1_CHIPLET_RE_FIR
{
  RECOVERABLE:
    PAU1_CHIPLET_RE_FIR & ~PAU1_CHIPLET_RE_FIR_MASK & `0fffffffffffffff`;
};

group gPAU1_CHIPLET_RE_FIR
    filter singlebit
{
    /** PAU1_CHIPLET_RE_FIR[4]
     *  Attention from PAU_LOCAL_FIR 1
     */
    (rPAU1_CHIPLET_RE_FIR, bit(4)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_RE_FIR[5]
     *  Attention from PAU_FIR_0 3
     */
    (rPAU1_CHIPLET_RE_FIR, bit(5)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_RE_FIR[6]
     *  Attention from PAU_FIR_1 3
     */
    (rPAU1_CHIPLET_RE_FIR, bit(6)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_RE_FIR[7]
     *  Attention from PAU_FIR_2 3
     */
    (rPAU1_CHIPLET_RE_FIR, bit(7)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_RE_FIR[13]
     *  Attention from PAU_PHY_FIR 1
     */
    (rPAU1_CHIPLET_RE_FIR, bit(13)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_RE_FIR[14]
     *  Attention from PAU_DL_FIR 1
     */
    (rPAU1_CHIPLET_RE_FIR, bit(14)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_RE_FIR[16]
     *  Attention from PAU_PTL_FIR 1
     */
    (rPAU1_CHIPLET_RE_FIR, bit(16)) ? analyzeConnectedPAUC1;

};

################################################################################
# PAU1 Chiplet Unit Checkstop FIR
################################################################################

rule rPAU1_CHIPLET_UCS_FIR
{
  UNIT_CS:
    PAU1_CHIPLET_UCS_FIR & ~PAU1_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU1_CHIPLET_UCS_FIR
    filter singlebit
{
    /** PAU1_CHIPLET_UCS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 1
     */
    (rPAU1_CHIPLET_UCS_FIR, bit(4)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_UCS_FIR[5]
     *  Attention from PAU_FIR_0 3
     */
    (rPAU1_CHIPLET_UCS_FIR, bit(5)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_UCS_FIR[6]
     *  Attention from PAU_FIR_1 3
     */
    (rPAU1_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_UCS_FIR[7]
     *  Attention from PAU_FIR_2 3
     */
    (rPAU1_CHIPLET_UCS_FIR, bit(7)) ? analyzeConnectedPAU3;

    /** PAU1_CHIPLET_UCS_FIR[13]
     *  Attention from PAU_PHY_FIR 1
     */
    (rPAU1_CHIPLET_UCS_FIR, bit(13)) ? analyzeConnectedPAUC1;

    /** PAU1_CHIPLET_UCS_FIR[14]
     *  Attention from PAU_DL_FIR 1
     */
    (rPAU1_CHIPLET_UCS_FIR, bit(14)) ? analyzeConnectedPAUC1;

};

################################################################################
# PAU1 Chiplet Host Attention FIR
################################################################################

rule rPAU1_CHIPLET_HA_FIR
{
  HOST_ATTN:
    PAU1_CHIPLET_HA_FIR & ~PAU1_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gPAU1_CHIPLET_HA_FIR
    filter singlebit
{
    /** PAU1_CHIPLET_HA_FIR[4]
     *  Attention from PAU_LOCAL_FIR 1
     */
    (rPAU1_CHIPLET_HA_FIR, bit(4)) ? analyzeConnectedPAUC1;

};

################################################################################
# PAU2 Chiplet Checkstop FIR
################################################################################

rule rPAU2_CHIPLET_CS_FIR
{
  CHECK_STOP:
    PAU2_CHIPLET_CS_FIR & ~PAU2_CHIPLET_CS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU2_CHIPLET_CS_FIR
    filter singlebit
{
    /** PAU2_CHIPLET_CS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 2
     */
    (rPAU2_CHIPLET_CS_FIR, bit(4)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_CS_FIR[5]
     *  Attention from PAU_FIR_0 4
     */
    (rPAU2_CHIPLET_CS_FIR, bit(5)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_CS_FIR[6]
     *  Attention from PAU_FIR_1 4
     */
    (rPAU2_CHIPLET_CS_FIR, bit(6)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_CS_FIR[7]
     *  Attention from PAU_FIR_2 4
     */
    (rPAU2_CHIPLET_CS_FIR, bit(7)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_CS_FIR[9]
     *  Attention from PAU_FIR_0 5
     */
    (rPAU2_CHIPLET_CS_FIR, bit(9)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_CS_FIR[10]
     *  Attention from PAU_FIR_1 5
     */
    (rPAU2_CHIPLET_CS_FIR, bit(10)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_CS_FIR[11]
     *  Attention from PAU_FIR_2 5
     */
    (rPAU2_CHIPLET_CS_FIR, bit(11)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_CS_FIR[13]
     *  Attention from PAU_PHY_FIR 2
     */
    (rPAU2_CHIPLET_CS_FIR, bit(13)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_CS_FIR[14]
     *  Attention from PAU_DL_FIR 2
     */
    (rPAU2_CHIPLET_CS_FIR, bit(14)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_CS_FIR[16]
     *  Attention from PAU_PTL_FIR 2
     */
    (rPAU2_CHIPLET_CS_FIR, bit(16)) ? analyzeConnectedPAUC2;

};

################################################################################
# PAU2 Chiplet Recoverable FIR
################################################################################

rule rPAU2_CHIPLET_RE_FIR
{
  RECOVERABLE:
    PAU2_CHIPLET_RE_FIR & ~PAU2_CHIPLET_RE_FIR_MASK & `0fffffffffffffff`;
};

group gPAU2_CHIPLET_RE_FIR
    filter singlebit
{
    /** PAU2_CHIPLET_RE_FIR[4]
     *  Attention from PAU_LOCAL_FIR 2
     */
    (rPAU2_CHIPLET_RE_FIR, bit(4)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_RE_FIR[5]
     *  Attention from PAU_FIR_0 4
     */
    (rPAU2_CHIPLET_RE_FIR, bit(5)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_RE_FIR[6]
     *  Attention from PAU_FIR_1 4
     */
    (rPAU2_CHIPLET_RE_FIR, bit(6)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_RE_FIR[7]
     *  Attention from PAU_FIR_2 4
     */
    (rPAU2_CHIPLET_RE_FIR, bit(7)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_RE_FIR[9]
     *  Attention from PAU_FIR_0 5
     */
    (rPAU2_CHIPLET_RE_FIR, bit(9)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_RE_FIR[10]
     *  Attention from PAU_FIR_1 5
     */
    (rPAU2_CHIPLET_RE_FIR, bit(10)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_RE_FIR[11]
     *  Attention from PAU_FIR_2 5
     */
    (rPAU2_CHIPLET_RE_FIR, bit(11)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_RE_FIR[13]
     *  Attention from PAU_PHY_FIR 2
     */
    (rPAU2_CHIPLET_RE_FIR, bit(13)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_RE_FIR[14]
     *  Attention from PAU_DL_FIR 2
     */
    (rPAU2_CHIPLET_RE_FIR, bit(14)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_RE_FIR[16]
     *  Attention from PAU_PTL_FIR 2
     */
    (rPAU2_CHIPLET_RE_FIR, bit(16)) ? analyzeConnectedPAUC2;

};

################################################################################
# PAU2 Chiplet Unit Checkstop FIR
################################################################################

rule rPAU2_CHIPLET_UCS_FIR
{
  UNIT_CS:
    PAU2_CHIPLET_UCS_FIR & ~PAU2_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU2_CHIPLET_UCS_FIR
    filter singlebit
{
    /** PAU2_CHIPLET_UCS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 2
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(4)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_UCS_FIR[5]
     *  Attention from PAU_FIR_0 4
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(5)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_UCS_FIR[6]
     *  Attention from PAU_FIR_1 4
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_UCS_FIR[7]
     *  Attention from PAU_FIR_2 4
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(7)) ? analyzeConnectedPAU4;

    /** PAU2_CHIPLET_UCS_FIR[9]
     *  Attention from PAU_FIR_0 5
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(9)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_UCS_FIR[10]
     *  Attention from PAU_FIR_1 5
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(10)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_UCS_FIR[11]
     *  Attention from PAU_FIR_2 5
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(11)) ? analyzeConnectedPAU5;

    /** PAU2_CHIPLET_UCS_FIR[13]
     *  Attention from PAU_PHY_FIR 2
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(13)) ? analyzeConnectedPAUC2;

    /** PAU2_CHIPLET_UCS_FIR[14]
     *  Attention from PAU_DL_FIR 2
     */
    (rPAU2_CHIPLET_UCS_FIR, bit(14)) ? analyzeConnectedPAUC2;

};

################################################################################
# PAU2 Chiplet Host Attention FIR
################################################################################

rule rPAU2_CHIPLET_HA_FIR
{
  HOST_ATTN:
    PAU2_CHIPLET_HA_FIR & ~PAU2_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gPAU2_CHIPLET_HA_FIR
    filter singlebit
{
    /** PAU2_CHIPLET_HA_FIR[4]
     *  Attention from PAU_LOCAL_FIR 2
     */
    (rPAU2_CHIPLET_HA_FIR, bit(4)) ? analyzeConnectedPAUC2;

};

################################################################################
# PAU3 Chiplet Checkstop FIR
################################################################################

rule rPAU3_CHIPLET_CS_FIR
{
  CHECK_STOP:
    PAU3_CHIPLET_CS_FIR & ~PAU3_CHIPLET_CS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU3_CHIPLET_CS_FIR
    filter singlebit
{
    /** PAU3_CHIPLET_CS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 3
     */
    (rPAU3_CHIPLET_CS_FIR, bit(4)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_CS_FIR[5]
     *  Attention from PAU_FIR_0 6
     */
    (rPAU3_CHIPLET_CS_FIR, bit(5)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_CS_FIR[6]
     *  Attention from PAU_FIR_1 6
     */
    (rPAU3_CHIPLET_CS_FIR, bit(6)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_CS_FIR[7]
     *  Attention from PAU_FIR_2 6
     */
    (rPAU3_CHIPLET_CS_FIR, bit(7)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_CS_FIR[9]
     *  Attention from PAU_FIR_0 7
     */
    (rPAU3_CHIPLET_CS_FIR, bit(9)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_CS_FIR[10]
     *  Attention from PAU_FIR_1 7
     */
    (rPAU3_CHIPLET_CS_FIR, bit(10)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_CS_FIR[11]
     *  Attention from PAU_FIR_2 7
     */
    (rPAU3_CHIPLET_CS_FIR, bit(11)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_CS_FIR[13]
     *  Attention from PAU_PHY_FIR 3
     */
    (rPAU3_CHIPLET_CS_FIR, bit(13)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_CS_FIR[14]
     *  Attention from PAU_DL_FIR 3
     */
    (rPAU3_CHIPLET_CS_FIR, bit(14)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_CS_FIR[16]
     *  Attention from PAU_PTL_FIR 3
     */
    (rPAU3_CHIPLET_CS_FIR, bit(16)) ? analyzeConnectedPAUC3;

};

################################################################################
# PAU3 Chiplet Recoverable FIR
################################################################################

rule rPAU3_CHIPLET_RE_FIR
{
  RECOVERABLE:
    PAU3_CHIPLET_RE_FIR & ~PAU3_CHIPLET_RE_FIR_MASK & `0fffffffffffffff`;
};

group gPAU3_CHIPLET_RE_FIR
    filter singlebit
{
    /** PAU3_CHIPLET_RE_FIR[4]
     *  Attention from PAU_LOCAL_FIR 3
     */
    (rPAU3_CHIPLET_RE_FIR, bit(4)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_RE_FIR[5]
     *  Attention from PAU_FIR_0 6
     */
    (rPAU3_CHIPLET_RE_FIR, bit(5)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_RE_FIR[6]
     *  Attention from PAU_FIR_1 6
     */
    (rPAU3_CHIPLET_RE_FIR, bit(6)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_RE_FIR[7]
     *  Attention from PAU_FIR_2 6
     */
    (rPAU3_CHIPLET_RE_FIR, bit(7)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_RE_FIR[9]
     *  Attention from PAU_FIR_0 7
     */
    (rPAU3_CHIPLET_RE_FIR, bit(9)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_RE_FIR[10]
     *  Attention from PAU_FIR_1 7
     */
    (rPAU3_CHIPLET_RE_FIR, bit(10)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_RE_FIR[11]
     *  Attention from PAU_FIR_2 7
     */
    (rPAU3_CHIPLET_RE_FIR, bit(11)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_RE_FIR[13]
     *  Attention from PAU_PHY_FIR 3
     */
    (rPAU3_CHIPLET_RE_FIR, bit(13)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_RE_FIR[14]
     *  Attention from PAU_DL_FIR 3
     */
    (rPAU3_CHIPLET_RE_FIR, bit(14)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_RE_FIR[16]
     *  Attention from PAU_PTL_FIR 3
     */
    (rPAU3_CHIPLET_RE_FIR, bit(16)) ? analyzeConnectedPAUC3;

};

################################################################################
# PAU3 Chiplet Unit Checkstop FIR
################################################################################

rule rPAU3_CHIPLET_UCS_FIR
{
  UNIT_CS:
    PAU3_CHIPLET_UCS_FIR & ~PAU3_CHIPLET_UCS_FIR_MASK & `0fffffffffffffff`;
};

group gPAU3_CHIPLET_UCS_FIR
    filter singlebit
{
    /** PAU3_CHIPLET_UCS_FIR[4]
     *  Attention from PAU_LOCAL_FIR 3
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(4)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_UCS_FIR[5]
     *  Attention from PAU_FIR_0 6
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(5)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_UCS_FIR[6]
     *  Attention from PAU_FIR_1 6
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(6)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_UCS_FIR[7]
     *  Attention from PAU_FIR_2 6
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(7)) ? analyzeConnectedPAU6;

    /** PAU3_CHIPLET_UCS_FIR[9]
     *  Attention from PAU_FIR_0 7
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(9)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_UCS_FIR[10]
     *  Attention from PAU_FIR_1 7
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(10)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_UCS_FIR[11]
     *  Attention from PAU_FIR_2 7
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(11)) ? analyzeConnectedPAU7;

    /** PAU3_CHIPLET_UCS_FIR[13]
     *  Attention from PAU_PHY_FIR 3
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(13)) ? analyzeConnectedPAUC3;

    /** PAU3_CHIPLET_UCS_FIR[14]
     *  Attention from PAU_DL_FIR 3
     */
    (rPAU3_CHIPLET_UCS_FIR, bit(14)) ? analyzeConnectedPAUC3;

};

################################################################################
# PAU3 Chiplet Host Attention FIR
################################################################################

rule rPAU3_CHIPLET_HA_FIR
{
  HOST_ATTN:
    PAU3_CHIPLET_HA_FIR & ~PAU3_CHIPLET_HA_FIR_MASK & `0fffffffffffffff`;
};

group gPAU3_CHIPLET_HA_FIR
    filter singlebit
{
    /** PAU3_CHIPLET_HA_FIR[4]
     *  Attention from PAU_LOCAL_FIR 3
     */
    (rPAU3_CHIPLET_HA_FIR, bit(4)) ? analyzeConnectedPAUC3;

};

 ##############################################################################
 #                                                                            #
 #    #                                  ###                                  #
 #   # #    ##  ##### ###  ###  #   #   #   # #     #    ###   ###  ###  ###  #
 #  #   #  #  #   #    #  #   # ##  #   #     #    # #  #     #     #   #     #
 # ####### #      #    #  #   # # # #   #     #   #####  ###   ###  ##   ###  #
 # #     # #  #   #    #  #   # #  ##   #   # #   #   #     #     # #       # #
 # #     #  ##    #   ###  ###  #   #    ###  ### #   #  ###   ###  ###  ###  #
 #                                                                            #
 ##############################################################################

# Include the actions defined for this target
.include "p10_common_actions.rule";
.include "p10_proc_actions.rule";

