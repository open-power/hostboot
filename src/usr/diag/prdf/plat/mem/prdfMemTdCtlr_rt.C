/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/usr/diag/prdf/plat/mem/prdfMemTdCtlr_rt.C $               */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2016,2024                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */

/** @file  prdfMemTdCtlr_rt.C
 *  @brief A state machine for memory Targeted Diagnostics (runtime only).
 */

#include <prdfMemTdCtlr.H>

// Platform includes
#include <prdfMemCaptureData.H>
#include <prdfMemEccAnalysis.H>
#include <prdfMemScrubUtils.H>
#include <prdfMemTps.H>
#include <prdfMemUtils.H>
#include <prdfMemVcm.H>
#include <prdfMemExtraSig.H>
#include <prdfOdyExtraSig.H>
#include <prdfPlatServices.H>
#include <prdfRegisterCache.H>


#ifdef __HOSTBOOT_RUNTIME
#include <prdfMemDynDealloc.H>
#endif

using namespace TARGETING;

namespace PRDF
{

using namespace PlatServices;

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t __handleNceEte( ExtensibleChip * i_chip,
                         const MemAddr & i_addr, STEP_CODE_DATA_STRUCT & io_sc,
                         bool i_isHard = false )
{
    #define PRDF_FUNC "[__handleNceEte] "

    uint32_t o_rc = SUCCESS;

    MemRank rank = i_addr.getRank();
    bool unexpectedSymCount = false;

    do
    {
        // Query the per-symbol counters for the CE symbol(s).
        MemUtils::MaintSymbols symData; MemSymbol junk;
        o_rc = MemUtils::collectCeStats<T>( i_chip, rank, i_addr.getPort(),
                                            symData, junk );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "MemUtils::collectCeStats(0x%08x,0x%02x,%x) "
                      "failed", i_chip->getHuid(), rank.getKey(),
                      i_addr.getPort() );
            break;
        }

        // Make sure the list size is correct. Note that OCMBs have two symbol
        // correction. So it is possible to have two symbols in the counters
        // even though the threshold is set to 1.
        uint32_t count = symData.size();
        switch ( T )
        {
            case TYPE_OCMB_CHIP:
            {
                // Expected 1 or 2 symbols
                if ( count < 1 || count > 2 )
                {
                    unexpectedSymCount = true;
                }

                // Increment the UE counter and store the rank we're on,
                // reset the UE and CE counts if we have stopped on a new rank.
                OcmbDataBundle * ocmbdb = getOcmbDataBundle(i_chip);
                if ( ocmbdb->iv_ceUeRank.first != i_addr.getPort() ||
                     ocmbdb->iv_ceUeRank.second != i_addr.getRank() )
                {
                    ocmbdb->iv_ceStopCounter.reset();
                    ocmbdb->iv_ueStopCounter.reset();
                }
                ocmbdb->iv_ceStopCounter.inc( io_sc );
                ocmbdb->iv_ceUeRank = std::make_pair(i_addr.getPort(),
                                                     i_addr.getRank());

                break;
            }
            default:
            {
                PRDF_ASSERT( false );
            }
        }

        // If there is an unexpected symbol count from the symbol counter
        // registers, just callout the rank and perform dynamic memory
        // deallocation if needed. Updating the CE table is missed in this
        // case. This case typically shouldn't be hit and is mainly in case
        // of strange behavior from the symbol counter registers.
        if ( unexpectedSymCount )
        {
            PRDF_ERR( PRDF_FUNC "Unexpected symbol count from the per-symbol "
                                "counter registers: %d", count );

            // Add the rank to the callout list.
            MemoryMru mm { i_chip->getTrgt(), rank, i_addr.getPort(),
                           MemoryMruData::CALLOUT_RANK };
            io_sc.service_data->SetCallout( mm );

            #ifdef __HOSTBOOT_RUNTIME
            if ( i_isHard )
            {
                // Dynamically deallocate the page.
                if ( SUCCESS != MemDealloc::page<T>( i_chip, i_addr ) )
                {
                    PRDF_ERR( PRDF_FUNC "MemDealloc::page(0x%08x) failed",
                              i_chip->getHuid() );
                }
            }
            #endif

            break;
        }

        for ( auto & d : symData )
        {
            // Add the symbol(s) to the callout list and CE table.
            bool doTps;
            o_rc = MemEcc::handleMemCe<T>( i_chip, i_addr, d.symbol, doTps,
                                           io_sc, false, i_isHard );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "handleMemCe(0x%08x) failed",
                          i_chip->getHuid() );
                break;
            }

            // Add a TPS procedure to the queue, if needed.
            if ( doTps )
            {
                TdEntry * e = new TpsEvent<T>{ i_chip, rank, i_addr.getPort() };
                MemDbUtils::pushToQueue<T>( i_chip, e );
            }
        }
        if ( SUCCESS != o_rc ) break;

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t __handleSoftInterCeEte( ExtensibleChip * i_chip,
                                 const MemAddr & i_addr,
                                 STEP_CODE_DATA_STRUCT & io_sc );

template<>
uint32_t __handleSoftInterCeEte<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                                 const MemAddr & i_addr,
                                                 STEP_CODE_DATA_STRUCT & io_sc )
{
    return __handleNceEte<TYPE_OCMB_CHIP>( i_chip, i_addr, io_sc );
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t __handleRceEte( ExtensibleChip * i_chip,
                         const MemAddr & i_addr, bool & o_errorsFound,
                         STEP_CODE_DATA_STRUCT & io_sc );

template<>
uint32_t __handleRceEte<TYPE_OCMB_CHIP>( ExtensibleChip * i_chip,
                                         const MemAddr & i_addr,
                                         bool & o_errorsFound,
                                         STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[__handleRceEte] "

    uint32_t o_rc = SUCCESS;

    // Should only get this attention in MNFG mode.
    PRDF_ASSERT( mfgMode() );

    do
    {
        // The RCE ETE attention could be from IUE, IMPE, or IRCD. Need to check
        // RDFFIR[37] (RDF_FIR[38] on Odyssey) to determine if there was at
        // least one IUE.

        // Odyssey OCMBs
        if (isOdysseyOcmb(i_chip->getTrgt()))
        {
            char reg[64];
            sprintf(reg, "RDF_FIR_%x", i_addr.getPort());
            SCAN_COMM_REGISTER_CLASS * fir = i_chip->getRegister( reg );
            o_rc = fir->Read();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR(PRDF_FUNC "Read() failed on RDF_FIR_%x: "
                         "i_chip=0x%08x", i_addr.getPort(), i_chip->getHuid());
                break;
            }
            if ( !fir->IsBitSet(38) ) break; // nothing else to do
        }
        // Explorer OCMBs
        else
        {
            SCAN_COMM_REGISTER_CLASS * fir = i_chip->getRegister( "RDFFIR" );
            o_rc = fir->Read();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "Read() failed on RDFFIR: i_chip=0x%08x",
                          i_chip->getHuid() );
                break;
            }
            if ( !fir->IsBitSet(37) ) break; // nothing else to do
        }

        // Handle the IUE.
        o_errorsFound = true;
        io_sc.service_data->AddSignatureList( i_chip->getTrgt(),
                                              PRDFSIG_MaintIUE );
        o_rc = MemEcc::handleMemIue<TYPE_OCMB_CHIP>( i_chip, i_addr.getRank(),
                                                     i_addr.getPort(), io_sc );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "handleMemIue(0x%08x,0x%02x,%x) failed",
                      i_chip->getHuid(), i_addr.getRank().getKey(),
                      i_addr.getPort() );
            break;
        }

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
bool __handleSteerRetries(ExtensibleChip * i_chip, const MemAddr & i_addr,
    MaintEccAttns i_attn, STEP_CODE_DATA_STRUCT & io_sc);

template<>
bool __handleSteerRetries<TYPE_OCMB_CHIP>(ExtensibleChip * i_chip,
    const MemAddr & i_addr, MaintEccAttns i_attn, STEP_CODE_DATA_STRUCT & io_sc)
{
    #define PRDF_FUNC "[__handleSteerRetries] "

    bool errHandled = false;

    // Background steer for Odyssey OCMBs reports all CEs and UEs as hard
    // errors. To determine whether the errors were possibly intermittent
    // a steer command will be run on the single address that was stopped on
    // with appropriate handling depending on the errors then found from that
    // single address steer.

    do
    {
        // This workaround only applies to Odyssey where background steer is
        // performed instead of background scrub. Break out if not Odyssey.
        if (!isOdysseyOcmb(i_chip->getTrgt()))
        {
            break; // do normal handling
        }

        // Check MCBMR0[0:3] to determine if the mcbist command being run was a
        // steer or not.
        SCAN_COMM_REGISTER_CLASS * mcbmr0 = i_chip->getRegister("MCBMR0");
        if (SUCCESS != mcbmr0->Read())
        {
            PRDF_ERR(PRDF_FUNC "Error from Read of MCBMR0 on 0x%08x",
                     i_chip->getHuid());
            break; // do normal handling
        }

        // 0b1010 in MCBMR0[0:3] indicates the MAINTSTEER value
        if (0b1010 != mcbmr0->GetBitFieldJustified(0,4))
        {
            // Not a steer command, so just break out and do normal handling.
            break;
        }

        // Clear command complete, ECC errors, and counters
        if (SUCCESS != prepareNextCmd<TYPE_OCMB_CHIP>(i_chip))
        {
            PRDF_ERR(PRDF_FUNC "Error from prepareNextCmd(0x%08x)",
                     i_chip->getHuid());
            break; // do normal handling
        }

        // Run the single address steer
        if (SUCCESS != singleAddrSteer<TYPE_OCMB_CHIP>(i_chip, i_addr))
        {
            PRDF_ERR(PRDF_FUNC "Error from singleAddrSteer(0x%08x, 0x%016llx)",
                     i_chip->getHuid(),
                     i_addr.toMaintAddr<TYPE_OCMB_CHIP>(i_chip->getTrgt()));
            break; // do normal handling
        }

        // Check to make sure the command complete bit is set
        SCAN_COMM_REGISTER_CLASS * mcbistfir =
            i_chip->getRegister("MCBIST_FIR");

        if (SUCCESS != mcbistfir->ForceRead())
        {
            PRDF_ERR(PRDF_FUNC "Error from ForceRead of MCBIST_FIR on 0x%08x",
                     i_chip->getHuid());
            break; // do normal handling
        }

        // Check to make sure the single address steer command has finished
        if (!mcbistfir->IsBitSet(11))
        {
            // Wait a bit and try again
            milliSleep(0,20); // 20 milliseconds
            if (SUCCESS != mcbistfir->ForceRead())
            {
                PRDF_ERR(PRDF_FUNC "Error from ForceRead of MCBIST_FIR on "
                         "0x%08x", i_chip->getHuid());
                break; // do normal handling
            }

            // If the command complete is still not set, give up, assume hard error
            if (!mcbistfir->IsBitSet(11))
            {
                PRDF_ERR(PRDF_FUNC "Command complete bit still not set after "
                         "waiting, assuming hard error.");
                break; // do normal handling
            }
        }

        // The single address steer has finished, check ECC errors
        // First clear the RDF_FIR from the cache so it will collect the new
        // data from the steer. The MCBIST_FIR does not need to be cleared from
        // the cache as a ForceRead was performed on it above.
        char rdfName[64];
        sprintf(rdfName, "RDF_FIR_%x", i_addr.getPort());
        RegDataCache & cache = RegDataCache::getCachedRegisters();
        SCAN_COMM_REGISTER_CLASS * rdffir = i_chip->getRegister(rdfName);
        cache.flush(i_chip, rdffir);

        uint32_t eccAttns;
        if ( SUCCESS != checkEccFirs<TYPE_OCMB_CHIP>(i_chip, i_addr.getPort(),
                                                     eccAttns) )
        {
            PRDF_ERR(PRDF_FUNC "checkEccFirs(0x%08x, %d) failed",
                     i_chip->getHuid(), i_addr.getPort());
            break; // do normal handling
        }

        if (i_attn == MAINT_HARD_NCE_ETE)
        {
            // if maint UE found
            if (eccAttns & MAINT_UE)
            {
                // Handle the error as a UE
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintUe);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerUe);
                if (SUCCESS != MemEcc::handleMemUe<TYPE_OCMB_CHIP>(i_chip,
                    i_addr, UE_TABLE::SCRUB_UE, io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "handleMemUe(0x%08x) failed",
                             i_chip->getHuid());
                    break;
                }
                errHandled = true;
            }
            // else if maint MPE found
            else if (eccAttns & MAINT_MPE)
            {
                // Handle the error as an MPE to trigger VCM
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintMpe);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerMpe);
                if (SUCCESS != MemEcc::handleMpe<TYPE_OCMB_CHIP>(i_chip,
                    i_addr, UE_TABLE::SCRUB_MPE, io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "handleMpe(0x%08x) failed",
                             i_chip->getHuid());
                    break;
                }
                errHandled = true;
            }
            // else if maint NCE/TCE found
            else if (eccAttns & MAINT_HARD_NCE_ETE)
            {
                // Handle as a hard CE, let the calling code take normal action
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintHardCe);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerCe);
                break;
            }
            // else no error found
            else
            {
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintInterCe);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerNone);
                // Handle as a soft/intermittent CE
                if (SUCCESS != __handleSoftInterCeEte<TYPE_OCMB_CHIP>(i_chip,
                    i_addr, io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "__handleSoftInterCeEte(0x%08x) failed",
                             i_chip->getHuid());
                }
                errHandled = true;
            }
        }
        else if (i_attn == MAINT_UE)
        {
            // if maint UE found
            if (eccAttns & MAINT_UE)
            {
                // Handle as a UE, let the calling code take normal action
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintUe);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerUe);
                break;
            }
            // else if maint MPE found
            else if (eccAttns & MAINT_MPE)
            {
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintIue);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerMpe);
                // Handle as an IUE
                if (SUCCESS != MemEcc::handleMemIue<TYPE_OCMB_CHIP>(i_chip,
                    i_addr.getRank(), i_addr.getPort(), io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "handleMemIue(0x%08x,0x%02x,%x) failed",
                             i_chip->getHuid(), i_addr.getRank().getKey(),
                             i_addr.getPort());
                    break;
                }
                // Handle the MPE to trigger VCM
                if (SUCCESS != MemEcc::handleMpe<TYPE_OCMB_CHIP>(i_chip,
                    i_addr.getRank(), i_addr.getPort(), UE_TABLE::SCRUB_MPE,
                    io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "handleMpe<T>(0x%08x, 0x%02x) failed",
                             i_chip->getHuid(), i_addr.getRank().getKey());
                    break;
                }

                errHandled = true;
            }
            // else if maint NCE/TCE
            else if (eccAttns & MAINT_HARD_NCE_ETE)
            {
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintIue);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerCe);
                // Handle as an IUE
                if (SUCCESS != MemEcc::handleMemIue<TYPE_OCMB_CHIP>(i_chip,
                    i_addr.getRank(), i_addr.getPort(), io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "handleMemIue(0x%08x,0x%02x,%x) failed",
                             i_chip->getHuid(), i_addr.getRank().getKey(),
                             i_addr.getPort());
                    break;
                }
                errHandled = true;
            }
            // Else no error found
            else
            {
                io_sc.service_data->setSignature(i_chip->getHuid(),
                                                 PRDFSIG_SasMaintIue);
                io_sc.service_data->AddSignatureList(i_chip->getTrgt(),
                                                     PRDFSIG_SteerNone);
                // Handle as an IUE
                if (SUCCESS != MemEcc::handleMemIue<TYPE_OCMB_CHIP>(i_chip,
                    i_addr.getRank(), i_addr.getPort(), io_sc))
                {
                    PRDF_ERR(PRDF_FUNC "handleMemIue(0x%08x,0x%02x,%x) failed",
                             i_chip->getHuid(), i_addr.getRank().getKey(),
                             i_addr.getPort());
                    break;
                }
                errHandled = true;
            }

        }
        else
        {
            PRDF_ERR(PRDF_FUNC "Invalid input ECC attn type: 0x%x", i_attn);
            break; // do normal handling
        }

    } while(0);

    return errHandled;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template <TARGETING::TYPE T>
uint32_t MemTdCtlr<T>::checkEcc( ExtensibleChip * i_chip,
                                 const MemAddr & i_addr, bool & o_errorsFound,
                                 STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemTdCtlr::checkEcc] "

    PRDF_ASSERT( nullptr != i_chip );
    PRDF_ASSERT( T == i_chip->getType() );

    uint32_t o_rc = SUCCESS;

    o_errorsFound = false;

    TargetHandle_t trgt = i_chip->getTrgt();
    HUID           huid = i_chip->getHuid();

    MemRank rank = i_addr.getRank();

    do
    {
        // Check for ECC errors.
        uint32_t eccAttns = 0;
        o_rc = checkEccFirs<T>( i_chip, i_addr.getPort(), eccAttns );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "checkEccFirs<T>(0x%08x, %x) failed", huid,
                      i_addr.getPort() );
            break;
        }

        if ( 0 != (eccAttns & MAINT_INT_NCE_ETE) )
        {
            o_errorsFound = true;
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MaintINTER_CTE);

            o_rc = __handleSoftInterCeEte<T>( i_chip, i_addr, io_sc );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "__handleSoftInterCeEte<T>(0x%08x) failed",
                          huid );
                break;
            }
        }

        if ( 0 != (eccAttns & MAINT_SOFT_NCE_ETE) )
        {
            o_errorsFound = true;
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MaintSOFT_CTE );

            o_rc = __handleSoftInterCeEte<T>( i_chip, i_addr, io_sc );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "__handleSoftInterCeEte<T>(0x%08x) failed",
                          huid );
                break;
            }
        }

        if ( 0 != (eccAttns & MAINT_HARD_NCE_ETE) )
        {
            o_errorsFound = true;
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MaintHARD_CTE );

            // Confirm the hard CE with __handleSteerRetries
            if (!__handleSteerRetries<T>(i_chip, i_addr, MAINT_HARD_NCE_ETE,
                                         io_sc))
            {
                o_rc = __handleNceEte<T>( i_chip, i_addr, io_sc, true );
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "__handleNceEte<T>(0x%08x) failed",
                              huid );
                    break;
                }
            }

            // Any hard CEs in MNFG should be immediately reported.
            // NOTE: We will only use the MNFG thresholds if DRAM repairs is
            //       disabled.
            if ( areDramRepairsDisabled() )
            {
                io_sc.service_data->setSignature( huid, PRDFSIG_MaintHARD_CTE );
                io_sc.service_data->setServiceCall();
            }
        }

        if ( 0 != (eccAttns & MAINT_MPE) )
        {
            o_errorsFound = true;
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MaintMPE );

            o_rc = MemEcc::handleMpe<T>( i_chip, i_addr, UE_TABLE::SCRUB_MPE,
                                         io_sc );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "handleMpe<T>(0x%08x, 0x%02x) failed",
                          i_chip->getHuid(), rank.getKey() );
                break;
            }
        }

        if ( 0 != (eccAttns & MAINT_RCE_ETE) )
        {
            o_rc = __handleRceEte<T>( i_chip, i_addr, o_errorsFound,
                                      io_sc );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "__handleRceEte<T>(0x%08x) failed", huid );
                break;
            }
        }

        if ( 0 != (eccAttns & MAINT_UE) )
        {
            o_errorsFound = true;
            io_sc.service_data->AddSignatureList( trgt, PRDFSIG_MaintUE );

            // Since this will be a predictive callout, change the primary
            // signature as well.
            io_sc.service_data->setSignature( huid, PRDFSIG_MaintUE );

            // Confirm the UE with __handleSteerRetries
            if (!__handleSteerRetries<T>(i_chip, i_addr, MAINT_UE, io_sc))
            {
                // Add the rank to the callout list.
                o_rc = MemEcc::handleMemUe<T>( i_chip, i_addr,
                                               UE_TABLE::SCRUB_UE, io_sc );
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "handleMemUe<T>(0x%08x) failed",
                              i_chip->getHuid() );
                    break;
                }

                // Add a TPS request to the TD queue for additional analysis. It is
                // unlikely the procedure will result in a repair because of the UE.
                // However, we want to run TPS once just to see how bad the rank is.
                TdEntry * e = new TpsEvent<T>{ i_chip, rank, i_addr.getPort() };
                MemDbUtils::pushToQueue<T>( i_chip, e );

                // Because of the UE, any further TPS requests will likely have no
                // effect. So ban all subsequent requests.
                MemDbUtils::banTps<T>( i_chip, rank, i_addr.getPort() );
            }
        }

        // Odyssey only: If no TD events are in queue, background steer will
        // need to be restarted on the next address. The continue_cmd
        // procedure cannot be used after a single addr steer.
        if (isOdysseyOcmb(trgt) && iv_queue.empty())
        {
            iv_restartOnNextAddr = true;
        }

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template <TARGETING::TYPE T>
uint32_t MemTdCtlr<T>::handleTdEvent( STEP_CODE_DATA_STRUCT & io_sc,
                                      uint8_t i_port )
{
    #define PRDF_FUNC "[MemTdCtlr::handleTdEvent] "

    uint32_t o_rc = SUCCESS;

    do
    {
        // Make sure the TD controller is initialized.
        o_rc = initialize();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "initialize() failed on 0x%08x",
                      iv_chip->getHuid() );
            break;
        }

        // Don't interrupt a TD procedure if one is already in progress.
        if ( nullptr != iv_curProcedure ) break;

        // If the queue is empty, there is nothing to do. So there is no point
        // to stopping background scrub. This could have happen if TPS was
        // banned on a rank and the TPS request was never added to the queue. In
        // that case, mask fetch attentions temporarily to prevent flooding.
        if ( iv_queue.empty() )
        {
            o_rc = maskEccAttns(i_port);
            if (SUCCESS != o_rc)
            {
                PRDF_ERR(PRDF_FUNC "maskEccAttns(%x) failed", i_port);
                break;
            }

            break; // Don't stop background scrub.
        }

        // Stop background scrubbing.
        o_rc = stopBgScrub<T>( iv_chip );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "stopBgScrub<T>(0x%08x) failed",
                      iv_chip->getHuid() );
            break;
        }

        // Since we had to manually stop the maintenance command, refresh all
        // relevant registers that may have changed since the initial capture.
        recaptureRegs( io_sc );

        collectStateCaptureData( io_sc, TD_CTLR_DATA::START );

        // It is possible that background scrub could have found an ECC error
        // before we had a chance to stop the command. Therefore, we need to
        // check for any ECC errors that can be handled. Also, initialize the
        // variables needed so we know where to restart background scrubbing.
        // First, get the address in which the command stopped.
        MemAddr addr;
        o_rc = getMemMaintAddr<T>( iv_chip, addr );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "getMemMaintAddr<T>(0x%08x) failed",
                      iv_chip->getHuid() );
            break;
        }

        // Update iv_stoppedRank.
        iv_stoppedRank = getStopRank(addr);

        // Check for ECC errors. This will add TD procedures to iv_queue in
        // some cases.
        bool errorsFound;
        o_rc = checkEcc(iv_chip, addr, errorsFound, io_sc);
        if (SUCCESS != o_rc)
        {
            PRDF_ERR(PRDF_FUNC "checkEcc(0x%08x) failed",
                     iv_chip->getHuid());
            break;
        }

        #ifdef __HOSTBOOT_RUNTIME

        if ( iv_queue.empty() )
        {
            // The queue is empty so if possible, simply resume the command
            // instead of starting a new one. This must be checked here instead
            // of in defaultStep() because a TD procedure could have been run
            // before defaultStep() and it is possible that canResumeBgScrub()
            // could give as a false positive in that case.
            o_rc = canResumeBgScrub( iv_resumeBgScrub, io_sc );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "canResumeBgScrub(0x%08x) failed",
                          iv_chip->getHuid() );
                break;
            }
        }
        else
        {
            // At this point, there are new TD procedures in the queue so we
            // want to mask certain fetch attentions to avoid the complication
            // of handling the attentions during the TD procedures.
            o_rc = maskEccAttns(0);
            if (SUCCESS != o_rc)
            {
                PRDF_ERR(PRDF_FUNC "maskEccAttns(0) failed");
                break;
            }

            if (isOdysseyOcmb(iv_chip->getTrgt()))
            {
                o_rc = maskEccAttns(1);
                if (SUCCESS != o_rc)
                {
                    PRDF_ERR(PRDF_FUNC "maskEccAttns(1) failed");
                    break;
                }
            }
        }

        #endif

        // Move onto the next step in the state machine.
        o_rc = nextStep( io_sc, addr );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "nextStep() failed on 0x%08x",
                      iv_chip->getHuid() );
            break;
        }

    } while (0);

    // Gather capture data even if something failed above.
    collectStateCaptureData( io_sc, TD_CTLR_DATA::END );

    if ( SUCCESS != o_rc )
    {
        PRDF_ERR( PRDF_FUNC "Failed on 0x%08x", iv_chip->getHuid() );

        // Change signature indicating there was an error in analysis.
        io_sc.service_data->setSignature( iv_chip->getHuid(),
                                          PRDFSIG_CmdComplete_ERROR );

        // Something definitely failed, so callout 2nd level support.
        io_sc.service_data->SetCallout( LEVEL2_SUPPORT, MRU_HIGH );
        io_sc.service_data->setServiceCall();
    }

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template <TARGETING::TYPE T>
uint32_t MemTdCtlr<T>::defaultStep( STEP_CODE_DATA_STRUCT & io_sc,
                                    const MemAddr & i_addr )
{
    #define PRDF_FUNC "[MemTdCtlr::defaultStep] "

    uint32_t o_rc = SUCCESS;

    if ( iv_resumeBgScrub )
    {
        // Background scrubbing paused for FFDC collection only. Resume the
        // current command. iv_resumeBgScrub will not be set when a background
        // steer command is being used for Odyssey OCMBs (see the
        // canResumeBgScrub function).
        iv_resumeBgScrub = false;

        // Reset iv_restartOnNextAddr as well. This would be for the case where
        // an Odyssey OCMB in mnfg mode is running background scrub instead of
        // background steer.
        iv_restartOnNextAddr = false;

        PRDF_TRAC( PRDF_FUNC "Calling resumeBgScrub<T>(0x%08x)",
                   iv_chip->getHuid() );

        o_rc = resumeBgScrub<T>( iv_chip, io_sc );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "resumeBgScrub<T>(0x%08x) failed",
                      iv_chip->getHuid() );
        }
    }
    else if (iv_restartOnNextAddr)
    {
        // Odyssey only: Background steer was stopped, a single address
        // steer was performed, and no targeted diagnostics procedure was
        // performed. As such background steer needs to be restarted on the
        // next address instead of the next rank.
        iv_restartOnNextAddr = false;

        PRDF_TRAC(PRDF_FUNC "Calling restartBgSteerOnNextAddr<T>(0x%08x)",
                  iv_chip->getHuid());


        o_rc = restartBgSteerOnNextAddr<T>(iv_chip, i_addr, io_sc);
        if (SUCCESS != o_rc)
        {
            PRDF_ERR(PRDF_FUNC "restartBgSteerOnNextAddr<T>(0x%08x) failed",
                     iv_chip->getHuid());
        }
    }
    else
    {
        // Unmask the ECC attentions that were explicitly masked during the
        // TD procedure.
        o_rc = unmaskEccAttns(0);
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "unmaskEccAttns(0) failed" );
        }

        if (isOdysseyOcmb(iv_chip->getTrgt()))
        {
            o_rc = unmaskEccAttns(1);
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "unmaskEccAttns(1) failed" );
            }
        }

        // Hardware Force Mirror (HWFM) workaround: HWFM needs to be cleared
        // after runtime targeted diagnostics has completed in case a mainline
        // NCE/TCE was hit which would trigger HWFM even though those errors
        // were masked.
        ExtensibleChip * mcc = getConnectedParent(iv_chip, TYPE_MCC);
        if (SUCCESS != MemUtils::clearHwfm(mcc))
        {
            PRDF_ERR(PRDF_FUNC "clearHwFm(0x%08x) failed", mcc->getHuid());
        }

        // A TD procedure has completed. Restart background scrubbing on the
        // next rank.

        TdRankListEntry nextRank = iv_rankList.getNext( iv_stoppedRank );

        PRDF_TRAC( PRDF_FUNC "Calling startBgScrub<T>(0x%08x, m%ds%d, %x)",
                   nextRank.getChip()->getHuid(),
                   nextRank.getRank().getMaster(),
                   nextRank.getRank().getSlave(),
                   nextRank.getPort() );

        o_rc = startBgScrub<T>(nextRank.getChip(), nextRank.getRank(),
                               nextRank.getPort());
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "startBgScrub<T>(0x%08x,m%ds%d,%x) failed",
                      nextRank.getChip()->getHuid(),
                      nextRank.getRank().getMaster(),
                      nextRank.getRank().getSlave(), nextRank.getPort() );
        }
    }

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE T>
uint32_t MemTdCtlr<T>::maskEccAttns(uint8_t i_port)
{
    #define PRDF_FUNC "[MemTdCtlr<T>::maskEccAttns] "

    uint32_t o_rc = SUCCESS;

    // Odyssey OCMBs
    if (isOdysseyOcmb(iv_chip->getTrgt()))
    {
        char maskName[64];
        sprintf(maskName, "RDF_FIR_MASK_OR_%x", i_port);
        SCAN_COMM_REGISTER_CLASS * mask = iv_chip->getRegister(maskName);

        mask->clearAllBits();
        mask->SetBit(9); // Mainline read NCE
        mask->SetBit(10); // Mainline read TCE

        o_rc = mask->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed on %s", maskName );
        }
    }
    // Explorer OCMBs
    else
    {
        SCAN_COMM_REGISTER_CLASS * mask =
            iv_chip->getRegister("RDFFIR_MASK_OR");

        mask->clearAllBits();
        mask->SetBit(8); // Mainline read NCE
        mask->SetBit(9); // Mainline read TCE

        o_rc = mask->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR_MASK_OR" );
        }
    }

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<>
uint32_t MemTdCtlr<TYPE_OCMB_CHIP>::unmaskEccAttns(uint8_t i_port)
{
    #define PRDF_FUNC "[MemTdCtlr<TYPE_OCMB_CHIP>::unmaskEccAttns] "

    uint32_t o_rc = SUCCESS;

    // Memory CEs were masked at the beginning of the TD procedure, so
    // clear and unmask them. Also, it is possible that memory UEs have
    // thresholded so clear and unmask them as well.

    // Odyssey OCMBs
    if (isOdysseyOcmb(iv_chip->getTrgt()))
    {
        // FIRs on Odyssey are write to clear so get the RDF_FIR and it's mask.
        char firName[64];
        sprintf(firName, "RDF_FIR_%x", i_port);
        SCAN_COMM_REGISTER_CLASS * fir = iv_chip->getRegister(firName);

        char maskName[64];
        sprintf(maskName, "RDF_FIR_MASK_%x", i_port);
        SCAN_COMM_REGISTER_CLASS * mask = iv_chip->getRegister(maskName);

        fir->clearAllBits();
        mask->clearAllBits();

        // Do not unmask NCE and TCE attentions if they have been permanently
        // masked due to certain TPS conditions.
        if (!(getOcmbDataBundle(iv_chip)->iv_maskMainlineNceTce.count(i_port)))
        {
            fir->SetBit(9);  mask->SetBit(9);  // Mainline read NCE
            fir->SetBit(10); mask->SetBit(10); // Mainline read TCE
        }
        fir->SetBit(15); mask->SetBit(15); // Mainline read UE

        o_rc = fir->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR_AND" );
        }

        o_rc = mask->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR_MASK_AND" );
        }

        // Clear the register cache for the RDF_FIR and RDF_FIR_MASK since
        // they've been written so the next time they're read, the new data
        // will be read from hardware.
        RegDataCache & cache = RegDataCache::getCachedRegisters();
        cache.flush(iv_chip, fir);
        cache.flush(iv_chip, mask);
    }
    // Explorer OCMBs
    else
    {
        SCAN_COMM_REGISTER_CLASS * fir = iv_chip->getRegister("RDFFIR_AND");
        SCAN_COMM_REGISTER_CLASS * mask =
            iv_chip->getRegister("RDFFIR_MASK_AND");

        fir->setAllBits(); mask->setAllBits();

        // Do not unmask NCE and TCE attentions if they have been permanently
        // masked due to certain TPS conditions.
        if (!(getOcmbDataBundle(iv_chip)->iv_maskMainlineNceTce.count(i_port)))
        {
            fir->ClearBit(8);  mask->ClearBit(8);  // Mainline read NCE
            fir->ClearBit(9);  mask->ClearBit(9);  // Mainline read TCE
        }
        fir->ClearBit(14); mask->ClearBit(14); // Mainline read UE

        o_rc = fir->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR_AND" );
        }

        o_rc = mask->Write();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR_MASK_AND" );
        }
    }

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<TARGETING::TYPE TP, TARGETING::TYPE TC>
uint32_t __findChipMarks( TdRankList<TC> & i_rankList );

template<>
uint32_t __findChipMarks<TYPE_OCMB_CHIP>(
        TdRankList<TYPE_OCMB_CHIP> & i_rankList )
{
    #define PRDF_FUNC "[__findChipMarks] "

    uint32_t o_rc = SUCCESS;

    for ( auto & entry : i_rankList.getList() )
    {
        ExtensibleChip * chip = entry.getChip();
        MemRank          rank = entry.getRank();
        uint8_t          port = entry.getPort();

        // Call readChipMark to get MemMark.
        MemMark chipMark;
        o_rc = MarkStore::readChipMark<TYPE_OCMB_CHIP>( chip, rank, port,
                                                        chipMark );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "readChipMark(0x%08x,0x%02x,%x) failed",
                      chip->getHuid(), rank.getKey(), port );
            break;
        }

        if ( !chipMark.isValid() ) continue; // no chip mark present

        // Get the DQ Bitmap data.
        MemDqBitmap dqBitmap;
        TargetHandle_t memport = getConnectedChild(chip->getTrgt(),
            TYPE_MEM_PORT, port);
        o_rc = getBadDqBitmap<TYPE_MEM_PORT>( memport, rank, dqBitmap );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "getBadDqBitmap(0x%08x,0x%02x)",
                      getHuid(memport), rank.getKey() );
            break;
        }

        // Check if the chip mark is verified or not.
        bool cmVerified = false;
        o_rc = dqBitmap.isChipMark( chipMark.getSymbol(), cmVerified );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "dqBitmap.isChipMark() failed on 0x%08x "
                      "0x%02x", chip->getHuid(), rank.getKey() );
            break;
        }

        // If the chip mark is unverified, add a VcmEvent to the TD queue.
        if ( !cmVerified )
        {
            // Chip mark is not present in VPD. Add it to queue.
            TdEntry * e = new VcmEvent<TYPE_OCMB_CHIP>{ chip, rank, chipMark,
                                                        port };
            MemDbUtils::pushToQueue<TYPE_OCMB_CHIP>( chip, e );

            // We will want to clear the MPE attention for the unverified chip
            // mark so we don't get any redundant attentions for chip marks that
            // are already in the queue. This is reset/reload safe because
            // initialize() will be called again and we can redetect the
            // unverified chip marks.
            if (isOdysseyOcmb(chip->getTrgt()))
            {
                // Odyssey registers are write to clear
                char regName[64];
                sprintf(regName, "RDF_FIR_%x", port);
                SCAN_COMM_REGISTER_CLASS * reg = chip->getRegister(regName);

                reg->clearAllBits();
                reg->SetBit( 1 + rank.getMaster()); // fetch
                reg->SetBit(21 + rank.getMaster()); // scrub
                o_rc = reg->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on %s: 0x%08x",
                              regName, chip->getHuid() );
                    break;
                }
                // Clear the register cache for the RDF_FIR since it's been
                // written so the next time it's read, the new data will be
                // read from hardware.
                RegDataCache & cache = RegDataCache::getCachedRegisters();
                cache.flush(chip, reg);
            }
            else
            {
                SCAN_COMM_REGISTER_CLASS * reg =
                    chip->getRegister( "RDFFIR_AND" );
                reg->setAllBits();
                reg->ClearBit(  0 + rank.getMaster() ); // fetch
                reg->ClearBit( 20 + rank.getMaster() ); // scrub
                o_rc = reg->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on RDFFIR AND: 0x%08x",
                              chip->getHuid() );
                    break;
                }
            }
        }
    }

    return o_rc;

    #undef PRDF_FUNC
}

template<>
uint32_t MemTdCtlr<TYPE_OCMB_CHIP>::initialize()
{
    #define PRDF_FUNC "[MemTdCtlr<TYPE_OCMB_CHIP>::initialize] "

    uint32_t o_rc = SUCCESS;

    do
    {
        if ( iv_initialized ) break; // nothing to do

        // Unmask the fetch attentions just in case there were masked during a
        // TD procedure prior to a reset/reload. For Odyssey, unmask both ports.
        if (nullptr != getConnectedChild(iv_chip->getTrgt(), TYPE_MEM_PORT, 0))
        {
            o_rc = unmaskEccAttns(0);
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "unmaskEccAttns(0) failed" );
                break;
            }
        }

        // Odyssey only: unmask port 1
        if (isOdysseyOcmb(iv_chip->getTrgt()) &&
            nullptr != getConnectedChild(iv_chip->getTrgt(), TYPE_MEM_PORT, 1))
        {
            o_rc = unmaskEccAttns(1);
            if (SUCCESS != o_rc)
            {
                PRDF_ERR(PRDF_FUNC "unmaskEccAttns(1) failed");
                break;
            }
        }

        // Find all unverified chip marks.
        o_rc = __findChipMarks<TYPE_OCMB_CHIP>( iv_rankList );
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "__findChipMarks() failed on 0x%08x",
                      iv_chip->getHuid() );
            break;
        }

        // At this point, the TD controller is initialized.
        iv_initialized = true;

    } while (0);

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<>
uint32_t MemTdCtlr<TYPE_OCMB_CHIP>::handleRrFo()
{
    #define PRDF_FUNC "[MemTdCtlr<TYPE_OCMB_CHIP>::handleRrFo] "

    uint32_t o_rc = SUCCESS;

    do
    {
        // Check if maintenance command complete attention is set.
        if (isOdysseyOcmb(iv_chip->getTrgt()))
        {
            SCAN_COMM_REGISTER_CLASS * mcbistfir =
                iv_chip->getRegister("MCBIST_FIR");
            o_rc = mcbistfir->Read();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "Read() failed on MCBIST_FIR");
                break;
            }

            // If there is a command complete attention, nothing to do, break out.
            if ( mcbistfir->IsBitSet(11) )
                break;
        }
        else
        {
            SCAN_COMM_REGISTER_CLASS * mcbistfir =
                iv_chip->getRegister("MCBISTFIR");
            o_rc = mcbistfir->Read();
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "Read() failed on MCBISTFIR");
                break;
            }

            // If there is a command complete attention, nothing to do, break out.
            if ( mcbistfir->IsBitSet(10) )
                break;
        }


        // Check if a command is not running.
        // If bit 0 of MCB_CNTLSTAT is on, a mcbist run is in progress.
        SCAN_COMM_REGISTER_CLASS * mcb_cntlstat =
            iv_chip->getRegister("MCB_CNTLSTAT");
        o_rc = mcb_cntlstat->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read() failed on MCB_CNTLSTAT" );
            break;
        }

        // If a command is not running, set command complete attn, break.
        if ( !mcb_cntlstat->IsBitSet(0) )
        {
            if (isOdysseyOcmb(iv_chip->getTrgt()))
            {
                SCAN_COMM_REGISTER_CLASS * mcbistfir_or =
                    iv_chip->getRegister("MCBIST_FIR_OR");
                mcbistfir_or->clearAllBits();
                mcbistfir_or->SetBit( 11 );

                mcbistfir_or->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on MCBIST_FIR_OR" );
                }
                break;
            }
            else
            {
                SCAN_COMM_REGISTER_CLASS * mcbistfir_or =
                    iv_chip->getRegister("MCBISTFIR_OR");
                mcbistfir_or->clearAllBits();
                mcbistfir_or->SetBit( 10 );

                mcbistfir_or->Write();
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "Write() failed on MCBISTFIR_OR" );
                }
                break;
            }
        }

        // Check if there are unverified chip marks.
        std::vector<TdRankListEntry> vectorList = iv_rankList.getList();

        for ( auto & entry : vectorList )
        {
            ExtensibleChip * ocmbChip = entry.getChip();
            MemRank rank = entry.getRank();
            uint8_t port = entry.getPort();

            // Get the chip mark
            MemMark chipMark;
            o_rc = MarkStore::readChipMark<TYPE_OCMB_CHIP>( ocmbChip, rank,
                                                            port, chipMark );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "readChipMark<TYPE_OCMB_CHIP>(0x%08x,%d,%x)"
                          " failed", ocmbChip->getHuid(), rank.getMaster(),
                          port );
                break;
            }

            if ( !chipMark.isValid() ) continue; // no chip mark present

            // Get the DQ Bitmap data.
            TargetHandle_t memport = getConnectedChild(ocmbChip->getTrgt(),
                                                       TYPE_MEM_PORT, port);

            MemDqBitmap dqBitmap;
            o_rc = getBadDqBitmap<TYPE_MEM_PORT>( memport, rank, dqBitmap );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "getBadDqBitmap(0x%08x, %d)",
                          getHuid(memport), rank.getMaster() );
                break;
            }

            // Check if the chip mark is verified or not.
            bool cmVerified = false;
            o_rc = dqBitmap.isChipMark( chipMark.getSymbol(), cmVerified );
            if ( SUCCESS != o_rc )
            {
                PRDF_ERR( PRDF_FUNC "dqBitmap.isChipMark failed." );
                break;
            }

            // If there are any unverified chip marks, stop the command, break.
            if ( !cmVerified )
            {
                o_rc = stopBgScrub<TYPE_OCMB_CHIP>( iv_chip );
                if ( SUCCESS != o_rc )
                {
                    PRDF_ERR( PRDF_FUNC "stopBgScrub<TYPE_OCMB_CHIP>(0x%08x) "
                              "failed", iv_chip->getHuid() );
                }
                break;
            }
        }

    } while (0);

    return o_rc;
    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

template<>
uint32_t MemTdCtlr<TYPE_OCMB_CHIP>::canResumeBgScrub( bool & o_canResume,
        STEP_CODE_DATA_STRUCT & io_sc )
{
    #define PRDF_FUNC "[MemTdCtlr<TYPE_OCMB_CHIP>::canResumeBgScrub] "

    uint32_t o_rc = SUCCESS;

    o_canResume = false;

    // It is possible that we were running a TD procedure and the PRD service
    // was reset. Therefore, we must check if background scrubbing was actually
    // configured. There really is not a good way of doing this. A scrub command
    // is a scrub command the only difference is the speed. Unfortunately, that
    // speed can change depending on how the hardware team tunes it. For now, we
    // can use the stop conditions, which should be unique for background scrub,
    // to determine if it has been configured.

    do
    {
        // Check MCBMR0[0:3] to determine if the mcbist command being run was a
        // steer or not. If the command was a steer command we must start a new
        // background scrub command as any error that gets stopped on will
        // result in a targeted diagnostics procedure or a single address steer
        // to confirm the error. Currently this will only be relevant for
        // Odyssey OCMBs.
        if (isOdysseyOcmb(iv_chip->getTrgt()))
        {
            SCAN_COMM_REGISTER_CLASS * mcbmr0 = iv_chip->getRegister("MCBMR0");
            if (SUCCESS != mcbmr0->Read())
            {
                PRDF_ERR(PRDF_FUNC "Error from Read of MCBMR0 on 0x%08x",
                         iv_chip->getHuid());
                break;
            }

            // 0b1010 in MCBMR0[0:3] indicates the MAINTSTEER value
            if (0b1010 == mcbmr0->GetBitFieldJustified(0,4))
            {
                break;
            }
        }

        SCAN_COMM_REGISTER_CLASS * reg = iv_chip->getRegister( "MBSTR" );
        o_rc = reg->Read();
        if ( SUCCESS != o_rc )
        {
            PRDF_ERR( PRDF_FUNC "Read() failed on MBSTR: iv_chip=0x%08x",
                    iv_chip->getHuid() );
            break;
        }
        // Note: The stop conditions for background scrubbing can now be
        // variable depending on whether we have hit threshold for the number
        // of UEs or CEs that we have stopped on on a rank.

        // If we haven't hit CE or UE threshold, check the CE stop conditions
        if ( !getOcmbDataBundle(iv_chip)->iv_ceStopCounter.thReached(io_sc) &&
             !getOcmbDataBundle(iv_chip)->iv_ueStopCounter.thReached(io_sc) )
        {
            // If the stop conditions aren't set, just break out.
            if ( !(0xf != reg->GetBitFieldJustified(0,4) && // NCE int TH
                   0xf != reg->GetBitFieldJustified(4,4) && // NCE soft TH
                   0xf != reg->GetBitFieldJustified(8,4)) ) // NCE hard TH
            {
                break;
            }

        }

        // If we haven't hit UE threshold yet, check the UE stop condition
        if ( !getOcmbDataBundle(iv_chip)->iv_ueStopCounter.thReached(io_sc) )
        {
            // If the stop condition isn't set, just break out
            if ( !reg->IsBitSet(35) ) // pause on UE
            {
                break;
            }
        }

        // Need to check the stop on mpe stop condition regardless of whether
        // we hit the UE or CE threshold.
        if ( reg->IsBitSet(34) ) // pause on MPE
        {
            // If we reach here, all the stop conditions are set for background
            // scrub, so we can resume.
            o_canResume = true;
        }
    }while(0);

    return o_rc;

    #undef PRDF_FUNC
}

//------------------------------------------------------------------------------

// Avoid linker errors with the template.
template class MemTdCtlr<TYPE_OCMB_CHIP>;

//------------------------------------------------------------------------------

} // end namespace PRDF


