/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/generic/memory/lib/utils/power_thermal/gen_throttle.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2019,2024                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
///
/// @file gen_throttle.H
/// @brief throttle API
///

// *HWP HWP Owner: Louis Stermole <stermole@us.ibm.com>
// *HWP HWP Backup: Stephen Glancy <sglancy@us.ibm.com>
// *HWP Team: Memory
// *HWP Level: 3
// *HWP Consumed by: FSP:HB

#ifndef _MSS_GEN_POWER_THROTTLE_
#define _MSS_GEN_POWER_THROTTLE_

#include <fapi2.H>
#include <generic/memory/lib/utils/shared/mss_generic_consts.H>
#include <generic/memory/lib/utils/power_thermal/gen_throttle_traits.H>
#include <generic/memory/lib/utils/count_dimm.H>
#include <mss_generic_system_attribute_getters.H>
#include <mss_generic_system_attribute_setters.H>
#include <mss_generic_attribute_setters.H>
#include <mss_generic_attribute_getters.H>
#include <generic/memory/lib/utils/mss_math.H>
#include <generic/memory/lib/utils/pos.H>
#ifndef __PPE__
    #include <generic/memory/lib/utils/dimm/kind.H>
#endif
#include <generic/memory/lib/utils/mss_generic_check.H>

namespace mss
{

namespace power_thermal
{

///
/// @brief throttle constants used in the power_thermal functions
///
enum throttle_const : size_t
{
    /// Dram data bus utilization is bus utilization / 4
    DRAM_BUS_UTILS = 4,

    /// 10000 to convert to and from c%
    UTIL_CONVERSION = 10000,

    /// Conversion to percentage
    PERCENT_CONVERSION = 100,

};

///
/// @brief Calculate the N throttle for a given dram data bus utilization value
///
/// @tparam T1  template parameter, type of input to be processed
/// @tparam T2  template parameter, type of input to be processed
/// @param[in]  i_dram_util    dram data bus utilization value in c%
/// @param[in]  i_throttle_m   M throttle value in N/M throttling
///
/// @return uint32_t calculated N throttle value
///
template<typename T1, typename T2>
inline uint32_t calc_n_from_dram_util(const T1 i_dram_util, const T2 i_throttle_m)
{
    constexpr uint64_t CONVERT_ADDR_UTIL_TO_DATA_UTIL = 4;

    const T1 l_numerator = i_dram_util * static_cast<T1>(i_throttle_m);
    return (static_cast<uint32_t>(l_numerator
                                  / (CONVERT_ADDR_UTIL_TO_DATA_UTIL)
                                  / (PERCENT_CONVERSION)
                                  / (PERCENT_CONVERSION)
                                 )
           );
}

#ifndef __PPE__
///
/// @brief Calculate N (address operations) allowed within a window of M DRAM clocks
/// @param[in] i_databus_util databus utilization percentage (e.g. 5% = 5)
/// @param[in] i_num_dram_clocks window of M DRAM clocks
/// @return number of throttled commands allowed
/// @note Uses N/M Throttling.
/// Equation:  N = (DRAM data bus utilization * M) / (4 * 10000)
///
inline uint32_t throttled_cmds(const uint32_t i_databus_util, const uint32_t i_num_dram_clocks)
{
    constexpr uint64_t l_divisor = DRAM_BUS_UTILS * UTIL_CONVERSION;
    const uint64_t l_dividend = i_databus_util * i_num_dram_clocks;
    const uint64_t l_result = l_dividend / l_divisor;

    //Make sure N is not equal to 0, or we brick the dram until reboot
    return ((l_result == 0) ? 1 : l_result);
}

///
/// @brief Perform thermal calculations as part of the effective configuration
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target the MCS target in which the runtime throttles will be reset
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode restore_runtime_throttles(const fapi2::Target<T>& i_target );

///
/// @brief Perform thermal calculations as part of the effective configuration (with optimization)
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target the MCS target in which the runtime throttles will be reset
/// @param[in] i_throttle_type denotes if this should be done for POWER or THERMAL throttles
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode restore_runtime_throttles(const fapi2::Target<T>& i_target,
        const mss::throttle_type i_throttle_type);

///
/// @brief Update the runtime throttles to the worst case of the general throttle values and the runtime values
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target the MCS target in which the runtime throttles will be set
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode update_runtime_throttle(const fapi2::Target<T>& i_target);

///
/// @brief Update the runtime throttles to the worst case of the general throttle values and the runtime values (with optimization)
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target the MCS target in which the runtime throttles will be set
/// @param[in] i_throttle_type denotes if this should be done for POWER or THERMAL throttles
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode update_runtime_throttle(const fapi2::Target<T>& i_target,
        const mss::throttle_type i_throttle_type);

///
/// @brief Update the runtime throttles to the worst case of the general throttle values and the runtime values
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target the MCS target in which the runtime throttles will be set
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode update_runtime_throttles(const std::vector< fapi2::Target<T> >& i_targets)

{
    for (const auto& l_mc : i_targets)
    {
        FAPI_TRY(update_runtime_throttle(l_mc));
    }

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Update the runtime throttles to the worst case of the general throttle values and the runtime values (with optimization)
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target the MCS target in which the runtime throttles will be set
/// @param[in] i_throttle_type denotes if this should be done for POWER or THERMAL throttles
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode update_runtime_throttles(const std::vector< fapi2::Target<T> >& i_targets,
        const mss::throttle_type i_throttle_type)

{
    for (const auto& l_mc : i_targets)
    {
        FAPI_TRY(update_runtime_throttle(l_mc, i_throttle_type));
    }

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Updates the max databus utilization based upon the DIMM type
/// @tparam MC mss::mc_type of the memory controller
/// @param[in] i_target the target on which to operate
/// @param[in,out] io_max_util the utilization of the dimm at maximum possible percentage (mrw or calculated)
/// @return fapi2::FAPI2_RC_SUCCESS iff the method was a success
///
template<mss::mc_type MC>
fapi2::ReturnCode update_max_util_by_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        double& io_max_util);

///
/// @brief Updates the database port max utilization based upon the DIMM type
/// @tparam mc_type MC the type of the memory controller
/// @tparam fapi2::TargetType T the target type of i_target
/// @param[in] i_target the target on which to operate
/// @param[in] i_database_port_max the maximum utilization to use depending upon the DIMM type
/// @param[in,out] io_util the utilization of the dimm at maximum possible percentage (mrw or calculated)
/// @return fapi2::FAPI2_RC_SUCCESS iff the method was a success
///
template<mss::mc_type MC, fapi2::TargetType T>
fapi2::ReturnCode update_databus_port_max_util_by_dimm_type(const fapi2::Target<T>& i_target,
        const double i_databus_port_max,
        double& io_util);


///
/// @class throttle
/// @brief Determine power_thermal throttles for memory
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
///
template<mss::mc_type MC, typename TT = throttle_traits<MC>>
class throttle
{
    private:
        ///
        /// @brief Calculate the power (cW) of inputs and the power curve
        /// @tparam T the type of i_util and return value
        /// @param[in] i_util the databus utilization that the power will be based on
        /// @param[in] l_pos the dimm position for the power value being calculated.
        /// @return Integral type T
        ///
        template<typename T>
        inline T calc_power (const T i_util, const size_t i_pos, fapi2::ReturnCode& o_rc ) const
        {
            o_rc = fapi2::FAPI2_RC_SUCCESS;
            FAPI_ASSERT( (i_pos < TT::DIMMS_PER_PORT),
                         fapi2::MSS_POWER_THERMAL_DIMM_INDEX_OUT_OF_BOUND()
                         .set_PORT_TARGET(iv_target)
                         .set_INPUT_SIZE(i_pos)
                         .set_MAX_SIZE(TT::DIMMS_PER_PORT),
                         "The dimm is index is out of bound for the port index: %d, max: %d for port " GENTARGTIDFORMAT,
                         i_pos, TT::DIMMS_PER_PORT, GENTARGTID(iv_target) );

            return ((i_util / UTIL_CONVERSION) * iv_pwr_slope[i_pos]) + iv_pwr_int[i_pos];

        fapi_try_exit:
            o_rc = fapi2::current_err;
            return 0;
        }

        ///
        /// @brief Raise the o_value by the percent passed in
        /// @param[in] i_uplift the percent the o_Value should be raised by
        /// @param[out] o_value the value that will be modified
        ///
        inline void calc_power_uplift (const uint8_t i_uplift, double& o_value) const
        {
            o_value *= (1 + (static_cast<double>(i_uplift) / PERCENT_CONVERSION));
        }

    public:
        const fapi2::Target<TT::PORT_TARGET_TYPE>& iv_target;

        uint32_t iv_databus_port_max;
        uint32_t iv_min_util_port;

        uint8_t iv_power_uplift_idle;
        uint8_t iv_power_uplift;

        uint16_t iv_runtime_n_slot;
        uint16_t iv_runtime_n_port;
        uint32_t iv_m_clocks;
        uint32_t iv_dimm_thermal_limit[TT::DIMMS_PER_PORT] = {};
        uint16_t iv_pwr_slope[TT::DIMMS_PER_PORT] = {};
        uint16_t iv_pwr_int[TT::DIMMS_PER_PORT] = {};
        uint16_t iv_n_slot;
        uint16_t iv_n_port;
        uint32_t iv_port_power_limit;
        uint32_t iv_calc_port_maxpower;

        //default ctor deleted
        throttle() = delete;

        ///
        /// @brief Constructor
        /// @param[in] i_target port target to call power thermal stuff on
        /// @param[out] o_rc fapi2::ReturnCode fapi2::FAPI2_RC_SUCCESS iff ctor was successful
        ///
        throttle( const fapi2::Target<TT::PORT_TARGET_TYPE>& i_port, fapi2::ReturnCode& o_rc);

        //
        // @brief Destructor
        //
        ~throttle() = default;

        ///
        /// @brief Calculates the min and max power usage for a port
        /// @param[in] i_idle_util the utilization of the databus in idle mode
        /// @param[in] i_max_util  the utilization of the port at maximum possible (mrw or calculated)
        /// @param[out] o_port_power_idle max value of port power in cW
        /// @param[out] o_port_power_max max value of port power in cW
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
        /// @note Called twice in p9_mss_bulk_pwr_throttles
        ///
        fapi2::ReturnCode calc_port_power( const double i_idle_util [TT::DIMMS_PER_PORT],
                                           const double i_max_util [TT::DIMMS_PER_PORT],
                                           double& o_port_power_idle,
                                           double& o_port_power_max) const;
        ///
        /// @brief Calculates max and min power usages based off of DIMM power curves
        /// @param[in] i_databus_port_max max databus utilization for the port (either calculated or mrw)
        /// @param[in] i_port_power_calc_idle double of the port's power consumption at idle
        /// @param[out] o_dimm_power_idle array of dimm power in cW
        /// @param[out] o_dimm_power_max array of dimm power in cW
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
        /// @note Called in p9_mss_bulk_pwr_throttles
        /// @note used for the thermal throttles
        ///
        fapi2::ReturnCode calc_dimm_power(const double i_databus_idle,
                                          const double i_databus_max,
                                          double o_dimm_power_idle [TT::DIMMS_PER_PORT],
                                          double o_dimm_power_max [TT::DIMMS_PER_PORT]) const;

        ///
        /// @brief Calculate the power curve in order to calculate databus utilization
        /// @param[in] i_power_idle double of the port's power consumption at idle
        /// @param[in] i_power_max double of the port's power consumption at max utilization
        /// @param[out] o_power_slope
        /// @param[out] o_power_int
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
        /// @note Called in p9_mss_bulk_pwr_throttles
        /// @note Power curve needed to calculate the utilization
        ///
        fapi2::ReturnCode calc_power_curve(const double i_power_idle,
                                           const double i_power_max,
                                           uint32_t& o_power_slope,
                                           uint32_t& o_power_int) const;
        ///
        /// @brief Calculate the databus utilization given the power curve
        /// @param[in] i_slope the slope of power curve
        /// @param[in] i_int the intercept of power curve
        /// @param[in] i_power_limit either iv_port_power_limit or thermal_power_limit depending on throttle type
        /// @param[out] o_port_util the port's databus utilization
        /// @return fapi2::FAPI2_RC_SUCCESS iff the method was a success
        /// @note Called in p9_mss_bulk_pwr_throttles
        /// @note Chooses worst case between the maximum allowed databus utilization and the calculated value
        ///
        fapi2::ReturnCode calc_util_usage(const uint32_t i_slope,
                                          const uint32_t i_int,
                                          const uint32_t i_power_limit,
                                          double& o_util) const;
        ///
        /// @brief set iv_n_port, iv_n_slot, iv_calc_port_maxpower
        /// @param[in] i_util_port pass in the calculated port databus utilization
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
        ///
        fapi2::ReturnCode calc_slots_and_power (const double i_util_port);

        ///
        /// @brief calculated the output power estimate from the calculated N throttle
        /// @param[in] i_n_slot the N throttle per slot
        /// @param[in] i_n_port the N throttle per port
        /// @param[out] o_power the calculated power
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
        ///
        fapi2::ReturnCode calc_power_from_n (const uint16_t i_n_slot, const uint16_t i_n_port, uint32_t& o_power) const;

        ///
        /// @brief Converts the port maximum databus util to a dimm level based on powerslopes and dimms installed
        /// @param[in] i_databus_port_max max databus utilization for the port (either calculated or mrw)
        /// @param[out] o_databus_dimm_max array of dimm utilization values
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
        /// @note Called in p9_mss_bulk_pwr_throttles
        /// @used to calculate the port power based off of DIMM power curves
        ///
        fapi2::ReturnCode calc_databus( const double i_databus_port_max,
                                        double o_databus_dimm_max [TT::DIMMS_PER_PORT]);
        ///
        /// @brief Converts the port and slot util to a dimm level based on powerslopes and number of dimms installed
        /// @param[in] i_util_slot databus utilization for the slot
        /// @param[in] i_util_port databus utilization for the port
        /// @param[out] o_util_dimm_max array of dimm utilization values
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
        /// @note determines worst case utilization per dimms, takes into account port and combine slot throttles
        ///
        fapi2::ReturnCode calc_split_util(
            const double i_util_slot,
            const double i_util_port,
            double o_util_dimm_max [TT::DIMMS_PER_PORT]) const;

        ///
        /// @brief Calculate ATTR_MSS_CHANNEL_PAIR_MAXPOWER and  ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
        /// @note Called in p9_mss_bulk_pwr_throttles
        /// @note determines the throttle levels based off of the port's power curve, max databus utilization,
        /// and memwat target.
        /// @note currently sets the slot and port throttles to the same value
        ///
        fapi2::ReturnCode power_regulator_throttles ();

        ///
        /// @brief Set ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
        /// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
        /// @note Called in p9_mss_bulk_pwr_throttles
        /// @note Sets the throttle levels based off of the dimm's thermal limits
        /// @note both DIMM's on a port are set to the same throttle level
        ///
        fapi2::ReturnCode thermal_throttles ();

        ///
        /// @brief Calculate the port databus utilization based off of N throttles and M dram clocks
        /// @param[in] i_n_throttles N (address operations) allowed within a window of M DRAM clocks
        /// @param[in] i_num_dram_clocks window of M DRAM clocks
        /// @param[out] o_calc_util
        /// @return FAPI2_RC_SUCCESS iff method was a success
        /// @note Uses N/M Throttling.
        /// @note DRAM databus utilization = N * 4 * 10000 / M
        ///
        fapi2::ReturnCode calc_util_from_throttles(const uint16_t i_n_throttles,
                const uint32_t i_num_dram_clocks,
                double& o_calc_util) const;

};

///
/// @brief Constructor
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_target MCS target to call power thermal stuff on
/// @param[out] o_rc, a return code which determines the success of the constructor
///
template<mss::mc_type MC, typename TT>
throttle<MC, TT>::throttle( const fapi2::Target<TT::PORT_TARGET_TYPE>& i_port, fapi2::ReturnCode& o_rc) :
    iv_target(i_port),
    iv_databus_port_max(0),
    iv_min_util_port(0),
    iv_runtime_n_slot(0),
    iv_runtime_n_port(0),
    iv_n_slot(0),
    iv_n_port(0),
    iv_port_power_limit(0),
    iv_calc_port_maxpower(0)
{
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                           iv_databus_port_max));
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_MSS_SAFEMODE_DRAM_DATABUS_UTIL, iv_target, iv_min_util_port));
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                           iv_power_uplift));
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE,
                           fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), iv_power_uplift_idle));
    FAPI_TRY(mss::attr::get_dimm_thermal_limit(iv_target, iv_dimm_thermal_limit));
    FAPI_TRY(mss::attr::get_total_pwr_intercept(iv_target, iv_pwr_int));
    FAPI_TRY(mss::attr::get_total_pwr_slope(iv_target, iv_pwr_slope));
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, iv_target, iv_runtime_n_slot));
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_EXP_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, iv_target, iv_runtime_n_port));
    FAPI_TRY(FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), iv_m_clocks));

    //Port power limit = sum of dimm power limits
    for ( const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target) )
    {
        uint32_t l_dimm_limit = 0;
        FAPI_TRY( mss::attr::get_mem_watt_target( l_dimm, l_dimm_limit) );
        iv_port_power_limit += l_dimm_limit;
    }

    FAPI_INF_NO_SBE("Setting up throttle for target " GENTARGTIDFORMAT ", Values are: max databus is %d, uplifts are %d %d",
                    GENTARGTID(iv_target),
                    iv_databus_port_max,
                    iv_power_uplift,
                    iv_power_uplift_idle);
    FAPI_INF_NO_SBE("Setting up throttle for target " GENTARGTIDFORMAT ", runtime throttles are %d %d",
                    GENTARGTID(iv_target),
                    iv_runtime_n_slot,
                    iv_runtime_n_port);

    FAPI_INF_NO_SBE("Safemode util (min util allowed) is %d c (centi-percent) for target " GENTARGTIDFORMAT,
                    iv_min_util_port,
                    GENTARGTID(iv_target));

    FAPI_INF_NO_SBE("The dimm power limit is %d, dram clocks are %d for " GENTARGTIDFORMAT,
                    iv_port_power_limit,
                    iv_m_clocks,
                    GENTARGTID(iv_target));
    FAPI_INF_NO_SBE("dimm power curve slopes are %d %d for " GENTARGTIDFORMAT,
                    iv_pwr_slope[0],
                    iv_pwr_slope[1],
                    GENTARGTID(iv_target));

    FAPI_INF_NO_SBE("DIMM power curve intercepts are %d %d for " GENTARGTIDFORMAT,
                    iv_pwr_int[0],
                    iv_pwr_int[1],
                    GENTARGTID(iv_target));
    FAPI_INF_NO_SBE("DIMM power thermal limits are %d %d for " GENTARGTIDFORMAT,
                    iv_dimm_thermal_limit[0],
                    iv_dimm_thermal_limit[1],
                    GENTARGTID(iv_target));

    FAPI_ASSERT( (iv_databus_port_max != 0),
                 fapi2::MSS_NO_DATABUS_UTILIZATION()
                 .set_PORT_TARGET(iv_target)
                 .set_PORT_DATABUS_UTIL(iv_databus_port_max)
                 .set_DIMM_COUNT(mss::count_dimm(iv_target)),
                 "Failed to get max databus utilization for target " GENTARGTIDFORMAT,
                 GENTARGTID(iv_target));

    FAPI_ASSERT( (iv_min_util_port != 0),
                 fapi2::MSS_NO_SAFEMODE_UTILIZATION()
                 .set_PORT_TARGET(iv_target)
                 .set_PORT_DATABUS_UTIL(iv_min_util_port),
                 "Failed to get safemode utilization for target " GENTARGTIDFORMAT,
                 GENTARGTID(iv_target));

    FAPI_ASSERT( (iv_port_power_limit != 0),
                 fapi2::MSS_NO_PORT_POWER_LIMIT()
                 .set_PORT_TARGET(iv_target)
                 .set_COUNT_DIMMS( mss::count_dimm(iv_target))
                 .set_PORT_POWER_LIMIT( iv_port_power_limit),
                 "Error calculating port_power_limit on target " GENTARGTIDFORMAT " with %d DIMMs installed",
                 GENTARGTID(iv_target),
                 iv_port_power_limit);

    //Checking to make sure all of the attributes are valid
    for ( const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target) )
    {
        const auto l_pos = mss::index(l_dimm);
        FAPI_ASSERT( (iv_pwr_int[l_pos] != 0),
                     fapi2::MSS_POWER_INTERCEPT_NOT_SET()
                     .set_PORT_TARGET(iv_target),
                     "The attribute ATTR_MSS_TOTAL_PWR_INTERCEPT equals 0 for " GENTARGTIDFORMAT,
                     GENTARGTID(l_dimm));

        FAPI_ASSERT( (iv_pwr_slope[l_pos] != 0),
                     fapi2::MSS_POWER_SLOPE_NOT_SET()
                     .set_PORT_TARGET(iv_target),
                     "The attribute ATTR_MSS_TOTAL_PWR_SLOPE equals 0 for " GENTARGTIDFORMAT,
                     GENTARGTID(l_dimm));
    }

fapi_try_exit:
    o_rc = fapi2::current_err;
    return;
}

///
/// @brief Set ATTR_MSS_CHANNEL_PAIR_MAXPOWER, ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT and _PER_PORT
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note determines the throttle levels based off of the port's power curve,
/// the _per_slot throttles are set to the _per_port values
/// throttles are all equalized and set to the worst case value
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::power_regulator_throttles()
{
    double l_port_power_calc_idle = 0;
    double l_port_power_calc_max = 0;
    uint32_t l_port_power_slope = 0;
    uint32_t l_port_power_int = 0;
    double l_calc_util_port = 0;
    double  l_databus_dimm_max[TT::DIMMS_PER_PORT] = {};
    double  l_calc_databus_port_idle[TT::DIMMS_PER_PORT] = {TT::IDLE_UTIL};

    //Decide utilization for each dimm based off of dimm count and power slopes
    FAPI_TRY( calc_databus(iv_databus_port_max, l_databus_dimm_max),
              "Failed to calculate each DIMMs' percentage of dram databus utilization for target " GENTARGTIDFORMAT
              ", max port databus is %d",
              GENTARGTID(iv_target),
              iv_databus_port_max);

    //Use the dimm utilizations and dimm power slopes to calculate port min and max power
    FAPI_TRY( calc_port_power(l_calc_databus_port_idle,
                              l_databus_dimm_max,
                              l_port_power_calc_idle,
                              l_port_power_calc_max),
              "Failed to calculate the max and idle power for port " GENTARGTIDFORMAT,
              GENTARGTID(iv_target));

    FAPI_INF_NO_SBE("POWER throttles: " GENTARGTIDFORMAT " max port power is %u", GENTARGTID(iv_target),
                    static_cast<uint32_t>(l_port_power_calc_max));

    //Calculate the power curve slope and intercept using the port's min and max power values
    FAPI_TRY(calc_power_curve(l_port_power_calc_idle,
                              l_port_power_calc_max,
                              l_port_power_slope,
                              l_port_power_int),
             "Failed to calculate the power curve for port " GENTARGTIDFORMAT ", calculated port power max is %u, idle is %u",
             GENTARGTID(iv_target),
             static_cast<uint32_t>(l_port_power_calc_max),
             static_cast<uint32_t>(l_port_power_calc_idle));

    FAPI_INF_NO_SBE(GENTARGTIDFORMAT " POWER Port power limit is %d", GENTARGTID(iv_target), iv_port_power_limit);

    //Calculate the port's utilization to get under watt target using the port's calculated slopes
    FAPI_TRY(calc_util_usage(l_port_power_slope,
                             l_port_power_int,
                             iv_port_power_limit,
                             l_calc_util_port), GENTARGTIDFORMAT " Error in calc_util_usage", GENTARGTID(iv_target));

    FAPI_INF_NO_SBE(GENTARGTIDFORMAT " POWER calc util port is %u",  GENTARGTID(iv_target),
                    static_cast<uint32_t>(l_calc_util_port));

    //Calculate the new slot values and the max power value for the port
    FAPI_TRY( calc_slots_and_power(l_calc_util_port),
              GENTARGTIDFORMAT
              " Error calculating the final throttles and power values for target with passed in port utilization %u",
              GENTARGTID(iv_target),
              static_cast<uint32_t>(l_calc_util_port));

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief set iv_n_port, iv_n_slot, iv_calc_port_maxpower
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_util_port pass in the calculated port databus utilization
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_slots_and_power(const double i_util_port)
{
    //Calculate the Port N throttles
    iv_n_port = power_thermal::throttled_cmds(i_util_port, iv_m_clocks);

    //Set iv_n_slot to the lower value between the slot runtime and iv_n_port
    iv_n_slot = (iv_runtime_n_slot != 0) ? std::min(iv_n_port, iv_runtime_n_slot) : iv_n_port;

    //Choose the lowest value of the runtime and the calculated
    iv_n_port = (iv_runtime_n_port != 0) ? std::min(iv_n_port, iv_runtime_n_port) : iv_n_port;

    //Use the throttle value to calculate the power that gets to exactly that value
    FAPI_TRY(calc_power_from_n(iv_n_slot, iv_n_port, iv_calc_port_maxpower));

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Set ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT and PER_PORT
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note Sets the throttle levels based off of the dimm's thermal limits
/// both DIMM's on a port are set to the same throttle level
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::thermal_throttles()
{
    double l_dimm_power_idle [TT::DIMMS_PER_PORT] = {};
    double l_dimm_power_max [TT::DIMMS_PER_PORT] = {};
    uint32_t l_dimm_power_slope [TT::DIMMS_PER_PORT] = {};
    uint32_t l_dimm_power_int [TT::DIMMS_PER_PORT] = {};
    double l_calc_util [TT::DIMMS_PER_PORT] = {};
    const auto l_count = count_dimm(iv_target);
    uint8_t l_found_ddimm = 0;

    //Calculate the dimm power range for each dimm at max utilization for each
    FAPI_TRY(calc_dimm_power(TT::IDLE_UTIL,
                             iv_databus_port_max,
                             l_dimm_power_idle,
                             l_dimm_power_max));

    //Let's calculate the N throttle for each DIMM
    for (const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target))
    {
        fapi2::ReturnCode l_rc = fapi2::FAPI2_RC_SUCCESS;
        uint16_t l_temp_n_slot = 0;
        const uint8_t l_pos = mss::relative_pos<MC, TT::PORT_TARGET_TYPE>(l_dimm);
        mss::dimm::kind<MC> l_kind(l_dimm, l_rc);
        FAPI_TRY(l_rc, GENTARGTIDFORMAT " Failed to create dimm::kind instance", GENTARGTID(l_dimm));
        l_found_ddimm = (l_kind.iv_dimm_type == fapi2::ENUM_ATTR_MEM_EFF_DIMM_TYPE_DDIMM) ? 1 : l_found_ddimm;
        //Calculate the power curve taking the thermal limit into account
        FAPI_TRY(calc_power_curve(l_dimm_power_idle[l_pos],
                                  l_dimm_power_max[l_pos],
                                  l_dimm_power_slope[l_pos],
                                  l_dimm_power_int[l_pos]),
                 "Failed to calculate the power curve for dimm " GENTARGTIDFORMAT
                 ", calculated dimm power curve slope is %d, intercept %d",
                 GENTARGTID(l_dimm),
                 l_dimm_power_slope[l_pos],
                 l_dimm_power_int[l_pos]);

        //Calculate the databus utilization at the calculated power curve
        FAPI_TRY(calc_util_usage(l_dimm_power_slope[l_pos],
                                 l_dimm_power_int[l_pos],
                                 iv_dimm_thermal_limit[l_pos],
                                 l_calc_util[l_pos]), "Failed calc_util_usage " GENTARGTIDFORMAT, GENTARGTID(l_dimm));

        FAPI_INF_NO_SBE("THERMAL throttles: " GENTARGTIDFORMAT " dram databus utilization is %u", GENTARGTID(l_dimm),
                        static_cast<uint32_t>(l_calc_util[l_pos]));

        l_temp_n_slot = power_thermal::throttled_cmds (l_calc_util[l_pos], iv_m_clocks);

        //Set to the min between the two value
        //If iv_n_slot == 0 (so uninitialized), set it to the calculated slot value
        //The l_n_slot value can't be equal to 0 because there's a dimm installed
        if ((l_temp_n_slot < iv_n_slot) || (iv_n_slot == 0))
        {
            iv_n_slot = l_temp_n_slot;
        }
    }

    //Set to lowest value between calculated and runtime
    FAPI_INF_NO_SBE("THERMAL throttles: runtime slot is %d, calc n slot is %d for " GENTARGTIDFORMAT, iv_runtime_n_slot,
                    iv_n_slot,
                    GENTARGTID(iv_target));
    //DDIMMs: Taking the min of the SLOT and the iv_runtime_port throttle value
    //ISDIMMs: Taking the min of the SLOT * (# of dimms on the port) and the iv_runtime_port throttle value
    //Thermal throttling happens after the POWER calculations. the iv_runtime_n_port value shouldn't be set to 0
    iv_n_port = (l_found_ddimm) ?
                std::min(iv_runtime_n_port, static_cast<uint16_t>(iv_n_slot)) :
                std::min(iv_runtime_n_port, static_cast<uint16_t>(iv_n_slot * l_count));
    iv_n_port = (iv_n_port == 0) ? TT::MIN_THROTTLE : iv_n_port;

    iv_n_slot = std::min(iv_n_slot, iv_runtime_n_slot);
    iv_n_slot = (iv_n_slot == 0) ? TT::MIN_THROTTLE : iv_n_slot;

    //Now time to get and set iv_calc_port_max from the calculated N throttle
    FAPI_TRY(calc_power_from_n(iv_n_slot, iv_n_port, iv_calc_port_maxpower),
             "Failed to calculate the final max port maxpower. Slot throttle value is %d, port value is %d for " GENTARGTIDFORMAT,
             iv_n_slot,
             iv_n_port,
             GENTARGTID(iv_target));

    return fapi2::FAPI2_RC_SUCCESS;
fapi_try_exit:
    FAPI_ERR("Error calculating mss::power_thermal::thermal_throttles() for " GENTARGTIDFORMAT, GENTARGTID(iv_target));
    return fapi2::current_err;
}

///
/// @brief Calculates the min and max power usage for a port based off of power curves and utilizations
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_idle_util the utilization of the databus in idle mode (0% most likely)
/// @param[in] i_max_util the utilization of the dimm at maximum possible percentage (mrw or calculated)
/// @param[out] o_port_power_idle max value of port power in cW
/// @param[out] o_port_power_max max value of port power in cW
/// @return fapi2::FAPI2_RC_SUCCESS iff the method was a success
/// @note uses dimm power curves from class variables
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_port_power(const double i_idle_util[TT::DIMMS_PER_PORT],
        const double i_max_util[TT::DIMMS_PER_PORT],
        double& o_port_power_idle,
        double& o_port_power_max) const
{
    //Playing it safe
    o_port_power_idle = 0;
    o_port_power_max = 0;
    fapi2::ReturnCode l_rc;

    //Calculate the port power curve info by summing the dimms on the port
    for (const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target))
    {
        const auto l_pos = mss::relative_pos<MC, TT::PORT_TARGET_TYPE>(l_dimm);

        // Updates the max power utilization by the DIMM type
        double l_max_util = i_max_util[l_pos];
        FAPI_TRY(update_max_util_by_dimm_type<MC>(l_dimm, l_max_util));

        //Printing as decimals because HB messes up floats
        FAPI_INF_NO_SBE(GENTARGTIDFORMAT " max dram databus for DIMM in pos %d is %u, databus for idle is %u",
                        GENTARGTID(iv_target),
                        l_pos,
                        static_cast<uint32_t>(l_max_util),
                        static_cast<uint32_t>(i_idle_util[l_pos]));
        //Sum up the dimm's power to calculate the port power curve
        o_port_power_idle += calc_power(i_idle_util[l_pos], l_pos, l_rc);
        FAPI_TRY(l_rc, "calc_power failed on " GENTARGTIDFORMAT, GENTARGTID(l_dimm));
        o_port_power_max  += calc_power(l_max_util, l_pos, l_rc);
        FAPI_TRY(l_rc, "calc_power failed on " GENTARGTIDFORMAT, GENTARGTID(l_dimm));
    }

    //Raise the powers by the uplift percent
    calc_power_uplift(iv_power_uplift_idle, o_port_power_idle);
    calc_power_uplift(iv_power_uplift, o_port_power_max);

    if (o_port_power_max <= 0)
    {
        FAPI_ERR("No Port Power limit was calculated for " GENTARGTIDFORMAT
                 ", %d DIMMs installed",
                 GENTARGTID(iv_target),
                 mss::count_dimm(iv_target));
        FAPI_ERR(GENTARGTIDFORMAT ", DIMM 0 Utils Idle %d Max %d, DIMM 1 Utils Idle %d Max %d",
                 GENTARGTID(iv_target),
                 i_idle_util[0],
                 i_max_util[0],
                 i_idle_util[1],
                 i_max_util[1]);
        FAPI_ASSERT( false,
                     fapi2::MSS_NO_PORT_POWER()
                     .set_PORT_TARGET(iv_target)
                     .set_COUNT_DIMMS(mss::count_dimm(iv_target))
                     .set_IDLE_UTILIZATION_DIMM_0(i_idle_util[0])
                     .set_IDLE_UTILIZATION_DIMM_1(i_idle_util[1])
                     .set_MAX_UTILIZATION_DIMM_0(i_max_util[0])
                     .set_MAX_UTILIZATION_DIMM_1(i_max_util[1]),
                     "No Port Power limit was calculated for " GENTARGTIDFORMAT
                     ". See above error messages for details.",
                     GENTARGTID(iv_target));
    }

    //FAPI_ASSERTs don't set the current err to good
    return fapi2::FAPI2_RC_SUCCESS;
fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Calculates max and min power usages based off of DIMM power curves
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_databus_idle idle databus utilization (either calculated or mrw)
/// @param[in] i_databus_max max databus utilization (either calculated or mrw)
/// @param[out] o_dimm_power_idle array of dimm power in cW
/// @param[out] o_dimm_power_max array of dimm power in cW
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
/// @note used for the thermal throttles
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_dimm_power(const double i_databus_idle,
        const double i_databus_max,
        double o_dimm_power_idle[TT::DIMMS_PER_PORT],
        double o_dimm_power_max[TT::DIMMS_PER_PORT]) const
{
    for (const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target))
    {
        char fapi_target_str[128] = { };
        fapi2::toString(l_dimm, fapi_target_str, sizeof(fapi_target_str));

        fapi2::ReturnCode l_rc;
        const uint8_t l_pos = mss::relative_pos<MC, TT::PORT_TARGET_TYPE>(l_dimm);
        o_dimm_power_idle[l_pos] = calc_power(i_databus_idle, l_pos, l_rc);
        FAPI_TRY(l_rc, "calc_power (idle) failed on %s", fapi_target_str);
        o_dimm_power_max[l_pos]  = calc_power(i_databus_max, l_pos, l_rc);
        FAPI_TRY(l_rc, "calc_power (max) failed on %s", fapi_target_str);

        //Raise the powers by the uplift percent
        calc_power_uplift(iv_power_uplift_idle, o_dimm_power_idle[l_pos]);
        calc_power_uplift(iv_power_uplift, o_dimm_power_max[l_pos]);

        FAPI_INF_NO_SBE("Calc_dimm_power: dimm (%d) power max is %u for " GENTARGTIDFORMAT,
                        l_pos,
                        static_cast<uint32_t>(o_dimm_power_max[l_pos]),
                        GENTARGTID(l_dimm));
        FAPI_INF_NO_SBE("Calc_dimm_power: dimm (%d) dimm slope %d, intercept %d for " GENTARGTIDFORMAT,
                        l_pos,
                        iv_pwr_slope[l_pos],
                        iv_pwr_int[l_pos],
                        GENTARGTID(l_dimm));
    }

    return fapi2::FAPI2_RC_SUCCESS;

fapi_try_exit:
    FAPI_INF_NO_SBE("Error calculating mss::power_thermal::calc_dimm_power for " GENTARGTIDFORMAT, GENTARGTID(iv_target));
    return fapi2::current_err;
}

///
/// @brief Calculate the port power curve in order to calculate the port utilization
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_power_idle double of the port's power consumption at idle
/// @param[in] i_power_max double of the port's power consumption at max utilization
/// @param[out] o_slope
/// @param[out] o_int
/// @note Port power curve needed to calculate the port utilization
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_power_curve(const double i_power_idle,
        const double i_power_max,
        uint32_t& o_slope,
        uint32_t& o_int) const
{
    const double l_divisor = ((static_cast<double>(iv_databus_port_max) / UTIL_CONVERSION) - TT::IDLE_UTIL);
    FAPI_ASSERT ((l_divisor > 0),
                 fapi2::MSS_CALC_POWER_CURVE_DIVIDE_BY_ZERO()
                 .set_PORT_TARGET(iv_target)
                 .set_PORT_DATABUS_UTIL(iv_databus_port_max)
                 .set_UTIL_CONVERSION(UTIL_CONVERSION)
                 .set_IDLE_UTIL(iv_min_util_port)
                 .set_RESULT(l_divisor),
                 "Calculated zero for the divisor in calc_power_curve on target " GENTARGTIDFORMAT,
                 GENTARGTID(iv_target) );

    FAPI_ASSERT (((i_power_max - i_power_idle) > 0),
                 fapi2::MSS_CALC_POWER_CURVE_NEGATIVE_OR_ZERO_SLOPE()
                 .set_PORT_TARGET(iv_target)
                 .set_PORT_IDLE_POWER(i_power_idle)
                 .set_PORT_MAX_UTIL_POWER(i_power_max)
                 .set_RESULT(i_power_max - i_power_idle),
                 "Calculated zero or negative value for the slope in calc_power_curve (%u - %u) on target " GENTARGTIDFORMAT,
                 static_cast<uint32_t>(i_power_max), static_cast<uint32_t>(i_power_idle), GENTARGTID(iv_target) );

    o_slope = (i_power_max - i_power_idle) / l_divisor;
    o_int = i_power_idle - (o_slope * TT::IDLE_UTIL);
    FAPI_INF_NO_SBE("Calc_power_curve: power idle is %u, max is %u for " GENTARGTIDFORMAT,
                    static_cast<uint32_t>(i_power_idle),
                    static_cast<uint32_t>(i_power_max),
                    GENTARGTID(iv_target));
    FAPI_INF_NO_SBE("Calc_power_curve: slope is %d, int is %d for " GENTARGTIDFORMAT,
                    o_slope,
                    o_int,
                    GENTARGTID(iv_target));

    return fapi2::FAPI2_RC_SUCCESS;

fapi_try_exit:
    FAPI_INF_NO_SBE("Error calculating mss::power_thermal::calc_power_curve for " GENTARGTIDFORMAT, GENTARGTID(iv_target));
    return fapi2::current_err;

}

///
/// @brief Calculate the databus utilization given the power curve
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_slope
/// @param[in] i_int
/// @param[in] i_power_limit either the port_power_limit or the dimm thermal power limit
/// @param[out] o_util the port's databus utilization
/// @return fapi2::FAPI2_RC_SUCCESS iff the method was a success
/// @note Called in p9_mss_bulk_pwr_throttles
/// @note Chooses worst case between the maximum allowed databus utilization and the calculated value
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_util_usage(const uint32_t i_slope,
        const uint32_t i_int,
        const uint32_t i_power_limit,
        double& o_util) const
{
    // Return 0 utilization if our intercept is above the power limit
    o_util = (i_power_limit > i_int) ? (((static_cast<double>(i_power_limit) - i_int) / i_slope ) * UTIL_CONVERSION) : 0;

    // Cast to uint32 for edge case where it has decimals
    o_util = (static_cast<uint32_t>(o_util) < iv_databus_port_max) ? static_cast<uint32_t>(o_util) : iv_databus_port_max;

    FAPI_TRY(update_databus_port_max_util_by_dimm_type<MC>(iv_target, iv_databus_port_max, o_util),
             "failed update_databus_port_max_util_by_dimm_type " GENTARGTIDFORMAT, GENTARGTID(iv_target));

    // Check for the minimum threshold and update if need be
    if(o_util < iv_min_util_port)
    {
        FAPI_INF_NO_SBE("Calculated utilization (%u) is less than the minimum utilization: %u. Setting to minimum value for "
                        GENTARGTIDFORMAT,
                        static_cast<uint32_t>(o_util),
                        static_cast<uint32_t>(iv_min_util_port), GENTARGTID(iv_target));
        o_util = iv_min_util_port;
    }

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Calculate the port databus utilization based off of N throttles and M dram clocks
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_n_throttles N (address operations) allowed within a window of M DRAM clocks
/// @param[in] i_num_dram_clocks window of M DRAM clocks
/// @param[out] o_calc_util
/// @return FAPI2_RC_SUCCESS iff method was a success
/// @note Uses N/M Throttling.
/// @note DRAM databus utilization = N * 4 * 10000 / M
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_util_from_throttles(const uint16_t i_n_throttles,
        const uint32_t i_num_dram_clocks,
        double& o_calc_util) const
{
    fapi2::current_err = fapi2::FAPI2_RC_SUCCESS;
    constexpr uint32_t l_multiplier = DRAM_BUS_UTILS * UTIL_CONVERSION;

    FAPI_ASSERT( (i_num_dram_clocks != 0),
                 fapi2::MSS_M_DRAM_CLOCKS_EQUALS_ZERO(),
                 "ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS was not set and equals zero");

    // brackets to avoid cross initialization compile errors (for above FAPI_ASSERT)
    {
        const uint64_t l_calc_util_uint64 = static_cast<uint64_t>((static_cast<double>(i_n_throttles) * l_multiplier) /
                                            i_num_dram_clocks);
        o_calc_util = (static_cast<double>(i_n_throttles) * l_multiplier) / i_num_dram_clocks;

        // Best way to check for overflow if o_calc_util can be a double?
        // If o_calc_util overflows, the value inside will be below the expected outcome
        // So compare o_calc_util with the calculated value, but store calculated value in largest storage
        // Compare ">=" because o_calc_util can be a double, and so we can't compare just equality due to truncation
        FAPI_ASSERT( o_calc_util >= l_calc_util_uint64,
                     fapi2::MSS_OUTPUT_OVERFLOW_CALC_UTIL()
                     .set_RESULT(o_calc_util)
                     .set_THROTTLES(i_n_throttles)
                     .set_DRAM_CLOCKS(i_num_dram_clocks)
                     .set_MULTIPLIER(l_multiplier),
                     "Overflow of output variable in calc_util_from_throttles throttles: %d, multiplier %d, dram_clocks %d",
                     i_n_throttles,
                     l_multiplier,
                     i_num_dram_clocks);

        // Check for the minimum
        if(o_calc_util < iv_min_util_port)
        {
            FAPI_INF_NO_SBE("Calculated utilization (%u) is less than the minimum utilization: %u. Setting to minimum value",
                            static_cast<uint32_t>(o_calc_util), static_cast<uint32_t>(iv_min_util_port));
            o_calc_util = iv_min_util_port;
        }

        FAPI_INF_NO_SBE("In calc_util_from_throttles, calculated %u for output utilization from throttles:%d, dram_clocks %d",
                        static_cast<uint32_t>(o_calc_util), i_n_throttles, i_num_dram_clocks);
    }

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief calculate the output power estimate from the calculated N throttle
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_n_slot the throttle per slot in terms of N commands
/// @param[in] i_n_port the throttle per port in terms of N commands
/// @param[out] o_power the calculated power
/// @return fapi2::ReturnCode iff it was a success
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_power_from_n (const uint16_t i_n_slot,
        const uint16_t i_n_port,
        uint32_t& o_power) const
{
    double l_calc_util_port = 0;
    double l_calc_util_slot = 0;
    double l_calc_databus_port_max[TT::DIMMS_PER_PORT] = {};
    double l_calc_databus_port_idle[TT::DIMMS_PER_PORT] = {};
    double l_port_power_max = 0;
    double l_port_power_idle = 0;

    FAPI_TRY( calc_util_from_throttles(i_n_slot, iv_m_clocks, l_calc_util_slot),
              GENTARGTIDFORMAT " Error calculating utilization from slot throttle %d and mem clocks %d",
              GENTARGTID(iv_target),
              i_n_slot,
              iv_m_clocks);
    FAPI_TRY( calc_util_from_throttles(i_n_port, iv_m_clocks, l_calc_util_port),
              GENTARGTIDFORMAT " Error calculating utilization from port throttle %d and mem clocks %d",
              GENTARGTID(iv_target),
              i_n_port,
              iv_m_clocks);

    //Determine the utilization for each DIMM that will maximize the port power
    FAPI_TRY( calc_split_util(l_calc_util_slot, l_calc_util_port, l_calc_databus_port_max),
              "Error splitting the utilization for target " GENTARGTIDFORMAT " with slot utilization %u and port util %u",
              GENTARGTID(iv_target),
              static_cast<uint32_t>(l_calc_util_slot),
              static_cast<uint32_t>(l_calc_util_port));

    FAPI_TRY( calc_port_power(l_calc_databus_port_idle,
                              l_calc_databus_port_max,
                              l_port_power_idle,
                              l_port_power_max),
              "Error calculating the port power value for " GENTARGTIDFORMAT ". Slot value is %d, port value is %d",
              GENTARGTID(iv_target),
              i_n_slot,
              i_n_port);

    o_power = mss::round_up(l_port_power_max);

fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Converts the port maximum databus to a dimm level based on powerslopes and dimms installed
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_databus_port_max max databus utilization for the port (either calculated or mrw)
/// @param[out] o_databus_dimm_max array of dimm utilization values
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
/// @note Called in p9_mss_bulk_pwr_throttles
/// @used to calculate the port power based off of DIMM power curves
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_databus (const double i_databus_port_max,
        double o_databus_dimm_max [TT::DIMMS_PER_PORT])
{
    const uint8_t l_count_dimms = count_dimm(iv_target);

    //No work for no dimms
    if (l_count_dimms == 0)
    {
        return fapi2::FAPI2_RC_SUCCESS;
    }

    for (const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target))
    {
        fapi2::ReturnCode l_rc = fapi2::FAPI2_RC_SUCCESS;
        //Left early if count_dimms == 0
        // For DDIMM, set each virtual DIMM to the same utilization value since mrw slope/intercept/limit attributes
        //   are equally divided by number of virtual dimms  (ie.  mrw values are for whole DDIMM, not individual virtual DIMMs)
        // For ISDIMM, divide utilization by number of DIMMs on the port
        mss::dimm::kind<MC> l_kind (l_dimm, l_rc);
        FAPI_TRY(l_rc, GENTARGTIDFORMAT " Failed to create dimm::kind instance", GENTARGTID(l_dimm));
        o_databus_dimm_max[mss::index(l_dimm)] = (l_kind.iv_dimm_type == fapi2::ENUM_ATTR_MEM_EFF_DIMM_TYPE_DDIMM) ?
                i_databus_port_max :
                i_databus_port_max / l_count_dimms;
    }

    //If the power slopes aren't equal, set the dimm with the highest power slope
    //Should be correct even if only one DIMM is installed
    if (iv_pwr_slope[0] != iv_pwr_slope[1])
    {
        o_databus_dimm_max[0] = (iv_pwr_slope[0] > iv_pwr_slope[1]) ? i_databus_port_max : 0;
        o_databus_dimm_max[1] = (iv_pwr_slope[1] > iv_pwr_slope[0]) ? i_databus_port_max : 0;
    }

    //Make sure both are not 0
    FAPI_ASSERT ( (o_databus_dimm_max[0] != 0) || (o_databus_dimm_max[1] != 0),
                  fapi2::MSS_NO_DATABUS_UTILIZATION()
                  .set_PORT_TARGET(iv_target)
                  .set_PORT_DATABUS_UTIL(i_databus_port_max)
                  .set_DIMM_COUNT(l_count_dimms),
                  "Failed to calculated databus utilization for target " GENTARGTIDFORMAT,
                  GENTARGTID(iv_target));

    return fapi2::FAPI2_RC_SUCCESS;
fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Converts the port and slot util to a dimm level based on powerslopes and number of dimms installed
/// @tparam MC mss::mc_type
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_util_slot databus utilization for the slot
/// @param[in] i_util_port databus utilization for the port
/// @param[out] o_util_dimm_max array of dimm utilization values
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff the split is OK
/// @note determines worst case utilization per dimms, takes into account port and combine slot throttles
/// @note used in calculating the port power, not for calculating the slot and port utilization
///
template<mss::mc_type MC, typename TT>
fapi2::ReturnCode throttle<MC, TT>::calc_split_util(
    const double i_util_slot,
    const double i_util_port,
    double o_util_dimm_max [TT::DIMMS_PER_PORT]) const
{
    uint8_t l_found_ddimm = 0;
    const uint8_t l_count_dimms = count_dimm (iv_target);
    //The total utilization to be used is limited by either what the port can allow or what the dimms can use
    FAPI_ASSERT( (i_util_slot <= i_util_port),
                 fapi2::MSS_SLOT_UTIL_EXCEEDS_PORT()
                 .set_PORT_TARGET(iv_target)
                 .set_SLOT_UTIL(i_util_slot)
                 .set_PORT_UTIL(i_util_port),
                 "The slot utilization (%u) exceeds the port's utilization (%u) for " GENTARGTIDFORMAT,
                 static_cast<uint32_t>(i_util_slot),
                 static_cast<uint32_t>(i_util_port),
                 GENTARGTID(iv_target));

    if (l_count_dimms == 0)
    {
        return fapi2::FAPI2_RC_SUCCESS;
    }

    for ( const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target) )
    {
        fapi2::ReturnCode l_rc = fapi2::FAPI2_RC_SUCCESS;
        mss::dimm::kind<MC> l_kind (l_dimm, l_rc);
        FAPI_TRY(l_rc, GENTARGTIDFORMAT " Failed to create dimm::kind instance", GENTARGTID(l_dimm));
        l_found_ddimm = (l_kind.iv_dimm_type == fapi2::ENUM_ATTR_MEM_EFF_DIMM_TYPE_DDIMM) ? 1 : l_found_ddimm;
    }

    //assumptions slot <= port, l_count_dimms <=2
    if (i_util_slot * l_count_dimms > i_util_port)
    {
        FAPI_INF_NO_SBE("i_util_slot is %u, i_util_port is %u, l_count_dimms is %d for " GENTARGTIDFORMAT,
                        static_cast<uint32_t>(i_util_slot),
                        static_cast<uint32_t>(i_util_port),
                        l_count_dimms,
                        GENTARGTID(iv_target));

        const uint8_t l_high_pos = (iv_pwr_slope[0] >= iv_pwr_slope[1]) ? 0 : 1;

        //Highest power_slope gets the higher utilization
        o_util_dimm_max[l_high_pos] = std::min(i_util_slot, i_util_port);

        //Set the other dimm to the left over utilization (i_util_port - i_util_slot) if not a DDIMM,
        //otherwise set to same value as above
        o_util_dimm_max[(!l_high_pos)] = (l_found_ddimm) ?
                                         o_util_dimm_max[l_high_pos] :
                                         ((l_count_dimms == TT::DIMMS_PER_PORT) ?
                                          (i_util_port - o_util_dimm_max[l_high_pos]) :
                                          0
                                         );

        FAPI_INF_NO_SBE("Split utilization for target " GENTARGTIDFORMAT ", DIMM in %d gets %u",
                        GENTARGTID(iv_target),
                        l_high_pos,
                        static_cast<uint32_t>(o_util_dimm_max[l_high_pos]));
        FAPI_INF_NO_SBE("Split utilization for target " GENTARGTIDFORMAT ", DIMM in %d gets %u",
                        GENTARGTID(iv_target),
                        !l_high_pos,
                        static_cast<uint32_t>(o_util_dimm_max[!l_high_pos]));
    }
    else
    {
        //If only 1 dimm, i_util_port == i_util_slot
        //If 2 dimms, 2*i_util_slot <= i_util_pot
        //Either way, limit utilization by the slot value
        for (const auto& l_dimm : mss::find_targets<fapi2::TARGET_TYPE_DIMM>(iv_target))
        {
            const size_t l_pos = mss::index(l_dimm);
            o_util_dimm_max[l_pos] = i_util_slot;
        }
    }

    //make sure both are not 0
    FAPI_ASSERT ( (o_util_dimm_max[0] != 0) || (o_util_dimm_max[1] != 0),
                  fapi2::MSS_NO_DATABUS_UTILIZATION()
                  .set_PORT_TARGET(iv_target)
                  .set_PORT_DATABUS_UTIL(i_util_port)
                  .set_DIMM_COUNT(mss::count_dimm(iv_target)),
                  "Failed to calculated util utilization for target " GENTARGTIDFORMAT,
                  GENTARGTID(iv_target));
fapi_try_exit:
    return fapi2::current_err;
}

///
/// @brief Calculate utilization from input or safemode utilization
/// @tparam T fapi2 target type of the port target
/// @param[in] i_target the port target
/// @param[in] i_input_databus_util input utilization
/// @param[in] i_min_databus_util minimum databus utilization limit
/// @param[in] i_max_databus_util maximum databus utilization limit
/// @param[out] o_util calculated utilization
/// @param[out] o_util_error true if input utilization is lower than minimum allowed
/// @param[out] o_safemode true if safemode throttle values were used for calculation
///
template<fapi2::TargetType T>
void calc_utilization(const fapi2::Target<T>& i_target,
                      const uint32_t i_input_databus_util,
                      const uint32_t i_min_databus_util,
                      const uint32_t i_max_databus_util,
                      uint32_t& o_util,
                      bool& o_util_error,
                      bool& o_safemode)
{
    o_safemode = false;

    // Use MRW safemode throttle values if input utilization is zero
    if (i_input_databus_util == 0)
    {
        FAPI_INF_NO_SBE(GENTARGTIDFORMAT " Safemode throttles being used since input util is zero:  Using Utilization %d c%%",
                        GENTARGTID(i_target),
                        i_min_databus_util);
        o_safemode = true;
    }
    else if (i_input_databus_util < i_min_databus_util)
    {
        o_util_error = true;
    }

    // Make sure min_utilization <= input_utilization <= max_utilization
    o_util = std::max(i_input_databus_util, i_min_databus_util);
    o_util = std::min(o_util, i_max_databus_util);

    FAPI_INF_NO_SBE(GENTARGTIDFORMAT " calc_utilization final databus utilization: %d",
                    GENTARGTID(i_target),
                    o_util);

}

///
/// @brief Calcuate the throttle values based on throttle type
/// @tparam mc_type MC the type of the memory controller under test
/// @tparam fapi2::TargetType T the target type under test
/// @param[in] i_target the MC target
/// @param[in] i_throttle_type thermal boolean to determine whether to calculate throttles based on the power regulator or thermal limits
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note determines the throttle levels based off of the port's power curve,
/// sets the slot throttles to the same
/// Enums are POWER for power egulator throttles and THERMAL for thermal throttles
/// equalizes the throttles to the lowest of runtime and the lowest slot-throttle value
///
template<mss::mc_type MC, fapi2::TargetType T>
fapi2::ReturnCode pwr_throttles( const fapi2::Target<T>& i_target,
                                 const mss::throttle_type i_throttle_type);

///
/// @brief Equalize the throttles and estimated power at those throttle levels
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 MC target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_targets vector of MC targets all on the same VDDR domain
/// @param[in] i_throttle_type denotes if this was done for POWER (VMEM) or THERMAL (VMEM+VPP) throttles
/// @param[out] o_exceeded_power vector of port targets where the estimated power exceeded the maximum allowed
/// @return FAPI2_RC_SUCCESS iff ok
/// @note sets the throttles and power to the worst case
/// Called by mss_bulk_pwr_throttles and by mss_utils_to_throttle (so by IPL or by OCC)
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode equalize_throttles_helper (const std::vector< fapi2::Target<T> >& i_targets,
        const throttle_type i_throttle_type,
        std::vector< fapi2::Target<TT::PORT_TARGET_TYPE> >& o_exceeded_power);

///
/// @brief Equalize the throttles among MC chips
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 MC target type of the target
/// @tparam TT throttle_traits throttle traits for the given mc_type
/// @param[in] i_targets vector of MC chips
/// @param[in] i_throttle_type denotes if this should be done for POWER (VMEM) or THERMAL (VMEM+VPP) throttles
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note equalizes the throttles to the lowest of runtime and the lowest slot-throttle value
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode equalize_throttles( const std::vector< fapi2::Target<T> >& i_targets,
                                      const mss::throttle_type i_throttle_type)
{
    std::vector< fapi2::Target<TT::PORT_TARGET_TYPE> > l_exceeded_power;

    // Set all of the throttles to the lowest value per port for performance reasons
    FAPI_TRY(mss::power_thermal::equalize_throttles_helper<MC>(i_targets, i_throttle_type, l_exceeded_power));

    // Report any port that exceeded the max power limit, and return a failing RC if we have any
    for (const auto& l_port : l_exceeded_power)
    {
        FAPI_ERR("MEM_PORT " GENTARGTIDFORMAT " estimated power exceeded the maximum allowed", GENTARGTID(l_port) );
        fapi2::current_err = fapi2::FAPI2_RC_FALSE;
    }

    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("Error equalizing throttles using %s throttling",
             ((i_throttle_type == mss::throttle_type::POWER) ? "power" : "thermal"));
    return fapi2::current_err;
}

///
/// @brief Adjusts memory power according to max achievable
///        utilization based on DIMM freq and port count
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle traits for the given MC target type
/// @param[in] i_target mem port target that is being executed
/// @param[in,out] io_fin_power Final power that is calculated based on frequency and port
/// @return FAPI2_RC_SUCCESS iff ok
///
template<mss::mc_type MC, fapi2::TargetType T>
fapi2::ReturnCode memory_power_adjustment(const fapi2::Target<T>& i_target,
        uint32_t& io_fin_power
                                         );

///
/// @brief Write the runtime memory throttle settings from attributes to scom registers
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle traits for the given MC target type
/// @param[in] i_target the port target
/// @return fapi2::FAPI2_RC_SUCCESS iff ok
/// @note overwriting the safemode throttle values
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode write_runtime_throttles(const fapi2::Target<T>& i_target);

///
/// @brief set the PWR CNTRL register
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle traits for the given MC target type
/// @param[in] i_target the port target
/// @return fapi2::FAPI2_RC_SUCCESS if ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode set_pwr_cntrl_reg(const fapi2::Target<T>& i_target);

///
/// @brief set the STR register
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle traits for the given MC target type
/// @param[in] i_target the port target
/// @return fapi2::FAPI2_RC_SUCCESS if ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode set_str_reg(const fapi2::Target<T>& i_target);

#endif //endif for __PPE__

///
/// @brief set the general N/M throttle register
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle traits for the given MC target type
/// @param[in] i_target the port target
/// @return fapi2::FAPI2_RC_SUCCESS if ok
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode set_nm_support(const fapi2::Target<T>& i_target);

///
/// @brief set the safemode throttle register
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @tparam TT throttle traits for the given MC target type
/// @param[in] i_target the port target
/// @return fapi2::FAPI2_RC_SUCCESS if ok
/// @note sets FARB4Q
/// @note used to set throttle window (N throttles  / M clocks)
///
template<mss::mc_type MC, fapi2::TargetType T, typename TT = throttle_traits<MC>>
fapi2::ReturnCode set_safemode_throttles(const fapi2::Target<T>& i_target);

///
/// @brief safemode throttle values defined from MRW attributes
/// @tparam MC mss::mc_type
/// @tparam T the fapi2 target type of the target
/// @param[in] i_target the port target
/// @return fapi2::FAPI2_RC_SUCCESS if ok
/// @note sets safemode values for emergency mode and regular throttling
///
template<mss::mc_type MC, fapi2::TargetType T>
fapi2::ReturnCode thermal_throttle_scominit(const fapi2::Target<T>& i_target);

} //ns power_thermal
}// mss

#endif
