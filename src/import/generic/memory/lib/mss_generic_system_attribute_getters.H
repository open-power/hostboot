/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/generic/memory/lib/mss_generic_system_attribute_getters.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2018,2022                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_generic_system_attribute_getters.H
#ifndef MSS_GENERIC_SYSTEM_ATTR_GETTERS_H_
#define MSS_GENERIC_SYSTEM_ATTR_GETTERS_H_

#include <fapi2.H>
#include <generic/memory/lib/utils/index.H>
#include <generic/memory/lib/utils/c_str.H>



namespace mss
{
namespace attr
{
///
/// @brief ATTR_IS_SIMULATION getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  env: 1 = Awan/HWSimulator. 0 = Simics/RealHW.
///
inline fapi2::ReturnCode get_is_simulation(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IS_SIMULATION, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_IS_SIMULATION: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_IS_SIMICS getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Returns the type of simics environment that the code is executing inside. 0 = RealHW/AWAN.
/// 1 = Simics. 2 = SUET.
///
inline fapi2::ReturnCode get_is_simics(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_IS_SIMICS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_IS_SIMICS: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MFG_FLAGS getter
/// @param[out] uint32_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The manufacturing flags. These enums represent which bit/flag to set in numeric
/// form, NOT binary form. These values/policies can no longer be bit wised together.
/// These numeric values match the flags as found in the PDF document: 'Hypervisor Interface
/// Data Specifications v10.5o-1.pdf', section 6.1.9 and should stay in sync with this
/// document and updated when said document gets updated.
///
inline fapi2::ReturnCode get_mfg_flags(uint32_t (&o_array)[4])
{
    uint32_t l_value[4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MFG_FLAGS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MFG_FLAGS: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MNFG_FLAGS getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  NOTE: This is being deprecated and being replaced by the attribute ATTR_MFG_FLAGS,
/// found above. Please switch over to the new attribute, ATTR_MFG_FLAGS, ASAP. @TODO:
/// RTC 252027: Remove this attribute when possible The manufacturing flags. This is
/// a bitfield. Each bit is a flag and multiple flags can be set
///
inline fapi2::ReturnCode get_mnfg_flags(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MNFG_FLAGS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MNFG_FLAGS: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MAX_ALLOWED_DIMM_FREQ getter
/// @param[out] uint32_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum frequency (in MHz) that this system can run the DIMMs at. There are 5 possible
/// values determined by the dimm configuration. For configurations which have mixed
/// rank configurations, the lowest frequency based on ranks of either DIMM is chosen.
/// For example if there was a 1R and a 2R DIMM installed, and 1R dual drop was a lower
/// max freq than 2R dual drop, then the 1R max freq would be the max allowed. [0]=One
/// rank, single drop [1]=Two rank, single drop [2]=Four rank, single drop [3]=One rank,
/// dual drop [4]=Two rank, dual drop A value of zero would indicate an unsupported
/// configuration. Note: Do not use this attribute to limit configurations, it is not
/// checked during plug rules. If you have an unsupported configuration, use the value
/// 0 as the maximum freq.
///
inline fapi2::ReturnCode get_max_allowed_dimm_freq(uint32_t (&o_array)[5])
{
    uint32_t l_value[5] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MAX_ALLOWED_DIMM_FREQ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 20);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MAX_ALLOWED_DIMM_FREQ: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_REQUIRED_SYNCH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specify the system policy to enforce synchronous mode between memory and nest. This
/// drives the value of ATTR_MEM_IN_SYNCH_MODE. UNDETERMINED : Run synchronously if
/// the dimm and nest freq matches ALWAYS : Require matching frequencies and deconfigure
/// memory that does not match the nest NEVER : Do not run synchronously, even if the
/// frequencies match
///
inline fapi2::ReturnCode get_required_synch_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_REQUIRED_SYNCH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_REQUIRED_SYNCH_MODE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_MEM_MRW_IS_PLANAR getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicates if the DIMM connected to this controller are in a planar configuration
///
inline fapi2::ReturnCode get_mem_mrw_is_planar(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_MRW_IS_PLANAR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_MRW_IS_PLANAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OCMB_RESET_GROUP getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  System specific definition of which RESET_N signal is connected to the OCMB's DIMM
/// slot. RESET_N signals are ordered from 0-N
///
inline fapi2::ReturnCode get_mrw_ocmb_reset_group(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OCMB_RESET_GROUP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_OCMB_RESET_GROUP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook safe mode throttle value for numerator cfg_nm_n_per_port
/// Set to below optimum value/ rate. On a per port basis Also used for emergency mode
/// throttle FARB4Q_EMERGENCY_N Used to thermally protect the system in all supported
/// environmental conditions when OCC is not functional Consumer: thermal_init, initfile
///
inline fapi2::ReturnCode get_mrw_safemode_mem_throttled_n_commands_per_port(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PWR_INTERCEPT getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Intercept for DIMM Used to get the VDDR and
/// VDDR+VPP power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT
/// Key Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE
/// = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID
/// = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW:
/// VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal
///
inline fapi2::ReturnCode get_mrw_pwr_intercept(uint64_t (&o_array)[100])
{
    uint64_t l_value[100] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PWR_INTERCEPT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 800);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_PWR_INTERCEPT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PWR_SLOPE getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Slope for DIMM Used to get the VDDR and VDDR+VPP
/// power curve for each DIMM Decoded and used to set ATTR_MSS_TOTAL_PWR_INTERCEPT Key
/// Value pair KEY (0-19): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE
/// = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13, DIMM_STACK_TYPE = 14-15, DRAM_MFGID
/// = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32: Not used VALUE (bits 32-63) in cW:
/// VMEM power curve = 32-47 VMEM+VPP power curve = 48-63 Consumers: eff_config_thermal
///
inline fapi2::ReturnCode get_mrw_pwr_slope(uint64_t (&o_array)[100])
{
    uint64_t l_value[100] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PWR_SLOPE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 800);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_PWR_SLOPE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_REFRESH_RATE_REQUEST getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Refresh Rate Desired refresh interval used in refresh
/// register 0, MBAREF0Q_CFG_REFRESH_INTERVAL 7.8 us (SINGLE) 3.9 us (DOUBLE) 7.02 us
/// (SINGLE_10_PERCENT_FASTER) 3.51 us (DOUBLE_10_PERCENT_FASTER)
///
inline fapi2::ReturnCode get_mrw_refresh_rate_request(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_REFRESH_RATE_REQUEST, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_REFRESH_RATE_REQUEST: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at max
/// utilization. Value should be 0 for ISDIMMs
///
inline fapi2::ReturnCode get_mrw_dimm_power_curve_percent_uplift(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at idle
/// utilization. Value should be 0 for ISDIMMs
///
inline fapi2::ReturnCode get_mrw_dimm_power_curve_percent_uplift_idle(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook for the number of M DRAM clocks. One approach to curbing
/// DRAM power usage is by throttling traffic through a programmable N commands over
/// M window.
///
inline fapi2::ReturnCode get_mrw_mem_m_dram_clocks(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_MEM_M_DRAM_CLOCKS: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for maximum dram data bus utilization in centi percent
/// (c%). Used to determine memory throttle values. Max databus utilization on a per
/// port basis Default to 90%
///
inline fapi2::ReturnCode get_mrw_max_dram_databus_util(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_MAX_DRAM_DATABUS_UTIL: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings programmed during IPL Used by OCC when exiting idle
/// power-save mode
///
inline fapi2::ReturnCode get_mrw_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_POWER_CONTROL_REQUESTED: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Memory power control settings for IDLE powersave mode Used by OCC when entering
/// idle power-save mode
///
inline fapi2::ReturnCode get_mrw_idle_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_IDLE_POWER_CONTROL_REQUESTED: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4 getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook VMEM regulator power limit per DIMM assuming a full configuration.
/// Units in cW Consumed in mss_eff_config_thermal
///
inline fapi2::ReturnCode get_mrw_vmem_regulator_power_limit_per_dimm_ddr4(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM_DDR4: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for the maximum possible number of dimms that can
/// be installed under any of the VMEM regulators. Consumed in eff_config_thermal to
/// calculate mem_watt_target
///
inline fapi2::ReturnCode get_mrw_max_number_dimms_possible_per_vmem_regulator(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_FINE_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. Sets DDR4 MRS3. ZZ uses normal mode. From JEDEC DDR4 Spec 1716.78C
/// from 07-2016 Page 47 Table 4.9.1
///
inline fapi2::ReturnCode get_mrw_fine_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_FINE_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_FINE_REFRESH_MODE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_RANGE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature refresh range. Sets DDR4 MRS4. Should be defaulted to extended range.
/// NORMAL for running at 85 degrees C or less, EXTENDED for 95 or less degrees C Used
/// for calculating periodic refresh intervals JEDEC DDR4 spec 1716.78C from 07-2016
/// page 46 4.8.1
///
inline fapi2::ReturnCode get_mrw_temp_refresh_range(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_RANGE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_TEMP_REFRESH_RANGE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  For resetting the phy delay values at the beginning of calling mss_draminit_training.
/// YES means the vaules will be reset.
///
inline fapi2::ReturnCode get_mrw_reset_delay_before_cal(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_RESET_DELAY_BEFORE_CAL: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic calibration for all ports: Reading left to right.
/// (DEFAULT: 0xD90C -> Byte 0(11011001), Byte 1(00001100)) For each bit: OFF = 0, ON
/// = 1. Setting to 0 indicates to disable periodic memcal. Byte 0: 0: ZCAL 1: SYSCK_ALIGN
/// 2: RDCENTERING 3: RDLCK_ALIGN 4: DQS_ALIGN 5: RDCLK_UPDATE 6: PER_DUTYCYCLE 7: PERCAL_PWR_DIS
/// Byte 1: 0: PERCAL_REPEAT 1: PERCAL_REPEAT 2: PERCAL_REPEAT 3: SINGLE_BIT_MPR 4:
/// MBA_CFG_0 5: MBA_CFG_1 6: SPARE 7: SPARE
///
inline fapi2::ReturnCode get_mrw_periodic_memcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Describes the settings for periodic ZQ calibration for all ports: Reading left to
/// right. For each bit: OFF = 0, ON = 1. Setting to 0 indicates to disable periodic
/// zqcal. Byte 0: 0: ZQCAL All others reserved for future use
///
inline fapi2::ReturnCode get_mrw_periodic_zqcal_mode_options(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_PERIODIC_ZQCAL_MODE_OPTIONS: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_2N_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Allows user to manually turn on and off 2N Mode. AUTO indicates to use Signal Integrity
/// generated setting (from VPD).
///
inline fapi2::ReturnCode get_mrw_dram_2n_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_2N_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_DRAM_2N_MODE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DRAM_WRITE_CRC getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables DRAM Write CRC
///
inline fapi2::ReturnCode get_mrw_dram_write_crc(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DRAM_WRITE_CRC, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_DRAM_WRITE_CRC: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_TEMP_REFRESH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used in MR4 A3 Temperature refresh mode Should be defaulted to disable
///
inline fapi2::ReturnCode get_mrw_temp_refresh_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_TEMP_REFRESH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_TEMP_REFRESH_MODE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_FORCE_BCMODE_OFF getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  An override switch to shut off broadcast mode Enum values: YES: broadcast mode is
/// forced off NO: broadcast mode uses the default value
///
inline fapi2::ReturnCode get_mrw_force_bcmode_off(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_FORCE_BCMODE_OFF, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_FORCE_BCMODE_OFF: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_NVDIMM_PLUG_RULES getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bitmap containing the plug rules for NVDIMM. 1 if a DIMM supports an NVDIMM being
/// plugged in, 0 if it does not DIMM slot 0 is the left most bit The index to the bitmap
/// is the position of the DIMM target As such, a bitmap of 0b10010000, would allow
/// NVDIMM plugged into DIMM0 and DIMM3 Note: this attribute is a 64 bit number to account
/// for 16 DIMM per processor if there is ever a 4 processor system
///
inline fapi2::ReturnCode get_mrw_nvdimm_plug_rules(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_NVDIMM_PLUG_RULES, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_NVDIMM_PLUG_RULES: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Switch that allows unsupported raw card references by providing a default raw card
/// setting.
///
inline fapi2::ReturnCode get_mrw_allow_unsupported_rcw(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_ALLOW_UNSUPPORTED_RCW: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bitmap of DRAM widths supported by a system. A 1 indicates that the system supports
/// a density. Enums below represent the the bit location in the attribute for a given
/// DRAM width. Default value is 0xC -> both x4/x8 supported
///
inline fapi2::ReturnCode get_mrw_supported_dram_width(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_SUPPORTED_DRAM_WIDTH: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles
/// to meet the thermal power per DIMM limit Per DIMM basis, uses first matching KEY
/// entry KEY (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8,
/// DIMM_WIDTH = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19,
/// DIMM_HEIGHT = 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW: thermal power
/// limit DDIMM: Total OCMB+DRAM power limit per DDIMM non-DDIMM: VMEM+VPP power limit
/// per DIMM
///
inline fapi2::ReturnCode get_mrw_ocmb_thermal_memory_power_limit(uint64_t (&o_array)[25])
{
    uint64_t l_value[25] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            l_value) );
    memcpy(o_array, &l_value, 200);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_OCMB_THERMAL_MEMORY_POWER_LIMIT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OCMB_PWR_SLOPE getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Slope for DIMM Used to calculate thermal throttles
/// and port power Per DIMM basis, uses first matching KEY entry KEY (0-21): In order
/// DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11, DIMM_DENSITY
/// = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT = 20-21, Bits
/// 22-32: Not used VALUE (bits 32-47) in cW/utilization: DIMM power slope DDIMM: Total
/// OCMB+DRAM power slope per DDIMM non-DDIMM: VMEM+VPP power slope per DIMM
///
inline fapi2::ReturnCode get_mrw_ocmb_pwr_slope(uint64_t (&o_array)[50])
{
    uint64_t l_value[50] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OCMB_PWR_SLOPE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 400);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_OCMB_PWR_SLOPE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OCMB_PWR_INTERCEPT getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Power Curve Intercept for DIMM Used to calculate thermal
/// throttles and port power Per DIMM basis, uses first matching KEY entry KEY (0-21):
/// In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH = 9-11,
/// DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT =
/// 20-21, Bits 22-32: Not used VALUE (bits 32-47) in cW/utilization: DIMM power intercept
/// DDIMM: Total OCMB+DRAM power intercept per DDIMM non-DDIMM: VMEM+VPP power intercept
/// per DIMM
///
inline fapi2::ReturnCode get_mrw_ocmb_pwr_intercept(uint64_t (&o_array)[50])
{
    uint64_t l_value[50] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OCMB_PWR_INTERCEPT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 400);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_OCMB_PWR_INTERCEPT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Current Curve Intercept and limit for DIMM Used to calculate
/// throttles to meet regulator current per DIMM limit Per DIMM basis, uses first matching
/// KEY entry For DDIMM, use PMIC SW output that provides worst case throttling KEY
/// (0-21): In order DIMM_SIZE = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-8, DIMM_WIDTH
/// = 9-11, DIMM_DENSITY = 12-14, DIMM_STACK_TYPE = 15-16, DRAM_MFGID = 17-19, DIMM_HEIGHT
/// = 20-21, Bits 22-32: Not used VALUE (bits 32-39): Current limit (dA) DDIMM: PMIC
/// output current limit per DDIMM non-DDIMM: VMEM regulator current limit per DIMM
/// VALUE (bits 40-51): Current slope (cA/utilization) DDIMM: PMIC output current slope
/// per DDIMM non-DDIMM: VMEM regulator current slope per DIMM VALUE (bits 52-63): Current
/// intercept (cA) DDIMM: PMIC output current intercept per DDIMM non-DDIMM: VMEM regulator
/// current intercept per DIMM
///
inline fapi2::ReturnCode get_mrw_ocmb_current_curve_with_limit(uint64_t (&o_array)[25])
{
    uint64_t l_value[25] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            l_value) );
    memcpy(o_array, &l_value, 200);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_OCMB_CURRENT_CURVE_WITH_LIMIT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for safe mode dram data bus utilization in centi
/// percent (c%). Set to below optimum value/ rate. On a per port basis Also used for
/// emergency mode throttle Used to thermally protect the system in all supported environmental
/// conditions when OCC is not functional Consumer: thermal_init, initfile Default to
/// 2500 c%%
///
inline fapi2::ReturnCode get_mrw_safemode_dram_databus_util(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_SAFEMODE_DRAM_DATABUS_UTIL: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD getter
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for polling period of DIMM thermal sensors.
///
inline fapi2::ReturnCode get_mrw_thermal_sensor_polling_period(uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_THERMAL_SENSOR_POLLING_PERIOD: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value to describe the airflow past DIMM slots. Facing
/// the front of the DIMM, the airflow is described as either RIGHT_TO_LEFT or LEFT_TO_RIGHT
/// using the attribute enums. Note that the enum values here map to the left/right
/// sensor locations in the DDIMM SPD.
///
inline fapi2::ReturnCode get_mrw_dimm_slot_airflow(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_DIMM_SLOT_AIRFLOW: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE getter
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the fapi position of the port that failed to calculate memory throttles
/// given the passed in watt target and or utilization
///
inline fapi2::ReturnCode get_port_pos_of_fail_throttle(uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_PORT_POS_OF_FAIL_THROTTLE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  System specific DIMM height mixing plug rule
///
inline fapi2::ReturnCode get_mrw_dimm_height_plug_rule(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_DIMM_HEIGHT_MIXING_POLICY: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT getter
/// @param[out] uint64_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Thermal Memory Power Limit Used to calculate throttles
/// to be at or under the power limit Per DIMM basis KEY (0-19): In order DIMM_SIZE
/// = bits 0-3, DIMM_GEN = 4-5, DIMM_TYPE = 6-7, DIMM_WIDTH = 8-10, DIMM_DENSITY = 11-13,
/// DIMM_STACK_TYPE = 14-15, DRAM_MFGID = 16-18, DIMMS_PER_PORT = 19-20, Bits 21-32:
/// Not used VALUE (bits 32-63) in cW: VMEM+VPP thermal power limit per DIMM = 32-63
/// Consumers: eff_config_thermal and bulk_pwr_throttles
///
inline fapi2::ReturnCode get_mrw_thermal_memory_power_limit(uint64_t (&o_array)[10])
{
    uint64_t l_value[10] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            l_value) );
    memcpy(o_array, &l_value, 80);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_THERMAL_MEMORY_POWER_LIMIT: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_other_attr_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set to ENABLED to activate a workaround for 4U DDIMMs to set thermal sensor usage
/// from DRAM to DRAM_AND_MEM_BUF_EXT, and from PMIC to MEM_BUF_EXT. Affects power management
/// subsystem fan speed controls.
///
inline fapi2::ReturnCode get_mrw_orverride_therm_sensor_usage(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MSS_MRW_OVERRIDE_THERM_SENSOR_USAGE: 0x%lx",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


} // attr
} // mss

#endif
