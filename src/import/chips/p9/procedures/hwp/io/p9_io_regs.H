/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/p9/procedures/hwp/io/p9_io_regs.H $          */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2015,2020                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
///
/// @file p9_io_regs.H
/// @brief Registers to be used with p9_io_scom.
///----------------------------------------------------------------------------
/// *HWP HWP Owner        : Chris Steffen <cwsteffen@us.ibm.com>
/// *HWP HWP Backup Owner : Gary Peterson <garyp@us.ibm.com>
/// *HWP FW Owner         : Jamie Knight <rjknight@us.ibm.com>
/// *HWP Team             : IO
/// *HWP Level            : 3
/// *HWP Consumed by      : FSP:HB
///----------------------------------------------------------------------------
///
/// @verbatim
/// Design specific registers
///
/// @endverbatim
///----------------------------------------------------------------------------


#ifndef P9_IO_REGS_H_
#define P9_IO_REGS_H_




/*
 * *****************************
 *  Registers & Fields
 * *****************************
*/
#define OPT_TX_ZCAL_N                                      0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_ZCAL_P                                      0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_PSEG_PRE_EN                                 0x800d34000000003f, 51,  5 // pre bank pseg enable
#define OPT_TX_PSEG_PRE_SEL                                0x800d34000000003f, 56,  5 // pre bank pseg mode selection
#define OPT_TX_NSEG_PRE_EN                                 0x800d3c000000003f, 51,  5 // pre bank nseg enable
#define OPT_TX_NSEG_PRE_SEL                                0x800d3c000000003f, 56,  5 // pre bank nseg mode selection
#define OPT_TX_PSEG_MARGINPU_EN                            0x800d44000000003f, 48,  8 // margin pull-up bank pseg enable
#define OPT_TX_PSEG_MARGINPD_EN                            0x800d44000000003f, 56,  8 // margin pull-down bank pseg enable
#define OPT_TX_NSEG_MARGINPU_EN                            0x800d4c000000003f, 48,  8 // margin pull-up bank nseg enable
#define OPT_TX_NSEG_MARGINPD_EN                            0x800d4c000000003f, 56,  8 // margin pull-down bank nseg enable
#define OPT_TX_MARGINPU_SEL                                0x800d54000000003f, 48,  8 // margin pull-up bank mode selection
#define OPT_TX_MARGINPD_SEL                                0x800d54000000003f, 56,  8 // margin pull-down bank mode selection
#define OPT_TX_PSEG_MAIN_EN                                0x800d5c000000003f, 51,  7 // main bank pseg enable
#define OPT_TX_NSEG_MAIN_EN                                0x800d64000000003f, 51,  7 // main bank nseg enable
#define OPT_TX_PSEG_POST_EN                                0x800d84000000003f, 49,  7 // post bank pseg enable
#define OPT_TX_PSEG_POST_SEL                               0x800d84000000003f, 56,  7 // post bank pseg mode selection
#define OPT_TX_NSEG_POST_EN                                0x800d8c000000003f, 49,  7 // post bank nseg enable
#define OPT_TX_NSEG_POST_SEL                               0x800d8c000000003f, 56,  7 // post bank nseg mode selection
#define OPT_TX_ZCAL_REQ                                    0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define OPT_TX_ZCAL_DONE                                   0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.
#define OPT_TX_ZCAL_ERROR                                  0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_BUSY                                   0x800f04000000003f, 52,  1 // impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.
#define OPT_TX_IMPCAL_PB                                   0x800f04000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_SM_MIN_VAL                             0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_ZCAL_SM_MAX_VAL                             0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_IMPCAL_SWO2_PB                              0x800f2c000000003f, 48, 16 // register -- description
#define OPT_RX_RUN_DCCAL                                   0x800320000000003f, 49,  1 // run on-die dc training on given lane
#define OPT_RX_DCCAL_DONE                                  0x800328000000003f, 49,  1 // on-die dc training complete on given lane
#define OPT_RX_B_BANK_CONTROLS                             0x800008000000003f, 58,  6 // power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define OPT_IORESET_HARD_BUS0                              0x0000000000000020,  2,  1 // io hard reset per-bus and gcr reset
#define OPT_RX_CLKDIST_PDWN                                0x800810000000003f, 48,  3
#define OPT_TX_CLKDIST_PDWN                                0x800C14000000003f, 48,  3
#define OPT_RX_IREF_PDWN_B                                 0x8008C0000000003f, 54, 1
#define OPT_RX_CTL_DATASM_CLKDIST_PDWN                     0x800B80000000003f, 60, 1
#define OPT_RX_LANE_ANA_PDWN                               0x800008000000003f, 54, 1
#define OPT_RX_LANE_DIG_PDWN                               0x800220000000003f, 48, 1
#define OPT_TX_LANE_PDWN                                   0x800404000000003f, 48, 1
#define OPT_RX_PR_FW_OFF                                   0x800228000000003f, 56, 1
#define OPT_RX_PR_EDGE_TRACK_CNTL                          0x800248000000003f, 48, 2

#define EDIP_RX_FIR_RESET                                  0x800ab0000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches including the isolation and parity error latches.
#define EDIP_TX_ZCAL_REQ                                   0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define EDIP_TX_ZCAL_DONE                                  0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.
#define EDIP_TX_ZCAL_ERROR                                 0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define EDIP_TX_IMPCAL_PB                                  0x800f04000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_N                                     0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_ZCAL_P                                     0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_ZCAL_SM_MIN_VAL                            0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_ZCAL_SM_MAX_VAL                            0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_IMPCAL_SWO2_PB                             0x800f2c000000003f, 48, 16 // register -- description
#define EDIP_TX_PSEG_PRE_EN                                0x800d34000000003f, 51,  5 // pre bank pseg enable
#define EDIP_TX_PSEG_PRE_SEL                               0x800d34000000003f, 56,  5 // pre bank pseg mode selection
#define EDIP_TX_NSEG_PRE_EN                                0x800d3c000000003f, 51,  5 // pre bank nseg enable
#define EDIP_TX_NSEG_PRE_SEL                               0x800d3c000000003f, 56,  5 // pre bank nseg mode selection
#define EDIP_TX_PSEG_MARGINPU_EN                           0x800d44000000003f, 48,  8 // margin pull-up bank pseg enable
#define EDIP_TX_PSEG_MARGINPD_EN                           0x800d44000000003f, 56,  8 // margin pull-down bank pseg enable
#define EDIP_TX_NSEG_MARGINPU_EN                           0x800d4c000000003f, 48,  8 // margin pull-up bank nseg enable
#define EDIP_TX_NSEG_MARGINPD_EN                           0x800d4c000000003f, 56,  8 // margin pull-down bank nseg enable
#define EDIP_TX_MARGINPU_SEL                               0x800d54000000003f, 48,  8 // margin pull-up bank mode selection
#define EDIP_TX_MARGINPD_SEL                               0x800d54000000003f, 56,  8 // margin pull-down bank mode selection
#define EDIP_TX_PSEG_MAIN_EN                               0x800d5c000000003f, 51, 13 // main bank pseg enable
#define EDIP_TX_NSEG_MAIN_EN                               0x800d64000000003f, 51, 13 // main bank nseg enable
#define EDIP_RX_LANE_INVALID                               0x800240000000003f, 50,  1 // marks this rx slice as invalid and fences other operations.  use this bit, for example, to broadcast a setting to all good lanes but not bad or disabled ones.
#define EDIP_RX_WT_CU_PLL_PGOOD                            0x8009f8000000003f, 48,  1 // rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset
#define EDIP_RX_WT_CU_BYP_PLL_LOCK                         0x8009f8000000003f, 49,  1 // override rx pll/dll lock.  this should be ored into places where pll locked is checked (i.e. wt state machine), used to bypass waiting for a pll lock
#define EDIP_RX_WT_PLL_REFCLKSEL                           0x8009f8000000003f, 50,  1 // select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock
#define EDIP_RX_PLL_REFCLKSEL_SCOM_EN                      0x8009f8000000003f, 51,  1 // selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock
#define EDIP_RX_IORESET                                    0x8009f8000000003f, 52,  1 // reset the given rx clock group including gcr slave
#define EDIP_RX_CTL_CNTL4_E_PG                             0x8009f8000000003f, 48, 16 // register -- description
#define EDIP_RX_START_DC_CALIBRATE                         0x8009f0000000003f, 53,  1 // when this register is written to a 1 the training state machine will run the dc calibrate substeps definedin eye optimizations.
#define EDIP_RX_DC_CALIBRATE_DONE                          0x800a38000000003f, 53,  1 // when this bit is read as a 1, the dc calibration steps have been completed. check the corresponding rx_dc_calibration_failed register field for the pass/fail status of operation state.
#define EDIP_RX_START_WDERF_ALIAS                          0x8009f0000000003f, 48,  5 // alias for rx_start_* bits
#define EDIP_RX_CTL_CNTL1_E_PG                             0x8009f0000000003f, 48, 16 // register -- description
#define EDIP_RX_WDERF_DONE_ALIAS                           0x800a38000000003f, 48,  5 // alias for rx_*_done bits
#define EDIP_RX_WDERF_FAILED_ALIAS                         0x800a38000000003f, 56,  5 // alias for rx_*_failed bits
#define EDIP_RX_CTL_STAT1_E_PG                             0x800a38000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_BAD_VEC_0_15                          0x800a40000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).  the bad_lane vector is only updated during initial training.  
#define EDIP_RX_CTL_STAT2_E_PG                             0x800a40000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_BAD_VEC_16_23                         0x800a50000000003f, 48,  8 // lanes found bad by hw (status) or method to force lane bad from software (control).
#define EDIP_RX_CTL_STAT4_E_PG                             0x800a50000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_DISABLED_VEC_0_15                     0x8009e0000000003f, 48, 16 // used to set which of group lanes 0-15 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_RX_CTL_MODE11_E_PG                            0x8009e0000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_DISABLED_VEC_16_23                    0x8009e8000000003f, 48,  8 // used to set which of group lanes 16-23 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_RX_CTL_MODE12_E_PG                            0x8009e8000000003f, 48, 16 // register -- description
#define EDIP_RX_MAIN_INIT_STATE                            0x800b18000000003f, 48,  4 // main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused
#define EDIP_RX_WTM_STATE                                  0x800b18000000003f, 52,  6 // main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail 
#define EDIP_RX_WTR_STATE                                  0x800b18000000003f, 58,  5 // receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused
#define EDIP_RX_GLBSM_STAT1_E_PG                           0x800b18000000003f, 48, 16 // register -- description
#define EDIP_RX_WTL_SM_STATUS                              0x800960000000003f, 48,  5 // wiretest lane machine status    
#define EDIP_RX_CTL_STAT3_EO_PG                            0x800960000000003f, 48, 16 // register -- description
#define EDIP_RX_WTR_BAD_LANE_COUNT                         0x800b20000000003f, 59,  5 // wiretest current number of bad lanes in this clk group
#define EDIP_RX_GLBSM_STAT2_E_PG                           0x800b20000000003f, 48, 16 // register -- description
#define EDIP_RX_WT_CLK_LANE_INVERTED                       0x800a58000000003f, 49,  1 // clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted
#define EDIP_RX_WT_CLK_LANE_BAD_CODE                       0x800a58000000003f, 50,  3 // clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused
#define EDIP_RX_CTL_STAT5_E_PG                             0x800a58000000003f, 48, 16 // register -- description
#define EDIP_RX_EYE_OPT_STATE                              0x800ab8000000003f, 48, 12 // eye optimizaton state machine current state 
#define EDIP_RX_GLBSM_STAT1_EO_PG                          0x800ab8000000003f, 48, 16 // register -- description
#define EDIP_RX_HIST_MIN_EYE_WIDTH_VALID                   0x800938000000003f, 48,  1 // rx historic eye width minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_WIDTH_LANE                    0x800938000000003f, 49,  5 // rx historic eye width lane number
#define EDIP_RX_HIST_MIN_EYE_WIDTH                         0x800938000000003f, 54,  8 // rx historic eye width minimum value.
#define EDIP_RX_CTL_CNTL13_EO_PG                           0x800938000000003f, 48, 16 // register -- description
#define EDIP_RX_RPR_STATE                                  0x800b30000000003f, 48,  7 // static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state
#define EDIP_RX_GLBSM_STAT4_E_PG                           0x800b30000000003f, 48, 16 // register -- description
#define EDIP_RX_BAD_LANE1                                  0x800b58000000003f, 48,  7 // encoded bad lane one in relation to the entire rx bus
#define EDIP_RX_BAD_LANE2                                  0x800b58000000003f, 55,  7 // encoded bad lane two in relation to the entire rx bus
#define EDIP_RX_BAD_LANE_CODE                              0x800b58000000003f, 62,  2 // rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes
#define EDIP_RX_GLBSM_STAT9_E_PG                           0x800b58000000003f, 48, 16 // register -- description
#define EDIP_TX_CLK_UNLOAD_CLK_DISABLE                     0x800c1c000000003f, 50,  1 // set to 0 to clock off sync logic on the clock slice and save power.  it should not be necessary to use the sync logic on the clock slice since it has no fifo but control is available just in case.
#define EDIP_TX_CLK_RUN_COUNT                              0x800c1c000000003f, 51,  1 // set to 1 to enable the tx clock slice serializer.  this should be enabled at all times but control is available just in case.
#define EDIP_TX_UNLOAD_CLK_DISABLE                         0x80040c000000003f, 56,  1 // set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define EDIP_SCOM_FIR_PB                                   0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define EDIP_RX_LANE_DIG_PDWN                              0x800220000000003f, 48,  1 // used to power down digital logic for a lane. 
#define EDIP_RX_LANE_ANA_PDWN                              0x800008000000003f, 54,  1 // lane power down of analog and custom circuits
#define EDIP_TX_MSBSWAP                                    0x800c14000000003f, 58,  1 // used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode
#define EDIP_TX_END_LANE_ID                                0x800c84000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.
#define EDIP_TX_LANE_PDWN                                  0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default). 
#define EDIP_RX_HIST_MIN_EYE_WIDTH_VALID                   0x800938000000003f, 48,  1 // rx historic eye width minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_WIDTH_LANE                    0x800938000000003f, 49,  5 // rx historic eye width lane number
#define EDIP_RX_HIST_MIN_EYE_WIDTH                         0x800938000000003f, 54,  8 // rx historic eye width minimum value.
#define EDIP_RX_CTL_CNTL13_EO_PG                           0x800938000000003f, 48, 16 // register -- description
#define EDIP_TX_IORESET                                    0x800c9c000000003f, 48,  1 // reset the given tx clock group and gcr slave
#define EDIP_TX_FIR_RESET                                  0x800d14000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.
#define EDIP_RX_ABORT_CHECK_TIMEOUT_SEL                    0x800840000000003f, 48,  4 // selects abort check timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_POLLING_TIMEOUT_SEL                        0x800840000000003f, 52,  4 // selects polling read timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_CTL_MODE7_EO_PG                            0x800840000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_CHG_CFG                              0x800868000000003f, 48,  4 // this register controls the minimum acceptable changes of the accum for a valid servo op. assures we have reached a stable point. 
#define EDIP_RX_AMP_INIT_TIMEOUT                           0x800878000000003f, 48,  4 // rx_amp_init_timeout   used for amplitude masurements during init.  (see workbook table 4.10 for timer settings)
#define EDIP_RX_AMP_RECAL_TIMEOUT                          0x800878000000003f, 52,  4 // rx_amp_recal_timeout  used for amplitude masurements during recal. (see workbook table 4.10 for timer settings)
#define EDIP_RX_PEAK_INIT_TIMEOUT                          0x800878000000003f, 56,  4 // rx_peak_init_timeout  used for peaking masurements during init.    (see workbook table 4.10 for timer settings)
#define EDIP_RX_PEAK_RECAL_TIMEOUT                         0x800878000000003f, 60,  4 // rx_peak_recal_timeout  used for peaking masurements during recal   (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE14_EO_PG                           0x800878000000003f, 48, 16 // register -- description
#define EDIP_RX_OFF_INIT_TIMEOUT                           0x800880000000003f, 48,  4 // rx_off_init_timeout   used for offset masurements during init.     (see workbook table 4.10 for timer settings)
#define EDIP_RX_OFF_RECAL_TIMEOUT                          0x800880000000003f, 52,  4 // rx_off_recal_timeout  used for offset masurements during recal.    (see workbook table 4.10 for timer settings)
#define EDIP_RX_CM_TIMEOUT                                 0x800880000000003f, 56,  4 // rx_cm_timeout            used for common mode measurements         (see workbook table 4.10 for timer settings)
#define EDIP_RX_AMIN_TIMEOUT                               0x800880000000003f, 60,  4 // rx_amin_timeout        used for amin masurements                   (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE15_EO_PG                           0x800880000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP_TIMEOUT                                0x800888000000003f, 48,  4 // rx_amp_timeout timeout used when running the generic amplitude servo ops    (see workbook table 4.10 for timer settings)
#define EDIP_RX_USERDEF_TIMEOUT                            0x800888000000003f, 52,  4 // rx_userdef_timeout timeout used when using the user defined servo ops       (see workbook table 4.10 for timer settings)
#define EDIP_RX_BER_TIMEOUT                                0x800888000000003f, 56,  4 // rx_ber_timeout, used for when making bit error measurements with a servo op (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE16_EO_PG                           0x800888000000003f, 48, 16 // register -- description
#define EDIP_CHAN_FAIL_MASK                                0x0000000000000020, 15,  8 // scom mode reg spares.
#define EDIP_RX_PG_SPARE_MODE_0                            0x800800000000003f, 48,  1 // per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_1                            0x800800000000003f, 49,  1 // per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_2                            0x800800000000003f, 50,  1 // per-group spare mode latch.
#define EDIP_RX_RC_ENABLE_CM_FINE_CAL                      0x8008b8000000003f, 56,  1 // rx recalibration    common mode fine calibration enable
#define EDIP_RX_EO_ENABLE_DAC_H1_CAL                       0x8008b0000000003f, 50,  1 // rx eye optimization h! dac calibration to reference
#define EDIP_RX_EO_ENABLE_DAC_H1_TO_A_CAL                  0x8008b0000000003f, 61,  1 // rx eye optimization h! dac to amplitude dac cross-calibration
#define EDIP_RX_A_INTEG_COARSE_GAIN                        0x800028000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.



#define EDI_RX_WTM_STATE                                   0x800950000000003f, 48,  5 // main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail \r\n\trjr
#define EDI_RX_WTR_STATE                                   0x800950000000003f, 53,  4 // receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused\r\n\trjr
#define EDI_RX_WTL_STATE                                   0x800950000000003f, 59,  5 // lane wiretest sub state machine current state (rjr)\r\n\tx00: idle\r\n\tx01: wait 1st long transition\r\n\tx02: wait 2nd long transition\r\n\tx03: wait short transition\r\n\tx04: wait transition from pn=01\r\n\tx05: wait transition from 10\r\n\tx06: wait transition from 00\r\n\tx07: wait transition from 11\r\n\tx10: good-no swap\r\n\tx11: bad-n=1-no swap\r\n\tx12: bad-n=0-no swap\r\n\tx13: bad-p=1-no swap\r\n\tx14: bad-p=0-no swap\r\n\tx15: bad-p or n floating\r\n\tx16: bad-pn=00\r\n\tx17: bad-pn=11\r\n\tx18: good--swapped\r\n\tx19: bad-n=1-swapped\r\n\tx1a: bad-n=0-swapped\r\n\tx1b: bad-p=1-swapped\r\n\tx1c: bad-p=0-swapped\r\n\tx1d: bad-pn=10\r\n\tx1e: bad-pn=01\r\n\tx1f: bad-unknown failure\r\n\trjr
#define EDI_RX_WIRETEST_STATE_PG                           0x800950000000003f, 48, 16 // rx wiretest state machine reg -- rx main and rx wiretest state machines
#define EDI_RX_WTR_BAD_LANE_COUNT                          0x800958000000003f, 59,  5 // wiretest current number of bad lanes in this clk group\r\n\trjr
#define EDI_RX_WIRETEST_LANEINFO_PG                        0x800958000000003f, 48, 16 // rx wiretest lane info reg -- rx wiretest current lane, max bad lanes allowed and number of currently marked bad lanes
#define EDI_RX_WT_CLK_LANE_INVERTED                        0x800a10000000003f, 49,  1 // clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted\r\n\trjr
#define EDI_RX_WT_CLK_LANE_BAD_CODE                        0x800a10000000003f, 50,  3 // clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused\r\n\trjr
#define EDI_RX_WT_CLK_STATUS_PG                            0x800a10000000003f, 48, 16 // rx clock wiretest status -- description
#define EDI_RX_EYE_OPT_STATE                               0x800ac0000000003f, 48,  8 // common edi/ei4 eye optimizaton state machine \r\n\t00000000: idle \r\n\t00000001: init latch offset cal done \r\n\t00000010: vref/dcd cal done \r\n\t00000011: vga done \r\n\t00000100: unused \r\n\t00000101: unused \r\n\t00000110: unused \r\n\t00000111: ctle done \r\n\t00001000: h1ap adjust done \r\n\t00001001: ddc done \r\n\t00001010: measure eye width done \r\n\t00001011: final l2u adjust done \r\n\t00001100: unused \r\n\t00001101: results check done \r\n\t00001110: eye opt all done \r\n\t00001111: unused \r\n\t00010000: start latch offset cal \r\n\t00010001: start latch offset cal 0 \r\n\t00010010: read latch offset cal 0 status \r\n\t00010011: check latch offset cal 0 status \r\n\t00010100: start latch offset cal 1 \r\n\t00010101: read latch offset cal 1 status \r\n\t00010110: check latch offset cal 1 status \r\n\t00010111: bist latch offset cal done \r\n\t00011000: unused \r\n\t00011001: unused \r\n\t00011010: unused \r\n\t00011011: unused \r\n\t00011100: unused \r\n\t00011101: unused \r\n\t00011110: unused \r\n\t00011111: unused \r\n\t00100000: start vref cal \r\n\t00100001: start vref servo \r\n\t00100010: read vref servo status \r\n\t00100011: check vref servo status \r\n\t00100100: start dcd adjust servo \r\n\t00100101: read dcd adjust servo status \r\n\t00100110: check dcd adjust servo status \r\n\t00100111: unused \r\n\t00101000: unused \r\n\t00101001: unused \r\n\t00101010: unused \r\n\t00101011: unused \r\n\t00101100: unused \r\n\t00101101: unused \r\n\t00101110: unused \r\n\t00101111: unused \r\n\t00110000: vga start-clear done flags \r\n\t00110001: vga measure ape/apo \r\n\t00110010: vga read ape/apo status \r\n\t00110011: vga check ape/apo status \r\n\t00110100: vga measure ane/ano \r\n\t00110101: vga read ane/ano status \r\n\t00110110: vga check ane/ano status \r\n\t00110111: vga measure ape dfe \r\n\t00111000: vga read ape dfe status \r\n\t00111001: vga check ape dfe status \r\n\t00111010: vga measure ane dfe \r\n\t00111011: vga read ane dfe status \r\n\t00111100: vga check ane dfe status \r\n\t00111101: vga measure apo dfe \r\n\t00111110: vga read apo dfe status \r\n\t00111111: vga check apo dfe status \r\n\t01000000: vga measure ano dfe \r\n\t01000001: vga read ano dfe status \r\n\t01000010: vga check ano dfe status \r\n\t01000011: vga measure amin no dfe \r\n\t01000100: vga read amin no dfe status \r\n\t01000101: vga check amin no dfe status \r\n\t01000110: vga measure amin dfe \r\n\t01000111: vga read amin dfe status \r\n\t01001000: vga check amin dfestatus \r\n\t01001001: vga clear lane address \r\n\t01001010: vga check lane valid \r\n\t01001011: vga read rx amp cntl \r\n\t01001100: vga read rx amp values \r\n\t01001101: vga read ape and apo \r\n\t01001110: vga read ane and ano \r\n\t01001111: vga read amine and amino \r\n\t01010000: vga check offset \r\n\t01010001: vga check amax \r\n\t01010010: vga write vga done control \r\n\t01010011: vga write all done status \r\n\t01010100: vga write vga adjust value \r\n\t01010101: vga check done \r\n\t01010110: unused \r\n\t01010111: unused \r\n\t01011000: unused \r\n\t01011001: unused \r\n\t01011010: unused \r\n\t01011011: unused \r\n\t01011100: unused \r\n\t01011101: unused \r\n\t01011110: unused \r\n\t01011111: unused \r\n\t01100000: unused \r\n\t01100001: unused \r\n\t01100010: unused \r\n\t01100011: unused \r\n\t01100100: unused \r\n\t01100101: unused \r\n\t01100110: unused \r\n\t01100111: unused \r\n\t01101000: unused \r\n\t01101001: unused \r\n\t01101010: unused \r\n\t01101011: unused \r\n\t01101100: unused \r\n\t01101101: unused \r\n\t01101110: unused \r\n\t01101111: unused \r\n\t01110000: ctle start \r\n\t01110001: ctle bump left \r\n\t01110010: ctle read bump left status \r\n\t01110011: ctle check bump left status \r\n\t01110100: ctle start servo \r\n\t01110101: ctle read servo status \r\n\t01110110: ctle check servo status \r\n\t01110111: ctle bump right \r\n\t01111000: ctle read bump right status \r\n\t01111001: ctle check bump rightstatus \r\n\t01111010: unused \r\n\t01111011: unused \r\n\t01111100: unused \r\n\t01111101: unused \r\n\t01111110: unused \r\n\t01111111: unused \r\n\t10000000: h1ap tweak start \r\n\t10000001: h1ap tweak run servo \r\n\t10000010: h1ap tweak read servo status \r\n\t10000011: h1ap tweak check servo status \r\n\t10000100: unused \r\n\t10000101: unused \r\n\t10000110: unused \r\n\t10000111: unused \r\n\t10001000: unused \r\n\t10001001: unused \r\n\t10001010: unused \r\n\t10001011: unused \r\n\t10001100: unused \r\n\t10001101: unused \r\n\t10001110: unused \r\n\t10001111: unused \r\n\t10010000: ddc start \r\n\t10010001: ddc run servo \r\n\t10010010: ddc read servo status \r\n\t10010011: ddc check servo status \r\n\t10010100: ddc check clear counter \r\n\t10010101: ddc check fly state \r\n\t10010110: ddc check lane \r\n\t10010111: ddc read  lane status \r\n\t10011000: ddc check lane status \r\n\t10011001: ddc write bad ddc \r\n\t10011010: ddc check if all done \r\n\t10011011: unused \r\n\t10011100: unused \r\n\t10011101: unused \r\n\t10011110: unused \r\n\t10011111: unused \r\n\t10100000: eye measure start \r\n\t10100001: eye measure start edge track \r\n\t10100010: eye measure read edge track status \r\n\t10100011: eye measure check edge track status \r\n\t10100100: eye measure fly state \r\n\t10100101: eye measure start eye track \r\n\t10100110: eye measure read eye track status \r\n\t10100111: eye measure check eye track status \r\n\t10101000: unused \r\n\t10101001: unused \r\n\t10101010: unused \r\n\t10101011: unused \r\n\t10101100: unused \r\n\t10101101: unused \r\n\t10101110: unused \r\n\t10101111: unused \r\n\t10110000: final l2u set sls checkers \r\n\t10110001: final l2u run err check timer \r\n\t10110010: final l2u dec l2u delay \r\n\t10110011: final l2u inc prbs \r\n\t10110100: final l2u inc l2u delay \r\n\t10110101: final l2u dec prbs \r\n\t10110110: unused \r\n\t10110111: final l2u run err check timer \r\n\t10111000: final l2u clear l2u counter \r\n\t10111001: final l2u check final delay \r\n\t10111010: final l2u inc l2u final delay \r\n\t10111011: final l2u dec prbs \r\n\t10111100: unused \r\n\t10111101: unused \r\n\t10111110: final l2u done \r\n\t10111111: final l2u fail \r\n\t11000000: final l2u wait for prev group status \r\n\t11000001: final l2u send status to next group \r\n\t11000010: final l2u wait for all group status \r\n\t11000011: unused \r\n\t11000100: unused \r\n\t11000101: unused \r\n\t11000110: unused \r\n\t11000111: unused \r\n\t11001000: unused \r\n\t11001001: unused \r\n\t11001010: unused \r\n\t11001011: unused \r\n\t11001100: unused \r\n\t11001101: unused \r\n\t11001110: final l2u max change send fail \r\n\t11001111: final l2u max change recv fail \r\n\t11010000: result check clear and start \r\n\t11010001: result check fly state \r\n\t11010010: result check for valid lane \r\n\t11010011: result check read eye width \r\n\t11010100: result check write bad width \r\n\t11010101: result check read amin values \r\n\t11010110: result check check height \r\n\t11010111: result check write bad height \r\n\t11011000: result check start ber servo \r\n\t11011001: result check read ber servo stat \r\n\t11011010: result check checkber status \r\n\t11011011: result check read ber count \r\n\t11011100: result checkcheck ber \r\n\t11011101: result check write bad ber \r\n\t11011110: result checkcheck if done \r\n\t11011111: result check fail \r\n\t11100000: completion start \r\n\t11100001: completion enable driving all \r\n\t11100010: completion drive eye opt done \r\n\t11100011: completion set up sls rcvr \r\n\t11100100: completion watch for sls nop \r\n\t11100101: completion drive sls nop ds \r\n\t11100110: completion wait for sls nop \r\n\t11100111: completion undrive lanes \r\n\t11101000: completion drive bogus sls nop \r\n\t11101001: completion wait non-sls data \r\n\t11101010: completion enable receive sls \r\n\t11101011: completion eye opt done \r\n\t11101100: unused \r\n\t11101101: unused \r\n\t11101110: unused \r\n\t11101111: unused \r\n\t11110000: latch offset fail \r\n\t11110001: vref fail \r\n\t11110010: vga measure ape/o fail \r\n\t11110011: vga measure ane/o fail \r\n\t11110100: vga measure ape dfe fail \r\n\t11110101: vga measure ane/o fail \r\n\t11110110: vga measure ane/o fail \r\n\t11110111: vga measure ano dfe fail \r\n\t11111000: vga measure amine fail \r\n\t11111001: vga measure amine fail \r\n\t11111010: ctle adjust fail \r\n\t11111011: h1ap tweak fail \r\n\t11111100: ddc fail \r\n\t11111101: measure eye fail \r\n\t11111110: dcd duty cycle fail \r\n\t11111111: unused \r\n\trjr
#define EDI_RX_EO_RECAL_PG                                 0x800ac0000000003f, 48, 16 // rx eye opt and recal status -- description
#define EDI_RX_RPR_STATE                                   0x800990000000003f, 48,  6 // static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state\r\n\tsmr
#define EDI_RX_STATIC_REPAIR_STATE_PG                      0x800990000000003f, 48, 16 // rx static repair state machine reg -- description
#define EDI_RX_BAD_LANE1_GCRMSG                            0x800988000000003f, 48,  7 // gcr message: encoded bad lane one in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE2_GCRMSG                            0x800988000000003f, 55,  7 // gcr message: encoded bad lane two in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE_CODE_GCRMSG                        0x800988000000003f, 62,  2 // gcr message: rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EDI_RX_BAD_LANE_ENC_GCRMSG_PG                      0x800988000000003f, 48, 16 // rx bad lanes encoded -- description
#define EDI_RX_START_WDERF_ALIAS                           0x800880000000003f, 48,  5 // alias for rx_start_* bits\r\n\tpmt
#define EDI_RX_TRAINING_START_PG                           0x800880000000003f, 48, 16 // rx training state start reg -- description
#define EDI_RX_WDERF_DONE_ALIAS                            0x800888000000003f, 48,  5 // alias for rx_*_done bits\r\n\tpmt
#define EDI_RX_WDERF_FAILED_ALIAS                          0x800888000000003f, 56,  5 // alias for rx_*_failed bits\r\n\tpmt
#define EDI_RX_TRAINING_STATUS_PG                          0x800888000000003f, 48, 16 // rx training state status reg -- description
#define EDI_RX_LANE_BAD_VEC_0_15                           0x800918000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).to be clear, the bad_lane vector is only updated during training.  it will not reflect bad lanes found post training during dynamic repair or dynamic recal.  for that, you need to read the [rx,tx]_bad_lane[1,2]_gcrmsg registers.  to calculate what you want to know, you need five registers:\r\n\t rx_bad_lane1_gcrmsg\r\n\t rx_bad_lane2_gcrmsg\r\n\t rx_bad_lane_code_gcrmsg\r\n\t rx_sls_lane_gcrmsg\r\n\t rx_wtr_max_bad_lanes\r\n\tin general, if the spares deployed fir goes on, and the bad_lane_code is a 1, then the newly spared lane resides in the rx_bad_lane1_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 2, then the newly spared lane resides in the rx_bad_lane2_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 3, then the newly spared lane resides in the rx_sls_lane_gcrmsg register. that might be enough information for what you want to know, trying to keep the answer very general.  at the moment, this case where both the spare deployed and max spares exceeded both come on at the same time, is for the edi where a third bad lane has been found and we have chosen to use the sls lane as a third spare. edi normally only has two spare lanes. in that case, i first set the spare deployed fir as the sls lane is being used as a third spare. but then a few cycles later, i set the max spares exceeded because i no longer have an sls lane and cant finish my sls repair handshake.\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_0_15_PG                        0x800918000000003f, 48, 16 // rx bad lanes 0 to 15 reg -- lanes found bad by wiretest or set as bad by firmware
#define EDI_RX_LANE_BAD_VEC_16_31                          0x800920000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_16_31_PG                       0x800920000000003f, 48, 16 // rx bad lanes 16 to 31 reg -- lanes found bad by wiretest or set as bad by firmware
#define EDI_RX_LANE_DISABLED_VEC_0_15                      0x800928000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_0_15_PG                   0x800928000000003f, 48, 16 // rx lane disable(d) 0 to 15 reg -- lanes disabled by firmware and therefore do not participate in link training
#define EDI_RX_LANE_DISABLED_VEC_16_31                     0x800930000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_16_31_PG                  0x800930000000003f, 48, 16 // rx lane disable(d) 16_31 reg -- lanes disabled by firmware and therefore do not participate in link training
#define EDI_SCOM_FIR_PB                                    0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define EDI_TX_FIR_RESET                                   0x800c44000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.\r\n\tpmt
#define EDI_RX_FIR_RESET                                   0x800848000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EDI_TX_ZCAL_N                                      0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_NVAL_PB                              0x800f0c000000003f, 48, 16 // tx impedance cal n value reg -- tx impedance cal n value reg
#define EDI_TX_ZCAL_P                                      0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_PVAL_PB                              0x800f14000000003f, 48, 16 // tx impedance cal p value reg -- tx impedance cal p value reg
#define EDI_TX_IMPCAL_PB                                   0x800f04000000003f, 48, 16 // tx impedance cal cntl and status reg -- tx impedance cal cntl and status reg
#define EDI_TX_FFE_MAIN_P_ENC                              0x800cd4000000003f, 49,  7 // tbd\r\n\tjfg
#define EDI_TX_FFE_MAIN_N_ENC                              0x800cd4000000003f, 57,  7 // tbd\r\n\tjfg
#define EDI_TX_FFE_POST_P_ENC                              0x800cdc000000003f, 51,  5 // tbd this field is updated during tx bist by logic temporarily\r\n\tjfg
#define EDI_TX_FFE_POST_N_ENC                              0x800cdc000000003f, 59,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_P_ENC                            0x800ce4000000003f, 51,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_N_ENC                            0x800ce4000000003f, 59,  5 // tbd\r\n\tjfg
#define EDI_RX_PDWN_LITE_DISABLE                           0x800818000000003f, 50,  1 // disables the power down lite feature of unused spare lanes (generally should match tx_pdwn_lite_disable)\r\n\tsmr
#define EDI_RX_WT_TIMEOUT_SEL                              0x800898000000003f, 58,  3 // selects wiretest timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_WT_CU_PLL_PGOOD                             0x800a30000000003f, 48,  1 // rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_RESET                             0x800a30000000003f, 49,  1 // rx pll/dll enable request\r\n\t1:(enable) clears pll pgood and begins reset timer. see rx_wt_cu_pll_pgooddly. \r\n\t0:(not_enable) do nothing\r\n\tjfg
#define EDI_RX_WT_CU_PLL_PGOODDLY                          0x800a30000000003f, 50,  3 // rx pll/dll pgood delay selects length of reset period after rx_wt_cu_pll_reset is set. \r\n\t000:(16ui) minimum 16ui for sim bypass \r\n\t001:(50ns) nominal 50ns reset per pll spec \r\n\t010:(100ns) double nominal 50ns reset per pll spec \r\n\t011:(960ui) typical simulation delay exceeding tx pll 40-refclk locking period \r\n\t100:(unused_100) reserved \r\n\t101:(unused_101) reserved \r\n\t110:(max) 1024 ui  \r\n\t111:(disable) disable rx_wt_cu_pll_reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_LOCK                              0x800a30000000003f, 53,  1 // rx pll/dll locked\r\n\tjfg
#define EDI_RX_WT_PLL_REFCLKSEL                            0x800a30000000003f, 54,  1 // select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock\r\n\tdmb
#define EDI_RX_PLL_REFCLKSEL_SCOM_EN                       0x800a30000000003f, 55,  1 // selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock\r\n\tdmb
#define EDI_RX_WIRETEST_PLL_CNTL_PG                        0x800a30000000003f, 48, 16 // rx pll or dll reset and calibration controls -- description
#define EDI_RX_OFFSET_CAL_DONE                             0x800888000000003f, 54,  1 // when this bit is read as a 1, offset cal has completed. \r\n\tjgr
#define EDI_RX_OFFSET_CAL_FAILED                           0x800888000000003f, 62,  1 // when this bit is read as a 1, the rx cu pll failed to lock and offset cal was not performed. (this bit is set along with rx_wt_bypass_failed and rx_start_bist_failed)\r\n\tjgr
#define EDI_RX_TRAINING_STATUS_PG                          0x800888000000003f, 48, 16 // rx training state status reg -- description
#define EDI_RX_START_OFFSET_CAL                            0x800880000000003f, 54,  1 // set bit to run offset cal and the required tx fifo init, rx cu pll lock, and rx fifo init through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (ocal) start offset cal \r\n\tjgr
#define EDI_RX_EO_LATCH_OFFSET_DONE                        0x800a40000000003f, 48,  1 // rx eye optimization latch offset adjustment done\r\n\trjr
#define EDI_TX_ZCAL_REQ                                    0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.\r\n\tjfg
#define EDI_TX_ZCAL_DONE                                   0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.\r\n\tjfg
#define EDI_TX_ZCAL_ERROR                                  0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.\r\n\tjfg
#define EDI_TX_LANE_PDWN                                   0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (tx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers tx_lane_disabled_vec_0_15 and tx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane drive inhibited (tristated) and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EDI_TX_END_LANE_ID                                 0x800ca4000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_TX_MSBSWAP                                     0x800c1c000000003f, 53,  1 // used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode\r\n\tmbs
#define EDI_RX_LANE_PDWN                                   0x800000000000003f, 48,  1 // used to receive inhibit and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (rx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers rx_lane_disabled_vec_0_15 and rx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane receive inhibited and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EDI_RX_WT_LANE_DISABLED                            0x8000f0000000003f, 48,  1 // wiretest has disabled this lane\r\n\trjr









#define OPT_TX_FIFO_L2U_DLY                                0x80040c000000003f, 48,  3 // this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define OPT_TX_UNLOAD_CLK_DISABLE                          0x80040c000000003f, 56,  1 // set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define OPT_TX_RXCAL                                       0x80040c000000003f, 57,  1 // set transmitter to drive vio/2 common mode on both legs.  use this control during far end rx offset calibration.
#define OPT_TX_UNLOAD_SEL                                  0x80040c000000003f, 58,  3 // controls the preset value of the tx slice unload counter, which effectively gives subcycle control of the offset of tx unload clock from grid clock.
#define OPT_TX_MODE2_PL                                    0x80040c000000003f, 48, 16 // register -- description
#define OPT_TX_ERR_INJECT                                  0x800414000000003f, 48,  5 // inject one beat of error on this lane.  set code 1yyyy where yyyy is the beat in the deserialized cycle to inject on.
#define OPT_TX_FIFO_INIT                                   0x800414000000003f, 53,  1 // used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.
#define OPT_TX_SET_UNLOAD_CLK_DISABLE                      0x800414000000003f, 60,  1 // set tx_unload_clk_disable register
#define OPT_TX_CLR_UNLOAD_CLK_DISABLE                      0x800414000000003f, 61,  1 // clear tx_unload_clk_disable register
#define OPT_TX_CNTL1G_PL                                   0x800414000000003f, 48, 16 // register -- description
#define OPT_RX_RUN_LANE                                    0x800320000000003f, 48,  1 // run training and subsequent recalibration on given lane
#define OPT_RX_LANE_BUSY                                   0x800328000000003f, 50,  1 // state machine busy indicator on given lane
#define OPT_RX_IORESET                                     0x800258000000003f, 63,  1 // reset the given rx lane (except the cdr logic)
#define OPT_TX_IORESET                                     0x80044c000000003f, 48,  1 // reset the given tx lane
#define OPT_RX_PR_RESET                                    0x800258000000003f, 62,  1 // set this to reset cdr logic.  power and clocks must be enabled in the slice.
#define OPT_RX_CLKDIST_PDWN                                0x800810000000003f, 48,  3 // used to disable the rx group clocks and put them into a low power state. \r\n\t bit 0 disables slices 0-7 \r\n\t bit 1 disables slices 8-15 \r\n\t bit 2 disables slices 16-23
#define OPT_RX_LANE_ANA_PDWN                               0x800008000000003f, 54,  1 // lane power down of analog and custom circuits
#define OPT_RX_LANE_DIG_PDWN                               0x800220000000003f, 48,  1 // used to power down digital logic for a lane.
#define OPT_TX_LANE_PDWN                                   0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default).
#define OPT_RX_PR_PHASE_STEP                               0x800228000000003f, 60,  4 // amount to be added or subtracted from to phase rotator accumulator on each shift left or right.  0000: decoded as b10000 in logic, so pr will update every 4 shifts; other values will update with every 4*(16/phase_step) shifts.
#define OPT_RX_CFG_LTE_MC                                  0x800000000000003f, 60,  4 // cfg_lte_mc, see glen for details
#define OPT_RX_A_INTEG_COARSE_GAIN                         0x800028000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.
#define OPT_RX_B_INTEG_COARSE_GAIN                         0x800098000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.
#define OPT_RX_E_INTEG_COARSE_GAIN                         0x8000c0000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.
#define OPT_RX_PR_FW_INTERTIA_AMT                          0x800228000000003f, 57,  3
#define OPT_RX_PR_IQ_RES_SEL                               0x800010000000003f, 59,  3
#define OPT_RX_LANE_DISABLED                               0x800320000000003f, 52,  1 // used to set the given lane to be ignored by training logic.  this does not affect powerdown.

/*
 * Leaving these as comments until we close out OPT RAS discussions and write Abus link training
 *
#define OPT_TX_MODE1_PL_FULL_REG                           0x800404000000003f, 48, 16 // iotk alias: for entire tx_mode1_pl register
#define OPT_TX_LANE_PDWN                                   0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default).
#define OPT_TX_LANE_INVERT                                 0x800404000000003f, 49,  1 // used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.
#define OPT_TX_LANE_QUIESCE                                0x800404000000003f, 50,  2 // used to force the output of a lane to a particular logical value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.
#define OPT_TX_PSAVE_REQ_DIS                               0x800404000000003f, 54,  1 // disable tx slice power gating from link layer psav_req control
#define OPT_TX_ERR_INJ_A_ENABLE                            0x800404000000003f, 55,  1 // control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane.
#define OPT_TX_ERR_INJ_B_ENABLE                            0x800404000000003f, 56,  1 // control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane.
#define OPT_TX_PL_SPARE_MODE_0                             0x800404000000003f, 60,  1 // per-lane spare mode latch.
#define OPT_TX_PL_SPARE_MODE_1                             0x800404000000003f, 61,  1 // per-lane spare mode latch.
#define OPT_TX_PL_SPARE_MODE_2                             0x800404000000003f, 62,  1 // per-lane spare mode latch.
#define OPT_TX_PL_SPARE_MODE_3                             0x800404000000003f, 63,  1 // per-lane spare mode latch.
#define OPT_TX_MODE1_PL                                    0x800404000000003f, 48, 16 // register -- description
#define OPT_TX_FIFO_L2U_DLY                                0x80040c000000003f, 48,  3 // this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define OPT_TX_UNLOAD_CLK_DISABLE                          0x80040c000000003f, 56,  1 // set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define OPT_TX_RXCAL                                       0x80040c000000003f, 57,  1 // set transmitter to drive vio/2 common mode on both legs.  use this control during far end rx offset calibration.
#define OPT_TX_UNLOAD_SEL                                  0x80040c000000003f, 58,  3 // controls the preset value of the tx slice unload counter, which effectively gives subcycle control of the offset of tx unload clock from grid clock.
#define OPT_TX_MODE2_PL                                    0x80040c000000003f, 48, 16 // register -- description
#define OPT_TX_ERR_INJECT                                  0x800414000000003f, 48,  5 // inject one beat of error on this lane.  set code 1yyyy where yyyy is the beat in the deserialized cycle to inject on.
#define OPT_TX_FIFO_INIT                                   0x800414000000003f, 53,  1 // used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.
#define OPT_TX_SET_UNLOAD_CLK_DISABLE                      0x800414000000003f, 60,  1 // set tx_unload_clk_disable register
#define OPT_TX_CLR_UNLOAD_CLK_DISABLE                      0x800414000000003f, 61,  1 // clear tx_unload_clk_disable register
#define OPT_TX_CNTL1G_PL                                   0x800414000000003f, 48, 16 // register -- description
#define OPT_TX_LANE_BIST_ERR                               0x80041c000000003f, 48,  1 // indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.
#define OPT_TX_LANE_BIST_ACTVITY_DET                       0x80041c000000003f, 49,  1 // indicates that activity was detected in prbs checker. \r\n\t0:(no_error) no activity \r\n\t1:(error) activity has been found during txbist.
#define OPT_TX_SEG_TEST_STATUS                             0x80041c000000003f, 50,  2 // driver segment test result. bit0 for pad p, bit1 for pad n
#define OPT_TX_TDR_CAPT_VAL                                0x80041c000000003f, 63,  1 // value captured by tdr function, 1-bit shared over a pack, so this value should be the same for each lane.
#define OPT_TX_STAT1_PL                                    0x80041c000000003f, 48, 16 // register -- description
#define OPT_TX_PL_FIR_ERRS_FULL_REG                        0x800424000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define OPT_TX_PL_FIR_ERRS                                 0x800424000000003f, 48,  1 // a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs
#define OPT_TX_PL_FIR_ERR_PL_REGS                          0x800424000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane tx register logic.
#define OPT_TX_FIR_PL                                      0x800424000000003f, 48, 16 // register -- description
#define OPT_TX_PL_FIR_ERRS_MASK_FULL_REG                   0x80042c000000003f, 48, 16 // iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.
#define OPT_TX_PL_FIR_ERRS_MASK                            0x80042c000000003f, 48,  1 // fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs
#define OPT_TX_PL_FIR_ERR_MASK_PL_REGS                     0x80042c000000003f, 48,  1 // iotk alias: fir mask for the per-lane tx register checker.
#define OPT_TX_FIR_MASK_PL                                 0x80042c000000003f, 48, 16 // register -- description
#define OPT_TX_PL_FIR_ERR_INJ_FULL_REG                     0x800434000000003f, 48, 16 // iotk alias: for tx_fir_error_inject_pl register
#define OPT_TX_PL_FIR_ERR_INJ                              0x800434000000003f, 48,  1 // tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker
#define OPT_TX_PL_FIR_ERR_INJ_PL_REGS                      0x800434000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane tx register logic.
#define OPT_TX_FIR_ERROR_INJECT_PL                         0x800434000000003f, 48, 16 // register -- description
#define OPT_TX_BIT_MODE1_E_PL                              0x80043c000000003f, 48, 16 // register -- description
#define OPT_TX_BIT_MODE2_E_PL                              0x800444000000003f, 48, 16 // register -- description
*/
#define OPT_TX_IORESET                                     0x80044c000000003f, 48,  1 // reset the given tx lane
/*
#define OPT_TX_CNTL2_O_PL                                  0x80044c000000003f, 48, 16 // register -- description
#define OPT_TX_TDR_ENABLE                                  0x800454000000003f, 48,  1 // enable tdr on the given tx lane\r\n\tgap
#define OPT_TX_CNTL3_EO_PL                                 0x800454000000003f, 48, 16 // register -- description
#define OPT_TX_PG_SPARE_MODE_0                             0x800c04000000003f, 48,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_1                             0x800c04000000003f, 49,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_2                             0x800c04000000003f, 50,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_3                             0x800c04000000003f, 51,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_4                             0x800c04000000003f, 52,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_5                             0x800c04000000003f, 53,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_6                             0x800c04000000003f, 54,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_7                             0x800c04000000003f, 55,  1 // per-group spare mode latch.
#define OPT_TX_PG_SPARE_MODE_8_9                           0x800c04000000003f, 56,  2 // per-group spare mode latch.
#define OPT_TX_SPARE_MODE_PG                               0x800c04000000003f, 48, 16 // register -- description
#define OPT_TX_BUS_ID                                      0x800c0c000000003f, 48,  6 // this field is used to programmably set the bus number that a group belongs to.
#define OPT_TX_ID1_PG                                      0x800c0c000000003f, 48, 16 // register -- description
#define OPT_TX_CLKDIST_PDWN                                0x800c14000000003f, 48,  3 // used to disable the tx group clocks and put them into a low power state. this does not control per-lane circuits or logic.  \r\n\t bit 0 disables slices 16-23 \r\n\t bit 1 disables slices 8-15 \r\n\t bit 2 disables slices 0-7
#define OPT_TX_BIST_EN                                     0x800c14000000003f, 51,  1 // this bit enables the tx bist state machine to begin testing.
#define OPT_TX_EXBIST_MODE                                 0x800c14000000003f, 52,  1 // this bit is the chicken switch to diable the bist enable through external io.
#define OPT_TX_CTL_MODE1_EO_PG                             0x800c14000000003f, 48, 16 // register -- description
#define OPT_TX_CTL_MODE2_EO_PG                             0x800c1c000000003f, 48, 16 // register -- description
#define OPT_TX_DRV_DATA_PATTERN_GCRMSG                     0x800c24000000003f, 50,  4 // tx drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id)\r\n\t0110:(drv_rxbist) alternate prbs7 pattern for rx bist \r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_prbs7) prbs7 pattern\r\n\t1001:(drv_prbs11) prbs11 pattern\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(drv_prbs15) prbs15 pattern\r\n\t1100:(drv_nvbus) alternate prbs23 for nvbus\r\n\t1101:(drv_prbs31) prbs31 pattern\r\n\t1110:(drv_clk) 1 to 1 clock pattern\r\n\t1111:(unused_b) unused\r\n\trjr
#define OPT_TX_CTL_CNTLG1_EO_PG                            0x800c24000000003f, 48, 16 // register -- description
#define OPT_TX_ERR_INJ_A_FINE_SEL                          0x800c2c000000003f, 48,  3 // random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define OPT_TX_ERR_INJ_A_COARSE_SEL                        0x800c2c000000003f, 51,  4 // random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define OPT_TX_ERR_INJ_A_BER_SEL                           0x800c2c000000003f, 55,  6 // used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)).
#define OPT_TX_ERR_INJ_ENABLE                              0x800c2c000000003f, 61,  1 // overall error injection enable.  when set to 0, all other injection is gated.
#define OPT_TX_ERR_INJ_CLOCK_ENABLE                        0x800c2c000000003f, 62,  1 // enable clocks to larger counter and prbs logic.  use this to stagger start times and effectively seed the injection mechanism randomly.
#define OPT_TX_CTL_CNTL2_EO_PG                             0x800c2c000000003f, 48, 16 // register -- description
#define OPT_TX_ERR_INJ_B_FINE_SEL                          0x800c34000000003f, 48,  3 // random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define OPT_TX_ERR_INJ_B_COARSE_SEL                        0x800c34000000003f, 51,  4 // random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define OPT_TX_ERR_INJ_B_BER_SEL                           0x800c34000000003f, 55,  6 // used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)).
#define OPT_TX_CTL_CNTL3_EO_PG                             0x800c34000000003f, 48, 16 // register -- description
#define OPT_TX_TDR_DAC_CNTL                                0x800ccc000000003f, 48,  8 // controls variable threshold receiver for tdr function
#define OPT_TX_TDR_PHASE_SEL                               0x800ccc000000003f, 57,  1 // controls phase select for tdr function, 0 is for _n leg, 1 is for _p leg.
#define OPT_TX_CTL_CNTL8_EO_PG                             0x800ccc000000003f, 48, 16 // register -- description
#define OPT_TX_TDR_PULSE_OFFSET                            0x800cd4000000003f, 48, 14 // offset value for tdr pulse.
#define OPT_TX_CTL_CNTL9_EO_PG                             0x800cd4000000003f, 48, 16 // register -- description
#define OPT_TX_TDR_PULSE_WIDTH                             0x800cdc000000003f, 48,  8 // width of tdr pulse.
#define OPT_TX_CTL_CNTL10_EO_PG                            0x800cdc000000003f, 48, 16 // register -- description
#define OPT_TX_CTL_STAT1_O_PG                              0x800c84000000003f, 48, 16 // register -- description
#define OPT_TX_CTL_STAT2_O_PG                              0x800c8c000000003f, 48, 16 // register -- description
#define OPT_TX_PG_FIR_ERRS_FULL_REG                        0x800d04000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.
#define OPT_TX_PG_FIR_ERR_TX_SM_REGS                       0x800d04000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group txctl registers.
#define OPT_TX_PG_FIR_ERR_GCR_BUFF                         0x800d04000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group gcr buffer.
#define OPT_TX_PG_FIR_ERR_GCRS_LD_SM                       0x800d04000000003f, 50,  1 // iotk alias: parity error has occurred in the per-group txctl gcr load state machine.
#define OPT_TX_PG_FIR_ERR_GCRS_UNLD_SM                     0x800d04000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_CTL_REGS                         0x800d04000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define OPT_TX_PL_FIR_ERR                                  0x800d04000000003f, 63,  1 // summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define OPT_TX_FIR_PG                                      0x800d04000000003f, 48, 16 // tx group fir error source-isolation reg -- description
#define OPT_TX_PG_FIR_ERR_MASK_FULL_REG                    0x800d0c000000003f, 48, 16 // iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.
#define OPT_TX_PG_FIR_ERRS_MASK                            0x800d0c000000003f, 48,  5 // fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define OPT_TX_PG_FIR_ERR_MASK_TX_SM_REGS                  0x800d0c000000003f, 48,  1 // iotk alias: fir mask for the per-group txctl registers.
#define OPT_TX_PG_FIR_ERR_MASK_GCR_BUFF                    0x800d0c000000003f, 49,  1 // iotk alias: fir mask for the per-group txctl gcr buffer.
#define OPT_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                  0x800d0c000000003f, 50,  1 // iotk alias: fir mask for the per-group txctl gcr load state machine.
#define OPT_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                0x800d0c000000003f, 51,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_MASK_CTL_REGS                    0x800d0c000000003f, 52,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_MASK_BIST                        0x800d0c000000003f, 53,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define OPT_TX_PL_FIR_ERR_MASK                             0x800d0c000000003f, 63,  1 // fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.
#define OPT_TX_FIR_MASK_PG                                 0x800d0c000000003f, 48, 16 // tx group fir error mask reg -- description
#define OPT_TX_CLR_PAR_ERRS                                0x800d14000000003f, 62,  1 // clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.
#define OPT_TX_FIR_RESET                                   0x800d14000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.
#define OPT_TX_FIR_RESET_PG                                0x800d14000000003f, 48, 16 // tx reset control action register -- description
#define OPT_TX_PG_FIR_ERR_INJ_FULL_REG                     0x800d1c000000003f, 48, 16 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.
#define OPT_TX_PG_FIR_ERR_INJ                              0x800d1c000000003f, 48,  5 // tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define OPT_TX_PG_FIR_ERR_INJ_TX_SM_REGS                   0x800d1c000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.
#define OPT_TX_PG_FIR_ERR_INJ_GCR_BUFF                     0x800d1c000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.
#define OPT_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                   0x800d1c000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.
#define OPT_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 0x800d1c000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_INJ_CTL_REGS                     0x800d1c000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define OPT_TX_PG_FIR_ERR_INJ_BIST                         0x800d1c000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define OPT_TX_FIR_ERROR_INJECT_PG                         0x800d1c000000003f, 48, 16 // tx group fir error injection reg -- description
#define OPT_TX_PG_CTL_SM_SPARE_MODE_0                      0x800d24000000003f, 48,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_1                      0x800d24000000003f, 49,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_2                      0x800d24000000003f, 50,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_3                      0x800d24000000003f, 51,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_4                      0x800d24000000003f, 52,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_5                      0x800d24000000003f, 53,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_6                      0x800d24000000003f, 54,  1 // per-group spare mode latch.
#define OPT_TX_PG_CTL_SM_SPARE_MODE_7                      0x800d24000000003f, 55,  1 // per-group spare mode latch.
#define OPT_TX_CTLSM_SPARE_MODE_PG                         0x800d24000000003f, 48, 16 // register -- description
#define OPT_TX_SEG_TEST_MODE                               0x800d2c000000003f, 50,  8 // driver segment test mode: all 0 means normal function mode, when this is not 0, segment test begins
#define OPT_TX_FFE_BOOST_EN                                0x800d2c000000003f, 59,  1 // driver segment test: to enable boost function of nvlink tx
#define OPT_TX_SEG_TEST_LEAKAGE_CTRL                       0x800d2c000000003f, 61,  1 // control txr_txc_sst_ctl_dc in every tx slice. 1 means run segment test in low leakage mode.
#define OPT_TX_CTLSM_MODE1_EO_PG                           0x800d2c000000003f, 48, 16 // register -- description
#define OPT_TX_PSEG_PRE_EN                                 0x800d34000000003f, 51,  5 // pre bank pseg enable
#define OPT_TX_PSEG_PRE_SEL                                0x800d34000000003f, 56,  5 // pre bank pseg mode selection
#define OPT_TX_CTLSM_CNTL1_EO_PG                           0x800d34000000003f, 48, 16 // register -- description
#define OPT_TX_NSEG_PRE_EN                                 0x800d3c000000003f, 51,  5 // pre bank nseg enable
#define OPT_TX_NSEG_PRE_SEL                                0x800d3c000000003f, 56,  5 // pre bank nseg mode selection
#define OPT_TX_CTLSM_CNTL2_EO_PG                           0x800d3c000000003f, 48, 16 // register -- description
#define OPT_TX_PSEG_MARGINPU_EN                            0x800d44000000003f, 48,  8 // margin pull-up bank pseg enable
#define OPT_TX_PSEG_MARGINPD_EN                            0x800d44000000003f, 56,  8 // margin pull-down bank pseg enable
#define OPT_TX_CTLSM_CNTL3_EO_PG                           0x800d44000000003f, 48, 16 // register -- description
#define OPT_TX_NSEG_MARGINPU_EN                            0x800d4c000000003f, 48,  8 // margin pull-up bank nseg enable
#define OPT_TX_NSEG_MARGINPD_EN                            0x800d4c000000003f, 56,  8 // margin pull-down bank nseg enable
#define OPT_TX_CTLSM_CNTL4_EO_PG                           0x800d4c000000003f, 48, 16 // register -- description
#define OPT_TX_MARGINPU_SEL                                0x800d54000000003f, 48,  8 // margin pull-up bank mode selection
#define OPT_TX_MARGINPD_SEL                                0x800d54000000003f, 56,  8 // margin pull-down bank mode selection
#define OPT_TX_CTLSM_CNTL5_EO_PG                           0x800d54000000003f, 48, 16 // register -- description
#define OPT_TX_PSEG_MAIN_EN                                0x800d5c000000003f, 51,  7 // main bank pseg enable
#define OPT_TX_CTLSM_CNTL6_EO_PG                           0x800d5c000000003f, 48, 16 // register -- description
#define OPT_TX_NSEG_MAIN_EN                                0x800d64000000003f, 51,  7 // main bank nseg enable
#define OPT_TX_CTLSM_CNTL7_EO_PG                           0x800d64000000003f, 48, 16 // register -- description
#define OPT_TX_BIST_DONE                                   0x800d6c000000003f, 50,  1 // indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running
#define OPT_TX_CTLSM_STAT1_EO_PG                           0x800d6c000000003f, 48, 16 // register -- description
#define OPT_TX_PSEG_POST_EN                                0x800d84000000003f, 49,  7 // post bank pseg enable
#define OPT_TX_PSEG_POST_SEL                               0x800d84000000003f, 56,  7 // post bank pseg mode selection
#define OPT_TX_CTLSM_CNTL1_O_PG                            0x800d84000000003f, 48, 16 // register -- description
#define OPT_TX_NSEG_POST_EN                                0x800d8c000000003f, 49,  7 // post bank nseg enable
#define OPT_TX_NSEG_POST_SEL                               0x800d8c000000003f, 56,  7 // post bank nseg mode selection
#define OPT_TX_CTLSM_CNTL2_O_PG                            0x800d8c000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_REQ                                    0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define OPT_TX_ZCAL_DONE                                   0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.
#define OPT_TX_ZCAL_ERROR                                  0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_BUSY                                   0x800f04000000003f, 52,  1 // impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.
#define OPT_TX_ZCAL_FORCE_SAMPLE                           0x800f04000000003f, 53,  1 // impedance comparison sample force\r\n\t initiates single cycle sample of the calibration circuit comparison output. accumulated in tx_zcal_sample_cnt(default)\r\n\t0:(disabled) inactive. \r\n\t1:(enabled) enable
#define OPT_TX_ZCAL_CMP_OUT                                0x800f04000000003f, 54,  1 // calibration circuit unqualified sample\r\n\t this is an unconditional sample of the calibration circuit comparison output.
#define OPT_TX_ZCAL_SAMPLE_CNT                             0x800f04000000003f, 55,  9 // calibration circuit qualified sample\r\n\t count of conditional samples of the calibration circuit comparison output properly async staged, inverted with tx_zcal_cya_data_inv, and enabled with tx_zcal_force_sample or normal calibration sequence. cleared on any new request.
#define OPT_TX_IMPCAL_PB                                   0x800f04000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_ANS_NOT_FOUND_ERROR                    0x800f3c000000003f, 49,  1 // impedance calibration sequence answer not found error\r\n\t indicates, independent of tx_zcal_done, no calibration answer was found. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_ANS_RANGE_ERROR                        0x800f3c000000003f, 50,  1 // impedance calibration sequence range check error\r\n\t indicates, independent of tx_zcal_done, the ans is not in max/min range, only works when tx_zcal_range_check is 1. cleared on tx_zcal_req.
#define OPT_TX_ZCAL_TEST_ENABLE                            0x800f3c000000003f, 53,  1 // start impedance bist
#define OPT_TX_ZCAL_TEST_STATUS                            0x800f3c000000003f, 54,  1 // this register stores the result of impedance bist
#define OPT_TX_ZCAL_TEST_DONE                              0x800f3c000000003f, 55,  1 // this register is set to 1 when impedance bist is finished
#define OPT_TX_IMPCAL2_PB                                  0x800f3c000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_N                                      0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_IMPCAL_NVAL_PB                              0x800f0c000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_P                                      0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define OPT_TX_IMPCAL_PVAL_PB                              0x800f14000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_P_4X                                   0x800f1c000000003f, 48,  5 // calibration circuit pseg-4x enable value this holds the current value of the enabled segments and is 2x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0x15 is maximum slices).
#define OPT_TX_IMPCAL_P_4X_PB                              0x800f1c000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_SWO_EN                                 0x800f24000000003f, 48,  1 // impedance calibration software override\r\n\t steers all calibration controls directly from these register fields. effectively disables state machine logic.(default)\r\n\t0:(inactive) inactive. \r\n\t1:(enabled) enable.
#define OPT_TX_ZCAL_SWO_CAL_SEGS                           0x800f24000000003f, 49,  1 // impedance calibration software bank select\r\n\t enable pseg calibration. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define OPT_TX_ZCAL_SWO_CMP_INV                            0x800f24000000003f, 50,  1 // impedance calibration software compare invert\r\n\t swap calibration circuit comparator inputs. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define OPT_TX_ZCAL_SWO_CMP_OFFSET                         0x800f24000000003f, 51,  1 // impedance calibration software offset flush\r\n\t equalize comparator offset in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable offset \r\n\t1:(enable) enable offset.
#define OPT_TX_ZCAL_SWO_CMP_RESET                          0x800f24000000003f, 52,  1 // impedance calibration software comparator reset\r\n\t reset comparator in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable reset \r\n\t1:(enable) enable reset.
#define OPT_TX_ZCAL_SWO_POWERDOWN                          0x800f24000000003f, 53,  1 // impedance calibration software circuit powerdown\r\n\t powerdown calibration circuit. (default)\r\n\t0:(disable) disable powerdown \r\n\t1:(enable) enable powerdown.
#define OPT_TX_ZCAL_SWO_TCOIL                              0x800f24000000003f, 54,  1 // impedance calibration software circuit tcoil\r\n\t
#define OPT_TX_ZCAL_RANGE_CHECK                            0x800f24000000003f, 55,  1 // controls the usage of tx_zcal_sm_min/max_val, 0 means these two registers are used to define the range of zcal. if 1, the calibration range is from 1 to 80, and the min/max registers are only used to check whether the result is in range
#define OPT_TX_ZCAL_CYA_DATA_INV                           0x800f24000000003f, 56,  1 // impedance calibration cya sample inversion\r\n\t select inverted comparator values in case of hardware error. see documentation.(default)\r\n\t0:(true) no sample inversion \r\n\t1:(invert) invert samples.
#define OPT_TX_ZCAL_TEST_OVR_2R                            0x800f24000000003f, 57,  1 // impedance calibration test-only 2r segment override\r\n\t
#define OPT_TX_ZCAL_TEST_OVR_1R                            0x800f24000000003f, 58,  1 // impedance calibration test-only 1r segment override\r\n\t
#define OPT_TX_ZCAL_TEST_OVR_4X_SEG                        0x800f24000000003f, 59,  1 // impedance calibration test-only 4x segment override\r\n\t
#define OPT_TX_ZCAL_TEST_CLK_DIV                           0x800f24000000003f, 60,  1 // this register controls the clock for impedance bist. 1 means the clock is divided by 32. when this register is 0, pll bypass mode is needed.
#define OPT_TX_IMPCAL_SWO1_PB                              0x800f24000000003f, 48, 16 // register -- description
#define OPT_TX_ZCAL_SM_MIN_VAL                             0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_ZCAL_SM_MAX_VAL                             0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define OPT_TX_IMPCAL_SWO2_PB                              0x800f2c000000003f, 48, 16 // register -- description
#define OPT_PB_SPARE_MODE_0                                0x800f34000000003f, 48,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_1                                0x800f34000000003f, 49,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_2                                0x800f34000000003f, 50,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_3                                0x800f34000000003f, 51,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_4                                0x800f34000000003f, 52,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_5                                0x800f34000000003f, 53,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_6                                0x800f34000000003f, 54,  1 // per-bus spare mode latch.
#define OPT_PB_SPARE_MODE_7                                0x800f34000000003f, 55,  1 // per-bus spare mode latch.
#define OPT_SPARE_MODE_PB                                  0x800f34000000003f, 48, 16 // register -- description
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_0                    0x800000000000003f, 48,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_1                    0x800000000000003f, 49,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_2                    0x800000000000003f, 50,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_3                    0x800000000000003f, 51,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_4                    0x800000000000003f, 52,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_5                    0x800000000000003f, 53,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_6                    0x800000000000003f, 54,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_DAC_SPARE_MODE_7                    0x800000000000003f, 55,  1 // per-lane spare mode latch.
#define OPT_RX_CFG_LTE_MC                                  0x800000000000003f, 60,  4 // cfg_lte_mc, see glen for details
#define OPT_RX_DATA_DAC_SPARE_MODE_PL                      0x800000000000003f, 48, 16 // register -- description
#define OPT_RX_A_BANK_CONTROLS                             0x800008000000003f, 48,  6 // power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define OPT_RX_LANE_ANA_PDWN                               0x800008000000003f, 54,  1 // lane power down of analog and custom circuits
#define OPT_RX_PRBS_TEST_DATA                              0x800008000000003f, 55,  3 // prbs test data
#define OPT_RX_B_BANK_CONTROLS                             0x800008000000003f, 58,  6 // power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define OPT_RX_DAC_CNTL1_EO_PL                             0x800008000000003f, 48, 16 // register -- description
*/
#define OPT_RX_A_CONTROLS                                  0x800010000000003f, 48,  6 // bit0 dfe h1 speculation mux select override enables speculation\r\n\tbit1 dfe h1 speculation mux select override\r\n\tbit2 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit3 enables the amp dac for measurements in this bank/nbit4 enables fence for initloff\r\n\tbit5 disables all the h-dacs when a 1\r\n\tcpg
/*
#define OPT_RX_CM_CNTL                                     0x800010000000003f, 54,  3 // bit0 enables integrator common mode cal, used in conjunction with integrator cal enable\r\n\tbit1 is the polarity bit\r\n\tbit 2 is common mode even when 1, odd when 0 /ncpg
#define OPT_RX_DAC_CNTL2_EO_PL                             0x800010000000003f, 48, 16 // register -- description
#define OPT_RX_A_OFFSET_E0                                 0x800018000000003f, 48,  7 // this is the vertical offset of the even low threshold sampling latch.
#define OPT_RX_A_OFFSET_E1                                 0x800018000000003f, 56,  7 // this is the vertical offset of the even high threshold sampling latch.
#define OPT_RX_DAC_CNTL3_EO_PL                             0x800018000000003f, 48, 16 // register -- description
#define OPT_RX_A_OFFSET_O0                                 0x800020000000003f, 48,  7 // this is the vertical offset of the odd low threshold sampling latch.
#define OPT_RX_A_OFFSET_O1                                 0x800020000000003f, 56,  7 // this is the vertical offset of the odd high threshold sampling latch.
*/
#define OPT_RX_DAC_CNTL4_EO_PL                             0x800020000000003f, 48, 16 // register -- description
#define OPT_RX_A_INTEG_COARSE_GAIN                         0x800028000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.
#define OPT_RX_A_EVEN_INTEG_FINE_GAIN                      0x800028000000003f, 52,  5 // this is integrator gain control used in making common mode adjustments.
#define OPT_RX_A_ODD_INTEG_FINE_GAIN                       0x800028000000003f, 57,  5 // this is integrator gain control used in making common mode adjustments.
#define OPT_RX_DAC_CNTL5_EO_PL                             0x800028000000003f, 48, 16 // register -- description
#define OPT_RX_A_CTLE_COARSE                               0x800030000000003f, 48,  5 // this is the ctle coarse peak value, only 4 bits currently used thinking future
#define OPT_RX_A_CTLE_GAIN                                 0x800030000000003f, 53,  4 // this is the ctle gain setting
/*
#define OPT_RX_DAC_CNTL6_EO_PL                             0x800030000000003f, 48, 16 // register -- description
#define OPT_RX_A_H1E_VAL                                   0x800038000000003f, 48,  7 // dfe h1 value for even samplers
#define OPT_RX_A_H1O_VAL                                   0x800038000000003f, 56,  7 // dfe h1 value for odd samplers
#define OPT_RX_DAC_CNTL7_EO_PL                             0x800038000000003f, 48, 16 // register -- description
*/
#define OPT_RX_AMP_VAL                                     0x800040000000003f, 48,  8 // rx ampdac value stored as sign magnitude
/*
#define OPT_RX_DAC_CNTL8_EO_PL                             0x800040000000003f, 48, 16 // register -- description
#define OPT_RX_B_CONTROLS                                  0x800080000000003f, 48,  5 // bit0 dfe h1 speculation mux select override enables speculation\r\n\tbit1 dfe h1 speculation mux select override\r\n\tbit2 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit3 enables the amp dac for measurements in this bank/nbit4 enables fence for initloff\r\n\tcpg
#define OPT_RX_DAC_CNTL1_O_PL                              0x800080000000003f, 48, 16 // register -- description
#define OPT_RX_B_OFFSET_E0                                 0x800088000000003f, 48,  7 // this is the vertical offset of the even low threshold sampling latch. the step size is vio/256.
#define OPT_RX_B_OFFSET_E1                                 0x800088000000003f, 56,  7 // this is the vertical offset of the even high threshold sampling latch. the step size is vio/256.
#define OPT_RX_DAC_CNTL2_O_PL                              0x800088000000003f, 48, 16 // register -- description
#define OPT_RX_B_OFFSET_O0                                 0x800090000000003f, 48,  7 // this is the vertical offset of the odd low threshold sampling latch. the step size is vio/256.
#define OPT_RX_B_OFFSET_O1                                 0x800090000000003f, 56,  7 // this is the vertical offset of the odd high threshold sampling latch. the step size is vio/256.
*/
#define OPT_RX_DAC_CNTL3_O_PL                              0x800090000000003f, 48, 16 // register -- description
#define OPT_RX_B_INTEG_COARSE_GAIN                         0x800098000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.
#define OPT_RX_B_EVEN_INTEG_FINE_GAIN                      0x800098000000003f, 52,  5 // this is integrator gain control used in making common mode adjustments
#define OPT_RX_B_ODD_INTEG_FINE_GAIN                       0x800098000000003f, 57,  5 // this is integrator gain control used in making common mode adjustments.
#define OPT_RX_DAC_CNTL4_O_PL                              0x800098000000003f, 48, 16 // register -- description
#define OPT_RX_B_CTLE_COARSE                               0x8000a0000000003f, 48,  5 // this is the ctle coarse peak value
#define OPT_RX_B_CTLE_GAIN                                 0x8000a0000000003f, 53,  4 // this is the ctle gain setting
/*
#define OPT_RX_DAC_CNTL5_O_PL                              0x8000a0000000003f, 48, 16 // register -- description
#define OPT_RX_B_H1E_VAL                                   0x8000a8000000003f, 48,  7 // dfe h1 value for even samplers
#define OPT_RX_B_H1O_VAL                                   0x8000a8000000003f, 56,  7 // dfe h1 value for odd samplers
#define OPT_RX_DAC_CNTL6_O_PL                              0x8000a8000000003f, 48, 16 // register -- description
#define OPT_RX_E_CONTROLS                                  0x8000b0000000003f, 48,  3 // bit0 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit1 enables the amp dac for measurements in this bank/nbit2 enables fence for initloff\r\n\tcpg
#define OPT_RX_DAC_CNTL7_O_PL                              0x8000b0000000003f, 48, 16 // register -- description
#define OPT_RX_E_OFFSET_E                                  0x8000b8000000003f, 48,  7 // this is the vertical offset of the even low threshold sampling latch. the step size is vio/256.
#define OPT_RX_E_OFFSET_O                                  0x8000b8000000003f, 56,  7 // this is the vertical offset of the odd low threshold sampling latch. the step size is vio/256.
*/
#define OPT_RX_DAC_CNTL8_O_PL                              0x8000b8000000003f, 48, 16 // register -- description
#define OPT_RX_E_INTEG_COARSE_GAIN                         0x8000c0000000003f, 48,  4 // this is integrator coarse gain control used in making common mode adjustments.
#define OPT_RX_E_EVEN_INTEG_FINE_GAIN                      0x8000c0000000003f, 52,  5 // this is integrator gain control used in making common mode adjustments
#define OPT_RX_E_ODD_INTEG_FINE_GAIN                       0x8000c0000000003f, 57,  5 // this is integrator gain control used in making common mode adjustments.
#define OPT_RX_DAC_CNTL9_O_PL                              0x8000c0000000003f, 48, 16 // register -- description
#define OPT_RX_E_CTLE_COARSE                               0x8000c8000000003f, 48,  5 // this is the ctle coarse peak value
#define OPT_RX_E_CTLE_GAIN                                 0x8000c8000000003f, 53,  4 // this is the ctle gain setting
/*
#define OPT_RX_DAC_CNTL10_O_PL                             0x8000c8000000003f, 48, 16 // register -- description
#define OPT_RX_PL_SPARE_MODE_0                             0x800200000000003f, 48,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_1                             0x800200000000003f, 49,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_2                             0x800200000000003f, 50,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_3                             0x800200000000003f, 51,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_4                             0x800200000000003f, 52,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_5                             0x800200000000003f, 53,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_6                             0x800200000000003f, 54,  1 // per-lane spare mode latch.
#define OPT_RX_PL_SPARE_MODE_7                             0x800200000000003f, 55,  1 // per-lane spare mode latch.
#define OPT_RX_SPARE_MODE_PL                               0x800200000000003f, 48, 16 // register -- description
#define OPT_RX_PL_FIR_ERRS_FULL_REG                        0x800208000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define OPT_RX_PL_FIR_ERRS                                 0x800208000000003f, 48,  3 // a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tbit1: parity error in ddc sm.
#define OPT_RX_PL_FIR_ERR_PL_REGS                          0x800208000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane rx registers.
#define OPT_RX_PL_FIR_ERR_DDC_SM                           0x800208000000003f, 49,  1 // iotk alias: parity error has occurred in the per-lane rx ddc state machine.
#define OPT_RX_PL_FIR_ERR_DAC_REGS                         0x800208000000003f, 50,  1 // iotk alias: parity error has occurred in the per-lane rx data dac regs.
#define OPT_RX_FIR_PL                                      0x800208000000003f, 48, 16 // register -- description
#define OPT_RX_PL_FIR_ERRS_MASK_FULL_REG                   0x800210000000003f, 48, 16 // iotk alias: fir mask for rx_fir_pl errors.
#define OPT_RX_PL_FIR_ERRS_MASK                            0x800210000000003f, 48,  3 // fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tbit1 - (err_pl_mask_ddc_sm) per-lane ddc sm parity error.
#define OPT_RX_PL_FIR_ERR_MASK_PL_REGS                     0x800210000000003f, 48,  1 // iotk alias: fir mask for per-lane register parity errors.
#define OPT_RX_PL_FIR_ERR_MASK_DDC_SM                      0x800210000000003f, 49,  1 // iotk alias: fir mask for per-lane rx ddc state machine parity error.
#define OPT_RX_PL_FIR_ERR_MASK_DAC_REGS                    0x800210000000003f, 50,  1 // iotk alias: fir mask for per-lane rx data dac regs parity error.
#define OPT_RX_FIR_MASK_PL                                 0x800210000000003f, 48, 16 // register -- description
#define OPT_RX_PL_FIR_ERR_INJ_FULL_REG                     0x800218000000003f, 48, 16 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define OPT_RX_PL_FIR_ERR_INJ                              0x800218000000003f, 48,  3 // rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tbit1: rx per-lane ddc sm parity error inject.\r\n\tbit2: rx per-lane data dac regs parity error inject.
#define OPT_RX_PL_FIR_ERR_INJ_PL_REGS                      0x800218000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define OPT_RX_PL_FIR_ERR_INJ_DDC_SM                       0x800218000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx ddc state machine.
#define OPT_RX_PL_FIR_ERR_INJ_DAC_REGS                     0x800218000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx data dac regs.
#define OPT_RX_FIR_ERROR_INJECT_PL                         0x800218000000003f, 48, 16 // register -- description
#define OPT_RX_MODE_PL_FULL_REG                            0x800220000000003f, 48, 16 // alias for entire rx_mode_pl register
#define OPT_RX_LANE_DIG_PDWN                               0x800220000000003f, 48,  1 // used to power down digital logic for a lane.
#define OPT_RX_BER_DPIPE_MUX_SEL                           0x800220000000003f, 49,  1 // diag ber data pipe mux select. when set to a 1 the xor of the main and alt data is muxed onto the main data path feeding the data pipe.
#define OPT_RX_DECOUPLE_EDGE_A                             0x800220000000003f, 50,  1 // this bit enables a mode where phase rotator a is decoupled from edge. its position is directly equal to the rx_pr_data_a_offset value.
#define OPT_RX_DECOUPLE_EDGE_B                             0x800220000000003f, 51,  1 // this bit enables a mode where phase rotator b is decoupled from edge. its position is directly equal to the rx_pr_data_b_offset value.
#define OPT_RX_PSAVE_DIG_REQ_DIS                           0x800220000000003f, 52,  1 // disable digital rx slice power gating from link layer psav_req control
#define OPT_RX_PSAVE_ANA_REQ_DIS                           0x800220000000003f, 53,  1 // disable analog rx slice power gating from link layer psav_req control
#define OPT_RX_BIT_MODE1_EO_PL                             0x800220000000003f, 48, 16 // register -- description
#define OPT_RX_PR_FW_OFF                                   0x800228000000003f, 56,  1 // removes the flywheel from the pr accumulator.  note, this is different than setting the inertia amount to zero.
#define OPT_RX_PR_FW_INERTIA_AMT                           0x800228000000003f, 57,  3 // amount to be added or subtracted from flywheel intertia.  note, setting this to zero may not turn off the flywheel if the flywheel accumulator already has a value (as if it were turned off after having run for some time).
#define OPT_RX_PR_PHASE_STEP                               0x800228000000003f, 60,  4 // amount to be added or subtracted from to phase rotator accumulator on each shift left or right.  0000: decoded as b10000 in logic, so pr will update every 4 shifts; other values will update with every 4*(16/phase_step) shifts.
#define OPT_RX_BIT_MODE2_EO_PL                             0x800228000000003f, 48, 16 // register -- description
#define OPT_RX_BER_CFG                                     0x800230000000003f, 48,  3 // this register controls the bit error rate threshold used for ddc.
#define OPT_RX_FIFO_DLY_CFG                                0x800230000000003f, 51,  2 // this register controls how many parallel clock cycles we wait after every change to the phase rotator before we begin using the data again.
#define OPT_RX_DDC_CFG                                     0x800230000000003f, 53,  2 // this register controls how many parallel clock cycles we wait looking for errors as we march further into the edge.
#define OPT_RX_BIT_MODE3_EO_PL                             0x800230000000003f, 48, 16 // register -- description
#define OPT_RX_PR_COARSE_MODE_EN                           0x800238000000003f, 48,  1 // allow the cdr to switch into coarse mode as needed - on a cdr stop/start or invalid lock (if enabled)
#define OPT_RX_PR_INVALID_LOCK_COARSE_EN                   0x800238000000003f, 49,  1 // allow the cdr to switch into coarse mode (when enabled) on an invalid lock; remain in coarse mode until there are no invalid locks regardless of this bit.
#define OPT_RX_PR_FW_INERTIA_AMT_COARSE                    0x800238000000003f, 50,  3 // flywheel inertia in coarse mode. see rx_pr_fw_inertia_amt for a description.
#define OPT_RX_PR_PHASE_STEP_COARSE                        0x800238000000003f, 53,  4 // phase step in coarse mode. see rx_pr_phase_step for a description.
#define OPT_RX_PR_COARSE_MODE_TIMER_SEL                    0x800238000000003f, 57,  2 // selects how long to remain in coarse mode; the timer is always reset on an invalid lock.  00: ~1.3us, 01: ~2.6us, 10: ~5.2us, 11: ~10.5us
#define OPT_RX_BIT_MODE4_EO_PL                             0x800238000000003f, 48, 16 // register -- description
*/
#define OPT_RX_CAL_LANE_SEL                                0x800240000000003f, 48,  1 // selects which lane to recalibrate.
#define OPT_RX_PIPE_SEL                                    0x800240000000003f, 49,  2 // selects what to mux onto the data pipe bus going to the calibration logic. \r\n\t00: first half main data, second half alt data \r\n\t01: first half main data, second half edge data \r\n\t10: double width deserialized main data \r\n\t11: reserved
#define OPT_RX_BANK_SEL_A                                  0x800240000000003f, 51,  1 // selects which data bank to select for main data samples and alt data samples. \r\n\t0:(datab) data bank b is selected for main data, and data bank a is selected for alt data \r\n\t1:(dataa) data bank a is selected for main data, and data bank b is selected for alt data.
/*
#define OPT_RX_PIPE_MARGIN                                 0x800240000000003f, 52,  1 // adds extra cycles of padding on the async data pipe handshake
#define OPT_RX_SCOPE_MODE                                  0x800240000000003f, 53,  2 // adds extra cycles in the asyc crossing for scope mode
#define OPT_RX_BIST_PIPE_DATA_SHIFT                        0x800240000000003f, 57,  1 // selects what to mux onto the data pipe bus going to the rx_bist engine to get upper order lanes on edge and alt only \r\n\t0: no shift \r\n\t1: shift data
#define OPT_RX_BIT_CNTLX1_EO_PL                            0x800240000000003f, 48, 16 // register -- description
#define OPT_RX_PR_EDGE_TRACK_CNTL                          0x800248000000003f, 48,  2 // runs edge tracking on the selected bank.  00: no edge tracking, 01: tracks against a data, 10: tracks against b data, 11: unused.
#define OPT_RX_PR_WOBBLE_A                                 0x800248000000003f, 50,  1 // wobbles the pr position for pr a for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define OPT_RX_PR_WOBBLE_B                                 0x800248000000003f, 51,  1 // wobbles the pr position for pr b for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define OPT_RX_PR_WOBBLE_EDGE                              0x800248000000003f, 52,  1 // wobbles the pr position for pr edge for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define OPT_RX_PR_DDC_A                                    0x800248000000003f, 53,  1 // enables ddc state machine to go through its ddc routine on pr a.  works by shifting to the left and right looking for errors to find the edges, then adds an offset that centers the data between the 2 edges.
#define OPT_RX_PR_DDC_B                                    0x800248000000003f, 54,  1 // enables ddc state machine to go through its ddc routine on pr b.  works by shifting to the left and right looking for errors to find the edges, then adds an offset that centers the data between the 2 edges.
#define OPT_RX_PR_BUMP_TO_EDGE_A                           0x800248000000003f, 55,  1 // bumps pr a position to the edge => +(16 - clkadj).
#define OPT_RX_PR_BUMP_TO_EDGE_B                           0x800248000000003f, 56,  1 // bumps pr b position to the edge. (not supported)
*/
#define OPT_RX_PR_BUMP_SL_1UI                              0x800248000000003f, 57,  1 // bumps the pr position of all prs to the next eye by shifting 32-steps. (not supported)
/*
#define OPT_RX_PR_BUMP_SR_1UI                              0x800248000000003f, 58,  1 // bumps the pr position to the previous eye by shifting 32-steps. (not supported)
#define OPT_RX_PR_DATA_OFFSET_DISABLE_A                    0x800248000000003f, 59,  1 // disables phase rotator offset for a bank (dd2
#define OPT_RX_PR_DATA_OFFSET_DISABLE_B                    0x800248000000003f, 60,  1 // disables phase rotator offset for b bank (dd2
#define OPT_RX_PR_USE_DFE_CLOCK_A                          0x800248000000003f, 61,  1 // rx use a-bank dfe (h1/ap-adjusted clock\r\n\t0: use ddc clock.\r\n\t1: use dfe clock.\r\n\trjrdmb
#define OPT_RX_PR_USE_DFE_CLOCK_B                          0x800248000000003f, 62,  1 // rx use b-bank dfe (h1/ap-adjusted clock\r\n\t0: use ddc clock.\r\n\t1: use dfe clock.\r\n\trjrdmb
#define OPT_RX_BIT_CNTL2_EO_PL                             0x800248000000003f, 48, 16 // register -- description
#define OPT_RX_PR_DATA_A_OFFSET                            0x800250000000003f, 48,  6 // offset value applied to pr a
#define OPT_RX_PR_DATA_B_OFFSET                            0x800250000000003f, 54,  6 // offset value applied to pr b
#define OPT_RX_PR_BIT_LOCK_DONE                            0x800250000000003f, 60,  1 // indicates that bit lock is done, used to gate invalid lock in the cdr logic
#define OPT_RX_PR_INVALID_LOCK_FILTER_EN                   0x800250000000003f, 61,  1 // enables the filtered invalid_lock phase rotator shift_right. default is on.
#define OPT_RX_PR_INVALID_LOCK_BUMP_SIZE                   0x800250000000003f, 62,  2 // sets the size of the invalid_lock_bump\r\n\t00: 0 steps\r\n\t01: 1 step\r\n\t10: 2 steps\r\n\t11: 4 steps
#define OPT_RX_BIT_CNTL3_EO_PL                             0x800250000000003f, 48, 16 // register -- description
#define OPT_RX_PR_TRACE_DDC_STOP                           0x800258000000003f, 48,  1 // enables the trace debug ddc state to stop the state machines.
#define OPT_RX_PR_TRACE_DDC_SM                             0x800258000000003f, 49,  5 // determines when to stop the state machine for trace debug.
#define OPT_RX_PR_TRACE_WOBBLE_STOP                        0x800258000000003f, 54,  1 // enables the trace debug wobble state to stop the state machines.
#define OPT_RX_PR_TRACE_WOBBLE_SM                          0x800258000000003f, 55,  3 // determines when to stop the state machine for trace debug.
*/
#define OPT_RX_PR_RESET                                    0x800258000000003f, 62,  1 // set this to reset cdr logic.  power and clocks must be enabled in the slice.
#define OPT_RX_IORESET                                     0x800258000000003f, 63,  1 // reset the given rx lane (except the cdr logic)
/*
#define OPT_RX_BIT_CNTL4_EO_PL                             0x800258000000003f, 48, 16 // register -- description
#define OPT_RX_PR_BUMP_SL_1STEP                            0x800260000000003f, 48,  1 // rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 adds one to the binary pr value. an increase in pr value has the effect of moving the c2 clocks to the samplat earlier in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_right_half servo command.
#define OPT_RX_PR_BUMP_SR_1STEP                            0x800260000000003f, 49,  1 // rx manual phase rotator shift left pulse\r\n\twriting this bit to a 1 subtracts one from the binary pr value. a decrease in pr value has the effect of moving the c2 clocks to the samplat later in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_left_half servo command.
#define OPT_RX_PR_IN_COARSE_MODE_STICKY_CLEAR              0x800260000000003f, 50,  1 // clears the rx_pr_in_coarse_mode_sticky sticky bit.
#define OPT_RX_BIT_CNTL5_EO_PL                             0x800260000000003f, 48, 16 // register -- description
#define OPT_RX_PSAVE_MODE_ACTIVE                           0x800268000000003f, 56,  1 // indicates that psave mode has been requested for this lane
#define OPT_RX_BIT_STAT1_EO_PL                             0x800268000000003f, 48, 16 // register -- description
#define OPT_RX_PR_WOBBLE_A_IP                              0x800270000000003f, 50,  1 // wobble in progress on pr a.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define OPT_RX_PR_WOBBLE_B_IP                              0x800270000000003f, 51,  1 // wobble in progress on pr b.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define OPT_RX_PR_WOBBLE_EDGE_IP                           0x800270000000003f, 52,  1 // wobble in progress on pr edge.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define OPT_RX_PR_DDC_DONE                                 0x800270000000003f, 53,  1 // dynamic data centering in done on pr a or b.
#define OPT_RX_PR_DDC_FAILED                               0x800270000000003f, 54,  1 // dynamic data centering in failed on pr a or b.
#define OPT_RX_PR_BUMP_SL_1UI_DONE                         0x800270000000003f, 56,  1 // bump forward 1-ui into the next eye done.  becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away.
#define OPT_RX_PR_BUMP_SR_1UI_DONE                         0x800270000000003f, 57,  1 // bump minus 1-ui into the next eye done   becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away.
#define OPT_RX_PR_TRACE_STOPPED                            0x800270000000003f, 58,  1 // indicates that the trace bus stop command has asserted.
#define OPT_RX_BIT_STAT2_EO_PL                             0x800270000000003f, 48, 16 // register -- description
#define OPT_RX_PR_L_R_EDGE_A_ALIAS                         0x800278000000003f, 48, 12 // rx phase rotator a bank leftand right edge alias
#define OPT_RX_PR_LEFT_EDGE_A                              0x800278000000003f, 48,  6 // rx phase rotator a bank left edge
#define OPT_RX_PR_RIGHT_EDGE_A                             0x800278000000003f, 54,  6 // rx phase rotator a bankright edge
#define OPT_RX_A_PR_DFE_CLKADJ                             0x800278000000003f, 60,  4 // tweak value in phase rotator steps for the bank a clock offset when doing dfe calibration
#define OPT_RX_BIT_STAT3_EO_PL                             0x800278000000003f, 48, 16 // register -- description
#define OPT_RX_PR_IN_COARSE_MODE                           0x800280000000003f, 48,  1 // asserted when the cdr is in coarse mode; this can be used as a not locked indicator since the coarse mode timer will not expire if are detecting invalid locks.
#define OPT_RX_PR_IN_COARSE_MODE_STICKY                    0x800280000000003f, 49,  1 // sticky bit. asserts when the cdr is in coarse mode and remains asserted until the sticky bit is cleared using rx_ioreset or rx_pr_in_coarse_mode_sticky_clear.
#define OPT_RX_PR_FW_GRAY_CODED                            0x800280000000003f, 50,  7 // the gray encoded flywheel value.
#define OPT_RX_BIT_STAT4_EO_PL                             0x800280000000003f, 48, 16 // register -- description
#define OPT_RX_PR_L_R_EDGE_B_ALIAS                         0x800318000000003f, 48, 12 // rx phase rotator b bank left and right edge alias
#define OPT_RX_PR_LEFT_EDGE_B                              0x800318000000003f, 48,  6 // rx phase rotator b bank left edge
#define OPT_RX_PR_RIGHT_EDGE_B                             0x800318000000003f, 54,  6 // rx phase rotator b bank right edge
#define OPT_RX_B_PR_DFE_CLKADJ                             0x800318000000003f, 60,  4 // tweak value in phase rotator steps for the bank b clock offset when doing dfe calibration
#define OPT_RX_BIT_STAT1_O_PL                              0x800318000000003f, 48, 16 // register -- description
*/
#define OPT_RX_RUN_LANE                                    0x800320000000003f, 48,  1 // run training and subsequent recalibration on given lane
/*
#define OPT_RX_RUN_DCCAL                                   0x800320000000003f, 49,  1 // run on-die dc training on given lane
#define OPT_RX_RECAL_REQ                                   0x800320000000003f, 50,  1 // request recalibration on given lane
*/
#define OPT_RX_RECAL_ABORT                                 0x800320000000003f, 51,  1 // stop recalibration on given lane
#define OPT_RX_LANE_DISABLED                               0x800320000000003f, 52,  1 // used to set the given lane to be ignored by training logic.  this does not affect powerdown.
#define OPT_RX_FORCE_INIT_DONE                             0x800320000000003f, 53,  1 // force init_done output port for this lane to one.

#define OPT_RX_INT_MODE                                    0x8008e8000000003f, 48,  4 // rx interrupt mode setting
#define OPT_RX_INT_ENABLE_ENC                              0x8008f0000000003f, 48,  4 // rx interrupt encoded enable
#define OPT_RX_INT_CURRENT_STATE                           0x8008e8000000003f, 52, 12 // rx interrupt current state to stop on
#define OPT_RX_INT_NEXT_STATE                              0x8008f0000000003f, 52, 12 // rx interrupt next state to stop on
#define OPT_RX_INT_GOTO_STATE                              0x8008f8000000003f, 52, 12 // rx interrupt state to go to upon interrupt trigger
/*
#define OPT_RX_FORCE_RECAL_DONE                            0x800320000000003f, 54,  1 // force recal_done output port for this lane to one.
#define OPT_RX_GLBSM_PL_CNTL1_O_PL                         0x800320000000003f, 48, 16 // register -- description
#define OPT_RX_INIT_DONE                                   0x800328000000003f, 48,  1 // initial training complete on given lane
#define OPT_RX_DCCAL_DONE                                  0x800328000000003f, 49,  1 // on-die dc training complete on given lane
#define OPT_RX_LANE_BUSY                                   0x800328000000003f, 50,  1 // state machine busy indicator on given lane
#define OPT_RX_RECAL_DONE                                  0x800328000000003f, 51,  1 // recalibration done on given lane
#define OPT_RX_RUN_LANE_ACTIVE                             0x800328000000003f, 52,  1 // lane is requested to train, actively training, or trained
#define OPT_RX_RECAL_REQ_ACTIVE                            0x800328000000003f, 53,  1 // lane is requested to recalibrate or actively recalibrating
#define OPT_RX_RECAL_ABORT_ACTIVE                          0x800328000000003f, 54,  1 // lane is requested to abort or actively aborting
#define OPT_RX_GLBSM_PL_STAT1_O_PL                         0x800328000000003f, 48, 16 // register -- description
#define OPT_RX_SET_RUN_LANE                                0x800330000000003f, 48,  1 // set rx_run_lane register bit used by rx_bist_engine
#define OPT_RX_CLR_RUN_LANE                                0x800330000000003f, 49,  1 // clear rx_run_lane register bit used by rx_bist_engine
#define OPT_RX_SET_RUN_DCCAL                               0x800330000000003f, 50,  1 // set rx_run_dccal register bit used by rx_bist_engine
#define OPT_RX_CLR_RUN_DCCAL                               0x800330000000003f, 51,  1 // clear rx_run_dccal register bit used by rx_bist_engine
#define OPT_RX_GLBSM_PL_CNTL1X_O_PL                        0x800330000000003f, 48, 16 // register -- description
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_0                   0x800380000000003f, 48,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_1                   0x800380000000003f, 49,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_2                   0x800380000000003f, 50,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_3                   0x800380000000003f, 51,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_4                   0x800380000000003f, 52,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_5                   0x800380000000003f, 53,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_6                   0x800380000000003f, 54,  1 // per-lane spare mode latch.
#define OPT_RX_PL_DATA_WORK_SPARE_MODE_7                   0x800380000000003f, 55,  1 // per-lane spare mode latch.
#define OPT_RX_DATA_WORK_SPARE_MODE_PL                     0x800380000000003f, 48, 16 // register -- description
#define OPT_RX_BIST_ERR_A                                  0x800388000000003f, 61,  1 // indicates that rxbist did not find two data eyes of sufficient width while testing bank a.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define OPT_RX_BIST_ERR_B                                  0x800388000000003f, 62,  1 // indicates that rxbist did not find two data eyes of sufficient width while testing bank b.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define OPT_RX_BIST_ERR_E                                  0x800388000000003f, 63,  1 // indicates that rxbist did not find two data eyes of sufficient width while testing bank e.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define OPT_RX_WORK_STAT1_EO_PL                            0x800388000000003f, 48, 16 // register -- description
#define OPT_RX_A_BAD_DFE_CONV                              0x800390000000003f, 48,  1 // eye opt step failed dfd convergence on bank a--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define OPT_RX_B_BAD_DFE_CONV                              0x800390000000003f, 49,  1 // eye opt step failed dfd convergence on bank b--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define OPT_RX_A_H1AP_AT_LIMIT                             0x800390000000003f, 50,  1 // eye opt h1/ap ratio limit hit bank a--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define OPT_RX_B_H1AP_AT_LIMIT                             0x800390000000003f, 51,  1 // eye opt h1/ap ratio limit hit bank_b--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define OPT_RX_A_AP                                        0x800390000000003f, 52,  8 // eye opt stored ap value
#define OPT_RX_WORK_STAT2_EO_PL                            0x800390000000003f, 48, 16 // register -- description
#define OPT_RX_A_PATH_OFF_EVEN                             0x800398000000003f, 48,  6 // eye opt a bank even path offset
#define OPT_RX_A_PATH_OFF_ODD                              0x800398000000003f, 54,  6 // eye opt a bank odd  path offset
#define OPT_RX_WORK_STAT3_EO_PL                            0x800398000000003f, 48, 16 // register -- description
#define OPT_RX_B_PATH_OFF_EVEN                             0x8003a0000000003f, 48,  6 // eye opt b bank even path offset
#define OPT_RX_B_PATH_OFF_ODD                              0x8003a0000000003f, 54,  6 // eye opt b bank odd  path offset
#define OPT_RX_WORK_STAT4_O_PL                             0x8003a0000000003f, 48, 16 // register -- description
#define OPT_RX_WORK_REGS_IORESET                           0x8003a8000000003f, 48,  1 // set bit to reset work regs of a single slice
#define OPT_RX_WORK_CNTL1_O_PL                             0x8003a8000000003f, 48, 16 // register -- description
#define OPT_RX_PG_SPARE_MODE_0                             0x800800000000003f, 48,  1 // per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_1                             0x800800000000003f, 49,  1 // per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_2                             0x800800000000003f, 50,  1 // per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_3                             0x800800000000003f, 51,  1 // per-group spare mode latch.
#define OPT_RX_PG_SPARE_MODE_4                             0x800800000000003f, 52,  1 // chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.
#define OPT_RX_SPARE_MODE_PG                               0x800800000000003f, 48, 16 // register -- description
#define OPT_RX_BUS_ID                                      0x800808000000003f, 48,  6 // this field is used to programmably set the bus number that a clkgrp belongs to.
#define OPT_RX_ID1_PG                                      0x800808000000003f, 48, 16 // register -- description
#define OPT_RX_CLKDIST_PDWN                                0x800810000000003f, 48,  3 // used to disable the rx group clocks and put them into a low power state. \r\n\t bit 0 disables slices 0-7 \r\n\t bit 1 disables slices 8-15 \r\n\t bit 2 disables slices 16-23
#define OPT_RX_BIST_MIN_EYE_WIDTH                          0x800810000000003f, 51,  6 // rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass.
#define OPT_RX_A_BIST_EN                                   0x800810000000003f, 57,  1 // bist enable pin
#define OPT_RX_B_BIST_EN                                   0x800810000000003f, 58,  1 // bist enable pin
#define OPT_RX_E_BIST_EN                                   0x800810000000003f, 59,  1 // bist enable pin
#define OPT_RX_BISTCLK_EN                                  0x800810000000003f, 60,  2 // bist clock enable pins
#define OPT_RX_DISABLE_BANK_PDWN                           0x800810000000003f, 62,  1 // used to disable powerdown of unused (functionally) bank
#define OPT_RX_CTL_MODE1_EO_PG                             0x800810000000003f, 48, 16 // register -- description
#define OPT_RX_DFE_CA_CFG                                  0x800818000000003f, 48,  2 // rx dfe clock adjust settings\r\n\tthis 2 bit register contains an encoded value for of k as follows\r\n\t00 - 8\r\n\t01 - 10\r\n\t10 - 12\r\n\t11 - 14\r\n\t  lab testing will be required to determine the proper value of k.
#define OPT_RX_SCOPE_CONTROL                               0x800818000000003f, 50,  4 // 4 bit value telling which scope bit we are capturing, valid values 0 through 9
#define OPT_RX_RECAL_REQ_DL_MASK                           0x800818000000003f, 54,  1 // mask rx_recal_req_dl primary inputs from data layer
#define OPT_RX_RECAL_DONE_DL_MASK                          0x800818000000003f, 55,  1 // mask rx_recal_done_dl primary inputs from data layer
#define OPT_RX_RUN_LANE_DL_MASK                            0x800818000000003f, 56,  1 // mask rx_run_lane_dl primary inputs from data layer
#define OPT_RX_RECAL_ABORT_DL_MASK                         0x800818000000003f, 57,  1 // mask rx_recal_abort_dl primary inputs from data layer
#define OPT_RX_INIT_DONE_DL_MASK                           0x800818000000003f, 58,  1 // mask rx_init_done_dl primary outputs to data layer
#define OPT_RX_DATA_PIPE_CLR_ON_READ_MODE                  0x800818000000003f, 59,  1 // data pipe capture on read mode.  when set, reading rx_data_pipe_16_31 will automatically capture new data.  otherwise rx_data_pipe_capture must be written.
#define OPT_RX_CTL_MODE2_EO_PG                             0x800818000000003f, 48, 16 // register -- description
#define OPT_RX_TRACKING_TIMEOUT_SEL                        0x800830000000003f, 56,  4 // time to wait for phase tracking to lock on the edge before proceding in the state machine (see workbook table 4.10 for timer settings)
#define OPT_RX_CTL_MODE5_EO_PG                             0x800830000000003f, 48, 16 // register -- description
#define OPT_RX_EO_CONVERGED_END_COUNT                      0x800838000000003f, 48,  4 // rx eye optimization covergence counter end value--number of times through the vga + ctle peaking substeps before giving up\r\n\t0000:16 \r\n\t0001: 1 \r\n\t0010:2  \r\n\t0011: 3 \r\n\t0100: 4 \r\n\t0101: 5 \r\n\t0110:6 \r\n\t0111:7  \r\n\t1000:8  \r\n\t1001:9   \r\n\t1010:10  \r\n\t1011:11  \r\n\t1100:12 \r\n\t1101:13 \r\n\t1110:14 \r\n\t1111:15 \r\n\trjr
#define OPT_RX_HIST_MIN_EYE_WIDTH_MODE                     0x800838000000003f, 52,  2 // rx historic eye width and height minimum measurement mode \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_width_lane and  rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define OPT_RX_HIST_MIN_EYE_HEIGHT_MODE                    0x800838000000003f, 54,  2 // rx historic eye height minimum measurement mode--inoperative on naples dd1 hardware--use the rx_hist_min_eye_width_mode control instead--set both the width and height_mode controls to the same value in test routines to maintain compatibiliy \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define OPT_RX_AMP_GAIN_CNT_MAX                            0x800838000000003f, 56,  4 // maximum number of attempts to adjust vga gain before doing a peaking operation. \r\n\t0000:16 \r\n\t0001: 1 \r\n\t0010:2  \r\n\t0011: 3 \r\n\t0100: 4 \r\n\t0101: 5 \r\n\t0110:6 \r\n\t0111:7  \r\n\t1000:8  \r\n\t1001:9   \r\n\t1010:10  \r\n\t1011:11  \r\n\t1100:12 \r\n\t1101:13 \r\n\t1110:14 \r\n\t1111:15 \r\n\trjr
#define OPT_RX_CTL_MODE6_EO_PG                             0x800838000000003f, 48, 16 // register -- description
#define OPT_RX_ABORT_CHECK_TIMEOUT_SEL                     0x800840000000003f, 48,  4 // selects abort check timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define OPT_RX_POLLING_TIMEOUT_SEL                         0x800840000000003f, 52,  4 // selects polling read timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define OPT_RX_CTL_MODE7_EO_PG                             0x800840000000003f, 48, 16 // register -- description
#define OPT_RX_CTL_MODE8_EO_PG                             0x800848000000003f, 48, 16 // register -- description
#define OPT_RX_MIN_EYE_WIDTH                               0x800850000000003f, 50,  6 // minimum acceptable eye width used during init or recal results checking--edi or ei4
#define OPT_RX_MIN_EYE_HEIGHT                              0x800850000000003f, 56,  8 // minimum acceptable eye height used during init or recal results checking--edi only
#define OPT_RX_CTL_MODE9_EO_PG                             0x800850000000003f, 48, 16 // register -- description
#define OPT_RX_AMP_INIT_CFG                                0x800858000000003f, 48,  3 // rx_amp_init_cfg   this register controls the servo filter for amplitude measurements during init. see workbook table 4.4 for settings
#define OPT_RX_AMP_RECAL_CFG                               0x800858000000003f, 51,  3 // rx_amp_recal_cfg      this register controls the servo filter for amplitude measurements during recal. see workbook table 4.4 for settings
#define OPT_RX_PEAK_INIT_CFG                               0x800858000000003f, 54,  3 // rx_peak_init_cfg  this register controls the servo filter for peaking during init. see workbook table 4.4 for settings
#define OPT_RX_PEAK_RECAL_CFG                              0x800858000000003f, 57,  3 // rx_peak_recal_cfg      this register controls the servo filter for peaking during recal. see workbook table 4.4 for settings
#define OPT_RX_AMP_CFG                                     0x800858000000003f, 60,  4 // rx_amp_cfg   this register controls the servo filter for rx_amp_0 and rx_amp_1 servo ops. see workbook table 4.4 for settings
#define OPT_RX_CTL_MODE10_EO_PG                            0x800858000000003f, 48, 16 // register -- description
#define OPT_RX_OFF_INIT_CFG                                0x800860000000003f, 48,  3 // rx_off_init_cfg   this register controls the servo filter for offset measurements during init. see workbook table 4.4 for settings
#define OPT_RX_OFF_RECAL_CFG                               0x800860000000003f, 51,  3 // rx_off_recal_cfg  this register controls the servo filter for offset measurements during recal. see workbook table 4.4 for settings
#define OPT_RX_CM_CFG                                      0x800860000000003f, 54,  3 // rx_cm_cfg          this register controls the servo during common mode measurement. see workbook table 4.4 for settings
#define OPT_RX_AMIN_CFG                                    0x800860000000003f, 57,  3 // rx_amin_cfg        this register controls the servo filtering used for amin measuremnts. see workbook table 4.4 for settings
#define OPT_RX_USERDEF_CFG                                 0x800860000000003f, 60,  4 // rx_user_cfg      this register controls the servo filtering when running the user defined servo ops table 4.4 for settings
#define OPT_RX_CTL_MODE11_EO_PG                            0x800860000000003f, 48, 16 // register -- description
#define OPT_RX_SERVO_CHG_CFG                               0x800868000000003f, 48,  4 // this register controls the minimum acceptable changes of the accum for a valid servo op. assures we have reached a stable point.
#define OPT_RX_DAC_BO_CFG                                  0x800868000000003f, 52,  3 // this register controls the time of the dac black out time.  see workbook dfe section
#define OPT_RX_FILTER_MODE                                 0x800868000000003f, 55,  2 // servo filter mode. 00 means normal filter duirng entire op. 01 means use the 1/4-1/2 mode, 10 means 1/8-1/4 mode and 11 means the automatic convergence detect mode
#define OPT_RX_MISC_CFG                                    0x800868000000003f, 57,  2 // per group rx misc configureation bits, bit 0 is chicken bit to re-enable the progressive filter mode for peaking, bit 1 when a 1 will enable the clearing of h1 during the amp0, amp1, and usrdef servo ops
#define OPT_RX_DISABLE_H1_CLEAR                            0x800868000000003f, 59,  1 // per group when set will disable the clearing when running servo ops which normally clear and restore the h1 registers
#define OPT_RX_VOFF_CFG                                    0x800868000000003f, 60,  3 // per group configuration regiseter for setting the filter value when running the vref version of offset on edge latches
#define OPT_RX_LOFF_AMP_EN                                 0x800868000000003f, 63,  1 // when set to a 1 the amp dac will be enabled during the loff versions of local latch offset cancellation
#define OPT_RX_CTL_MODE12_EO_PG                            0x800868000000003f, 48, 16 // register -- description
#define OPT_RX_CM_OFFSET_VAL                               0x800870000000003f, 49,  7 // value used to offset the amp dac when running common mode
#define OPT_RX_SERVO_THRESH1                               0x800870000000003f, 56,  4 // value used as threshold of when to switch to normal filtering mode
#define OPT_RX_SERVO_THRESH2                               0x800870000000003f, 60,  4 // value used as threshold of when we think the servo has converged
#define OPT_RX_CTL_MODE13_EO_PG                            0x800870000000003f, 48, 16 // register -- description
#define OPT_RX_AMP_INIT_TIMEOUT                            0x800878000000003f, 48,  4 // rx_amp_init_timeout   used for amplitude masurements during init.  (see workbook table 4.10 for timer settings)
#define OPT_RX_AMP_RECAL_TIMEOUT                           0x800878000000003f, 52,  4 // rx_amp_recal_timeout  used for amplitude masurements during recal. (see workbook table 4.10 for timer settings)
#define OPT_RX_PEAK_INIT_TIMEOUT                           0x800878000000003f, 56,  4 // rx_peak_init_timeout  used for peaking masurements during init.    (see workbook table 4.10 for timer settings)
#define OPT_RX_PEAK_RECAL_TIMEOUT                          0x800878000000003f, 60,  4 // rx_peak_recal_timeout  used for peaking masurements during recal   (see workbook table 4.10 for timer settings)
#define OPT_RX_CTL_MODE14_EO_PG                            0x800878000000003f, 48, 16 // register -- description
#define OPT_RX_OFF_INIT_TIMEOUT                            0x800880000000003f, 48,  4 // rx_off_init_timeout   used for offset masurements during init.     (see workbook table 4.10 for timer settings)
#define OPT_RX_OFF_RECAL_TIMEOUT                           0x800880000000003f, 52,  4 // rx_off_recal_timeout  used for offset masurements during recal.    (see workbook table 4.10 for timer settings)
#define OPT_RX_CM_TIMEOUT                                  0x800880000000003f, 56,  4 // rx_cm_timeout            used for common mode measurements         (see workbook table 4.10 for timer settings)
#define OPT_RX_AMIN_TIMEOUT                                0x800880000000003f, 60,  4 // rx_amin_timeout        used for amin masurements                   (see workbook table 4.10 for timer settings)
#define OPT_RX_CTL_MODE15_EO_PG                            0x800880000000003f, 48, 16 // register -- description
#define OPT_RX_AMP_TIMEOUT                                 0x800888000000003f, 48,  4 // rx_amp_timeout timeout used when running the generic amplitude servo ops    (see workbook table 4.10 for timer settings)
#define OPT_RX_USERDEF_TIMEOUT                             0x800888000000003f, 52,  4 // rx_userdef_timeout timeout used when using the user defined servo ops       (see workbook table 4.10 for timer settings)
#define OPT_RX_BER_TIMEOUT                                 0x800888000000003f, 56,  4 // rx_ber_timeout, used for when making bit error measurements with a servo op (see workbook table 4.10 for timer settings)
#define OPT_RX_SPARE4_TIMEOUT                              0x800888000000003f, 60,  4 // rx_spare4_timeout just a spare for now                              (see workbook table 4.10 for timer settings)
#define OPT_RX_CTL_MODE16_EO_PG                            0x800888000000003f, 48, 16 // register -- description
#define OPT_RX_AMAX_HIGH                                   0x800890000000003f, 48,  8 // rx amax high target in amplitude dac steps (as measured by 2ap-amin method) default d120
#define OPT_RX_AMAX_LOW                                    0x800890000000003f, 56,  8 // rx amax low target in amplitude dac steps (as measured by 2ap-amin method)  default d80
#define OPT_RX_CTL_MODE17_EO_PG                            0x800890000000003f, 48, 16 // register -- description
#define OPT_RX_AMP0_FILTER_MASK                            0x800898000000003f, 48,  8 // rx_amp_0_filter_mask   this register controls the filter and mask for the amp_0 servo ops.
#define OPT_RX_AMP1_FILTER_MASK                            0x800898000000003f, 56,  8 // rx_amp_1_filter_mask   this register controls the filter and mask for the amp_1 servo ops.
#define OPT_RX_CTL_MODE18_EO_PG                            0x800898000000003f, 48, 16 // register -- description
#define OPT_RX_CTLE_GAIN_MAX                               0x8008a0000000003f, 48,  4 // rx ctle (vga) gain maximum allowable gain value
#define OPT_RX_AMP_START_VAL                               0x8008a0000000003f, 56,  8 // rx amp start value, used when making amplitude measurements as the starting point
#define OPT_RX_CTL_MODE19_EO_PG                            0x8008a0000000003f, 48, 16 // register -- description
#define OPT_RX_DFE_CONVERGED_CNT_MAX                       0x8008a8000000003f, 48,  4 // number of iterations through dfe h1 and kh1ap adjust before ending dfe unless ended by rx_ap110ap010_delta criteria met\r\n\trjr
#define OPT_RX_AP110_AP010_DELTA_MAX                       0x8008a8000000003f, 52,  4 // maximum delta between apx110 and apx010 measurements to end dfe h1 and kh1ap adjust unless ended by dfe_converged_cnt_max\r\n\trjr
#define OPT_RX_CTL_MODE20_EO_PG                            0x8008a8000000003f, 48, 16 // register -- description
#define OPT_RX_EO_STEP_CNTL_OPT_ALIAS                      0x8008b0000000003f, 48, 11 // rx eye optimization step control opt alias
#define OPT_RX_EO_ENABLE_INTEG_LATCH_OFFSET_CAL            0x8008b0000000003f, 48,  1 // rx eye optimization latch offset adjustment enable with integrator-based disable
#define OPT_RX_EO_ENABLE_CTLE_COARSE_CAL                   0x8008b0000000003f, 49,  1 // rx eye optimization coarse ctle/peakin enable
#define OPT_RX_EO_ENABLE_DAC_H1_CAL                        0x8008b0000000003f, 50,  1 // rx eye optimization h! dac calibration to reference
#define OPT_RX_EO_ENABLE_VGA_CAL                           0x8008b0000000003f, 51,  1 // rx eye optimization vga gainand offset adjust enable
#define OPT_RX_EO_ENABLE_DFE_H1_CAL                        0x8008b0000000003f, 52,  1 // rx eye optimization dfe h1  adjust enable
#define OPT_RX_EO_ENABLE_H1AP_TWEAK                        0x8008b0000000003f, 53,  1 // rx eye optimization h1/an pr adjust enable
#define OPT_RX_EO_ENABLE_DDC                               0x8008b0000000003f, 54,  1 // rx eye optimization dynamic data centering enable
#define OPT_RX_EO_ENABLE_CM_COARSE_CAL                     0x8008b0000000003f, 55,  1 // rx eye optimization common mode coarse calibration enable
#define OPT_RX_EO_ENABLE_CM_FINE_CAL                       0x8008b0000000003f, 56,  1 // rx eye optimization common mode fine calibration enable
#define OPT_RX_EO_ENABLE_VGA_EDGE_OFFSET_CAL               0x8008b0000000003f, 57,  1 // rx eye optimization edge offset calibration enable during vga calibration\r\n\trjr
#define OPT_RX_EO_ENABLE_CTLE_EDGE_OFFSET_CAL              0x8008b0000000003f, 58,  1 // rx eye optimization edge offset calibration enable during ctle calibration\r\n\trjr
#define OPT_RX_CTL_MODE21_EO_PG                            0x8008b0000000003f, 48, 16 // register -- description
#define OPT_RX_RC_STEP_CNTL_OPT_ALIAS                      0x8008b8000000003f, 48, 11 // rx recalibration    step control opt alias
#define OPT_RX_RC_ENABLE_INTEG_LATCH_OFFSET_CAL            0x8008b8000000003f, 48,  1 // rx recalibration    latch offset adjustment enable with integrator-based disable
#define OPT_RX_RC_ENABLE_CTLE_COARSE_CAL                   0x8008b8000000003f, 49,  1 // rx recalibration    coarse ctle/peakin enable
#define OPT_RX_RC_ENABLE_DAC_H1_CAL                        0x8008b8000000003f, 50,  1 // rx recalibration    h! dac calibration to reference
#define OPT_RX_RC_ENABLE_VGA_CAL                           0x8008b8000000003f, 51,  1 // rx recalibration    vga gainand offset adjust enable
#define OPT_RX_RC_ENABLE_DFE_H1_CAL                        0x8008b8000000003f, 52,  1 // rx recalibration    dfe h1  adjust enable
#define OPT_RX_RC_ENABLE_H1AP_TWEAK                        0x8008b8000000003f, 53,  1 // rx recalibration    h1/an pr adjust enable
#define OPT_RX_RC_ENABLE_DDC                               0x8008b8000000003f, 54,  1 // rx recalibration    dynamic data centering enable
#define OPT_RX_RC_ENABLE_CM_COARSE_CAL                     0x8008b8000000003f, 55,  1 // rx recalibration    common mode coarse calibration enable
#define OPT_RX_RC_ENABLE_CM_FINE_CAL                       0x8008b8000000003f, 56,  1 // rx recalibration    common mode fine calibration enable
#define OPT_RX_RC_ENABLE_VGA_EDGE_OFFSET_CAL               0x8008b8000000003f, 57,  1 // rx recalibration    edge offset calibration enable during vga calibration\r\n\trjr
#define OPT_RX_RC_ENABLE_CTLE_EDGE_OFFSET_CAL              0x8008b8000000003f, 58,  1 // rx recalibration    edge offset calibration enable during ctle calibration\r\n\trjr
#define OPT_RX_CTL_MODE22_EO_PG                            0x8008b8000000003f, 48, 16 // register -- description
#define OPT_RX_IREF_RES_DAC                                0x8008c0000000003f, 50,  3 // twos complement control vector for setting magnitude of output current of res outputs.
#define OPT_RX_IREF_BYPASS                                 0x8008c0000000003f, 53,  1 // chicken-switch for bypassing closed loop controller for an open loop bias.
#define OPT_RX_IREF_PDWN_B                                 0x8008c0000000003f, 54,  1 // iref power down control (active low)
#define OPT_RX_CTL_MODE23_EO_PG                            0x8008c0000000003f, 48, 16 // register -- description
#define OPT_RX_H1AP_CFG                                    0x8008c8000000003f, 48,  2 // this register controls the maximum allowed ration of h1 and ap. this is not a servo setting but rather the setting of a ration between h1 and the value of ap. \r\n\t00:.5 \r\n\t01:.625 \r\n\t10:.25 \r\n\t11:.375
#define OPT_RX_CTLE_UPDATE_MODE                            0x8008c8000000003f, 50,  1 // controls updating of ctle_coarse (peaking) values: \r\n\t0: update edge and a or b peaking values while servoing \r\n\t1: update a or b peaking values after edge bank servoing complete
#define OPT_RX_USER_FILTER_MASK                            0x8008c8000000003f, 56,  8 // rx_user_filter_mask   this register controls the filter and mask for user defined servo ops.
#define OPT_RX_CTL_MODE24_EO_PG                            0x8008c8000000003f, 48, 16 // register -- description
#define OPT_RX_APX111_HIGH                                 0x8008d0000000003f, 48,  8 // rx amax high target in amplitude dac steps (as measured by ap_x111 and an_x000) default d102
#define OPT_RX_APX111_LOW                                  0x8008d0000000003f, 56,  8 // rx amax low target in amplitude dac steps (as measured by ap_x111 and an_x000)  default d68
#define OPT_RX_CTL_MODE29_EO_PG                            0x8008d0000000003f, 48, 16 // register -- description
#define OPT_RX_BER_EN                                      0x8008d8000000003f, 48,  1 // diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.
#define OPT_RX_BER_TIMER_FREEZE_EN                         0x8008d8000000003f, 49,  1 // diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the timer is frozen when any lane error count saturates in that pack.
#define OPT_RX_BER_COUNT_FREEZE_EN                         0x8008d8000000003f, 50,  1 // diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.
#define OPT_RX_BER_COUNT_SEL                               0x8008d8000000003f, 51,  4 // diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t0000:(1) 1\r\n\t0001:(2) 2\r\n\t0010:(4) 4\r\n\t0011:(8) 8\r\n\t0100:(16) 16\r\n\t0101:(32) 32\r\n\t0110:(64) 64\r\n\t0111:(128) 128\r\n\t1000: (256) 256\r\n\t1001: (512) 512\r\n\t1010: (1024) 1024\r\n\t1011: (unused1) unused1\r\n\t1100: (unused2) unused2\r\n\t1101: (unused3) unused3\r\n\t1110: (unused4) unused4\r\n\t1111: (unused5) unused5
#define OPT_RX_BER_TIMER_SEL                               0x8008d8000000003f, 56,  3 // diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t000:(2tothe31st) 2^31\r\n\t001:(2tothe27th) 2^27\r\n\t010:(2tothe23rd) 2^23\r\n\t011:(2tothe19th) 2^19\r\n\t100:(2tothe17th) 2^17\r\n\t101:(2tothe13th) 2^13\r\n\t110:(2tothe9th) 2^9\r\n\t111:(2tothe5th) 2^5
#define OPT_RX_BER_CLR_COUNT_ON_READ_EN                    0x8008d8000000003f, 59,  1 // diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.
#define OPT_RX_BER_CLR_TIMER_ON_READ_EN                    0x8008d8000000003f, 60,  1 // diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes timer when it is read from any lane in the pack.
#define OPT_RX_CTL_CNTL1_EO_PG                             0x8008d8000000003f, 48, 16 // register -- description
#define OPT_RX_TRC_MODE                                    0x8008e0000000003f, 48,  4 // rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd
#define OPT_RX_CTL_CNTL2_EO_PG                             0x8008e0000000003f, 48, 16 // register -- description
#define OPT_RX_INT_MODE                                    0x8008e8000000003f, 48,  4 // rx interrupt mode setting
#define OPT_RX_INT_CURRENT_STATE                           0x8008e8000000003f, 52, 12 // rx interrupt current state to stop on
#define OPT_RX_CTL_CNTL3_EO_PG                             0x8008e8000000003f, 48, 16 // register -- description
#define OPT_RX_INT_ENABLE_ENC                              0x8008f0000000003f, 48,  4 // rx interrupt encoded enable
#define OPT_RX_INT_NEXT_STATE                              0x8008f0000000003f, 52, 12 // rx interrupt next state to stop on
#define OPT_RX_CTL_CNTL4_EO_PG                             0x8008f0000000003f, 48, 16 // register -- description
#define OPT_RX_INT_GOTO_STATE                              0x8008f8000000003f, 52, 12 // rx interrupt state to go to upon interrupt trigger
#define OPT_RX_CTL_CNTL5_EO_PG                             0x8008f8000000003f, 48, 16 // register -- description
#define OPT_RX_INT_RETURN_STATE                            0x800900000000003f, 52, 12 // rx interrupt state to go to upon return from interrupt code
#define OPT_RX_CTL_CNTL6_EO_PG                             0x800900000000003f, 48, 16 // register -- description
#define OPT_RX_CAL_LANE_PG_PHY_GCRMSG                      0x800908000000003f, 56,  5 // encoded calibration lane in relation to the local, physical group.
#define OPT_RX_CTL_CNTLX7_EO_PG                            0x800908000000003f, 48, 16 // register -- description
#define OPT_RX_SERVO_OP                                    0x800910000000003f, 48, 15 // servo operation code, written by global training state machine
#define OPT_RX_SERVO_DONE                                  0x800910000000003f, 63,  1 // servo op completed, read by global training state machine
#define OPT_RX_CTL_CNTL8_EO_PG                             0x800910000000003f, 48, 16 // register -- description
#define OPT_RX_BIST_EN                                     0x800918000000003f, 48,  1 // this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define OPT_RX_BIST_EXT_START_MODE                         0x800918000000003f, 49,  1 // this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define OPT_RX_BIST_INIT_DISABLE                           0x800918000000003f, 50,  3 // each bit disables an individual step of the rx bist init state machine when raised; bit 0 disables the cu pll lock, bit 1 disables the rx fifo init, and bit 2 disables eye opt/training
#define OPT_RX_BIST_CUPLL_LOCK_CHECK_EN                    0x800918000000003f, 53,  1 // this bit enables the cu pll lock check mode of the rx bist init state machine. when set high, the test will check for the pll lock signal and set an error if it is not present.
#define OPT_RX_BIST_STORE_EYES_LANE_SEL                    0x800918000000003f, 54,  6 // this register selects which lane to store rx bist eye width data from. the data is stored in the rx_bist_eye_a_width and rx_bist_eye_b_width registers.
#define OPT_RX_BIST_STORE_EYES_BANK_SEL                    0x800918000000003f, 60,  2 // this register selects which bank to store rx bist eye width data from. \r\n\t00:(bank_a) store bank a widths\r\n\t01:(bank_b) store bank b widths\r\n\t10:(bank_e) store bank e widths\r\n\t11:(bank_a_edi) edi+ bank a
#define OPT_RX_PERVASIVE_CAPT                              0x800918000000003f, 62,  1 // this bit latches glb_ctl and jtag_bndy pervasive signals in iocrc_pervasive_capt when set high. ro reg bit rx_prvcpt_change_det goes high when latched values differ from pervasive inputs.
#define OPT_RX_BIST_LL_TEST_EN                             0x800918000000003f, 63,  1 // this bit enables the link test portion of rx bist
#define OPT_RX_CTL_CNTL9_EO_PG                             0x800918000000003f, 48, 16 // register -- description
#define OPT_RX_BIST_PRBS_TEST_TIME                         0x800920000000003f, 48,  4 // controls how long rx bist will test the prbs7 data for errors. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define OPT_RX_BIST_BUS_DATA_MODE                          0x800920000000003f, 52,  1 // this bit enables a mode where rx bist tests data from the bus
#define OPT_RX_BIST_PRBS_PROP_TIME                         0x800920000000003f, 53,  4 // controls how long rx bist waits between incrementing a phaserot and begining to test the prbs data. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define OPT_RX_CTL_CNTL10_EO_PG                            0x800920000000003f, 48, 16 // register -- description
#define OPT_RX_DACTEST_LLMT                                0x800928000000003f, 48,  9 // rx dactest control register : lower threshold limit
#define OPT_RX_DACTEST_RESET                               0x800928000000003f, 57,  1 // rx dactest control register : reset
#define OPT_RX_DACTEST_START                               0x800928000000003f, 58,  1 // rx dactest control register : start
#define OPT_RX_CTL_CNTL11_EO_PG                            0x800928000000003f, 48, 16 // register -- description
#define OPT_RX_DACTEST_HLMT                                0x800930000000003f, 48,  9 // rx dactest control register : higher threshold limit
#define OPT_RX_CTL_CNTL12_EO_PG                            0x800930000000003f, 48, 16 // register -- description
#define OPT_RX_HIST_MIN_EYE_WIDTH_VALID                    0x800938000000003f, 48,  1 // rx historic eye width minimum value and lane are valid.
#define OPT_RX_HIST_MIN_EYE_WIDTH_LANE                     0x800938000000003f, 49,  5 // rx historic eye width lane number
#define OPT_RX_HIST_MIN_EYE_WIDTH                          0x800938000000003f, 54,  8 // rx historic eye width minimum value.
#define OPT_RX_CTL_CNTL13_EO_PG                            0x800938000000003f, 48, 16 // register -- description
#define OPT_RX_HIST_MIN_EYE_HEIGHT_VALID                   0x800940000000003f, 48,  1 // rx historic eye height minimum value and lane are valid.
#define OPT_RX_HIST_MIN_EYE_HEIGHT_LANE                    0x800940000000003f, 49,  5 // rx historic eye height lane number.
#define OPT_RX_HIST_MIN_EYE_HEIGHT                         0x800940000000003f, 54,  8 // rx historic eye height minimum value (peak-to-peak).
#define OPT_RX_CTL_CNTL14_EO_PG                            0x800940000000003f, 48, 16 // register -- description
#define OPT_RX_CTL_CNTL15_EO_PG                            0x800948000000003f, 48, 16 // register -- description
#define OPT_RX_SERVO_RESULT                                0x800950000000003f, 48,  8 // servo op result, read by global training state machine
#define OPT_RX_CTL_STAT1_EO_PG                             0x800950000000003f, 48, 16 // register -- description
#define OPT_RX_BIST_INIT_DONE                              0x800958000000003f, 48,  1 // this bit signals completion of the rx bist init state machine.
#define OPT_RX_BIST_DONE                                   0x800958000000003f, 49,  1 // this bit signals completion of the entire rx bist procedure.
#define OPT_RX_BIST_LL_ERR                                 0x800958000000003f, 50,  1 // this bit indicates an error was detected during the link layer test portion of rx bist.
#define OPT_RX_BIST_NO_EDGE_DET                            0x800958000000003f, 51,  1 // this bit indicates that one eye was counted to be significantly large (over 60 phase rotator steps).
#define OPT_RX_BIST_EYE_A_WIDTH                            0x800958000000003f, 52,  6 // this register holds the counted eye a width of one particular lane.
#define OPT_RX_BIST_EYE_B_WIDTH                            0x800958000000003f, 58,  6 // this register holds the counted eye b width of one particular lane.
#define OPT_RX_CTL_STAT2_EO_PG                             0x800958000000003f, 48, 16 // register -- description
#define OPT_RX_CTL_STAT3_EO_PG                             0x800960000000003f, 48, 16 // register -- description
#define OPT_RX_EO_STEP_CNTL2_OPT_ALIAS                     0x800968000000003f, 48,  3 // rx eye optimization step control opt alias
#define OPT_RX_EO_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL         0x800968000000003f, 48,  1 // rx eye optimization first latch offsett adjustment enable with ctle-based disable
#define OPT_RX_EO_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL         0x800968000000003f, 49,  1 // rx eye optimization second latch offsett adjustment enable with ctle-based disable
#define OPT_RX_EO_ENABLE_VGA_AMAX_MODE                     0x800968000000003f, 50,  1 // rx eye optimization vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define OPT_RX_CTL_MODE26_EO_PG                            0x800968000000003f, 48, 16 // register -- description
#define OPT_RX_RC_STEP_CNTL2_OPT_ALIAS                     0x800970000000003f, 48,  4 // rx recalibration    step control opt alias
#define OPT_RX_RC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL         0x800970000000003f, 48,  1 // rx recalibration    first latch offset adjustment enable with ctle-based disable
#define OPT_RX_RC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL         0x800970000000003f, 49,  1 // rx recalibratoin    second latch offset adjustment enable with ctle-based disable
#define OPT_RX_RC_ENABLE_VGA_AMAX_MODE                     0x800970000000003f, 50,  1 // rx recalibration    vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
*/
#define OPT_RX_RC_ENABLE_AUTO_RECAL                        0x800970000000003f, 51,  1 // rx recalibration    vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
/*
#define OPT_RX_CTL_MODE27_EO_PG                            0x800970000000003f, 48, 16 // register -- description
#define OPT_RX_DC_STEP_CNTL_OPT_ALIAS                      0x800978000000003f, 48,  5 // rx dc step control opt alias
#define OPT_RX_DC_ENABLE_CM_COARSE_CAL                     0x800978000000003f, 48,  1 // rx dc cal eye optimization common mode coarse calibration enable
#define OPT_RX_DC_ENABLE_CM_FINE_CAL                       0x800978000000003f, 49,  1 // rx dc cal eye optimization common mode fine calibration enable
#define OPT_RX_DC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL         0x800978000000003f, 50,  1 // rx dc cal eye optimization latch offset adjustment enable done prior to ctle
#define OPT_RX_DC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL         0x800978000000003f, 51,  1 // rx dc cal eye optimization latch offset adjustment enable done after to ctle
#define OPT_RX_DC_ENABLE_INTEG_LATCH_OFFSET_CAL            0x800978000000003f, 52,  1 // rx dc cal eye optimization latch offset adjustment enable done prior to integrator
#define OPT_RX_CTL_MODE28_EO_PG                            0x800978000000003f, 48, 16 // register -- description
#define OPT_RX_CTL_CNTL1_O_PG                              0x800980000000003f, 48, 16 // register -- description
#define OPT_RX_CTL_CNTL3_O_PG                              0x800990000000003f, 48, 16 // register -- description
#define OPT_RX_CTL_CNTL4_O_PG                              0x800998000000003f, 48, 16 // register -- description
#define OPT_RX_MINIKERF                                    0x8009b0000000003f, 48, 16 // rx minikerf control bits.\r\n\t  bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \r\n\t (0:2)=000 - reserved \r\n\t (0:2)=001 - use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \r\n\t (0:2)=010 - impedance control termref_mk_probe_ana(0:1) only for centaur. all other buses use the tx_minikerf_pb\r\n\t (0:2)=011 - rx cleanup pll atst on pad_io_p. pad_io_n=0. \r\n\t (0:2)=100 - reserved \r\n\t (0:2)=101 - reserved. \r\n\t (0:2)=110 - rx cleanup pll clk on c4 pads. \r\n\t (0:2)=111 - reserved
#define OPT_RX_CTL_MODE1_O_PG                              0x8009b0000000003f, 48, 16 // register -- description
*/
#define OPT_RX_OCTANT_SELECT                               0x800988000000003f, 48,  3 // which c16 clock is used on ioo
#define OPT_RX_SPEED_SELECT                                0x800988000000003f, 51,  2 // ioo speed control
#define OPT_RX_AC_COUPLED                                  0x800988000000003f, 53,  1 // ioo select ac coupled mode in receiver
#define OPT_RX_CTL_MODE2_O_PG                              0x800988000000003f, 48, 16 // register -- description
#define OPT_RX_EYE_OPT_STATE                               0x800ab8000000003f, 48, 12 // eye optimizaton state machine current state
/*
#define OPT_RX_PG_GLBSM_SPARE_MODE_0                       0x800a80000000003f, 48,  1 // per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_1                       0x800a80000000003f, 49,  1 // per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_2                       0x800a80000000003f, 50,  1 // per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_3                       0x800a80000000003f, 51,  1 // repurposed spare mode as rx_chksw_do_deskew_ddcseed. set 1 to restore risky behavior of seeding prbs scramble pattern from live bus data prior to eyeopt.
#define OPT_RX_PG_GLBSM_SPARE_MODE_4                       0x800a80000000003f, 52,  1 // per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_5                       0x800a80000000003f, 53,  1 // per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_6                       0x800a80000000003f, 54,  1 // per-group spare mode latch.
#define OPT_RX_PG_GLBSM_SPARE_MODE_7                       0x800a80000000003f, 55,  1 // per-group spare mode latch.
#define OPT_RX_GLBSM_SPARE_MODE_PG                         0x800a80000000003f, 48, 16 // register -- description
#define OPT_RX_PG_FIR1_ERRS_FULL_REG                       0x800a88000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.
#define OPT_RX_PG_FIR_ERR_PG_REGS                          0x800a88000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group rxctl registers.
#define OPT_RX_PG_FIR_ERR_GCR_BUFF                         0x800a88000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group gcr buffer.
#define OPT_RX_PG_FIR_ERR_GCRS_LD_SM                       0x800a88000000003f, 50,  1 // iotk alias: parity error has occurred in the per-group gcr load state machine.
#define OPT_RX_PG_FIR_ERR_GCRS_UNLD_SM                     0x800a88000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group gcr unload state machine.
#define OPT_RX_PG_FIR_ERR_GLBSM_REGS                       0x800a88000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_GLBSM_REGRW                      0x800a88000000003f, 53,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_DATASM_REGS                      0x800a88000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_DATASM_REGRW                     0x800a88000000003f, 55,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define OPT_RX_PG_FIR_ERR_EYEOPT_SM                        0x800a88000000003f, 56,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_BIST_MAIN_STATE                  0x800a88000000003f, 57,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_BIST_INIT_STATE                  0x800a88000000003f, 58,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_RX_SERVO_SM                      0x800a88000000003f, 59,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define OPT_RX_PG_FIR_ERR_WORK_REGS                        0x800a88000000003f, 60,  1 // iotk alias: parity error has occurred in the per-group rx work regs.
#define OPT_RX_PL_FIR_ERR                                  0x800a88000000003f, 62,  1 // summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define OPT_RX_FIR1_PG                                     0x800a88000000003f, 48, 16 // register -- description
#define OPT_FIR1_ERRS_MASK_FULL_REG                        0x800a90000000003f, 48, 16 // iotk alias: fir mask for rx_fir1_pg errors.
#define OPT_RX_PG_FIR1_ERRS_MASK                           0x800a90000000003f, 48, 15 // fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.
#define OPT_FIR_ERR_MASK_PG_REGS                           0x800a90000000003f, 48,  1 // iotk alias: fir mask for the per-group rxctl register checker.
#define OPT_FIR_ERR_MASK_GCR_BUFF                          0x800a90000000003f, 49,  1 // iotk alias: fir mask for the per-group rxctl gcr buffer.
#define OPT_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                  0x800a90000000003f, 50,  1 // iotk alias: fir mask for the per-group rxctl gcr load state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                0x800a90000000003f, 51,  1 // iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_GLBSM_REGS                  0x800a90000000003f, 52,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_GLBSM_REGRW                 0x800a90000000003f, 53,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_DATASM_REGS                 0x800a90000000003f, 54,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_DATASM_REGRW                0x800a90000000003f, 55,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_EYEOPT_SM                   0x800a90000000003f, 56,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_BIST_MAIN_STATE             0x800a90000000003f, 57,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_BIST_INIT_STATE             0x800a90000000003f, 58,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_RX_SERVO_SM                 0x800a90000000003f, 59,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define OPT_RX_PG_FIR_ERR_MASK_WORK_REGS                   0x800a90000000003f, 60,  1 // iotk alias: fir mask for the per-group rxctl work regs checker.
#define OPT_RX_PL_FIR_ERR_MASK                             0x800a90000000003f, 62,  1 // fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.
#define OPT_RX_FIR1_MASK_PG                                0x800a90000000003f, 48, 16 // register -- description
#define OPT_RX_PG_FIR1_ERR_INJ_FULL_REG                    0x800a98000000003f, 48, 16 // iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define OPT_RX_PG_FIR1_ERR_INJ                             0x800a98000000003f, 48, 15 // rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.
#define OPT_RX_PG_FIR_ERR_INJ_PG_REGS                      0x800a98000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GCR_BUFF                     0x800a98000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.
#define OPT_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                   0x800a98000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 0x800a98000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GLBSM_REGS                   0x800a98000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_GLBSM_REGRW                  0x800a98000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_DATASM_REGS                  0x800a98000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_DATASM_REGRW                 0x800a98000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_EYEOPT_SM                    0x800a98000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_BIST_MAIN_STATE              0x800a98000000003f, 57,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_BIST_INIT_STATE              0x800a98000000003f, 58,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_RX_SERVO_SM                  0x800a98000000003f, 59,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define OPT_RX_PG_FIR_ERR_INJ_WORK_REGS                    0x800a98000000003f, 60,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl work regs checker.
#define OPT_RX_FIR1_ERROR_INJECT_PG                        0x800a98000000003f, 48, 16 // register -- description
#define OPT_RX_FIR_TRAINING_PG                             0x800aa0000000003f, 48, 16 // register -- description
#define OPT_RX_FIR_TRAINING_MASK_PG                        0x800aa8000000003f, 48, 16 // register -- description
#define OPT_RX_CLR_PAR_ERRS                                0x800ab0000000003f, 62,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define OPT_RX_FIR_RESET                                   0x800ab0000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches including the isolation and parity error latches.
#define OPT_RX_GLBSM_CNTLX1_EO_PG                          0x800ab0000000003f, 48, 16 // register -- description
#define OPT_RX_EYE_OPT_STATE                               0x800ab8000000003f, 48, 12 // eye optimizaton state machine current state
#define OPT_RX_GLBSM_STAT1_EO_PG                           0x800ab8000000003f, 48, 16 // register -- description
#define OPT_RX_RECAL_CNT                                   0x800ac0000000003f, 48, 16 // number of times bus has been recalibrated since initialization
#define OPT_RX_GLBSM_STAT2_EO_PG                           0x800ac0000000003f, 48, 16 // register -- description
#define OPT_RX_DACTEST_ISGT                                0x800ac8000000003f, 48,  1 // rx dactest control register : is greater than
#define OPT_RX_DACTEST_ISLT                                0x800ac8000000003f, 49,  1 // rx dactest control register : is lesser than
#define OPT_RX_DACTEST_ISEQ                                0x800ac8000000003f, 50,  1 // rx dactest control register : is equal to
#define OPT_RX_DACTEST_DIFF                                0x800ac8000000003f, 51,  9 // rx dactest control register : difference
#define OPT_RX_GLBSM_STAT3_EO_PG                           0x800ac8000000003f, 48, 16 // register -- description
#define OPT_RX_INT_REQ                                     0x800ad0000000003f, 48, 16 // rx interrupt request isolation latch
#define OPT_RX_GLBSM_STAT4_EO_PG                           0x800ad0000000003f, 48, 16 // register -- description
#define OPT_RX_LANE_CURRENTLY_INITIALIZING                 0x800ad8000000003f, 48,  1 // rx_current_recal_init_lane is being initialized
#define OPT_RX_LANE_CURRENTLY_RECALIBRATING                0x800ad8000000003f, 49,  1 // rx_current_recal_init_lane is being recalibrated
#define OPT_RX_CURRENT_RECAL_INIT_LANE                     0x800ad8000000003f, 50,  5 // number oflane that currently being initialized or recalibrated
#define OPT_RX_MANUAL_RECAL_DONE                           0x800ad8000000003f, 55,  1 // manual recalibration done handshake signal
#define OPT_RX_GLBSM_STAT5_EO_PG                           0x800ad8000000003f, 48, 16 // register -- description
#define OPT_RX_CNT_SINGLE_LANE_RECAL                       0x800ae0000000003f, 49,  1 // single lane recalibration monitor mode \r\n\t0:increment recalibration counter every time any lane completes recal\r\n\t1:increment recalibration counter only when recalibrating lane designated by rx_recal_lane_to_monitor
#define OPT_RX_RECAL_LANE_TO_MONITOR                       0x800ae0000000003f, 50,  5 // designate lane to monitor when rx_cnt_single_lane_recal is 1
#define OPT_RX_GLBSM_CNTL2_EO_PG                           0x800ae0000000003f, 48, 16 // register -- description
#define OPT_RX_MANUAL_RECAL_REQUEST                        0x800ae8000000003f, 48,  1 // recal request from microcontroller
#define OPT_RX_MANUAL_RECAL_LANE                           0x800ae8000000003f, 51,  5 // recal lane from microcontroller
#define OPT_RX_GLBSM_CNTL3_EO_PG                           0x800ae8000000003f, 48, 16 // register -- description
#define OPT_RX_CLR_RECAL_CNT                               0x800af0000000003f, 48,  1 // clear recalibration counter to zero.\r\n\t0:normal incrementing\1:reset counter to zero
#define OPT_RX_INT_RETURN                                  0x800af0000000003f, 49,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define OPT_RX_MANUAL_RECAL_ABORT                          0x800af0000000003f, 50,  1 // recal abort from microcontroller
#define OPT_RX_MANUAL_RECAL_CONTINUE                       0x800af0000000003f, 51,  1 // recal continue from microcontroller--pulsed version
#define OPT_RX_GLBSM_CNTL4_EO_PG                           0x800af0000000003f, 48, 16 // register -- description
#define OPT_RX_RC_ENABLE_PU_EDGE_TRACK                     0x800af8000000003f, 48,  1 // rx recalibration    optical edge track at start of recalibration enable
#define OPT_RX_GLBSM_MODE1_EO_PG                           0x800af8000000003f, 48, 16 // register -- description
#define OPT_RX_PG_DATASM_SPARE_MODE_0                      0x800b80000000003f, 48,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_1                      0x800b80000000003f, 49,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_2                      0x800b80000000003f, 50,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_3                      0x800b80000000003f, 51,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_4                      0x800b80000000003f, 52,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_5                      0x800b80000000003f, 53,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_6                      0x800b80000000003f, 54,  1 // per-group spare mode latch.
#define OPT_RX_PG_DATASM_SPARE_MODE_7                      0x800b80000000003f, 55,  1 // per-group spare mode latch.
#define OPT_RX_SERVO_CONFIG                                0x800b80000000003f, 56,  4 // per-group servo configuration bits.
#define OPT_RX_CTL_DATASM_CLKDIST_PDWN                     0x800b80000000003f, 60,  1 // used to put addtional rx_ctl_datasm_mac logic into clock off mode
#define OPT_RX_DATASM_SPARE_MODE_PG                        0x800b80000000003f, 48, 16 // register -- description
#define OPT_RX_BER_COUNT_CLR                               0x800b88000000003f, 49,  1 // diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define OPT_RX_BER_TIMER_CLR                               0x800b88000000003f, 50,  1 // diag ber timer clear pulse. when written to a 1 the timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define OPT_RX_SCOPE_CAPTURE                               0x800b88000000003f, 51,  1 // when written to a 1 it will cause the scope capture register to copy the current main input
*/
#define OPT_RX_DATA_PIPE_CAPTURE                           0x800b88000000003f, 52,  1 // data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
/*
#define OPT_RX_RESET_SERVO_STATUS                          0x800b88000000003f, 53,  1 // data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define OPT_RX_BER_RESET                                   0x800b88000000003f, 54,  1 // diag ber reset pulse. when written to a 1 it will clear both the error counter and timer.
#define OPT_RX_DATASM_CNTLX1_EO_PG                         0x800b88000000003f, 48, 16 // register -- description
#define OPT_RX_BER_COUNT                                   0x800b90000000003f, 48, 11 // per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.
#define OPT_RX_BER_COUNT_SATURATED                         0x800b90000000003f, 59,  1 // pl diag ber error counter saturation indicator. when 1 indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.
#define OPT_RX_BER_COUNT_FROZEN_BY_ERR_CNT                 0x800b90000000003f, 60,  1 // pl diag ber error counter and or pp timer has been frozen by another lanes error counter being saturated.
#define OPT_RX_BER_COUNT_FROZEN_BY_TIMER                   0x800b90000000003f, 61,  1 // pl diag ber error counter has been frozen by a diag ber timer becoming saturated.
#define OPT_RX_BER_TIMER_SATURATED                         0x800b90000000003f, 62,  1 // pl diag ber timer saturation indicator. when 1 indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.
#define OPT_RX_DATASM_STAT1_EO_PG                          0x800b90000000003f, 48, 16 // register -- description
#define OPT_RX_BER_TIMER_VALUE_0_15                        0x800b98000000003f, 48, 16 // pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.
#define OPT_RX_DATASM_STAT2_EO_PG                          0x800b98000000003f, 48, 16 // register -- description
#define OPT_RX_BER_TIMER_VALUE_16_31                       0x800ba0000000003f, 48, 16 // pl diag ber timer value, bits 16-31.
#define OPT_RX_DATASM_STAT3_EO_PG                          0x800ba0000000003f, 48, 16 // register -- description
*/
#define OPT_RX_DATA_PIPE_0_15                              0x800ba8000000003f, 48, 16 // data pipe captured output bits 0-15.
/*
#define OPT_RX_DATASM_STAT4_EO_PG                          0x800ba8000000003f, 48, 16 // register -- description
*/
#define OPT_RX_DATA_PIPE_16_31                             0x800bb0000000003f, 48, 16 // data pipe captured output bits 16-31.
/*
#define OPT_RX_DATASM_STAT5_EO_PG                          0x800bb0000000003f, 48, 16 // register -- description
#define OPT_RX_SERVO_STATUS                                0x800bb8000000003f, 48, 16 // per group servo status. , bits 0-10 are the servo op captured, bits 11-15 are the lane captured. no error if bits 0 to 10 are all zeroes
#define OPT_RX_DATASM_STAT6_EO_PG                          0x800bb8000000003f, 48, 16 // register -- description
#define OPT_RX_SERVO_CHG_CNT                               0x800bc0000000003f, 48,  4 // per group servo status. 4 bit value of the number of times the accumulator reversed directions during op, value is fluid except when bit 0 of servo_status is a 1.
#define OPT_RX_IREF_PARITY_CHK                             0x800bc0000000003f, 59,  4 // iref control parity observation bits
#define OPT_RX_PRVCPT_CHANGE_DET                           0x800bc0000000003f, 63,  1 // read only bit that signals when a change has been detected in the captured pervasive signals in iocrc_pervasive_capt
#define OPT_RX_DATASM_STAT7_EO_PG                          0x800bc0000000003f, 48, 16 // register -- description
#define OPT_RX_SCAN_P_0_15                                 0x800bc8000000003f, 48, 16 // rx boundary scan ovservation : p  0 to 15
#define OPT_RX_DATASM_STAT8_EO_PG                          0x800bc8000000003f, 48, 16 // register -- description
#define OPT_RX_SCAN_P_16_23                                0x800bd0000000003f, 48,  9 // rx boundary scan ovservation : p 16 to 23
#define OPT_RX_DATASM_STAT9_EO_PG                          0x800bd0000000003f, 48, 16 // register -- description
#define OPT_RX_SCAN_N_16_23                                0x800bd8000000003f, 56,  8 // rx boundary scan ovservation : n 16 to 23
#define OPT_RX_DATASM_STAT10_EO_PG                         0x800bd8000000003f, 48, 16 // register -- description
#define OPT_RX_SCAN_N_0_15                                 0x800be0000000003f, 48, 16 // rx boundary scan ovservation : n  0 to 15
#define OPT_RX_DATASM_STAT11_EO_PG                         0x800be0000000003f, 48, 16 // register -- description
#define OPT_RX_PB_CLR_PAR_ERRS                             0x800f80000000003f, 62,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.
#define OPT_RX_PB_FIR_RESET                                0x800f80000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.
#define OPT_RX_FIR_RESET_PB                                0x800f80000000003f, 48, 16 // register -- description
#define OPT_RX_PB_FIR_ERRS_FULL_REG                        0x800f88000000003f, 48, 10 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.
#define OPT_RX_PB_FIR_ERRS                                 0x800f88000000003f, 48, 10 // a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.
#define OPT_RX_PB_FIR_ERR_PB_REGS                          0x800f88000000003f, 48,  1 // iotk alias: parity error has occurred in the per-bus busctl registers.
#define OPT_RX_PB_FIR_ERR_GCR_BUFF0                        0x800f88000000003f, 49,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr buffer.
#define OPT_RX_PB_FIR_ERR_GCR_BUFF1                        0x800f88000000003f, 50,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.
#define OPT_RX_PB_FIR_ERR_GCR_BUFF2                        0x800f88000000003f, 51,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.
#define OPT_RX_PB_FIR_ERR_GCRS_LD_SM0                      0x800f88000000003f, 52,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_LD_SM1                      0x800f88000000003f, 53,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_LD_SM2                      0x800f88000000003f, 54,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_UNLD_SM0                    0x800f88000000003f, 55,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_UNLD_SM1                    0x800f88000000003f, 56,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.
#define OPT_RX_PB_FIR_ERR_GCRS_UNLD_SM2                    0x800f88000000003f, 57,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.
#define OPT_RX_FIR_PB                                      0x800f88000000003f, 48, 16 // register -- description
#define OPT_RX_PB_FIR_ERRS_MASK_FULL_REG                   0x800f90000000003f, 48, 10 // iotk alias: fir mask for rx_fir_pb errors.
#define OPT_RX_PB_FIR_ERRS_MASK                            0x800f90000000003f, 48, 10 // fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.
#define OPT_RX_PB_FIR_ERR_MASK_PB_REGS                     0x800f90000000003f, 48,  1 // iotk alias: fir mask for the per-bus busctl registers.
#define OPT_RX_PB_FIR_ERR_MASK_GCR_BUFF0                   0x800f90000000003f, 49,  1 // iotk alias: fir mask for the per-bus busctl gcr buffer.
#define OPT_RX_PB_FIR_ERR_MASK_GCR_BUFF1                   0x800f90000000003f, 50,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1.
#define OPT_RX_PB_FIR_ERR_MASK_GCR_BUFF2                   0x800f90000000003f, 51,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                 0x800f90000000003f, 52,  1 // iotk alias: fir mask for the per-bus busctl gcr load state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                 0x800f90000000003f, 53,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                 0x800f90000000003f, 54,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0               0x800f90000000003f, 55,  1 // iotk alias: fir mask for the per-bus busctl gcr unload state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1               0x800f90000000003f, 56,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.
#define OPT_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2               0x800f90000000003f, 57,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.
#define OPT_RX_FIR_MASK_PB                                 0x800f90000000003f, 48, 16 // register -- description
#define OPT_RX_PB_FIR_ERRS_INJ_FULL_REG                    0x800f98000000003f, 48, 10 // iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define OPT_RX_PB_FIR_ERRS_INJ                             0x800f98000000003f, 48, 10 // rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.
#define OPT_RX_PB_FIR_ERR_INJ_PB_REGS                      0x800f98000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.
#define OPT_RX_PB_FIR_ERR_INJ_SPARE0                       0x800f98000000003f, 49,  1 // iotk alias: spare inject 0.
#define OPT_RX_PB_FIR_ERR_INJ_SPARE1                       0x800f98000000003f, 50,  1 // iotk alias: spare inject 1.
#define OPT_RX_PB_FIR_ERR_INJ_GCR_BUFF2                    0x800f98000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 (bus control register interface)
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                  0x800f98000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                  0x800f98000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                  0x800f98000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0                0x800f98000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1                0x800f98000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.
#define OPT_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2                0x800f98000000003f, 57,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.
#define OPT_RX_FIR_ERROR_INJECT_PB                         0x800f98000000003f, 48, 16 // register -- description
#define OPT_RX_INTR_MSG                                    0x800ff0000000003f, 48, 16 // dummy intr gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define OPT_RX_INTR_MSG_PB                                 0x800ff0000000003f, 48, 16 // register -- description
#define OPT_RX_FIR_MSG                                     0x800ff8000000003f, 48,  8 // dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define OPT_RX_FIR_MSG_PB                                  0x800ff8000000003f, 48, 16 // register -- description
#define OPT_GCR_TEST_MODE                                  0x0000000000000020,  0,  1 // gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define OPT_ENABLE_GCR_OFL_BUFF                            0x0000000000000020,  1,  1 // enables 2nd gcr overflow buffer, one is used by default.
#define OPT_IORESET_HARD_BUS0                              0x0000000000000020,  2,  1 // io hard reset per-bus and gcr reset
#define OPT_MMIO_PG_REG_ACCESS                             0x0000000000000020,  3,  1 // mmio pg register access is blocked by default. setting this bit high grants mmio access to the pg regs.
#define OPT_SCOM_MODE_PB_SPARES1                           0x0000000000000020,  4,  4 // scom mode reg spares.
#define OPT_GCR_HANG_DET_SEL                               0x0000000000000020,  8,  3 // gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 63 cycles\r\n\t010: 127 cycles\r\n\t011: 255 cycles\r\n\t100: 511 cycles\r\n\t101: 1023 cycles\r\n\t110: 2047 cycles\r\n\t111: 4096 cycles.
#define OPT_GCR_BUFFER_ENABLED                             0x0000000000000020, 11,  1 // flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.
#define OPT_GCR_HANG_ERROR_MASK                            0x0000000000000020, 12,  1 // mask for gcr hang error when 2nd buffer is enabled.
#define OPT_GCR_HANG_ERROR_INJ                             0x0000000000000020, 13,  1 // inject for gcr hang error.
#define OPT_PPE_GCR_MODE                                   0x0000000000000020, 14,  1 // gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define OPT_CHAN_FAIL_MASK                                 0x0000000000000020, 15,  8 // scom mode reg spares.
#define OPT_SCOM_MODE_PB_SPARES2                           0x0000000000000020, 23,  8 // scom mode reg spares.
#define OPT_SCOM_MODE_PB                                   0x0000000000000020,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_FIR_PB                                    0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define OPT_SCOM_FIR_CLR_PB                                0x0000000000000001,  0, 64 // fir scom clear reg -- description
#define OPT_SCOM_FIR_SET_PB                                0x0000000000000002,  0, 64 // fir scom set reg -- description
#define OPT_SCOM_FIR_MASK_PB                               0x0000000000000003,  0, 64 // fir scom mask rw reg -- description
#define OPT_SCOM_FIR_MASK_CLR_PB                           0x0000000000000004,  0, 64 // fir scom mask clear reg -- description
#define OPT_SCOM_FIR_MASK_SET_PB                           0x0000000000000005,  0, 64 // fir scom mask set reg -- description
#define OPT_SCOM_FIR_ACTION0_PB                            0x0000000000000006,  0, 64 // fir scom action0 reg -- description
#define OPT_SCOM_FIR_ACTION1_PB                            0x0000000000000007,  0, 64 // fir scom action1 reg -- description
#define OPT_SCOM_FIR_WOF_PB                                0x0000000000000008,  0, 64 // fir scom wof reg -- description
#define OPT_SCOM_PPE_XCR_NONE_0_63                         0x0000000000000010,  0, 64 // ppe register
#define OPT_SCOM_PPE_XCR_NONE                              0x0000000000000010,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_XCR_SPRG0_0_63                        0x0000000000000011,  0, 64 // ppe register
#define OPT_SCOM_PPE_XCR_SPRG0                             0x0000000000000011,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_IR_SPRG0_0_63                         0x0000000000000012,  0, 64 // ppe register
#define OPT_SCOM_PPE_IR_SPRG0                              0x0000000000000012,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_XSR_SPRG0_0_63                        0x0000000000000013,  0, 64 // ppe register
#define OPT_SCOM_PPE_XSR_SPRG0                             0x0000000000000013,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_IR_EDR_0_63                           0x0000000000000014,  0, 64 // ppe register
#define OPT_SCOM_PPE_IR_EDR                                0x0000000000000014,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_XSR_IAR_0_63                          0x0000000000000015,  0, 64 // ppe register
#define OPT_SCOM_PPE_XSR_IAR                               0x0000000000000015,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_MEM_ARB_SCR_0_63                      0x000000000000000a,  0, 64 // ppe register
#define OPT_SCOM_PPE_MEM_ARB_SCR                           0x000000000000000a,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_MEM_ARB_CSAR_0_63                     0x000000000000000d,  0, 64 // ppe register
#define OPT_SCOM_PPE_MEM_ARB_CSAR                          0x000000000000000d,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_MEM_ARB_CSDR_0_63                     0x000000000000000e,  0, 64 // ppe register
#define OPT_SCOM_PPE_MEM_ARB_CSDR                          0x000000000000000e,  0, 64 // normal scom mode reg -- description
#define OPT_SCOM_PPE_IORESET                               0x0000000000000020,  0,  1 // ppe register
#define OPT_SCOM_PPE_PDWN                                  0x0000000000000020,  1,  1 // ppe register
#define OPT_SCOM_PPE_INTERRUPT                             0x0000000000000020,  2,  1 // ppe register
#define OPT_SCOM_PPE_ARB_ECC_INJECT_ERR                    0x0000000000000020,  3,  1 // ppe register
#define OPT_SCOM_PPE_SPARES                                0x0000000000000020,  4, 12 // ppe register
#define OPT_SCOM_PPE_CNTL                                  0x0000000000000020,  0, 64 // normal scom mode reg in ppe macro -- description
#define OPT_SCOM_PPE_WORK1                                 0x0000000000000021,  0, 32 // ppe register
#define OPT_SCOM_PPE_WORK_REG1                             0x0000000000000021,  0, 64 // normal scom mode reg in ppe macro -- description
#define OPT_SCOM_PPE_WORK2                                 0x0000000000000022,  0, 32 // ppe register
#define OPT_SCOM_PPE_WORK_REG2                             0x0000000000000022,  0, 64 // normal scom mode reg in ppe macro -- description
#define OPT_SCOM_PPE_FLAGS                                 0x0000000000000023,  0, 16 // ppe register
#define OPT_SCOM_PPE_FLAGS_REG                             0x0000000000000023,  0, 64 // normal scom mode reg in ppe macro -- description
#define OPT_SCOM_PPE_FLAGS_SET                             0x0000000000000024,  0, 16 // ppe register
#define OPT_SCOM_PPE_FLAGS_SET_REG                         0x0000000000000024,  0, 64 // normal scom mode reg in ppe macro -- description
#define OPT_SCOM_PPE_FLAGS_CLR                             0x0000000000000025,  0, 16 // ppe register
#define OPT_SCOM_PPE_FLAGS_CLR_REG                         0x0000000000000025,  0, 64 // normal scom mode reg in ppe macro -- description
*/

/*
#define EDI_TX_MODE_PL_FULL_REG                            0x800404000000003f, 48, 16 // iotk alias: for entire tx_mode_pl register
#define EDI_TX_LANE_PDWN                                   0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (tx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers tx_lane_disabled_vec_0_15 and tx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane drive inhibited (tristated) and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EDI_TX_LANE_INVERT                                 0x800404000000003f, 49,  1 // used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.\r\n\tmbs
#define EDI_TX_LANE_QUIESCE_P                              0x800404000000003f, 50,  2 // used to force the output of the positive differential leg of a lane to a particular value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.\r\n\tmbs
#define EDI_TX_LANE_QUIESCE_N                              0x800404000000003f, 52,  2 // used to force the output of the negative differential leg of a lane to a particular value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.\r\n\tmbs
#define EDI_TX_LANE_SCRAMBLE_DISABLE                       0x800404000000003f, 54,  1 // used to disable the tx scrambler on a specific lane or all lanes by using a per-lane/per-group global write.\r\n\tmbs
#define EDI_TX_MODE_PL                                     0x800404000000003f, 48, 16 // tx lane mode reg -- description
#define EDI_TX_FIFO_ERR                                    0x80040c000000003f, 48,  1 // indicates an error condition in the tx fifo.\r\n\trgr
#define EDI_TX_CNTL_STAT_PL                                0x80040c000000003f, 48, 16 // tx cntl and status reg -- description
#define EDI_TX_PL_SPARE_MODE_0                             0x800414000000003f, 48,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_1                             0x800414000000003f, 49,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_2                             0x800414000000003f, 50,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_3                             0x800414000000003f, 51,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_4                             0x800414000000003f, 52,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_5                             0x800414000000003f, 53,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_6                             0x800414000000003f, 54,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_PL_SPARE_MODE_7                             0x800414000000003f, 55,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_TX_SPARE_MODE_PL                               0x800414000000003f, 48, 16 // tx per-lane spare mode reg -- description
#define EDI_TX_LANE_BIST_ERR                               0x80042c000000003f, 48,  1 // indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.\r\n\tjgr
#define EDI_TX_LANE_BIST_DONE                              0x80042c000000003f, 49,  1 // indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running.\r\n\tjgr
#define EDI_TX_BIST_STAT_PL                                0x80042c000000003f, 48, 16 // tx bist status reg -- description
#define EDI_TX_PRBS_TAP_ID                                 0x800434000000003f, 48,  3 // tx per-lane prbs tap selector\r\n\tused to specify the tap-point for each lanes prbs scramble pattern.  this must be set consistent with rx_prbs_tap_id.  see data scrambling workbook section for details.  \r\n\t000:(pattern_a) prbs tap point a\r\n\t001:(pattern_b) prbs tap point b\r\n\t010:(pattern_c) prbs tap point c\r\n\t011:(pattern_d) prbs tap point d\r\n\t100:(pattern_e) prbs tap point e\r\n\t101:(pattern_f) prbs tap point f\r\n\t110:(pattern_g) prbs tap point g\r\n\t111:(pattern_h) prbs tap point h\r\n\trjr
#define EDI_TX_PRBS_MODE_PL                                0x800434000000003f, 48, 16 // tx per-lane prbs mode reg -- description
#define EDI_TX_DRV_DATA_PATTERN_GCRMSG                     0x80043c000000003f, 48,  4 // gcr message: tx per data lane drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id) (\r\n\t0110:(drv_red_prbs) prbs reduced density scramble pattern (see tx_prbs_tap_id and tx_reduced_scramble_mode)\r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_ei3_iap) ei-3 busy iap pattern (ei4 only)\r\n\t1001:(unused_e) unused\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(k28_5) drives 20-bit k28.5 pattern - padded to 32 bits\r\n\t1100:(unused_a) unused\r\n\t1101:(unused_b) unused\r\n\t1110:(unused_c) unused\r\n\t1111:(unused_d) unused\r\n\trjr
#define EDI_TX_SLS_LANE_SEL_GCRMSG                         0x80043c000000003f, 53,  1 // gcr message: sls commands & recalibration\r\n\t0:(sls_gated) sls commands & recalibration data gated\r\n\t1:(snd_sls) send sls command or recalibration data\r\n\tsmr
#define EDI_TX_DATA_CNTL_GCRMSG_PL                         0x80043c000000003f, 48, 16 // tx data control reg -- description
#define EDI_TX_DRV_SYNC_PATT_GCRMSG                        0x800444000000003f, 49,  1 // sync pattern command\r\n\t used to reset the tx prbs register and send a 1111 1111 1111 sync pattern followed by changing tx_drv_data_pattern_gcrmsg to send full prbs (code 0101).  the rx prbs register is then reset after seeing the twelve ones if the rx_prbs_check_sync bit is set.  normally this is set by the training machine after sending the deskew pattern.  note that most prbs patterns have twelve ones so this operation could not be done after prbs is already started.  \r\n\t0:(sync_gated) sync pattern gated\r\n\t1:(snd_sync) send sync pattern
#define EDI_TX_SYNC_PATTERN_GCRMSG_PL                      0x800444000000003f, 48, 16 // tx sync pattern control reg -- description
#define EDI_TX_PL_FIR_ERRS_FULL_REG                        0x800454000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\tpmt
#define EDI_TX_PL_FIR_ERRS                                 0x800454000000003f, 48,  1 // a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_PL_REGS                          0x800454000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane tx register logic.\r\n\tpmt
#define EDI_TX_FIR_PL                                      0x800454000000003f, 48, 16 // tx per-lane fir error source-isolation reg -- description
#define EDI_TX_PL_FIR_ERRS_MASK_FULL_REG                   0x80045c000000003f, 48, 16 // iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.\r\n\tpmt
#define EDI_TX_PL_FIR_ERRS_MASK                            0x80045c000000003f, 48,  1 // fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_MASK_PL_REGS                     0x80045c000000003f, 48,  1 // iotk alias: fir mask for the per-lane tx register checker.\r\n\tpmt
#define EDI_TX_FIR_MASK_PL                                 0x80045c000000003f, 48, 16 // tx per-lane fir error mask reg -- description
#define EDI_TX_PL_FIR_ERR_INJ_FULL_REG                     0x800464000000003f, 48, 16 // iotk alias: for tx_fir_error_inject_pl register.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_INJ                              0x800464000000003f, 48,  1 // tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - tx_pl_fir_err_inj_from_regs.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_INJ_PL_REGS                      0x800464000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane tx register logic.\r\n\tpmt
#define EDI_TX_FIR_ERROR_INJECT_PL                         0x800464000000003f, 48, 16 // tx per-lane fir error injection reg -- description
#define EDI_TX_ERR_INJECT                                  0x80046c000000003f, 48,  4 // software-only controlled register to inject one or more errors for one deserialized clock pulse on one or more specified beats on this lane.  set bit position x to inject on beat x of a cycle.  bits 0:3 are used in edi and 0:1 are used in ei4. \r\n\tmbs
#define EDI_TX_ERR_INJ_A_ENABLE                            0x80046c000000003f, 52,  1 // control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane. \r\n\tmbs
#define EDI_TX_ERR_INJ_B_ENABLE                            0x80046c000000003f, 53,  1 // control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane. \r\n\tmbs
#define EDI_TX_MODE_FAST_PL                                0x80046c000000003f, 48, 16 // tx per-lane fast-clocked mode reg -- description
#define EDI_TX_TDR_CAPT_VAL                                0x800474000000003f, 48,  1 // value captured by tdr function, 1-bit shared over a pack, so this value should be the same for each lane.\r\n\tdmb
#define EDI_TX_TDR_STAT_PL                                 0x800474000000003f, 48, 16 // tx tdr capture status -- description
#define EDI_TX_PDWN_LITE_GCRMSG                            0x80047c000000003f, 48,  1 // gcr message: when set, gates tx data path (post fifo) to 0s on unused spare lanes when not being recalibrated.\r\n\tsmr
#define EDI_TX_CNTL_GCRMSG_PL                              0x80047c000000003f, 48, 16 // tx cntl reg via gcr messages -- description
#define EDI_TX_CLK_PDWN                                    0x800c04000000003f, 48,  1 // used to disable the tx clock and put it into a low power state.\r\n\t0:(clk_enable) clk enabled (default)\r\n\t1:(clk_disable) clk disabled.\r\n\tmbs
#define EDI_TX_CLK_INVERT                                  0x800c04000000003f, 49,  1 // used to invert the polarity of the clock.\r\n\t0:(normal_clk) normal clk polarity (default)\r\n\t1:(invert_clk) invert clk.\r\n\tmbs
#define EDI_TX_CLK_QUIESCE_P                               0x800c04000000003f, 50,  2 // used to force the output of the positive differential leg of the clock lane to a particular value.  note that the 0 and 1 settings for edi are for lab characterization only, and the circuits are not deemed to have the proper drive strength in those modes to meet production level quality.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.\r\n\tmbs
#define EDI_TX_CLK_QUIESCE_N                               0x800c04000000003f, 52,  2 // used to force the output of the negative differential leg of the clock lane to a particular value.  note that the 0 and 1 settings for edi are for lab characterization only, and the circuits are not deemed to have the proper drive strength in those modes to meet production level quality.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.\r\n\tmbs
#define EDI_TX_CLK_DDR_MODE                                0x800c04000000003f, 54,  1 // used to select tx clock qdr mode or ddr mode. \r\n\t0:(qdr) qdr mode (default)\r\n\t1:(ddr) ddr mode.\r\n\tmbs
#define EDI_TX_CLK_MODE_PG                                 0x800c04000000003f, 48, 16 // tx per-group clk mode reg -- description
#define EDI_TX_PG_SPARE_MODE_0                             0x800c0c000000003f, 48,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_1                             0x800c0c000000003f, 49,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_2                             0x800c0c000000003f, 50,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_3                             0x800c0c000000003f, 51,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_4                             0x800c0c000000003f, 52,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_5                             0x800c0c000000003f, 53,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_6                             0x800c0c000000003f, 54,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_PG_SPARE_MODE_7                             0x800c0c000000003f, 55,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_TX_SPARE_MODE_PG                               0x800c0c000000003f, 48, 16 // tx per-group spare mode reg -- description
#define EDI_TX_FIFO_INIT                                   0x800c14000000003f, 49,  1 // used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.\r\n\tthis bit is write-only and as such writing a 1 to this bit will generate a pulse signal. there is no need to write this bit back to a 0.\r\n\trjr
#define EDI_TX_CNTL_STAT_PG                                0x800c14000000003f, 48, 16 // tx cntl and status reg -- description
#define EDI_TX_MAX_BAD_LANES                               0x800c1c000000003f, 48,  5 // static repair, dynamic repair & recal max number of bad lanes per tx bus (note: should match rx side)\r\n\tsmr
#define EDI_TX_MSBSWAP                                     0x800c1c000000003f, 53,  1 // used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode\r\n\tmbs
#define EDI_TX_PDWN_LITE_DISABLE                           0x800c1c000000003f, 54,  1 // disables the power down lite feature of unused spare lanes (generally should match rx_pdwn_lite_disable)\r\n\tsmr
#define EDI_TX_MODE_PG                                     0x800c1c000000003f, 48, 16 // tx mode reg -- description
#define EDI_TX_RESET_CFG_ENA                               0x800c44000000003f, 48,  1 // enable configurable group reset\r\n\t0:(normal) functional mode\r\n\t1:(reset) execute a clock group reset pulse.\r\n\tjfg
#define EDI_TX_CLR_PAR_ERRS                                0x800c44000000003f, 62,  1 // clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.\r\n\tpmt
#define EDI_TX_FIR_RESET                                   0x800c44000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.\r\n\tpmt
#define EDI_TX_RESET_ACT_PG                                0x800c44000000003f, 48, 16 // tx reset control action register (rcar) -- a set of configurable logic reset actions.
#define EDI_TX_CLK_BIST_ERR                                0x800c4c000000003f, 49,  1 // indicates a txbist clock side error occurred.\r\n\t0:(no_error) no error\r\n\t1:(error) a clock side error has has been found\r\n\tjgr
#define EDI_TX_CLK_BIST_DONE                               0x800c4c000000003f, 51,  1 // indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running\r\n\tjgr
#define EDI_TX_BIST_STAT_PG                                0x800c4c000000003f, 48, 16 // tx bist clk status reg -- description
#define EDI_TX_PG_FIR_ERRS_FULL_REG                        0x800c54000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.\r\n\tpmt
#define EDI_TX_PG_FIR_ERRS                                 0x800c54000000003f, 48,  8 // a per-group txctl register or state machine parity error has occurred.\r\n\tbit0 - par_err_txctl_regs\r\n\tbit1: par_err_gcr_buff\r\n\tbit2 - reserved.\r\n\tbit3: par_err_tx_stt_rpr_snd_msg_state.\r\n\tbit4 - par_err_gcrs_ld_state\r\n\tbit5 - par_err_gcrs_unld_state\r\n\tbit6 - reserved.\r\n\tbit7 - reserved.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_PG_REGS                          0x800c54000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group txctl registers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_GCR_BUFF                         0x800c54000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group gcr buffer.\r\n\tdmb
#define EDI_TX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM              0x800c54000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EDI_TX_PG_FIR_ERR_GCRS_LD_SM                       0x800c54000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group txctl gcr load state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_GCRS_UNLD_SM                     0x800c54000000003f, 53,  1 // iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_PP_REGS                          0x800c54000000003f, 54,  1 // iotk alias: parity error has occurred in the per-pack register space.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR                                  0x800c54000000003f, 63,  1 // summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.\r\n\tpmt
#define EDI_TX_FIR_PG                                      0x800c54000000003f, 48, 16 // tx per-group fir error source-isolation reg -- description
#define EDI_TX_PG_FIR_ERR_MASK_FULL_REG                    0x800c5c000000003f, 48, 16 // iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tpmt
#define EDI_TX_PG_FIR_ERRS_MASK                            0x800c5c000000003f, 48,  8 // fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_PG_REGS                     0x800c5c000000003f, 48,  1 // iotk alias: fir mask for the per-group txctl registers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_GCR_BUFF                    0x800c5c000000003f, 49,  1 // iotk alias: fir mask for the per-group txctl gcr buffer.\r\n\tdmb
#define EDI_TX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM         0x800c5c000000003f, 51,  1 // iotk alias: fir mask for the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EDI_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                  0x800c5c000000003f, 52,  1 // iotk alias: fir mask for the per-group txctl gcr load state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                0x800c5c000000003f, 53,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_MASK_PP_REGS                     0x800c5c000000003f, 54,  1 // iotk alias: fir mask for the per-group per-pack register space.\r\n\tpmt
#define EDI_TX_PL_FIR_ERR_MASK                             0x800c5c000000003f, 63,  1 // fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.\r\n\tpmt
#define EDI_TX_FIR_MASK_PG                                 0x800c5c000000003f, 48, 16 // tx per-group fir error source-isolation reg -- description
#define EDI_TX_PG_FIR_ERR_INJ_FULL_REG                     0x800c64000000003f, 48, 16 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ                              0x800c64000000003f, 48,  8 // tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_PG_REGS                      0x800c64000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_GCR_BUFF                     0x800c64000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.\r\n\tdmb
#define EDI_TX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM          0x800c64000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group tx stat repair gcr send message state machine.\r\n\tjgr
#define EDI_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                   0x800c64000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 0x800c64000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.\r\n\tpmt
#define EDI_TX_PG_FIR_ERR_INJ_PP_REGS                      0x800c64000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group per-pack register space.\r\n\tpmt
#define EDI_TX_FIR_ERROR_INJECT_PG                         0x800c64000000003f, 48, 16 // tx per-group fir error injection reg -- description
#define EDI_TX_BUS_ID                                      0x800c94000000003f, 48,  6 // this field is used to programmably set the bus number that a clkgrp belongs to.\r\n\tdmb
#define EDI_TX_GROUP_ID                                    0x800c94000000003f, 55,  6 // this field is used to programmably set the clock group number within a bus.\r\n\tdmb
#define EDI_TX_ID1_PG                                      0x800c94000000003f, 48, 16 // tx clock group identification 1 reg -- description
#define EDI_TX_LAST_GROUP_ID                               0x800c9c000000003f, 48,  6 // this field is used to programmably set the last clock group number within a bus.\r\n\tdmb
#define EDI_TX_ID2_PG                                      0x800c9c000000003f, 48, 16 // tx clock group identification 2 reg -- description
#define EDI_TX_START_LANE_ID                               0x800ca4000000003f, 49,  7 // this field is used to programmably set the first lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_TX_END_LANE_ID                                 0x800ca4000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_TX_ID3_PG                                      0x800ca4000000003f, 48, 16 // tx clock group identification 3 reg -- description
#define EDI_TX_DRV_CLK_PATTERN_GCRMSG                      0x800cc4000000003f, 48,  2 // tx clock drive patterns\r\n\t00:(drv_0s) drive all 0s pattern\r\n\t01:(drv_wt) drive wiretest pattern\r\n\t10:(drv_c4) drive clock pattern\r\n\t11:(unused) unused\r\n\tdmb
#define EDI_TX_CLK_CNTL_GCRMSG_PG                          0x800cc4000000003f, 48, 16 // tx clock control reg -- description
#define EDI_TX_FFE_TEST_MODE                               0x800ccc000000003f, 50,  2 // driver segment test mode\r\n\t00:(normal) mission mode enable\r\n\t01:(seg_test) driver output test mode\r\n\t10:(unused1) reserved\r\n\t11:(unused2) reserved\r\n\tjfg
#define EDI_TX_FFE_TEST_OVERRIDE1R                         0x800ccc000000003f, 54,  1 // driver segment test 1r override\r\n\t0:(normal) test 1r segments individually\r\n\t1:(override_1r) test 1r segments in pairs\r\n\tjfg
#define EDI_TX_FFE_TEST_OVERRIDE2R                         0x800ccc000000003f, 55,  1 // driver segment test 2r override\r\n\t0:(normal) test 2r segments individually\r\n\t1:(override_2r) test 2r segments with all 1r enabled\r\n\tjfg
#define EDI_TX_FFE_MODE_PG                                 0x800ccc000000003f, 48, 16 // tx ffe test mode reg -- tx ffe test mode reg
#define EDI_TX_FFE_MAIN_P_ENC                              0x800cd4000000003f, 49,  7 // tbd\r\n\tjfg
#define EDI_TX_FFE_MAIN_N_ENC                              0x800cd4000000003f, 57,  7 // tbd\r\n\tjfg
#define EDI_TX_FFE_MAIN_PG                                 0x800cd4000000003f, 48, 16 // tx ffe main reg -- tx ffe main reg
#define EDI_TX_FFE_POST_P_ENC                              0x800cdc000000003f, 51,  5 // tbd this field is updated during tx bist by logic temporarily\r\n\tjfg
#define EDI_TX_FFE_POST_N_ENC                              0x800cdc000000003f, 59,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_POST_PG                                 0x800cdc000000003f, 48, 16 // tx ffe post reg -- tx ffe post reg
#define EDI_TX_FFE_MARGIN_P_ENC                            0x800ce4000000003f, 51,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_N_ENC                            0x800ce4000000003f, 59,  5 // tbd\r\n\tjfg
#define EDI_TX_FFE_MARGIN_PG                               0x800ce4000000003f, 48, 16 // tx ffe margin reg -- tx ffe margin reg
#define EDI_TX_BAD_LANE1_GCRMSG                            0x800cec000000003f, 48,  7 // gcr message: encoded bad lane one in relation to the entire tx bus\r\n\tsmr
#define EDI_TX_BAD_LANE2_GCRMSG                            0x800cec000000003f, 55,  7 // gcr message: encoded bad lane two in relation to the entire tx bus\r\n\tsmr
#define EDI_TX_BAD_LANE_CODE_GCRMSG                        0x800cec000000003f, 62,  2 // gcr message: tx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EDI_TX_BAD_LANE_ENC_GCRMSG_PG                      0x800cec000000003f, 48, 16 // tx bad lanes encoded -- description
#define EDI_TX_BER_CNTL_PG                                 0x800cf4000000003f, 48, 16 // tx bit error rate -- description
#define EDI_TX_SLS_LANE_GCRMSG                             0x800cfc000000003f, 48,  7 // gcr message: encoded sls lane in relation to the entire tx bus\r\n\tsmr
#define EDI_TX_SLS_LANE_VAL_GCRMSG                         0x800cfc000000003f, 55,  1 // gcr message: tx sls lane valid\r\n\tsmr
#define EDI_TX_SLS_LANE_ENC_GCRMSG_PG                      0x800cfc000000003f, 48, 16 // tx sls lane encoded -- description
#define EDI_TX_WT_EN_ALL_CLK_SEGS_GCRMSG                   0x800d04000000003f, 48,  1 // tx clock wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.\r\n\trjr
#define EDI_TX_WT_EN_ALL_DATA_SEGS_GCRMSG                  0x800d04000000003f, 49,  1 // tx data  wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.\r\n\trjr
#define EDI_TX_WT_SEG_ENABLE_PG                            0x800d04000000003f, 48, 16 // tx wiretest driver segment enable -- description
#define EDI_TX_LANE_DISABLED_VEC_0_15                      0x800d1c000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control).\r\n\tsmr
#define EDI_TX_LANE_DISABLED_VEC_0_15_PG                   0x800d1c000000003f, 48, 16 // tx lane disable(d) 0 to 15 reg -- lanes disabled by firmware
#define EDI_TX_LANE_DISABLED_VEC_16_31                     0x800d24000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control).\r\n\tsmr
#define EDI_TX_LANE_DISABLED_VEC_16_31_PG                  0x800d24000000003f, 48, 16 // tx lane disable(d) 16 to 31 reg -- lanes disabled by firmware
#define EDI_TX_SLS_LANE_SHDW_GCRMSG                        0x800d2c000000003f, 48,  1 // gcr message: sls lane shadowing or unshadowing functional data (used to set up tx mux controls)\r\n\tsmr
#define EDI_TX_SLS_LANE_MUX_GCRMSG_PG                      0x800d2c000000003f, 48, 16 // tx sls lane tx mux setting -- description
#define EDI_TX_SLS_HNDSHK_STATE                            0x800d34000000003f, 48,  5 // sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for tx_sls_hndshk_state\r\n\t smr
#define EDI_TX_DYN_RPR_PG                                  0x800d34000000003f, 48, 16 // tx dynamic repair & recalibration status -- description
#define EDI_TX_SLV_MV_SLS_SHDW_REQ_GCRMSG                  0x800d3c000000003f, 48,  1 // gcr message: request to tx slave to move sls lane\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_SHDW_RPR_REQ_GCRMSG              0x800d3c000000003f, 49,  1 // gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_UNSHDW_REQ_GCRMSG                0x800d3c000000003f, 50,  1 // gcr message: request to tx slave to move sls lane\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_UNSHDW_RPR_REQ_GCRMSG            0x800d3c000000003f, 51,  1 // gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EDI_TX_BUS_WIDTH                                   0x800d3c000000003f, 52,  7 // gcr message: tx bus width\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_RPR_REQ_GCRMSG                   0x800d3c000000003f, 59,  1 // gcr message: request to tx slave to move sls lane & set bad lane register\r\n\tsmr
#define EDI_TX_SLS_LANE_SEL_LG_GCRMSG                      0x800d3c000000003f, 60,  1 // gcr message: sets the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios\r\n\tsmr
#define EDI_TX_SLS_LANE_UNSEL_LG_GCRMSG                    0x800d3c000000003f, 61,  1 // gcr message: clears the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios\r\n\tsmr
#define EDI_TX_SPR_LNS_PDWN_LITE_GCRMSG                    0x800d3c000000003f, 62,  1 // gcr message: signals the tx side to power down lite (data gate) unused spare lanes at the end of static repair\r\n\tsmr
#define EDI_TX_SLV_LGL_RPR_REQ_GCRMSG                      0x800d3c000000003f, 63,  1 // gcr message: request to tx slave to set bad lane register to last good lane of the bus (during recal bad lane scenarios)\r\n\tsmr
#define EDI_TX_SLV_MV_SLS_LN_REQ_GCRMSG_PG                 0x800d3c000000003f, 48, 16 // tx dynamic repair & recalibration messages -- description
#define EDI_TX_WT_PATTERN_LENGTH                           0x800e84000000003f, 48,  2 // tx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024\r\n\trjr
#define EDI_TX_WIRETEST_PP                                 0x800e84000000003f, 48, 16 // tx wiretest per-group & pack shadow reg -- description
#define EDI_TX_REDUCED_SCRAMBLE_MODE                       0x800e8c000000003f, 48,  2 // enables/disables and sets reduced density of scramble pattern. this must be set consistent with rx_reduced_scramble_mode.  \r\n\t00:(disable_0) full density \r\n\t01:(disable_1) full density \r\n\t10:(enable_div2) enable div2 reduced density \r\n\t11:(enable_div4) enable div4 reduced density (div4 is edi only).\r\n\trjr
#define EDI_TX_PRBS_SCRAMBLE_MODE                          0x800e8c000000003f, 50,  2 // selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by tx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EDI_TX_FIFO_L2U_DLY                                0x800e8c000000003f, 52,  3 // this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define EDI_TX_MODE_PP                                     0x800e8c000000003f, 48, 16 // tx mode per-pack shadow reg -- description
#define EDI_TX_SND_SLS_CMD_GCRMSG                          0x800e94000000003f, 48,  1 // gcr message: send sls command or recalibration data\r\n\tsmr
#define EDI_TX_DYN_RECAL_TSR_IGNORE_GCRMSG                 0x800e94000000003f, 49,  1 // gcr message: send dynamic recal sls commands all the time (not just during the status reporting interval)\r\n\tsmr
#define EDI_TX_SLS_CMD_GCRMSG                              0x800e94000000003f, 50,  6 // gcr message: tx sls command\r\n\tsmr
#define EDI_TX_SND_SLS_CMD_PREV_GCRMSG                     0x800e94000000003f, 56,  1 // gcr message: revert to sending previous sls command or recalibration data after recovery repair made\r\n\tsmr
#define EDI_TX_SND_SLS_USING_REG_SCRAMBLE                  0x800e94000000003f, 57,  1 // gcr message: send sls command using normal scramble pattern instead of calibration or 9th pattern\r\n\trjr
#define EDI_TX_SLS_GCRMSG_PP                               0x800e94000000003f, 48, 16 // tx sls command -- description
#define EDI_TX_ERR_INJ_A_RAND_BEAT_DIS                     0x800e9c000000003f, 48,  1 // used to disable randomization of error inject on different beats of data for pattern a.\r\n\t0:(enabled) error inject on random beat (0:1 on ei4, or 0:3 on edi) (default)\r\n\t1:(disabled) error inject only on beat 0.\r\n\tmbs
#define EDI_TX_ERR_INJ_A_FINE_SEL                          0x800e9c000000003f, 49,  3 // random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles (2 ui for ei4, 4 ui for edi). \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.\r\n\tmbs
#define EDI_TX_ERR_INJ_A_COARSE_SEL                        0x800e9c000000003f, 52,  4 // random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25\r\n\tmbs
#define EDI_TX_ERR_INJ_A_BER_SEL                           0x800e9c000000003f, 58,  6 // used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). \r\n\tmbs
#define EDI_TX_BER_CNTL_A_PP                               0x800e9c000000003f, 48, 16 // tx bit error injection control a shadow reg -- controls the parameters for tx error injection pattern a, which may be applied to any lane by way of the per-lane tx_err_inj_a_enable control
#define EDI_TX_ERR_INJ_B_RAND_BEAT_DIS                     0x800ea4000000003f, 48,  1 // used to disable randomization of error inject on different beats of data for pattern b.\r\n\t0:(enabled) error inject on random beat (0:1 on ei4, or 0:3 on edi) (default)\r\n\t1:(disabled) error inject only on beat 0.\r\n\tmbs
#define EDI_TX_ERR_INJ_B_FINE_SEL                          0x800ea4000000003f, 49,  3 // random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles (2 ui for ei4, 4 ui for edi). \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.\r\n\tmbs
#define EDI_TX_ERR_INJ_B_COARSE_SEL                        0x800ea4000000003f, 52,  4 // random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25\r\n\tmbs
#define EDI_TX_ERR_INJ_B_BER_SEL                           0x800ea4000000003f, 58,  6 // used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)). \r\n\tmbs
#define EDI_TX_BER_CNTL_B_PP                               0x800ea4000000003f, 48, 16 // tx bit error injection control b shadow reg -- controls the parameters for tx error injection pattern b, which may be applied to any lane by way of the per-lane tx_err_inj_a_enable control
#define EDI_TX_DYN_RECAL_INTERVAL_TIMEOUT_SEL              0x800eac000000003f, 49,  3 // tx dynamic recalibration interval timeout selects\r\n\t000:(tap0) 1024ui or 106.5ns very small value for sim only\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite\r\n\tsmr
#define EDI_TX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL            0x800eac000000003f, 52,  2 // tx dynamic recalibration status reporting timeout selects\r\n\t00:(tap0) 512ui or 53.2ns very small value for sim only\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns\r\n\t(note that the first 1/4 and last 1/4 of this time are actually sending the prbs pattern, so the actual time the sls command is on the lane is 1/2 of this value.  for more info see figure 2.4 eye-opening initialization step/recalibration timing description in the workbook.)\r\n\tsmr
#define EDI_TX_DYN_RECAL_TIMEOUTS_PP                       0x800eac000000003f, 48, 16 // tx dynamic recalibration timeout selects -- description
#define EDI_TX_BIST_EN                                     0x800eb4000000003f, 48,  1 // this bit enables the tx bist state machine to begin testing.\r\n\tjgr
#define EDI_TX_BIST_CNTL_PP                                0x800eb4000000003f, 48, 16 // tx bist cntl reg -- description
#define EDI_TX_ERR_INJ_SLS_MODE                            0x800ebc000000003f, 48,  1 // used to set the random bit error injection for pattern a to work during sls transmission only. \r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_ALL_CMD                         0x800ebc000000003f, 49,  1 // used to qualify the sls mode error injection for pattern a, to inject on all sls command transmissions. \r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_RECAL                           0x800ebc000000003f, 50,  1 // used to qualify the sls mode error injection for pattern a, to inject on the calibration lane only when not sending an sls command. see workbook for details.\r\n\tmbs
#define EDI_TX_ERR_INJ_SLS_CMD                             0x800ebc000000003f, 58,  6 // used to qualify the sls mode error injection for pattern a, to inject on only this sls command transmission. see workbook for sls command codes.\r\n\tmbs
#define EDI_TX_BER_CNTL_SLS_PP                             0x800ebc000000003f, 48, 16 // tx bit error injection control sls shadow reg -- controls conditional sls/calibration lane injection settings for injection pattern a only.
#define EDI_TX_ENABLE_REDUCED_SCRAMBLE                     0x800ec4000000003f, 48,  1 // enables reduced density of scramble pattern. normally this is set automatically in the functional mode training state.  users should use tx_reduced_scramble_mode to throttle density.  \r\n\t0:(disabled) disable reduced density \r\n\t1:(enabled) enable reduced density per the tx_reduced_scramble_mode setting.\r\n\trjr
#define EDI_TX_CNTL_PP                                     0x800ec4000000003f, 48, 16 // tx cntl per-pack reg -- description
#define EDI_TX_RESET_CFG_HLD                               0x800ecc000000003f, 48, 16 // reserved: this is not implemented. original description follows: configurable reset hold list\r\n\tlist of functions and values to preserve state or hold value over a configurable reset (via tx_reset_cfg_ena). any 1 excludes that value/function from a reset action.\r\n\tlist tbd.\r\n\tjfg
#define EDI_TX_RESET_CFG_PP                                0x800ecc000000003f, 48, 16 // tx configurable reset control register (crcr) -- list of features or value which are selectively preserved thru a configurable reset.
#define EDI_TX_TDR_DAC_CNTL                                0x800ed4000000003f, 48,  8 // controls variable threshold receiver for tdr function\r\n\tdmb
#define EDI_TX_TDR_PHASE_SEL                               0x800ed4000000003f, 57,  1 // controls phase select for tdr function, 0 is for _n leg, 1 is for _p leg.\r\n\tdmb
#define EDI_TX_TDR_CNTL1_PP                                0x800ed4000000003f, 48, 16 // tx tdr control register -- description
#define EDI_TX_TDR_PULSE_OFFSET                            0x800edc000000003f, 48, 12 // offset value for tdr pulse.\r\n\tdmb
#define EDI_TX_TDR_CNTL2_PP                                0x800edc000000003f, 48, 16 // tx tdr control register -- description
#define EDI_TX_TDR_PULSE_WIDTH                             0x800ee4000000003f, 48, 12 // width of tdr pulse.\r\n\tdmb
#define EDI_TX_TDR_CNTL3_PP                                0x800ee4000000003f, 48, 16 // tx tdr control register -- description
#define EDI_TX_ZCAL_REQ                                    0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.\r\n\tjfg
#define EDI_TX_ZCAL_DONE                                   0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.\r\n\tjfg
#define EDI_TX_ZCAL_ERROR                                  0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.\r\n\tjfg
#define EDI_TX_ZCAL_BUSY                                   0x800f04000000003f, 52,  1 // impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.\r\n\tjfg
#define EDI_TX_ZCAL_FORCE_SAMPLE                           0x800f04000000003f, 53,  1 // impedance comparison sample force\r\n\t initiates single cycle sample of the calibration circuit comparison output. accumulated in tx_zcal_sample_cnt(default)\r\n\t0:(disabled) inactive. \r\n\t1:(enabled) enable\r\n\tjfg
#define EDI_TX_ZCAL_CMP_OUT                                0x800f04000000003f, 54,  1 // calibration circuit unqualified sample\r\n\t this is an unconditional sample of the calibration circuit comparison output.\r\n\tjfg
#define EDI_TX_ZCAL_SAMPLE_CNT                             0x800f04000000003f, 55,  9 // calibration circuit qualified sample\r\n\t count of conditional samples of the calibration circuit comparison output properly async staged, inverted with tx_zcal_cya_data_inv, and enabled with tx_zcal_force_sample or normal calibration sequence. cleared on any new request.\r\n\tjfg
#define EDI_TX_IMPCAL_PB                                   0x800f04000000003f, 48, 16 // tx impedance cal cntl and status reg -- tx impedance cal cntl and status reg
#define EDI_TX_ZCAL_N                                      0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_NVAL_PB                              0x800f0c000000003f, 48, 16 // tx impedance cal n value reg -- tx impedance cal n value reg
#define EDI_TX_ZCAL_P                                      0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_PVAL_PB                              0x800f14000000003f, 48, 16 // tx impedance cal p value reg -- tx impedance cal p value reg
#define EDI_TX_ZCAL_P_4X                                   0x800f1c000000003f, 48,  5 // calibration circuit pseg-4x enable value this holds the current value of the enabled segments and is 2x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0x15 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_P_4X_PB                              0x800f1c000000003f, 48, 16 // tx impedance cal p 4x value reg -- tx impedance cal p 4x value reg
#define EDI_TX_ZCAL_SWO_EN                                 0x800f24000000003f, 48,  1 // impedance calibration software override\r\n\t steers all calibration controls directly from these register fields. effectively disables state machine logic.(default)\r\n\t0:(inactive) inactive. \r\n\t1:(enabled) enable.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CAL_SEGS                           0x800f24000000003f, 49,  1 // impedance calibration software bank select\r\n\t enable pseg calibration. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CMP_INV                            0x800f24000000003f, 50,  1 // impedance calibration software compare invert\r\n\t swap calibration circuit comparator inputs. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CMP_OFFSET                         0x800f24000000003f, 51,  1 // impedance calibration software offset flush\r\n\t equalize comparator offset in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable offset \r\n\t1:(enable) enable offset.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_CMP_RESET                          0x800f24000000003f, 52,  1 // impedance calibration software comparator reset\r\n\t reset comparator in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable reset \r\n\t1:(enable) enable reset.\r\n\tjfg
#define EDI_TX_ZCAL_SWO_POWERDOWN                          0x800f24000000003f, 53,  1 // impedance calibration software circuit powerdown\r\n\t powerdown calibration circuit. (default)\r\n\t0:(disable) disable powerdown \r\n\t1:(enable) enable powerdown.\r\n\tjfg
#define EDI_TX_ZCAL_CYA_DATA_INV                           0x800f24000000003f, 54,  1 // impedance calibration cya sample inversion\r\n\t select inverted comparator values in case of hardware error. see documentation.(default)\r\n\t0:(true) no sample inversion \r\n\t1:(invert) invert samples.\r\n\tjfg
#define EDI_TX_ZCAL_TEST_OVR_2R                            0x800f24000000003f, 55,  1 // impedance calibration test-only 2r segment override\r\n\t override 2r segment enable. see documentation.(default)\r\n\t0:(false) no override\r\n\t1:(true) override.\r\n\tjfg
#define EDI_TX_ZCAL_DEBUG_MODE                             0x800f24000000003f, 62,  2 // calibration circuit debug mode select\r\n\t this enables outputs for use with the minikerf but does not enable the minikerf. please reference tx_minikerf.\r\n\t(default)\r\n\t00:(disabled00) debug mode disabled\r\n\t01:(filters) probea=rcin_p, probeb=rcin_n observe filter input nodes, rcin_n is off-chip.\r\n\t10:(comparators) probea=comp_in_p, probeb=comp_in_n  observe comparator inputs.\r\n\t11:(disabled11) debug mode disabled\r\n\tjfg
#define EDI_TX_IMPCAL_SWO1_PB                              0x800f24000000003f, 48, 16 // tx impedance cal sw workaround 1 reg -- tx impedance cal sw workaround 1 reg
#define EDI_TX_ZCAL_SM_MIN_VAL                             0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).\r\n\tjfg
#define EDI_TX_ZCAL_SM_MAX_VAL                             0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).\r\n\tjfg
#define EDI_TX_IMPCAL_SWO2_PB                              0x800f2c000000003f, 48, 16 // tx impedance cal sw workaround 2 reg -- tx impedance cal sw workaround 2 reg
#define EDI_TX_IREF_BC                                     0x800f34000000003f, 48,  3 // bias code for the iref macros on the tx side. all eight 3 bit codes enable current out. the cml voltage swings of the output current will vary with this code.\r\n\tsmc
#define EDI_TX_ANALOG_IREF_PB                              0x800f34000000003f, 48, 16 // tx iref bias code input -- tx iref bias code for the tx side
#define EDI_TX_MINIKERF                                    0x800f3c000000003f, 48, 16 // tx minikerf cntl reg: \r\n\t bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \r\n\t (0:2)=000 - reserved \r\n\t (0:2)=001 - use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \r\n\t (0:2)=010 - impedance control termref_mk_probe_ana(0:1) except on centaur which uses rx_minikerf_pg \r\n\t (0:2)=011 - reserved \r\n\t (0:2)=100 - reserved \r\n\t (0:2)=101 - tx tank pll clk on c4 pads except in centaur case, which has dedicated c4 pads from the clk_4t1sst_drvr. \r\n\t (0:2)=110 - reserved. \r\n\t (0:2)=111 - reserved\r\n\tsmc
#define EDI_TX_MINIKERF_PB                                 0x800f3c000000003f, 48, 16 // tx minikerf cntl reg -- tx minikerf control bits. bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \n000: reserved \n001: use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \n010: impedance control termref_mk_probe_ana(0:1) except on centaur which uses rx_minikerf_pg \n011: reserved \n100: reserved \n101: tx tank pll clk on c4 pads except in centaur case, which has dedicated c4 pads from the clk_4t1sst_drvr. \n110: reserved. \n111: reserved
#define EDI_TX_INIT_VERSION                                0x800f44000000003f, 48, 16 // initfile version\r\n\tthis field is used to hold the initfile version for debug purposes.\r\n\tpmt
#define EDI_TX_INIT_VERSION_PB                             0x800f44000000003f, 48, 16 // tx initfile version reg -- tx initfile version
#define EDI_TX_SCRATCH_REG                                 0x800f4c000000003f, 48, 16 // scratch register\r\n\tthis field is used to enable fw procedures to communicate.\r\n\tpmt
#define EDI_TX_SCRATCH_REG_PB                              0x800f4c000000003f, 48, 16 // tx scratch reg -- tx scratch reg used for various purposes
#define EDI_RX_MODE_PL_FULL_REG                            0x800000000000003f, 48, 16 // alias for entire rx_mode_pl register\r\n\tpmt
#define EDI_RX_LANE_PDWN                                   0x800000000000003f, 48,  1 // used to receive inhibit and fully power down a lane independent of the logical lane disable. this control is independent from the per-group logical lane disable settings (rx_lane_disable_vec*) in order to allow for flexibility. note that this control routes through the boundary scan logic, which has dominance.  also note that per-group registers rx_lane_disabled_vec_0_15 and rx_lane_disabled_vec_16_31 are used to logically disable a lane with respect to the training, recalibration, and repair machines so both this per-lane and the per-group registers need to be set in order to logically disable and powerdown a lane. note that this per-lane register is adjusted for lane swizzling automatically in hw but it is not adjusted automatically in hw when in the msb-lsb swap mode so the erepair procedure needs to take care to power down the correct lane when in this mode. \r\n\t0:(enabled) lane powered up (default)\r\n\t1:(disabled) lane receive inhibited and powered down. the lane_disable_vec_* per-group registers configure the state machine but do not automatically power down or tristate the lanes. debug note: you have to account for swizzle when correlating the per-pack latch to the per-group latch setting.\r\n\tmbs
#define EDI_RX_LANE_SCRAMBLE_DISABLE                       0x800000000000003f, 54,  1 // used to disable the rx descrambler on a specific lane or all lanes by using a per-lane/per-group global write.\r\n\tmbs
#define EDI_RX_MODE_PL                                     0x800000000000003f, 48, 16 // rx lane mode reg -- description
#define EDI_RX_BLOCK_LOCK_LANE                             0x800008000000003f, 48,  1 // enables rotation and checking for block lock. \r\n\t0:(disabled) disable checking (forces block_locked_b to 1)\r\n\t1:(enabled) enable checking and run block lock.\r\n\trjr
#define EDI_RX_CHECK_SKEW_LANE                             0x800008000000003f, 49,  1 // per-lane initialization controls. checks skew request\r\n\trjr
#define EDI_RX_PDWN_LITE                                   0x800008000000003f, 50,  1 // gcr message: when set, partially powers down unused spare lanes when not being recalibrated\r\n\tsmr
#define EDI_RX_OFFCAL_MODE                                 0x800008000000003f, 51,  1 // when set, put this lanes front end into offset cancellation mode. only needed as an override since running offset cancellation does this automatically.\r\n\tjfg
#define EDI_RX_CNTL_PL                                     0x800008000000003f, 48, 16 // rx cntl and status reg -- description
#define EDI_RX_PL_SPARE_MODE_0                             0x800010000000003f, 48,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_1                             0x800010000000003f, 49,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_2                             0x800010000000003f, 50,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_3                             0x800010000000003f, 51,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_4                             0x800010000000003f, 52,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_5                             0x800010000000003f, 53,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_6                             0x800010000000003f, 54,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_PL_SPARE_MODE_7                             0x800010000000003f, 55,  1 // per-lane spare mode latch.\r\n\tpmt
#define EDI_RX_SPARE_MODE_PL                               0x800010000000003f, 48, 16 // rx per-lane spare mode reg -- description
#define EDI_RX_PHASEROT_LEFT_EDGE                          0x800018000000003f, 50,  6 // rx phase rotator left edge\r\n\trjr
#define EDI_RX_PHASEROT_RIGHT_EDGE                         0x800018000000003f, 56,  6 // rx phase rotator right edge\r\n\trjr
#define EDI_RX_PROT_EDGE_STATUS_PL                         0x800018000000003f, 48, 16 // rx phase rotator edge status reg -- description
#define EDI_RX_BIST_ERR                                    0x800028000000003f, 48,  1 // indicates that rxbist did not find two data eyes of sufficient width.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist\r\n\tjgr
#define EDI_RX_BIST_DONE                                   0x800028000000003f, 49,  1 // indicates a rxbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running\r\n\tjgr
#define EDI_RX_BIST_STAT_PL                                0x800028000000003f, 48, 16 // rx bist status reg -- description
#define EDI_RX_OFFSET_EVEN_SAMP1                           0x800040000000003f, 49,  7 // this is the vertical offset of the even sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_EVEN_SAMP0                           0x800040000000003f, 57,  7 // this is the vertical offset of the even sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_EVEN_PL                              0x800040000000003f, 48, 16 // rx even sample latch offset cntl reg -- description
#define EDI_RX_OFFSET_ODD_SAMP1                            0x800048000000003f, 49,  7 // this is the vertical offset of the odd sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_ODD_SAMP0                            0x800048000000003f, 57,  7 // this is the vertical offset of the odd sampling latch. the step size is vio/256.\r\n\tcpg
#define EDI_RX_OFFSET_ODD_PL                               0x800048000000003f, 48, 16 // rx odd sample latch offset cntl reg -- description
#define EDI_RX_AMP_PEAK                                    0x800050000000003f, 48,  4 // this is the vertical offset of the pre-amp.\r\n\tcpg
#define EDI_RX_AMP_GAIN                                    0x800050000000003f, 52,  4 // this is the gain setting of the pre-amp.\r\n\tcpg
#define EDI_RX_AMP_OFFSET                                  0x800050000000003f, 58,  6 // this is the peaking setting of the pre-amp.\r\n\tcpg
#define EDI_RX_AMP_VAL_PL                                  0x800050000000003f, 48, 16 // rx preamp value reg -- description
#define EDI_RX_AMP_ADJ_DONE                                0x800058000000003f, 48,  1 // vga adjust is complete for this lane\r\n\trjr
#define EDI_RX_AMP_ADJ_ALL_DONE_B                          0x800058000000003f, 49,  1 // vga adjust is complete for all valid lanves-asserted (low) if the lane *_done is asserted or the lane is disabled or the lane is bad--intended for global reading using the dot-or nature of the bus to see that all valid lanes are done when low \r\n\trjr
#define EDI_RX_AMP_CNTL_PL                                 0x800058000000003f, 48, 16 // rx preamp value reg -- description
#define EDI_RX_PHASEROT_VAL                                0x800060000000003f, 50,  6 // rx phase rotator current value\r\n\trjr
#define EDI_RX_PHASEROT_DDC_COMPLETE                       0x800060000000003f, 56,  1 // rx ddc state machine completion indicator\r\n\trjr
#define EDI_RX_PHASEROT_BLOCK_LOCK_ERR                     0x800060000000003f, 57,  1 // rx ddc state machine block lock error indicator\r\n\trjr
#define EDI_RX_PROT_STATUS_PL                              0x800060000000003f, 48, 16 // rx phase rotator status reg -- description
#define EDI_RX_PHASEROT_OFFSET                             0x800068000000003f, 50,  6 // rx phase rotator fixed offset from learned value\r\n\tthis is different than what happens in ei4, it does not just add an offset to the rotator. edi has one rotator which is used for everything. we retain the idea of a fixed offset which is derived from learning but it is applied in a much differant way. during most operations we must know exactly where the rotator is at. but after running ddc we may find that that is not the spot that gives us the best bit error rate. \r\n\tduring ddc we search and find both edges of the eye. at the end we are at the right edge of the eye and we do math to find out where the middle is. at this point we march back to the left until we are at the average of the two points. the value of this register is added to that value before we shift left to the middle. this does present some possible problem or limitations. the value of this register must be such that the sum of this register and the average of the left and right edge must be to the left of the right edge. \r\n\tit is possible to put a value in this register that will really get you messed up so great care must be given.\r\n\tcpg
#define EDI_RX_PROT_MODE_PL                                0x800068000000003f, 48, 16 // rx phase rotator mode reg -- description
#define EDI_RX_EXT_SR                                      0x800070000000003f, 52,  1 // rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 adds one to the binary pr value. an increase in pr value has the effect of moving the c2 clocks to the samplat earlier in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_right_half servo command.\r\n\tcpg
#define EDI_RX_EXT_SL                                      0x800070000000003f, 53,  1 // rx manual phase rotator shift left pulse\r\n\twriting this bit to a 1 subtracts one from the binary pr value. a decrease in pr value has the effect of moving the c2 clocks to the samplat later in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_left_half servo command.\r\n\tcpg
#define EDI_RX_PROT_CNTL_PL                                0x800070000000003f, 48, 16 // rx phase rotator control reg -- description
#define EDI_RX_FIFO_L2U_DLY                                0x800078000000003f, 48,  4 // rx fifo load-to-unload delay, initailed during fifo init and modified thereafter by the deskew machine.  for setting x, the latency is 4*x to 4*x+4 ui.  default is 20-24 ui\r\n\trjr
#define EDI_RX_FIFO_INIT                                   0x800078000000003f, 52,  1 // initializes the fifo unload counter with the load counter and initializes the fifo load to unload delay\r\n\trjr
#define EDI_RX_FIFO_STAT_PL                                0x800078000000003f, 48, 16 // rx fifo status reg -- description
#define EDI_RX_AP_EVEN_SAMP                                0x800080000000003f, 48,  8 // average value of a 1 in the even sampler\r\n\trjr
#define EDI_RX_AP_ODD_SAMP                                 0x800080000000003f, 56,  8 // average value of a 1 in the  odd sampler\r\n\trjr
#define EDI_RX_AP_PL                                       0x800080000000003f, 48, 16 // rx ap even/odd sampler reg -- description
#define EDI_RX_AN_EVEN_SAMP                                0x800088000000003f, 48,  8 // average value of a 0 in the even sampler\r\n\trjr
#define EDI_RX_AN_ODD_SAMP                                 0x800088000000003f, 56,  8 // average value of a 0 in the  odd sampler\r\n\trjr
#define EDI_RX_AN_PL                                       0x800088000000003f, 48, 16 // rx an even/odd sampler reg -- description
#define EDI_RX_AMIN_EVEN                                   0x800090000000003f, 48,  8 // lowest value of a 1 in the even sampler\r\n\trjr
#define EDI_RX_AMIN_ODD                                    0x800090000000003f, 56,  8 // lowest value of a 1 in the  odd sampler\r\n\trjr
#define EDI_RX_AMIN_PL                                     0x800090000000003f, 48, 16 // rx amin reg -- description
#define EDI_RX_H1_EVEN_SAMP1                               0x800098000000003f, 49,  7 // dfe h1 value for even sampler 1\r\n\trjr
#define EDI_RX_H1_EVEN_SAMP0                               0x800098000000003f, 57,  7 // dfe h1 value for even sampler 0\r\n\trjr
#define EDI_RX_H1_EVEN_PL                                  0x800098000000003f, 48, 16 // rx h1 even sampler reg -- description
#define EDI_RX_H1_ODD_SAMP1                                0x8000a0000000003f, 49,  7 // dfe h1 value for odd  sampler 1\r\n\trjr
#define EDI_RX_H1_ODD_SAMP0                                0x8000a0000000003f, 57,  7 // dfe h1 value for odd  sampler 0\r\n\trjr
#define EDI_RX_H1_ODD_PL                                   0x8000a0000000003f, 48, 16 // rx h1 odd sampler reg -- description
#define EDI_RX_PRBS_TAP_ID                                 0x8000b0000000003f, 48,  3 // per-lane prbs tap selector\r\n\tused to specify the tap-point for each lanes prbs scramble pattern.  this must be set consistent with tx_prbs_tap_id.  see data descramble workbook section for details.  \r\n\t000:(pattern_a) prbs tap point a\r\n\t001:(pattern_b) prbs tap point b\r\n\t010:(pattern_c) prbs tap point c\r\n\t011:(pattern_d) prbs tap point d\r\n\t100:(pattern_e) prbs tap point e\r\n\t101:(pattern_f) prbs tap point f\r\n\t110:(pattern_g) prbs tap point g\r\n\t111:(pattern_h) prbs tap point h\r\n\trjr
#define EDI_RX_PRBS_MODE_PL                                0x8000b0000000003f, 48, 16 // rx per-lane prbs mode reg -- description
#define EDI_RX_SOME_BLOCK_LOCKED                           0x8000c0000000003f, 48,  1 // per-lane block lock indicator\r\n\tused to indicate that the phase rotator block lock has locked on the deskew pattern a or b.\r\n\t0:(low) lane not block locked.\r\n\t1:(high) lane block locked\r\n\trjr
#define EDI_RX_ALL_BLOCK_LOCKED_B                          0x8000c0000000003f, 49,  1 // per-lane block lock indicator\r\n\tused to indicate that the phase rotator block lock has locked on the deskew pattern a or b.\r\n\t0:(low) lane block locked\r\n\t1:(high) lane not block locked.\r\n\trjr
#define EDI_RX_SOME_SKEW_VALID                             0x8000c0000000003f, 50,  1 // per-lane deskew pattern b detect indicator\r\n\tused to indicate that the deskew pattern b was detected on the lane.\r\n\t0:(low) pattern not detected.\r\n\t1:(high) pattern detected\r\n\trjr
#define EDI_RX_ALL_SKEW_VALID_B                            0x8000c0000000003f, 51,  1 // per-lane deskew pattern b detect indicator (active low)\r\n\tused to indicate that the deskew pattern b was detected on the lane.\r\n\t0:(low) pattern detected\r\n\t1:(high) pattern not detected.\r\n\trjr
#define EDI_RX_SOME_PRBS_SYNCED                            0x8000c0000000003f, 52,  1 // per-lane prbs synchronization indicator\r\n\tused to indicate that the prbs generator in a lanes pack is synchronized.\r\n\t0:(low) prbs is synchronized on any lane in a pack.\r\n\t1:(high) prbs is not synchronized\r\n\trjr
#define EDI_RX_PRBS_SYNCED_B                               0x8000c0000000003f, 53,  1 // per-lane prbs synchronization indicator (active low)\r\n\tused to indicate that the prbs generator in a lanes pack is synchronized.\r\n\t0:(low) prbs is synchronized or there are no valid or good lanes in the pack.\r\n\t1:(high) prbs is not synchronized\r\n\trjr
#define EDI_RX_SKEW_VALUE                                  0x8000c0000000003f, 54,  6 // per-lane prbs synchronization count\r\n\tvalue of the free-running counter when the marker pattern of deskew pattern b is detected\r\n\trjr
#define EDI_RX_STAT_PL                                     0x8000c0000000003f, 48, 16 // rx per-lane deskew status reg -- description
#define EDI_RX_BAD_BLOCK_LOCK                              0x8000c8000000003f, 48,  1 // deskew step block lock not established--lane marked bad\r\n\trjr
#define EDI_RX_BAD_SKEW                                    0x8000c8000000003f, 49,  1 // deskew step skew value not detected--lane marked bad\r\n\trjr
#define EDI_RX_BAD_DESKEW                                  0x8000c8000000003f, 50,  1 // deskew step deskew value\r\n\trjr
#define EDI_RX_DESKEW_STAT_PL                              0x8000c8000000003f, 48, 16 // rx fifo deskew status/error register -- description
#define EDI_RX_PL_FIR_ERRS_FULL_REG                        0x8000d0000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\tpmt
#define EDI_RX_PL_FIR_ERRS                                 0x8000d0000000003f, 48,  2 // a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tbit1: parity error in ddc sm.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_PL_REGS                          0x8000d0000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane rx registers.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_DDC_SM                           0x8000d0000000003f, 49,  1 // iotk alias: parity error has occurred in the per-lane rx ddc state machine.\r\n\tpmt
#define EDI_RX_FIR_PL                                      0x8000d0000000003f, 48, 16 // rx per-lane fir error source-isolation reg -- description
#define EDI_RX_PL_FIR_ERRS_MASK_FULL_REG                   0x8000d8000000003f, 48, 16 // iotk alias: fir mask for rx_fir_pl errors.\r\n\tpmt
#define EDI_RX_PL_FIR_ERRS_MASK                            0x8000d8000000003f, 48,  2 // fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tbit1 - (err_pl_mask_ddc_sm) per-lane ddc sm parity error.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_MASK_PL_REGS                     0x8000d8000000003f, 48,  1 // iotk alias: fir mask for per-lane register parity errors.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_MASK_DDC_SM                      0x8000d8000000003f, 49,  1 // iotk alias: fir mask for per-lane rx ddc state machine parity error.\r\n\tpmt
#define EDI_RX_FIR_MASK_PL                                 0x8000d8000000003f, 48, 16 // rx per-lane fir error source-isolation mask reg -- description
#define EDI_RX_PL_FIR_ERR_INJ_FULL_REG                     0x8000e0000000003f, 48, 16 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ                              0x8000e0000000003f, 48,  2 // rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tbit1: rx per-lane ddc sm parity error inject.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ_PL_REGS                      0x8000e0000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_INJ_DDC_SM                       0x8000e0000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx ddc state machine.\r\n\tpmt
#define EDI_RX_FIR_ERROR_INJECT_PL                         0x8000e0000000003f, 48, 16 // rx per-lane fir error injection reg -- description
#define EDI_RX_SLS_LANE_SEL                                0x8000e8000000003f, 48,  1 // selects which lane to receive sls commands and recalibration data on\r\n\tsmr
#define EDI_RX_9TH_PATTERN_EN                              0x8000e8000000003f, 49,  1 // sets rx descrabmler to use calibration or 9th scramble pattern\r\n\tsmr
#define EDI_RX_SLS_PL                                      0x8000e8000000003f, 48, 16 // rx sls settings register -- description
#define EDI_RX_WT_LANE_DISABLED                            0x8000f0000000003f, 48,  1 // wiretest has disabled this lane\r\n\trjr
#define EDI_RX_WT_LANE_INVERTED                            0x8000f0000000003f, 49,  1 // wiretest lane inverted ( or _n and _p swapped)\r\n\t0--not inverted if rx_wt_lane_bad_code = 000 \r\n\t1--inverted if rx_wt_lane_bad_code = 000\r\n\t see rx_wt_lane_bad_code descriptions  for meaning if rx_wt_lane_bad_code not = 000\r\n\trjr
#define EDI_RX_WT_LANE_BAD_CODE                            0x8000f0000000003f, 50,  3 // wiretest lane bad code concatenate rx_wt_lane_inverted with rx_wt_lane_bad_code to get a full status: \r\n\t0000--good lane--not inverted (edi and ei-4)\r\n\t0001--bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010--bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011--bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100--bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101--bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110--bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111--bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000--good lane--inverted (edi and ei-4) \r\n\t1001--bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010--bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011--bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100--bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101--bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110--bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111--bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EDI_RX_WT_LANE_STATUS_ALIAS                        0x8000f0000000003f, 49,  4 // alias for rx_wt_lane_inverted concatenated with rx_wt_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EDI_RX_WT_STATUS_PL                                0x8000f0000000003f, 48, 16 // rx wiretest status register   -- description
#define EDI_RX_FIFO_INC_L2U_DLY                            0x8000f8000000003f, 48,  1 // increment existing fifo load-to-unload delay register\r\n\trjr
#define EDI_RX_FIFO_DEC_L2U_DLY                            0x8000f8000000003f, 49,  1 // decrement existing fifo load-to-unload delay register\r\n\trjr
#define EDI_RX_CLR_SKEW_VALID                              0x8000f8000000003f, 50,  1 // clear skew valid registers\r\n\trjr
#define EDI_RX_FIFO_CNTL_PL                                0x8000f8000000003f, 48, 16 // rx fifo control reg -- description
#define EDI_RX_BER_COUNT                                   0x800100000000003f, 48,  8 // per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.\r\n\tpmt
#define EDI_RX_BER_COUNT_SATURATED                         0x800100000000003f, 56,  1 // pl diag ber error counter saturation indicator. when '1' indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.\r\n\tpmt
#define EDI_RX_BER_COUNT_FROZEN_BY_LANE                    0x800100000000003f, 57,  1 // pl diag ber error counter and or pp timer has been frozen by another lane's error counter being saturated.\r\n\tpmt
#define EDI_RX_BER_COUNT_FROZEN_BY_TIMER                   0x800100000000003f, 58,  1 // pl diag ber error counter has been frozen by a diag ber timer becoming saturated.\r\n\tpmt
#define EDI_RX_BER_TIMER_SATURATED                         0x800100000000003f, 59,  1 // pl diag ber timer saturation indicator. when '1' indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.\r\n\tpmt
#define EDI_RX_BER_STATUS_PL                               0x800100000000003f, 48, 16 // rx ber status reg -- description
#define EDI_RX_BER_TIMER_VALUE_0_15                        0x800108000000003f, 48, 16 // pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.\r\n\tpmt
#define EDI_RX_BER_TIMER_0_15_PL                           0x800108000000003f, 48, 16 // rx ber current timer value reg - bits 0 to 15 -- description
#define EDI_RX_BER_TIMER_VALUE_16_31                       0x800110000000003f, 48, 16 // pl diag ber timer value, bits 16-31.\r\n\tpmt
#define EDI_RX_BER_TIMER_16_31_PL                          0x800110000000003f, 48, 16 // rx ber current timer value reg - bits 16 to 31 -- description
#define EDI_RX_BER_TIMER_VALUE_32_39                       0x800118000000003f, 48,  8 // pl diag ber timer value, bits 32-39.\r\n\tpmt
#define EDI_RX_BER_TIMER_32_39_PL                          0x800118000000003f, 48, 16 // rx ber current timer value reg - bits 32 to 39 -- description
#define EDI_RX_SERVO_OP_DONE                               0x800120000000003f, 48,  1 // servo op completed\r\n\trjr
#define EDI_RX_SERVO_OP_ALL_DONE_B                         0x800120000000003f, 49,  1 // servo op code on all lanes-asserted (low) if the lane *_done is asserted or the lane is disabled or the lane is bad--intended for global reading using the dot-or nature of the bus to see that all valid lanes are done when low \r\n\trjr
#define EDI_RX_SERVO_OP                                    0x800120000000003f, 50,  5 // servo operation code \r\n\t00000: c_nop \r\n\t00001: c_offcal_0 \r\n\t00010: c_offcal_1 \r\n\t00011: c_ctle \r\n\t00100: c_vref \r\n\t00101: c_blocklock \r\n\t00110: c_edgetrack \r\n\t00111: c_ddc \r\n\t01000: c_ap_noh \r\n\t01001: c_an_noh \r\n\t01010: c_amin_noh \r\n\t01011: unused \r\n\t01100: unused \r\n\t01101: unused \r\n\t01110: c_eye_track \r\n\t01111: c_dcd_adj \r\n\t10000: c_dfe_ape \r\n\t10001: c_dfe_ane \r\n\t10010: c_dfe_apo \r\n\t10011: c_dfe_ano \r\n\t10100: c_dfe_amin \r\n\t10101: unused \r\n\t10110: unused \r\n\t10111: unused \r\n\t11000: c_bump_left \r\n\t11001: c_bump_right \r\n\t11010: c_bump1 \r\n\t11011: c_bump2 \r\n\t11100: c_h1ap_adjust \r\n\t11101: c_ber_test \r\n\t11110: unused \r\n\t11111: unused  \r\n\trjr
#define EDI_RX_SERVO_CNTL_PL                               0x800120000000003f, 48, 16 // rx servo operation command and control -- description
#define EDI_RX_FIFO_OUT_0_15                               0x800128000000003f, 48, 16 // diag capture: fifo entries 0 to 15\r\n\tdmb
#define EDI_RX_FIFO_DIAG_0_15_PL                           0x800128000000003f, 48, 16 // rx fifo output 0 to 15 for diag -- description
#define EDI_RX_FIFO_OUT_16_31                              0x800130000000003f, 48, 16 // diag capture: fifo entries 16 to 31\r\n\tdmb
#define EDI_RX_FIFO_DIAG_16_31_PL                          0x800130000000003f, 48, 16 // rx fifo output 16 to 31 for diag -- description
#define EDI_RX_FIFO_OUT_32_47                              0x800138000000003f, 48, 16 // diag capture: fifo entries 32 to 47\r\n\tdmb
#define EDI_RX_FIFO_DIAG_32_47_PL                          0x800138000000003f, 48, 16 // rx fifo output 32 to 47 for diag -- description
#define EDI_RX_EYE_WIDTH                                   0x800140000000003f, 50,  6 // rx current eye width (in pr steps).\r\n\tdmb
#define EDI_RX_HIST_MIN_EYE_WIDTH_VALID                    0x800140000000003f, 56,  1 // rx historic eye minimum is valid for this lane.\r\n\tdmb
#define EDI_RX_HIST_MIN_EYE_WIDTH                          0x800140000000003f, 58,  6 // rx historic eye minimum--per-pack register valid for this lane if rx_hist_eye_min_valid is asserted for this lane.\r\n\tdmb
#define EDI_RX_EYE_WIDTH_STATUS_PL                         0x800140000000003f, 48, 16 // rx current and historic minimum eye width -- description
#define EDI_RX_RESET_HIST_EYE_WIDTH_MIN                    0x800148000000003f, 48,  1 // rx historic eye minimum reset--reset historic min to maximum value and clears valid bits.\r\n\tdmb
#define EDI_RX_EYE_WIDTH_CNTL_PL                           0x800148000000003f, 48, 16 // rx historic minimum eye width reset control -- description
#define EDI_RX_DFE_CLKADJ                                  0x800150000000003f, 48,  4 // tweak value for the clock offset when doing dfe calibration\r\n\tthis is a per lane register which contains the distance in pr steps that the correct spot to position the clock is to the left of the center as defined by edge tracking.\r\n\tprior to running dfe we must have our clock positioned in the correct spot. with dfe applied the center of the data eye is shifted left. the greater the ratio of ap and h1, the further to the left this becomes. when running ctle we do not apply the h1 coefficients so we are tracking the edge of the non adjusted eye. so if we take the edge of the eye, the center of the fuzz, and move over 1/2ui or 16 phase rotator steps we will not be in the center of the dfe adjusted eye. this is compensated for by the h1/ap adjust. this is exactly as implied except there is a constant thrown in. the actual equation is h1/ap * k where k is selectable to be 10, 12, 14, or 16. and stored in a 2 bit register rx_dfe_ca_cfg where we encode the value of k.\r\n\tthe value of the clock adjust may be written manually and will remain that value as long as the servo op h1ap_adjust is not executed. every time the init_sm says h1ap_adjust we do the math to see if the register value matches the calculated value. if not we inc/dec some filtering logic which will actually change the clkadj register when it over/under flows. you can set this register but if the init_sm says to update the clk_adj it just might inc/dec one step.\r\n\tcpg
#define EDI_RX_DFE_CLKADJ_PL                               0x800150000000003f, 48, 16 // rx dfe clock adjust register -- description
#define EDI_RX_LN_TRC_EN                                   0x800158000000003f, 48,  1 // enable tracing of this lane.\r\n\tsmr
#define EDI_RX_TRACE_PL                                    0x800158000000003f, 48, 16 // rx trace per lane settings -- description
#define EDI_RX_SERVO_BER_COUNT                             0x800160000000003f, 48, 12 // servo-based bit error count.\r\n\trjr
#define EDI_RX_SERVO_BER_COUNT_PL                          0x800160000000003f, 48, 16 // rx servo-based ber count pl -- description
#define EDI_RX_BAD_EYE_OPT_BER                             0x800168000000003f, 48,  1 // eye opt step failed ber test--lane marked bad\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_WIDTH                           0x800168000000003f, 49,  1 // eye opt step failed width test--lane marked bad\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_HEIGHT                          0x800168000000003f, 50,  1 // eye opt step failed height test--lane marked bad\r\n\trjr
#define EDI_RX_BAD_EYE_OPT_DDC                             0x800168000000003f, 51,  1 // eye opt step failed dynamic data centering--lane marked bad\r\n\trjr
#define EDI_RX_EYE_OPT_STAT_PL                             0x800168000000003f, 48, 16 // rx eye optimization error register -- description
#define EDI_RX_CLK_PDWN                                    0x800800000000003f, 48,  1 // used to disable the rx clock and put it into a low power state.\r\n\t0:(enabled) clk enabled (default)\r\n\t1:(disabled) clk disabled
#define EDI_RX_CLK_INVERT                                  0x800800000000003f, 49,  1 // used to invert the polarity of the clock.\r\n\t0:(normal) normal clk polarity (default)\r\n\t1:(inverted) clk inverted
#define EDI_RX_CLK_MODE_PG                                 0x800800000000003f, 48, 16 // rx per-group clk mode reg -- description
#define EDI_RX_PG_SPARE_MODE_0                             0x800808000000003f, 48,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_1                             0x800808000000003f, 49,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_2                             0x800808000000003f, 50,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_3                             0x800808000000003f, 51,  1 // per-group spare mode latch.\r\n\tpmt
#define EDI_RX_PG_SPARE_MODE_4                             0x800808000000003f, 52,  1 // chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.\r\n\tsmr
#define EDI_RX_SLS_EXTEND_SEL                              0x800808000000003f, 53,  3 // how long to extend sending of the tx sls command (i.e. delay the gcr_wrt_done to the sending sm).\r\n\t(times based on edi slow clk of 833ps)\r\n\t000:(tap1) 0.833ns\r\n\t001:(tap2) 53.3ns\r\n\t010:(tap3) 106.6ns\r\n\t011:(tap4) 213.2ns\r\n\t100:(tap5) 426.5ns\r\n\t101:(tap6) 853.0ns\r\n\t110:(tap7) 1.7us\r\n\t111:(tap8) 3.4us\r\n\tsmr
#define EDI_RX_SPARE_MODE_PG                               0x800808000000003f, 48, 16 // rx per-group spare mode reg -- description
#define EDI_RX_STOP_STATE_ENABLE                           0x800810000000003f, 48,  1 // enable state machine stop of address\r\n\trjr
#define EDI_RX_STATE_STOPPED                               0x800810000000003f, 49,  1 // state machines stopped\r\n\trjr
#define EDI_RX_RESUME_FROM_STOP                            0x800810000000003f, 50,  1 // resume stopped state machines and /or counters\r\n\trjr
#define EDI_RX_STOP_ADDR_MSB                               0x800810000000003f, 56,  4 // stop address most-significant four bits 0 to 3\r\n\trjr
#define EDI_RX_STOP_MASK_MSB                               0x800810000000003f, 60,  4 // stop mask    most-significant four bits 0 to 3\r\n\trjr
#define EDI_RX_STOP_CNTL_STAT_PG                           0x800810000000003f, 48, 16 // rx trace/state stop control/status/ msb reg -- description
#define EDI_RX_MASTER_MODE                                 0x800818000000003f, 48,  1 // master mode\r\n\tused to set a chip bus as the master side of the interface. the master side of the interface is where training is kicked off and coordinated in the logic.\r\n\t0:(slave) slave\r\n\t1:(master) master\r\n\trjr
#define EDI_RX_DISABLE_FENCE_RESET                         0x800818000000003f, 49,  1 // set to disable clearing of the rx and tx fence controls at the end of training. \r\n\t0:(enable) clear the fence bit (default) \r\n\t1:(disable) leave the fence in its current state \r\n\tmbs
#define EDI_RX_PDWN_LITE_DISABLE                           0x800818000000003f, 50,  1 // disables the power down lite feature of unused spare lanes (generally should match tx_pdwn_lite_disable)\r\n\tsmr
#define EDI_RX_USE_SLS_AS_SPR                              0x800818000000003f, 51,  1 // determines whether the rx sls lane can be used as a spare lane on the bus to repair bad lanes (note: if yes, recal is disabled once the sls lane has been used as a spare lane.)\r\n\t(note: applies to tx side as well)\r\n\tsmr
#define EDI_RX_BUMP_BEFORE_PRBS_SYNC                       0x800818000000003f, 52,  1 // chicken switch: determines whether a 1/2 bit bump occurs before or after prbs sync on edi buses:\r\n\t0:(after_prbs) after prbs sync (default)\r\n\t1:(before_prbs) before prbs sync (original mode)\r\n\trjr
#define EDI_RX_MODE_PG                                     0x800818000000003f, 48, 16 // rx mode reg -- description
#define EDI_RX_STOP_ADDR_LSB                               0x800838000000003f, 48, 16 // stop address least-significant 16 bits 4 to 19\r\n\trjr
#define EDI_RX_STOP_ADDR_LSB_PG                            0x800838000000003f, 48, 16 // rx trace/state stop address 4-19  reg -- description
#define EDI_RX_STOP_MASK_LSB                               0x800840000000003f, 48, 16 // stop mask    least-significant 16 bits 4 to 19\r\n\trjr
#define EDI_RX_STOP_MASK_LSB_PG                            0x800840000000003f, 48, 16 // rx trace/state stop mask    4-19  reg -- description
#define EDI_RX_RESET_CFG_ENA                               0x800848000000003f, 48,  1 // enable configurable group reset\r\n\t0:(normal) functional mode\r\n\t1:(reset) execute a clock group reset pulse.\r\n\tjfg
#define EDI_RX_CLR_PAR_ERRS                                0x800848000000003f, 62,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.\r\n\tpmt
#define EDI_RX_FIR_RESET                                   0x800848000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EDI_RX_RESET_ACT_PG                                0x800848000000003f, 48, 16 // rx reset control action register (rcar) -- a set of configurable logic reset actions.
#define EDI_RX_BUS_ID                                      0x800850000000003f, 48,  6 // this field is used to programmably set the bus number that a clkgrp belongs to.\r\n\tdmb
#define EDI_RX_GROUP_ID                                    0x800850000000003f, 55,  6 // this field is used to programmably set the clock group number within a bus.\r\n\tdmb
#define EDI_RX_ID1_PG                                      0x800850000000003f, 48, 16 // rx clock group identification 1 reg -- description
#define EDI_RX_LAST_GROUP_ID                               0x800858000000003f, 48,  6 // this field is used to programmably set the last clock group number within a bus.\r\n\tdmb
#define EDI_RX_ID2_PG                                      0x800858000000003f, 48, 16 // rx clock group identification 2 reg -- description
#define EDI_RX_START_LANE_ID                               0x800860000000003f, 49,  7 // this field is used to programmably set the first lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_RX_END_LANE_ID                                 0x800860000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.\r\n\tdmb
#define EDI_RX_ID3_PG                                      0x800860000000003f, 48, 16 // rx clock group identification 3 reg -- description
#define EDI_RX_MINIKERF                                    0x800868000000003f, 48, 16 // rx minikerf control bits.\r\n\t  bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \r\n\t (0:2)=000 - reserved \r\n\t (0:2)=001 - use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \r\n\t (0:2)=010 - impedance control termref_mk_probe_ana(0:1) only for centaur. all other buses use the tx_minikerf_pb\r\n\t (0:2)=011 - rx cleanup pll atst on pad_io_p. pad_io_n=0. \r\n\t (0:2)=100 - reserved \r\n\t (0:2)=101 - reserved. \r\n\t (0:2)=110 - rx cleanup pll clk on c4 pads. \r\n\t (0:2)=111 - reserved\r\n\tsmc
#define EDI_RX_MINIKERF_PG                                 0x800868000000003f, 48, 16 // rx minikerf cntl reg -- rx minikerf control bits.  bits (3:13) are only used when (0:2)=001. bits (14:15) are spare. (0:2) is level 1 steering, \n000: reserved \n001: use bits (3:5) level 2 steering, (6:13) dac controls, (14:15) spare \n010: impedance control termref_mk_probe_ana(0:1) only for centaur. all other buses use the tx_minikerf_pb\n011: rx cleanup plls atst on pad_io_p. pad_io_n=0. \n100: reserved \n101: reserved. \n110: rx cleanup pll clk on c4 pads. \n111: reserved
#define EDI_RX_BAD_BUS_LANE_ERR_CNTR_DIS_CLR               0x800870000000003f, 48,  1 // disable clearing of the bad bus lane error counter (aka counter1) when the next crc/ecc error comes in on a new lane\r\n\tsmr
#define EDI_RX_BAD_BUS_LANE_ERR_CNTR                       0x800870000000003f, 49,  7 // bad bus lane error counter (aka counter1)\r\n\tsmr
#define EDI_RX_LAST_BAD_BUS_LANE                           0x800870000000003f, 57,  7 // last bad bus lane (bus lane causing the last crc or ecc error)\r\n\tsmr
#define EDI_RX_DYN_RPR_DEBUG2_PG                           0x800870000000003f, 48, 16 // dynamic repair testfloor/debug register -- description
#define EDI_RX_SLS_DISABLE                                 0x800878000000003f, 48,  1 // disables receiving & decoding of sls commands\r\n\tsmr
#define EDI_TX_SLS_DISABLE                                 0x800878000000003f, 49,  1 // if set, the sls command being sent will always just be a nop.  to truly disable the full sls logic path, also do some combination of the following (depending on what exactly you are trying to do): set the rx_sls_disable, manually override the tx_snd_sls_cmd_gcrmsg per pack registers (if you do not also disable the various sending sms, though, this will eventually get overwritten), set tx_sls_lane_val_gcrmsg to 0 (if there is no valid tx sls lane, no sls command will get sent on it), and/or disable the recal, repair, recovery sms (rx_dyn_recal_suspend, rx_dyn_rpr_disable, rx_sls_rcvy_disable) that initiate the sending of sls commands\r\n\tsmr
#define EDI_RX_SLS_CNTR_TAP_PTS                            0x800878000000003f, 50,  2 // how long the sls rx command needs to be stable for.\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) edi - 16 c8 clks; ei4 - 32 c4 clks\r\n\t01:(tap2) edi - 32 c8 clks; ei4 - 64 c4 clks\r\n\t10:(tap3) edi - 64 c8 clks; ei4 - 128 c4 clks\r\n\t11:(tap4) edi - 128 c8 clks; ei4 - 256 c4 clks\r\n\tsmr
#define EDI_RX_NONSLS_CNTR_TAP_PTS                         0x800878000000003f, 52,  2 // how long a non-sls rx command needs to be stable for (to know we have switched from an sls command to data).\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) edi - 32 c8 clks; ei4 - 64 c4 clks\r\n\t01:(tap2) edi - 64 c8 clks; ei4 - 128 c4 clks\r\n\t10:(tap3) edi - 128 c8 clks; ei4 - 256 c4 clks\r\n\t11:(tap4) edi - 256 c8 clks; ei4 - 512 c4 clks\r\n\tsmr
#define EDI_RX_SLS_ERR_CHK_RUN                             0x800878000000003f, 54,  1 // run sls error check counter\r\n\tsmr
#define EDI_RX_FINAL_NOP_CS                                0x800878000000003f, 55,  1 // hw210823 chicken switch.  0: allows receiver of final nop to accept either sls_nop or sls_*_req to exit the handshake sm; 1: reverts to original dd1.0 logic to only accept nop to exit the handshake sm. \r\n\tsmr
#define EDI_RX_SR_FINAL_NOP_TIMEOUT_SEL                    0x800878000000003f, 56,  3 // hw232404: for ei4 in the case of 2 bad lanes, so no sls lane, how long to wait for final nop during static repair. \r\n\t000:(tap0) 0.8ns (one cycle chicken switch) \r\n\t001:(tap1) 1.7us \r\n\t010:(tap2) 3.4us \r\n\t011:(tap3) 6.8us \r\n\t100:(tap4) 13.6us \r\n\t101:(tap5) 27.2us \r\n\t110:(tap6) 54.6us \r\n\t111:(tap7) infinite\r\n\tsmr
#define EDI_RX_SLS_EXCEPTION2_CS                           0x800878000000003f, 59,  1 // hw235842: added chicken switch for new sls exception2 command.  need to set this when mixing allv3 and later logic with logic previous to allv3\r\n\tif set to 1, should set rx_sls_timeout_sel > 4x recal_overall_timeout_sel so avoid sending exception on sr interval and seeing false exception resmr
#define EDI_RX_SLS_MODE_PG                                 0x800878000000003f, 48, 16 // rx spare lane signaling mode reg -- description
#define EDI_RX_START_WDERF_ALIAS                           0x800880000000003f, 48,  5 // alias for rx_start_* bits\r\n\tpmt
#define EDI_RX_START_WIRETEST                              0x800880000000003f, 48,  1 // when this register is written to a 1 the training state machine will run the wiretest portion of the training states.\r\n\trjr
#define EDI_RX_START_DESKEW                                0x800880000000003f, 49,  1 // when this register is written to a 1 the training state machine will run the deskew portion of the training states.\r\n\trjr
#define EDI_RX_START_EYE_OPT                               0x800880000000003f, 50,  1 // when this register is written to a 1 the training state machine will run the data eye optimization portion of the training states.\r\n\trjr
#define EDI_RX_START_REPAIR                                0x800880000000003f, 51,  1 // when this register is written to a 1 the training state machine will run the static lane repair portion of the training states.\r\n\trjr
#define EDI_RX_START_FUNC_MODE                             0x800880000000003f, 52,  1 // when this register is written to a 1 the training state machine will run the transition to functional data portion of the training states.\r\n\trjr
#define EDI_RX_START_BIST                                  0x800880000000003f, 53,  1 // set bit to run bist and perform the required tx fifo init, rx cu pll lock, rx fifo init, and offset calibration in the bist helper state machine. the rx bist state machine is enabled through a gcr message to the rx_bist_en register field. \r\n\t0: (idle) idle \r\n\t1: (en_rx_bist) start rx bist \r\n\tjgr
#define EDI_RX_START_OFFSET_CAL                            0x800880000000003f, 54,  1 // set bit to run offset cal and the required tx fifo init, rx cu pll lock, and rx fifo init through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (ocal) start offset cal \r\n\tjgr
#define EDI_RX_START_WT_BYPASS                             0x800880000000003f, 55,  1 // set bit to run wiretest bypass and the required tx fifo initialization through the bist helper state machine. \r\n\t0: (idle) idle \r\n\t1: (wtbyp) start wiretest bypass \r\n\tjgr
#define EDI_RX_TRAINING_START_PG                           0x800880000000003f, 48, 16 // rx training state start reg -- description
#define EDI_RX_WDERF_DONE_ALIAS                            0x800888000000003f, 48,  5 // alias for rx_*_done bits\r\n\tpmt
#define EDI_RX_WIRETEST_DONE                               0x800888000000003f, 48,  1 // when this bit is read as a 1, the wiretest training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_DESKEW_DONE                                 0x800888000000003f, 49,  1 // when this bit is read as a 1, the deskew training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_EYE_OPT_DONE                                0x800888000000003f, 50,  1 // when this bit is read as a 1, the eye optimization training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_REPAIR_DONE                                 0x800888000000003f, 51,  1 // when this bit is read as a 1, the static lane repair training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_FUNC_MODE_DONE                              0x800888000000003f, 52,  1 // when this bit is read as a 1, the transition to functional data training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.\r\n\trjr
#define EDI_RX_BIST_STARTED                                0x800888000000003f, 53,  1 // when this bit is read as a 1, the rx bist helper initializations have completed and a gcr enable message has been sent to rx bist. \r\n\tjgr
#define EDI_RX_OFFSET_CAL_DONE                             0x800888000000003f, 54,  1 // when this bit is read as a 1, offset cal has completed. \r\n\tjgr
#define EDI_RX_WT_BYPASS_DONE                              0x800888000000003f, 55,  1 // when this bit is read as a 1, wiretest bypass has completed. \r\n\tjgr
#define EDI_RX_WDERF_FAILED_ALIAS                          0x800888000000003f, 56,  5 // alias for rx_*_failed bits\r\n\tpmt
#define EDI_RX_WIRETEST_FAILED                             0x800888000000003f, 56,  1 // when this bit is read as a 1, the wiretest training state encountered an error.\r\n\trjr
#define EDI_RX_DESKEW_FAILED                               0x800888000000003f, 57,  1 // when this bit is read as a 1, the deskew training state encountered an error.\r\n\trjr
#define EDI_RX_EYE_OPT_FAILED                              0x800888000000003f, 58,  1 // when this bit is read as a 1, the eye optimization training state encountered an error.\r\n\trjr
#define EDI_RX_REPAIR_FAILED                               0x800888000000003f, 59,  1 // when this bit is read as a 1, the static lane repair training state encountered an error.\r\n\trjr
#define EDI_RX_START_BIST_FAILED                           0x800888000000003f, 61,  1 // when this bit is read as a 1, the rx cu pll failed to lock and bist was not started. (this bit is set along with rx_wt_bypass_failed and rx_offset_cal_failed)\r\n\tjgr
#define EDI_RX_OFFSET_CAL_FAILED                           0x800888000000003f, 62,  1 // when this bit is read as a 1, the rx cu pll failed to lock and offset cal was not performed. (this bit is set along with rx_wt_bypass_failed and rx_start_bist_failed)\r\n\tjgr
#define EDI_RX_WT_BYPASS_FAILED                            0x800888000000003f, 63,  1 // when this bit is read as a 1, the rx cu pll failed to lock. wiretest bypass did not complete. (this bit is set along with rx_offset_cal_failed and rx_start_bist_failed)\r\n\tjgr
#define EDI_RX_TRAINING_STATUS_PG                          0x800888000000003f, 48, 16 // rx training state status reg -- description
#define EDI_RX_RECAL_STATUS                                0x800890000000003f, 48, 16 // no longer used--remove for dd2 design\r\n\trjr
#define EDI_RX_RECAL_STATUS_PG                             0x800890000000003f, 48, 16 // rx recal status reg -- description
#define EDI_RX_SLS_TIMEOUT_SEL                             0x800898000000003f, 48,  4 // selects spare lane signalling timeout value (how long to wait for a sls handshake command)\r\n\t0000:(tap0) 6.8us very small value for sim only\r\n\t0001:(tap1) 54.6us \r\n\t0010:(tap2) 109.2us \r\n\t0011:(tap3) 218.4us \r\n\t0100:(tap4) 436.7us \r\n\t0101:(tap5) 873.5us \r\n\t0110:(tap6) 1.7ms \r\n\t0111:(tap7) 3.5ms \r\n\t1000:(tap8) 7.0ms \r\n\t1001:(tap9) 14.0ms \r\n\t1010:(tap10) 28.0ms \r\n\t1011:(tap11) 55.9ms \r\n\t1100:(tap12) 111.8ms \r\n\t1101:(tap13) 447.2ms \r\n\t1110:(tap14) 1.8 s \r\n\t1111:(tap15) infinite\r\n\tnote: value must be 4x larger than tx_dyn_recal_interval_timeout_sel when doing recal aborts, and should really be 4x rx_dyn_recal_overall_timeout_sel.\r\n\tsmr
#define EDI_RX_DS_BL_TIMEOUT_SEL                           0x800898000000003f, 52,  3 // selects deskew block lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_CL_TIMEOUT_SEL                              0x800898000000003f, 55,  3 // selects clock lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_WT_TIMEOUT_SEL                              0x800898000000003f, 58,  3 // selects wiretest timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_DS_TIMEOUT_SEL                              0x800898000000003f, 61,  3 // selects deskew  timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_TIMEOUT_SEL_PG                              0x800898000000003f, 48, 16 // rx timeout select reg -- description
#define EDI_RX_FIFO_INITIAL_L2U_DLY                        0x8008a0000000003f, 48,  4 // rx fifo initial load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 16-20 ui\r\n\trjr
#define EDI_RX_FIFO_FINAL_L2U_DLY                          0x8008a0000000003f, 52,  4 // rx fifo final load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 8-12 ui\r\n\trjr
#define EDI_RX_FIFO_FINAL_L2U_MIN_ERR_THRESH               0x8008a0000000003f, 60,  2 // rx fifo error threshold used to qualify the minimum load to unload delay as bad, which is used as the point of reference for adjusting to the final load to unload delay. note that the errors are accumulated across the entire clock group for a length of time selected by rx_eo_final_l2u_timeout_sel. \r\n\t00:(tap0) 8 errors \r\n\t01:(tap1) 16 errors \r\n\t10:(tap2) 128 errors \r\n\t11:(tap3) 255 errors\r\n\tmbs
#define EDI_RX_FIFO_MODE_PG                                0x8008a0000000003f, 48, 16 // rx fifo mode reg -- description
#define EDI_RX_SLS_CMD_VAL                                 0x8008b8000000003f, 48,  1 // current sls command valid\r\n\tsmr
#define EDI_RX_SLS_CMD_ENCODE                              0x8008b8000000003f, 50,  6 // current sls command\r\n\t000000:(nop) null operation\r\n\t000001:(shadow_request) driven by the rx side to request shadowing of its receive lane from lane n-1 to lane n\r\n\t000010:(shadow_done) driven by the rx side to signal now receiving lane n-1s data on lane n\r\n\t000011:(shadow_repair_request) driven by the rx side to request shadowing and repair of its receive lane from lane n-1 to n.\r\n\t000100:(shadow_repair_done) driven by the rx side to signal lane n-1 is repaired.\r\n\t000101:(unshadow_request) driven by the rx side to request shadowing of receive lane from lane n+1 to lane n.\r\n\t000110:(unshadow_done) driven by the rx side to signal now receiving lane n+1 data on lane n\r\n\t000111:(unshadow_repair_request) driven by the rx side to request unshadowing and repair of its receive lane from lane n+1 to lane n.\r\n\t001000:(unshadow_repair_done) driven by the rx side to signal lane n+1 is repaired.\r\n\t001001:(sls_exception) driven by the rx side to indicate to the other side of the bus its rx sls lane is broken.\r\n\t001010:(init_done) driven to signal the ctle/dfe/offset (re-)calibration operations have completed (not currently used).\r\n\t001011:(recal_request) driven on recalibration lane x to request a recalibration of its receive recalibration lane y.\r\n\t001100:(recal_running) driven during the status reporting interval of recalibration to indicate recalibration has not completed\r\n\t001101:(recal_done) driven to indicate its recalibration is complete.\r\n\t001110:(recal_failed) driven to indicate recalibration has failed on its receive recalibration lane\r\n\t001111:(recal_abort) abort recalibration.\r\n\t010000:(reserved2) reserved.010001:(reserved3) reserved.\r\n\t010010:(reserved4) reserved.\r\n\t010011:(reserved5) reserved.\r\n\t010100:(reserved6) reserved.\r\n\t010101:(reserved7) reserved.\r\n\t010110:(reserved8) reserved.\r\n\t010111:(reserved9) reserved.\r\n\t011000:(reserved10) reserved.\r\n\t\n011001:(init_ack_done) driven in response to an init_done (not currently used).\r\n\t011010:(reserved11) reserved.\r\n\t011011:(recal_ack) driven on recalibration lane y in response to a recal_request on its receive recalibration lane x\r\n\t011100:(reserved12) reserved.\r\n\t011101:(reserved13) reserved.\r\n\t011110:(reserved14) reserved.\r\n\t011111:(recal_abort_ack) abort recalibration acknowledge.\r\n\t1cdddd: transmits four bits of data dddd command each time clock c toggles.\r\n\tsmr
#define EDI_RX_SLS_ERR_CHK_CNT                             0x8008b8000000003f, 56,  8 // error count result for sls error checking mode\r\n\tsmr
#define EDI_RX_SLS_STATUS_PG                               0x8008b8000000003f, 48, 16 // rx spare lane signalling status reg -- description
#define EDI_RX_DYN_RPR_ENC_BAD_DATA_LANE_SHFT_AMT          0x8008c0000000003f, 48,  7 // crc/ecc dynamic repair: programmable register value that is subtracted from the enc_bad_data_lane value provided from the crc/ecc check logic (except for the all 1s clear pattern).  (e.g. should be set to 0x07 for the zmci logic to compensate for disabled lanes, but otherwise generally 0x00.  note: always check figtree for current settings, though, and not this comment!).\r\n\tsmr
#define EDI_RX_DYN_RPR_MODE_PG                             0x8008c0000000003f, 48, 16 // crc/ecc dynamic repair lane mode register -- description
#define EDI_RX_PG_FIR1_ERRS_FULL_REG                       0x8008d0000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERRS                                0x8008d0000000003f, 48, 14 // a per-group rxctl register or state machine parity error has occurred.\r\n\tbit0: (par_err_rxctl_regs) rxctl register parity error.\r\n\tbit1: reserved\r\n\tbit2: reserved\r\n\tbit3: (par_err_gcrs_ld_state) rxctl gcr load state machine parity error.\r\n\tbit4: (par_err_gcrs_unld_state) rxctl gcr unload state machine parity error.\r\n\tbit5: (par_err_snd_msg_state)\r\n\tbit6: (par_err_rx_main_init_state) rxctl main init sm parity error.\r\n\tbit7: (par_err_rx_wtm_state) rxctl wiretest main sm parity error.\r\n\tbit8: (par_err_rx_wtr_state)\r\n\tbit9: (par_err_rx_wtl_state)\r\n\tbit10: (par_err_rx_rpr_state)\r\n\tbit11: (par_err_rx_eyeopt_state)\r\n\tbit12: (par_err_dsm_state)\r\n\tbit13: (par_err_rxdsm_state)\r\n\tbit14:(channel_fail) dmi-only\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_PG_REGS                          0x8008d0000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group rxctl registers.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_GCR_BUFF                         0x8008d0000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group gcr buffer.\r\n\tdmb
#define EDI_RX_PG_FIR_ERR_GCRS_LD_SM                       0x8008d0000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group gcr load state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_GCRS_UNLD_SM                     0x8008d0000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group gcr unload state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_GLB_INIT_SND_MSG_SM              0x8008d0000000003f, 53,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MAIN_INIT_SM                     0x8008d0000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group main init state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_WTM_SM                           0x8008d0000000003f, 55,  1 // iotk alias: parity error has occurred in the per-group main wiretest state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_WTR_SM                           0x8008d0000000003f, 56,  1 // iotk alias: parity error has occurred in the per-group receiver wiretest state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_WTL_SM                           0x8008d0000000003f, 57,  1 // iotk alias: parity error has occurred in the per-group lane wiretest state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_RPR_SM                           0x8008d0000000003f, 58,  1 // iotk alias: parity error has occurred in the per-group repair state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_EYEOPT_SM                        0x8008d0000000003f, 59,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_DSM_SM                           0x8008d0000000003f, 60,  1 // iotk alias: parity error has occurred in the per-group main deskew state machine.the deskew main state machines function is to control both the driver and receiver sub-machines during block lock, deskew, and prbs scrambler/descrambler synchronization.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_RXDSM_SM                         0x8008d0000000003f, 61,  1 // iotk alias: parity error has occurred in the per-group rx deskew state machine.\r\n\tpmt
#define EDI_RX_PG_CHAN_FAIL_RSVD                           0x8008d0000000003f, 62,  1 // iotk alias: reserved.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR                                  0x8008d0000000003f, 63,  1 // summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.\r\n\tpmt
#define EDI_RX_FIR1_PG                                     0x8008d0000000003f, 48, 16 // rx per-group fir error source-isolation reg -- description
#define EDI_RX_PG_FIR2_ERRS_FULL_REG                       0x8008d8000000003f, 48,  9 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERRS                                0x8008d8000000003f, 48,  9 // a per-group register or state machine parity error has occurred.\r\n\tbit0: (err_dyn_rpr_sm) rxctl dynamic repair sm parity error.\r\n\tbit1: (err_sls_hndshk_sm) rxctl sls handshake sm parity error.\r\n\tbit2: (err_rpr_snd_msg_sm) rxctl repair send message sm parity error.\r\n\tbit3: (err_recal_sm) rxctl recal state machine parity error.\r\n\tbit4: reserved.\r\n\tbit5: reserved.\r\n\tbit6: reserved.\r\n\tbit7: reserved.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_DYN_RPR_SM                       0x8008d8000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group lane repair logic state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_SLS_HNDSHK_SM                    0x8008d8000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group lane repair logic sls state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_DYN_RPR_SND_MSG_SM               0x8008d8000000003f, 50,  1 // iotk alias: parity error has occurred in the per-group lane repair logic gcr send message state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_RECAL_SM                         0x8008d8000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group recalibration state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_SLS_ENC_SND_MSG_SM               0x8008d8000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group sls encode gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_GLB_CAL_SND_MSG_SM               0x8008d8000000003f, 53,  1 // iotk alias: parity error has occurred in the per-group global cal gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM              0x8008d8000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group stat repair gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_SLS_RCVY_SM                      0x8008d8000000003f, 55,  1 // iotk alias: parity error has occurred in the per-group stat repair sls recovery state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_PP_REGS                          0x8008d8000000003f, 56,  1 // iotk alias: parity error has occurred in the per-pack registers.\r\n\tdmb
#define EDI_RX_FIR2_PG                                     0x8008d8000000003f, 48, 16 // rx per-group fir error source-isolation reg -- description
#define EDI_RX_PG_FIR1_ERRS_MASK_FULL_REG                  0x8008e0000000003f, 48, 16 // iotk alias: fir mask for rx_fir1_pg errors.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERRS_MASK                           0x8008e0000000003f, 48, 14 // fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_PG_REGS                     0x8008e0000000003f, 48,  1 // iotk alias: fir mask for the per-group rxctl register checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_GCR_BUFF                    0x8008e0000000003f, 49,  1 // iotk alias: fir mask for the per-group rxctl gcr buffer.\r\n\tdmb
#define EDI_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                  0x8008e0000000003f, 51,  1 // iotk alias: fir mask for the per-group rxctl gcr load state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM                0x8008e0000000003f, 52,  1 // iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_GLB_INIT_SND_MSG_SM         0x8008e0000000003f, 53,  1 // iotk alias: fir mask for the per-group rxctl repair state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_MAIN_INIT_SM                0x8008e0000000003f, 54,  1 // iotk alias: fir mask for the per-group rxctl gcr send message state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_WTM_SM                      0x8008e0000000003f, 55,  1 // iotk alias: fir mask for the per-group rxctl main init state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_WTR_SM                      0x8008e0000000003f, 56,  1 // iotk alias: fir mask for the per-group rxctl main wiretest state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_WTL_SM                      0x8008e0000000003f, 57,  1 // iotk alias: fir mask for the per-group rxctl receiver wiretest state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_RPR_SM                      0x8008e0000000003f, 58,  1 // iotk alias: fir mask for the per-group rxctl lane wiretest state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_EYEOPT_SM                   0x8008e0000000003f, 59,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_DSM_SM                      0x8008e0000000003f, 60,  1 // iotk alias: fir mask for the per-group main deskew state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_RXDSM_SM                    0x8008e0000000003f, 61,  1 // iotk alias: fir mask for the per-group rx deskew state machine.\r\n\tpmt
#define EDI_RX_PL_FIR_ERR_MASK                             0x8008e0000000003f, 63,  1 // fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.\r\n\tpmt
#define EDI_RX_FIR1_MASK_PG                                0x8008e0000000003f, 48, 16 // rx per-group fir error source-isolation mask reg -- description
#define EDI_RX_PG_FIR2_ERRS_MASK_FULL_REG                  0x8008e8000000003f, 48,  9 // iotk alias: fir mask for rx_fir2_pg errors.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERRS_MASK                           0x8008e8000000003f, 48,  9 // fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_dyn_rpr_sm) rxctl dynamic repair sm parity error mask.\r\n\tbit1: (mask_sls_hndshk_sm) rxctl sls handshake sm parity error mask.\r\n\tbit2: (mask_rpr_snd_msg_sm) rxctl repair send message sm parity error mask.\r\n\tbit3: (mask_recal_sm) rxctl recal state machine parity error mask.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_DYN_RPR_SM                  0x8008e8000000003f, 48,  1 // iotk alias: fir mask for the per-group dynamic lane repair logic state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_SLS_HNDSHK_SM               0x8008e8000000003f, 49,  1 // iotk alias: fir mask for the per-group lane repair logic sls state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_DYN_RPR_SND_MSG_SM          0x8008e8000000003f, 50,  1 // iotk alias: fir mask for the per-group dynamic lane repair logic gcr send message state machine.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_RECAL_SM                    0x8008e8000000003f, 51,  1 // iotk alias: fir mask for the per-group recalibration state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_MASK_SLS_ENC_SND_MSG_SM          0x8008e8000000003f, 52,  1 // iotk alias: fir mask for the per-group sls encode gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_GLB_CAL_SND_MSG_SM          0x8008e8000000003f, 53,  1 // iotk alias: fir mask for the per-group global cal gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM         0x8008e8000000003f, 54,  1 // iotk alias: fir mask for the per-group stat repair gcr send message state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_SLS_RCVY_SM                 0x8008e8000000003f, 55,  1 // iotk alias: fir mask for the per-group sls recovery state machine.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_MASK_PP_REGS                     0x8008e8000000003f, 56,  1 // iotk alias: fir mask for the per-group per-pack registers.\r\n\tdmb
#define EDI_RX_FIR2_MASK_PG                                0x8008e8000000003f, 48, 16 // rx per-group fir error source-isolation mask reg -- description
#define EDI_RX_PG_FIR1_ERR_INJ_FULL_REG                    0x8008f0000000003f, 48, 16 // iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EDI_RX_PG_FIR1_ERR_INJ                             0x8008f0000000003f, 48, 14 // rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_PG_REGS                      0x8008f0000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_GCR_BUFF                     0x8008f0000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.\r\n\tdmb
#define EDI_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                   0x8008f0000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                 0x8008f0000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_GLB_INIT_SND_MSG_SM          0x8008f0000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_MAIN_INIT_SM                 0x8008f0000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main init state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_WTM_SM                       0x8008f0000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_WTR_SM                       0x8008f0000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_WTL_SM                       0x8008f0000000003f, 57,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_RPR_SM                       0x8008f0000000003f, 58,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_EYEOPT_SM                    0x8008f0000000003f, 59,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl eye opt state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_DSM_SM                       0x8008f0000000003f, 60,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_RXDSM_SM                     0x8008f0000000003f, 61,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.\r\n\tpmt
#define EDI_RX_FIR1_ERROR_INJECT_PG                        0x8008f0000000003f, 48, 16 // rx per-group fir error injection reg -- description
#define EDI_RX_PG_FIR2_ERR_INJ_FULL_REG                    0x8008f8000000003f, 48,  9 // iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EDI_RX_PG_FIR2_ERR_INJ                             0x8008f8000000003f, 48,  9 // rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_dyn_rpr_sm) rxctl dynamic repair sm parity error inject.\r\n\tbit1: (inj_sls_hndshk_sm) rxctl sls handshake sm parity error inject.\r\n\tbit2: (inj_rpr_snd_msg_sm) rxctl repair send message sm parity error inject.\r\n\tbit3: (inj_recal_sm) rxctl recal state machine parity error inject.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_DYN_RPR_SM                   0x8008f8000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on per-group lane repair logic state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_SLS_HNDSHK_SM                0x8008f8000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group lane repair logic sls state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_DYN_RPR_SND_MSG_SM           0x8008f8000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group dynamic lane repair logic gcr send message state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_RECAL_SM                     0x8008f8000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group recalibration state machine parity checker.\r\n\tpmt
#define EDI_RX_PG_FIR_ERR_INJ_SLS_ENC_SND_MSG_SM           0x8008f8000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls encode gcr send message state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_GLB_CAL_SND_MSG_SM           0x8008f8000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group global cal gcr send message state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM          0x8008f8000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group stat repair gcr send message state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_SLS_RCVY_SM                  0x8008f8000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls recovery state machine parity checker.\r\n\tjgr
#define EDI_RX_PG_FIR_ERR_INJ_PP_REGS                      0x8008f8000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group per pack register checker.\r\n\tdmb
#define EDI_RX_FIR2_ERROR_INJECT_PG                        0x8008f8000000003f, 48, 16 // rx per-group fir error injection reg -- description
#define EDI_RX_PG_FIR_TRAINING_ERROR                       0x800900000000003f, 48,  1 // this field is now defunct and is permanently masked in the rx_fir_training_mask_pg fir isolation register.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_SPARE_DEPLOYED                0x800900000000003f, 49,  1 // a spare lane has been deployed during training to heal a lane that was detected as bad. rx_static_spare_deployed (ssd) will be set after the repair training step if during training either wiretest, deskew, eyeopt or repair has detected one or more bad lanes have been detected. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed and the rx_bad_lane.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED           0x800900000000003f, 50,  1 // a lane has been detected as bad during training but there are no spare lanes available to heal it. this fir will not be set until the repair training step has been run. this is a catastrophic failure for the bus when in mission mode but all training steps will still be run on whatever good lanes there are. rx_static_max_spares_exceeded will be set if wiretest, deskew, eyeopt or repair find the excessive number of bad lanes.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_REPAIR_ERROR                 0x800900000000003f, 51,  1 // a dynamic repair error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED               0x800900000000003f, 52,  1 // a spare lane has been deployed by ecc/crc logic to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED          0x800900000000003f, 53,  1 // a lane has been detected as bad by ecc/crc logic but there are no spare lanes to heal it. this is a catastrophic failure for the bus.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_ERROR                          0x800900000000003f, 54,  1 // a recalibration error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_SPARE_DEPLOYED                 0x800900000000003f, 55,  1 // a spare lane has been deployed during recal to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED            0x800900000000003f, 56,  1 // a lane has been detected as bad during recal but there are no spare lanes to heal it. this is a catastrophic failure for the bus.\r\n\tpmt
#define EDI_RX_PG_FIR_TOO_MANY_BUS_ERRORS                  0x800900000000003f, 57,  1 // more than one lane has been detected as having too many errors during functional operation. this is a catastrophic failure for the bus.\r\n\tpmt
#define EDI_RX_FIR_TRAINING_PG                             0x800900000000003f, 48, 16 // rx per-group training fir error reg -- description
#define EDI_RX_PG_FIR_TRAINING_ERROR_MASK                  0x800908000000003f, 48,  1 // fir mask for rx_pg_fir_training_error.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_SPARE_DEPLOYED_MASK           0x800908000000003f, 49,  1 // fir mask for rx_pg_fir_static_spare_deployed.\r\n\tpmt
#define EDI_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED_MASK      0x800908000000003f, 50,  1 // fir mask for rx_pg_fir_static_max_spares_exceeded\r\n\tpmt.
#define EDI_RX_PG_FIR_DYNAMIC_REPAIR_ERROR_MASK            0x800908000000003f, 51,  1 // fir mask for rx_pg_fir_dynamic_repair_error\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED_MASK          0x800908000000003f, 52,  1 // fir mask for rx_pg_fir_dynamic_spare_deployed.\r\n\tpmt
#define EDI_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED_MASK     0x800908000000003f, 53,  1 // fir mask for rx_pg_fir_dynamic_max_spares_exceeded.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_ERROR_MASK                     0x800908000000003f, 54,  1 // fir mask for rx_pg_fir_recal_error.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_SPARE_DEPLOYED_MASK            0x800908000000003f, 55,  1 // fir mask for rx_pg_fir_recal_spare_deployed.\r\n\tpmt
#define EDI_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED_MASK       0x800908000000003f, 56,  1 // fir mask for rx_pg_fir_recal_max_spares_exceeded.\r\n\tpmt
#define EDI_RX_PG_FIR_TOO_MANY_BUS_ERRORS_MASK             0x800908000000003f, 57,  1 // fir mask for rx_pg_fir_too_many_bus_errors.\r\n\tpmt
#define EDI_RX_FIR_TRAINING_MASK_PG                        0x800908000000003f, 48, 16 // rx per-group training fir error mask reg -- description
#define EDI_RX_EO_OFFSET_TIMEOUT_SEL                       0x800910000000003f, 48,  3 // selects latch offset timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_AMP_TIMEOUT_SEL                          0x800910000000003f, 51,  3 // selects  amplitude measurement watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_CTLE_TIMEOUT_SEL                         0x800910000000003f, 54,  3 // selects  ctle ajdust watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_H1AP_TIMEOUT_SEL                         0x800910000000003f, 57,  3 // selects  h1ap ajdust watchdog timeout. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_DDC_TIMEOUT_SEL                          0x800910000000003f, 60,  3 // selects  ddc watchdog timeout (edi only). \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_TIMEOUT_SEL                    0x800910000000003f, 63,  1 // selects final load to unload delay qualification time per step. \r\n\t0:(tap0) 4k ui or 0.425us \r\n\t1:(tap1) 64k ui or 6.8us\r\n\tmbs
#define EDI_RX_TIMEOUT_SEL1_PG                             0x800910000000003f, 48, 16 // rx timeout select reg 1 -- description
#define EDI_RX_LANE_BAD_VEC_0_15                           0x800918000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).to be clear, the bad_lane vector is only updated during training.  it will not reflect bad lanes found post training during dynamic repair or dynamic recal.  for that, you need to read the [rx,tx]_bad_lane[1,2]_gcrmsg registers.  to calculate what you want to know, you need five registers:\r\n\t rx_bad_lane1_gcrmsg\r\n\t rx_bad_lane2_gcrmsg\r\n\t rx_bad_lane_code_gcrmsg\r\n\t rx_sls_lane_gcrmsg\r\n\t rx_wtr_max_bad_lanes\r\n\tin general, if the spares deployed fir goes on, and the bad_lane_code is a 1, then the newly spared lane resides in the rx_bad_lane1_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 2, then the newly spared lane resides in the rx_bad_lane2_gcrmsg register. if the spares deployed fir goes on, and the bad_lane_code is a 3, then the newly spared lane resides in the rx_sls_lane_gcrmsg register. that might be enough information for what you want to know, trying to keep the answer very general.  at the moment, this case where both the spare deployed and max spares exceeded both come on at the same time, is for the edi where a third bad lane has been found and we have chosen to use the sls lane as a third spare. edi normally only has two spare lanes. in that case, i first set the spare deployed fir as the sls lane is being used as a third spare. but then a few cycles later, i set the max spares exceeded because i no longer have an sls lane and cant finish my sls repair handshake.\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_0_15_PG                        0x800918000000003f, 48, 16 // rx bad lanes 0 to 15 reg -- lanes found bad by wiretest or set as bad by firmware
#define EDI_RX_LANE_BAD_VEC_16_31                          0x800920000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).\r\n\trjr
#define EDI_RX_LANE_BAD_VEC_16_31_PG                       0x800920000000003f, 48, 16 // rx bad lanes 16 to 31 reg -- lanes found bad by wiretest or set as bad by firmware
#define EDI_RX_LANE_DISABLED_VEC_0_15                      0x800928000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_0_15_PG                   0x800928000000003f, 48, 16 // rx lane disable(d) 0 to 15 reg -- lanes disabled by firmware and therefore do not participate in link training
#define EDI_RX_LANE_DISABLED_VEC_16_31                     0x800930000000003f, 48, 16 // lanes disabled by hw (status) or method to force lane to be disabled (save power) from software (control)\r\n\trjr
#define EDI_RX_LANE_DISABLED_VEC_16_31_PG                  0x800930000000003f, 48, 16 // rx lane disable(d) 16_31 reg -- lanes disabled by firmware and therefore do not participate in link training
#define EDI_RX_LANE_SWAPPED_VEC_0_15                       0x800938000000003f, 48, 16 // wiretest found that the p & n wire legs have been swapped on the lane indicated. has the effect of basically inverting the signal.  note that this status is invalid if the lane is marked bad\r\n\trjr
#define EDI_RX_LANE_SWAPPED_VEC_0_15_PG                    0x800938000000003f, 48, 16 // rx p & n lanes swapped 0 to 15 reg -- lanes whose p&n receivers are swapped
#define EDI_RX_LANE_SWAPPED_VEC_16_31                      0x800940000000003f, 48, 16 // wiretest found that the p & n wire legs have been swapped on the lane indicated. has the effect of basically inverting the signal.  note that this status is invalid if the lane is marked bad\r\n\trjr
#define EDI_RX_LANE_SWAPPED_VEC_16_31_PG                   0x800940000000003f, 48, 16 // rx p & n lanes swapped 16 to 31 reg -- lanes whose p&n receivers are swapped
#define edi_rx_main_init_state                             0x800948000000003f, 48,  4 // main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused\r\n\trjr
#define edi_rx_init_state_pg                               0x800948000000003f, 48, 16 // rx init machine status -- description
#define EDI_RX_WTM_STATE                                   0x800950000000003f, 48,  5 // main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail \r\n\trjr
#define EDI_RX_WTR_STATE                                   0x800950000000003f, 53,  4 // receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused\r\n\trjr
#define EDI_RX_WTL_STATE                                   0x800950000000003f, 59,  5 // lane wiretest sub state machine current state (rjr)\r\n\tx00: idle\r\n\tx01: wait 1st long transition\r\n\tx02: wait 2nd long transition\r\n\tx03: wait short transition\r\n\tx04: wait transition from pn=01\r\n\tx05: wait transition from 10\r\n\tx06: wait transition from 00\r\n\tx07: wait transition from 11\r\n\tx10: good-no swap\r\n\tx11: bad-n=1-no swap\r\n\tx12: bad-n=0-no swap\r\n\tx13: bad-p=1-no swap\r\n\tx14: bad-p=0-no swap\r\n\tx15: bad-p or n floating\r\n\tx16: bad-pn=00\r\n\tx17: bad-pn=11\r\n\tx18: good--swapped\r\n\tx19: bad-n=1-swapped\r\n\tx1a: bad-n=0-swapped\r\n\tx1b: bad-p=1-swapped\r\n\tx1c: bad-p=0-swapped\r\n\tx1d: bad-pn=10\r\n\tx1e: bad-pn=01\r\n\tx1f: bad-unknown failure\r\n\trjr
#define EDI_RX_WTL_DONE_ALIAS                              0x800950000000003f, 59,  1 // iotk alias: wiretest lane state machine done indication(rjr):\r\n\t0: idling or running.\r\n\t1: done\r\n\trjr
#define EDI_RX_WTL_P_N_SWAP_ALIAS                          0x800950000000003f, 60,  1 // iotk alias: for wiretest lane state machine p/n wire swap indication(rjr):\r\n\t0: lane p/n wires not swapped.\r\n\t1: lane p/n wires swapped\r\n\t:may have different meaning if fault code is non-zero\r\n\trjr
#define EDI_RX_WTL_FAULT_CODE_ALIAS                        0x800950000000003f, 61,  3 // iotk alias: for wiretest lane state machine fault code(rjr):\r\n\t000: lane good.\r\n\t001: lane n wire stuck at 1.\r\n\t010: lane n wire stuck at 0.\r\n\t011: lane p wire stuck at 1\r\n\t100: lane p wire stuck at 0\r\n\t101: lane n or p wire floating: swap status invalid.\r\n\t110: lane p and n stuck--00 if swap=0, 10 if swap=1, swap status invalid.\r\n\t111: p and n stuck at 1 if swap=0 unknown failure if swap=1.\r\n\trjr
#define EDI_RX_WIRETEST_STATE_PG                           0x800950000000003f, 48, 16 // rx wiretest state machine reg -- rx main and rx wiretest state machines
#define EDI_RX_WTR_CUR_LANE                                0x800958000000003f, 48,  5 // wiretest current lane under test\r\n\trjr
#define EDI_RX_WTR_MAX_BAD_LANES                           0x800958000000003f, 53,  5 // wiretest max number of bad lanes allowed per clk group\r\n\trjr\r\n\talso static repair, dynamic repair & recal max number of bad lanes per rx bus (note: should match tx side)\r\n\tsmr
#define EDI_RX_WTR_BAD_LANE_COUNT                          0x800958000000003f, 59,  5 // wiretest current number of bad lanes in this clk group\r\n\trjr
#define EDI_RX_WIRETEST_LANEINFO_PG                        0x800958000000003f, 48, 16 // rx wiretest lane info reg -- rx wiretest current lane, max bad lanes allowed and number of currently marked bad lanes
#define EDI_RX_WT_PREV_DONE_GCRMSG                         0x800960000000003f, 48,  1 // gcr message: previous clk group has completed wiretest\r\n\tjfg
#define EDI_RX_WT_ALL_DONE_GCRMSG                          0x800960000000003f, 49,  1 // gcr message: all clk groups have completed wiretest\r\n\tjfg
#define EDI_RX_CD_PREV_DONE_GCRMSG                         0x800960000000003f, 50,  1 // gcr message: previous clk group has finished sending & receiving 4 clk/data sls commands\r\n\tsmr
#define EDI_RX_CD_ALL_DONE_GCRMSG                          0x800960000000003f, 51,  1 // gcr message: all clk groups have completed sending & receiving 4 clk/data sls commands.  in the case of the slave side, also the final nop has been received.\r\n\tsmr
#define EDI_RX_CNTLS_PREV_LDED_GCRMSG                      0x800960000000003f, 52,  1 // gcr message: previous clk group has finished updating rx sls/bad lane & repair controls\r\n\tsmr
#define EDI_RX_WIRETEST_GCRMSG_PG                          0x800960000000003f, 48, 16 // rx wiretest gcr message reg -- gcr msg: previous/all clk group(s) have completed wiretest
#define EDI_RX_DESKEW_SEQ_GCRMSG                           0x800968000000003f, 48,  3 // gcr message: rx deskew sequencer gcr messages\r\n\t000:(dsprevdeskewed) indicate prior group deskewed.\r\n\t001:(dsalldeskewed) indicate all groups deskewed.\r\n\t010:(dsprevdone) indicate prior group completed deskew.\r\n\t011:(dsalldone) indicate all groups completed deskew.\r\n\t100:(dsprevskew) transmit skew values from prior group.\r\n\t101:(dsmaxskew) transmit max skew values to all groups.\r\n\t110:(unused) unused.\r\n\t111:(dsnomsg) no message.\r\n\trjr
#define EDI_RX_DESKEW_SKMIN_GCRMSG                         0x800968000000003f, 52,  6 // gcr message: min skew value for deskew sequence.\r\n\trjr
#define EDI_RX_DESKEW_SKMAX_GCRMSG                         0x800968000000003f, 58,  6 // gcr message: max skew value for deskew sequence.\r\n\trjr
#define EDI_RX_DESKEW_GCRMSG_PG                            0x800968000000003f, 48, 16 // rx deskew gcr message reg -- gcr msg: deskew
#define EDI_RX_DSM_STATE                                   0x800970000000003f, 50,  6 // main deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init tx fifo\r\n\tx02: master driver patt b\r\n\tx03:block lock\r\n\tx04: check skew\r\n\tx05:send skew to other groups\r\n\tx06: wait for max skew message\r\n\tx07: check max skew\r\n\tx08: deskew group\r\n\tx09: send deskewed message\r\n\tx0a: wait for all deskewd message\r\n\tx0b: deskew group\r\n\tx0c: drive prbs sync\r\n\tx0d: wait for prbs synced\r\n\tx0e: send done message\r\n\tx0f: wait for all done message\r\n\tx10: slave drive patt a\r\n\tx11: enable prbs sync checking\r\n\t:x12-x1e: unused\r\n\tx1f: deskew done\r\n\tx20-x22: unused\r\n\tx23: block lock failed\r\n\tx24: group skew measure fail--timeout\r\n\tx25: group skew fail-rxdsm fail\r\n\tx25: bus deskew fail\r\n\tx27: max skew in group fail\r\n\tx28: group deskew timeout fail\r\n\tx29: unused\r\n\tx2a: bus deskew timeout fail\r\n\tx2b-x2c: unused\r\n\tx2d: wait prbs sync timeout fail\r\n\tx2e: timeout while sending done message fail\r\n\tx2f: timeout waiting for bus deskew all done message fail\r\n\tx30-x3f: unused\r\n\trjr
#define EDI_RX_RXDSM_STATE                                 0x800970000000003f, 57,  7 // rx deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init rx fifo\r\n\tx02: start block lock\r\n\tx03:read block lock status\r\n\tx04: check block lock status\r\n\tx05:check lane valid\r\n\tx06: check max lane count\r\n\tx07: lane block lock status\r\n\tx08: write bad lane block lock\r\n\tx09: block lock done\r\n\tx0a: start check skew\r\n\tx0b: read skew status\r\n\tx0c: check skew status\r\n\tx0d: check valid lanes for skew\r\n\tx0e: check max lane count\r\n\tx0f: read first valid lane skew status\r\n\tx10: write bad skew status\r\n\tx11: check lane count\r\n\t:x12: check other lanes valid\r\n\tx13: read lane skew status\r\n\tx14: write lane bad skew stus\r\n\tx15: send rx skew valid to main deskew machine\r\n\tx16: check lane valid for deskew\r\n\tx17: read skew for deskewing\r\n\tx18:  write new rx fifo load-unload delay\r\n\tx19: write bad skew status\r\n\tx1a check last lane for done\r\n\tx1bb: clear skew status\r\n\tx1c: read global skew status\r\n\tx1d: check global skew status\r\n\tx1e: check lane valid for deskew check\r\n\tx1f: read lane deskew status\r\n\tx20: check lane count for done\r\n\tx21: stop checking skew\r\n\tx22: wait for check prbs sync signal\r\n\tx23: read prbs sync status\r\n\tx24: check prbs sync status\r\n\tx25: prbs synced/deskew done\r\n\tx26: clear deskew control\r\n\tx27: write bad deskew status\r\n\tx28-4d: unused\r\n\tx4e: skew error oddbadd fail\r\n\tx4f-7f: unused\r\n\trjr
#define EDI_RX_DESKEW_STATE_PG                             0x800970000000003f, 48, 16 // rx deskew state machine status reg -- rx deskew state machine states
#define EDI_RX_DESKEW_MAX_LIMIT                            0x800978000000003f, 48,  6 // maximum deskewable skew fail threshold \r\n\t000000:   0 ui \r\n\t000001:   2 ui \r\n\t000010:   4 ui \r\n\t000011:   6 ui \r\n\t000100:   8 ui \r\n\t000101:  10 ui \r\n\t000110:  12 ui \r\n\t000111:  14 ui \r\n\t001000:  16 ui \r\n\t001001:  18 ui \r\n\t001010:  20 ui \r\n\t001011:  22 ui > ei-4 max \r\n\t001100:  24 ui > ei-4 max \r\n\t001101:  26 ui > ei-4 max \r\n\t001110:  28 ui > ei-4 max \r\n\t001111:  30 ui > ei-4 max \r\n\t010000:  32 ui > ei-4 max \r\n\t010001:  34 ui > ei-4 max \r\n\t010010:  36 ui > ei-4 max \r\n\t010011:  38 ui > ei-4 max \r\n\t010100:  40 ui > ei-4 max \r\n\t010101:  42 ui > ei-4 max \r\n\t010110:  44 ui > ei-4 max \r\n\t010111:  46 ui > ei-4 & edi max \r\n\t011000:  48 ui > ei-4 & edi max \r\n\t011001:  50 ui > ei-4 & edi max \r\n\t011010:  52 ui > ei-4 & edi max \r\n\t011011:  54 ui > ei-4 & edi max \r\n\t011100:  56 ui > ei-4 & edi max \r\n\t011101:  58 ui > ei-4 & edi max \r\n\t011110:  60 ui > ei-4 & edi max \r\n\t011111:  62 ui > ei-4 & edi max \r\n\t100000:  64 ui > ei-4 & edi max \r\n\t100001:  66 ui > ei-4 & edi max \r\n\t100010:  68 ui > ei-4 & edi max \r\n\t100011:  70 ui > ei-4 & edi max \r\n\t100100:  72 ui > ei-4 & edi max \r\n\t100101:  74 ui > ei-4 & edi max \r\n\t100110:  76 ui > ei-4 & edi max \r\n\t100111:  78 ui > ei-4 & edi max \r\n\t101000:  80 ui > ei-4 & edi max \r\n\t101001:  82 ui > ei-4 & edi max \r\n\t101010:  84 ui > ei-4 & edi max \r\n\t101011:  86 ui > ei-4 & edi max \r\n\t101100:  88 ui > ei-4 max \r\n\t101101:  90 ui > ei-4 max \r\n\t101110:  92 ui > ei-4 max \r\n\t101111:  94 ui > ei-4 max \r\n\t110000:  96 ui > ei-4 max \r\n\t110001:  98 ui > ei-4 max \r\n\t110010: 100 ui > ei-4 max \r\n\t110011: 102 ui > ei-4 max \r\n\t110100: 104 ui > ei-4 max \r\n\t110101: 106 ui > ei-4 max \r\n\t110110: 108 ui > ei-4 max \r\n\t110111: 110 ui > ei-4 max \r\n\t111000: 112 ui > ei-4 & edi max \r\n\t111001: 114 ui > ei-4 & edi max \r\n\t111010: 116 ui > ei-4 & edi max \r\n\t111011: 118 ui > ei-4 & edi max \r\n\t111100: 120 ui > ei-4 & edi max \r\n\t111101: 122 ui > ei-4 & edi max \r\n\t111110: 124 ui > ei-4 & edi max \r\n\t111111: 126 ui > ei-4 & edi max \r\n\trjr
#define EDI_RX_DESKEW_MODE_PG                              0x800978000000003f, 48, 16 // rx deskew state machine control reg -- rx deskew state machine controls
#define EDI_RX_DESKEW_MINSKEW_GRP                          0x800980000000003f, 48,  6 // deskew per-group raw skew min\r\n\trjr
#define EDI_RX_DESKEW_MAXSKEW_GRP                          0x800980000000003f, 54,  6 // deskew per-group raw skew max\r\n\trjr
#define EDI_RX_DESKEW_STATUS_PG                            0x800980000000003f, 48, 16 // rx deskew state machine status values -- local skew and other deskew status not including actual state values
#define EDI_RX_BAD_LANE1_GCRMSG                            0x800988000000003f, 48,  7 // gcr message: encoded bad lane one in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE2_GCRMSG                            0x800988000000003f, 55,  7 // gcr message: encoded bad lane two in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_BAD_LANE_CODE_GCRMSG                        0x800988000000003f, 62,  2 // gcr message: rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes\r\n\tsmr
#define EDI_RX_BAD_LANE_ENC_GCRMSG_PG                      0x800988000000003f, 48, 16 // rx bad lanes encoded -- description
#define EDI_RX_RPR_STATE                                   0x800990000000003f, 48,  6 // static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state\r\n\tsmr
#define EDI_RX_STATIC_REPAIR_STATE_PG                      0x800990000000003f, 48, 16 // rx static repair state machine reg -- description
#define EDI_RX_TX_BUS_WIDTH                                0x800998000000003f, 48,  7 // tx bus width\r\n\tsmr
#define EDI_RX_RX_BUS_WIDTH                                0x800998000000003f, 55,  7 // rx bus width\r\n\tsmr
#define EDI_RX_TX_BUS_INFO_PG                              0x800998000000003f, 48, 16 // tx bus info for rx ctl macs -- description
#define EDI_RX_SLS_LANE_GCRMSG                             0x8009a0000000003f, 48,  7 // gcr message: encoded sls lane in relation to the entire rx bus\r\n\tsmr
#define EDI_RX_SLS_LANE_VAL_GCRMSG                         0x8009a0000000003f, 55,  1 // gcr message: rx sls lane valid\r\n\tsmr
#define EDI_RX_SLS_LANE_ENC_GCRMSG_PG                      0x8009a0000000003f, 48, 16 // rx sls lane encoded -- description
#define EDI_RX_FENCE                                       0x8009a8000000003f, 48,  1 // rx & tx fence bit\r\n\t0:(unfenced) functional data is being driven to & front nest logic\r\n\t1:(fenced) functional data is gated to zeroes to & from nest logic. also indicates that link training not yet complete.\r\n\tsmr
#define EDI_RX_FENCE_PG                                    0x8009a8000000003f, 48, 16 // rx per group fence -- description
#define EDI_RX_FUNC_MODE_TIMEOUT_SEL                       0x8009b8000000003f, 48,  3 // selects functional mode wait timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 16k ui or 1.7us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_RC_SLOWDOWN_TIMEOUT_SEL                     0x8009b8000000003f, 51,  3 // selects recal  slowdown      timeout. note that his should be longer than rx_sls_timeout_sel. \r\n\t000:(tap0) 0   ui or   0us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_PUP_LITE_WAIT_SEL                           0x8009b8000000003f, 54,  2 // how long to wait for analog logic to power up an unused spare lane for recal and repair\r\n\t00:(tap0) 833ps (for sim use only)\r\n\t01:(tap1) 107ns (default value)\r\n\t10:(tap2) 213ns\r\n\t11:(tap3) 427ns\r\n\tsmr
#define EDI_RX_EO_L2U_WD_TIMEOUT_SEL                       0x8009b8000000003f, 57,  3 // selects final load to unload delay watchdog timeout.\r\n\t000:(tap0) 16k ui or 1.7us \r\n\t001:(tap1) 128k ui or 13.7us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 512k ui or 54.6us \r\n\t100:(tap4) 1m ui or 109.2us \r\n\t101:(tap5) 2m ui or 218.5us \r\n\t110:(tap6) 64m ui or 7ms\r\n\t111:(tap7) infinite\r\n\trjr
#define EDI_RX_EO_VGA_WD_TIMEOUT_SEL                       0x8009b8000000003f, 60,  4 // selects watchdog timeout for vga adjustment. \r\n\t0000:(tap0) 1.7us \r\n\t0001:(tap1) 54.6 us \r\n\t0010:(tap2) 109.2us \r\n\t0011:(tap3) 218.4us \r\n\t0100:(tap4) 436.7us \r\n\t0101:(tap5) 873.4us \r\n\t0110:(tap6) 1.7ms \r\n\t0111:(tap7) 3.5ms \r\n\t1000:(tap8) 7.0ms \r\n\t1001:(tap9) 13.9ms \r\n\t1010:(tap10) 27.9ms \r\n\t1011:(tap11) 55.9ms \r\n\t1100:(tap12) 111.7ms \r\n\t1101:(tap13) 447.2ms \r\n\t1110:(tap14) 1.7 sec \r\n\t1111:(tap15) infinite\r\n\trjr
#define EDI_RX_TIMEOUT_SEL2_PG                             0x8009b8000000003f, 48, 16 // rx timeout select reg 2 -- description
#define EDI_RX_C4_SEL                                      0x8009c0000000003f, 48,  2 // select 1 of 4 possible phases for the c4 clock to send along with the data for integration flexibility and tuning for slack into the rx fifo.\r\n\tcpg
#define EDI_RX_NEGZ_EN                                     0x8009c0000000003f, 50,  1 // turns on a gyrator stage in the ctle pushing up the high freq corner\r\n\tcpg
#define EDI_RX_PROT_SPEED_SLCT                             0x8009c0000000003f, 51,  1 // tbd (enable the flux capacitor?)\r\n\tcpg
#define EDI_RX_IREF_BC                                     0x8009c0000000003f, 52,  3 // bias code for the iref macros on the rx side. all eight 3 bit codes enable current out. the cml voltage swings of the output current will vary with this code.\r\n\tcpg
#define EDI_RX_MISC_ANALOG_PG                              0x8009c0000000003f, 48, 16 // rx misc analog reg -- description
#define EDI_RX_DYN_RPR_STATE                               0x8009c8000000003f, 50,  6 // dynamic repair main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_rpr_state\r\n\tsmr
#define EDI_RX_SLS_HNDSHK_STATE                            0x8009c8000000003f, 56,  8 // sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_hndshk_state\r\n\tsmr
#define EDI_RX_DYN_RPR_PG                                  0x8009c8000000003f, 48, 16 // rx dynamic repair & recalibration status -- description
#define EDI_RX_DYN_RPR_REQ_GCRMSG                          0x8009d0000000003f, 48,  1 // gcr message: crc/ecc tallying logic has a dynamic repair request\r\n\tsmr
#define EDI_RX_DYN_RPR_LANE2RPR_GCRMSG                     0x8009d0000000003f, 49,  7 // gcr message: crc/ecc tallying logic bad lane to repair\r\n\tsmr
#define EDI_RX_DYN_RPR_IP_GCRMSG                           0x8009d0000000003f, 56,  1 // gcr message: crc/ecc bad lane repair in progress\r\n\tsmr
#define EDI_RX_DYN_RPR_COMPLETE_GCRMSG                     0x8009d0000000003f, 57,  1 // gcr message: crc/ecc bad lane repaired\r\n\tsmr
#define EDI_RX_DYN_RPR_GCRMSG_PG                           0x8009d0000000003f, 48, 16 // crc/ecc dynamic repair gcr message reg -- description
#define EDI_RX_DYN_RPR_BAD_LANE_MAX                        0x8009d8000000003f, 48,  7 // crc/ecc dynamic repair: max number of times a lane can be found bad before repaired\r\n\tsmr
#define EDI_RX_DYN_RPR_ERR_CNTR1_DURATION                  0x8009d8000000003f, 55,  4 // crc/ecc dynamic repair: duration the lane error counter1 can run before being cleared (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite\r\n\tsmr
#define EDI_RX_DYN_RPR_CLR_ERR_CNTR1                       0x8009d8000000003f, 59,  1 // crc/ecc dynamic repair: firmware-based clear of lane error counter1 register\r\n\tsmr
#define EDI_RX_DYN_RPR_DISABLE                             0x8009d8000000003f, 60,  1 // crc/ecc dynamic repair: when set, disables dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2)\r\n\tsmr
#define EDI_RX_DYN_RPR_ENC_BAD_DATA_LANE_WIDTH             0x8009d8000000003f, 61,  3 // crc/ecc dynamic repair: width of the enc_bad_data_lane vector used to determine number of 1s in clear code\r\n\tsmr
#define EDI_RX_DYN_RPR_ERR_TALLYING1_PG                    0x8009d8000000003f, 48, 16 // crc/ecc dynamic repair lane error frequency settings -- description
#define EDI_RX_EO_FINAL_L2U_DLY_SEQ_GCRMSG                 0x8009e0000000003f, 48,  2 // gcr message: rx final load to unload delay gcr messages\r\n\t00:(fl2uprevchg) indicate prior group calculated max load to unload change.\r\n\t01:(fl2uallchg) indicate all groups have calculated max load to unload change.\r\n\t10:(unused) unused.\r\n\t11:(fl2unomsg) no message.\r\n\tmbs
#define EDI_RX_EO_FINAL_L2U_DLY_MAXCHG_GCRMSG              0x8009e0000000003f, 50,  6 // gcr message: max change in miniumum load to unload delay.\r\n\tmbs
#define EDI_RX_EO_FINAL_L2U_DLY_CHG                        0x8009e0000000003f, 58,  6 // gcr message: local change in miniumum load to unload delay.\r\n\tmbs
#define EDI_RX_EO_FINAL_L2U_GCRMSG_PG                      0x8009e0000000003f, 48, 16 // rx final load to unload gcr messages -- description
#define EDI_RX_GCR_MSG_DEBUG_DEST_IDS_PG                   0x8009e8000000003f, 48, 16 // rx sw initiated gcr message destination ids -- description
#define EDI_RX_GCR_MSG_DEBUG_SRC_IDS_PG                    0x8009f0000000003f, 48, 16 // rx sw initiated gcr message source ids -- description
#define EDI_RX_GCR_MSG_DEBUG_DEST_ADDR_PG                  0x8009f8000000003f, 48, 16 // rx sw initiated gcr message destination addr -- description
#define EDI_RX_GCR_MSG_DEBUG_WRITE_DATA_PG                 0x800a00000000003f, 48, 16 // rx sw initiated gcr message write data -- description
#define EDI_RX_SERVO_RECAL_IP                              0x800a08000000003f, 48,  1 // rx servo lane calibration in progress\r\n\tsmr
#define EDI_RX_DYN_RECAL_MAIN_STATE                        0x800a08000000003f, 50,  6 // dynamic recalibration main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_main_state\r\n\tsmr
#define EDI_RX_DYN_RECAL_HNDSHK_STATE                      0x800a08000000003f, 57,  7 // dynamic recalibration handshake state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_hndshk_state\r\n\tsmr
#define EDI_RX_DYN_RECAL_PG                                0x800a08000000003f, 48, 16 // rx dynamic recalibration status -- description
#define EDI_RX_WT_CLK_LANE_INVERTED                        0x800a10000000003f, 49,  1 // clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted\r\n\trjr
#define EDI_RX_WT_CLK_LANE_BAD_CODE                        0x800a10000000003f, 50,  3 // clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused\r\n\trjr
#define EDI_RX_WT_CLK_LANE_STATUS_ALIAS                    0x800a10000000003f, 49,  4 // alias for rx_wt_clk_lane_inverted concatenated with rx_wt_clk_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at '0'--not swapped/inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--swapped or inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--swapped or inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--swapped or inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--swapped or inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)\r\n\trjr
#define EDI_RX_WT_CLK_STATUS_PG                            0x800a10000000003f, 48, 16 // rx clock wiretest status -- description
#define EDI_RX_DYN_RECAL_OVERALL_TIMEOUT_SEL               0x800a18000000003f, 48,  3 // dynamic recalibration overall timeout selects\r\n\t000:(tap0) 27.30us - really small value for sim\r\n\t001:(tap1) 436.73us - smallest value for normal operation\r\n\t010:(tap2) 873.46us\r\n\t011:(tap3) 1.75ms\r\n\t100:(tap4) 3.49ms - recal should be around 2ms\r\n\t101:(tap5) 13.97ms\r\n\t110:(tap6) 55.90ms - largest value for normal operation\r\n\t111:(tap7) infinite- for debug purposes\r\n\tsmr
#define EDI_RX_DYN_RECAL_SUSPEND                           0x800a18000000003f, 51,  1 // suspend dynamic recalibration; otherwise starts automatically after link training\r\n\tsmr
#define EDI_RX_DYN_RECAL_CONFIG_PG                         0x800a18000000003f, 48, 16 // rx dynamic recalibration configuration -- description
#define EDI_RX_WT_CHECK_COUNT                              0x800a20000000003f, 48,  5 // selects number of extra times the wiretest pattern is checked for a good lane \r\n\trjr
#define EDI_RX_WT_CHECK_LANES                              0x800a20000000003f, 53,  2 // selects number of lanes that are checked during all-ones or all-zeroes check during wiretest:\r\n\t00:check all good lanes \r\n\t01:check majority of good lanes\r\n\t10:check half of good lanes\r\n\t11:check good lanes-2\r\n\trjr
#define EDI_RX_WT_CONFIG_PG                                0x800a20000000003f, 48, 16 // rx wiretest miscelleneous configuration -- description
#define EDI_RX_DYN_RECAL_IP_GCRMSG                         0x800a28000000003f, 48,  1 // gcr message: rx dynamic recalibration in progress\r\n\tsmr
#define EDI_RX_DYN_RECAL_FAILED_GCRMSG                     0x800a28000000003f, 49,  1 // gcr message: rx dynamic recalibration failed\r\n\tsmr
#define EDI_RX_DYN_RECAL_RIPPLE_GCRMSG                     0x800a28000000003f, 50,  1 // gcr message: rx dynamic recalibration: reached end of bus...ripple back down to the beginning\r\n\tsmr
#define EDI_RX_DYN_RECAL_TIMEOUT_GCRMSG                    0x800a28000000003f, 51,  1 // gcr message: rx dynamic recalibration: recal handshake timed out\r\n\tsmr
#define EDI_RX_DYN_RECAL_GCRMSG_PG                         0x800a28000000003f, 48, 16 // rx dynamic recalibration gcr messages -- description
#define EDI_RX_WT_CU_PLL_PGOOD                             0x800a30000000003f, 48,  1 // rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_RESET                             0x800a30000000003f, 49,  1 // rx pll/dll enable request\r\n\t1:(enable) clears pll pgood and begins reset timer. see rx_wt_cu_pll_pgooddly. \r\n\t0:(not_enable) do nothing\r\n\tjfg
#define EDI_RX_WT_CU_PLL_PGOODDLY                          0x800a30000000003f, 50,  3 // rx pll/dll pgood delay selects length of reset period after rx_wt_cu_pll_reset is set. \r\n\t000:(16ui) minimum 16ui for sim bypass \r\n\t001:(50ns) nominal 50ns reset per pll spec \r\n\t010:(100ns) double nominal 50ns reset per pll spec \r\n\t011:(960ui) typical simulation delay exceeding tx pll 40-refclk locking period \r\n\t100:(unused_100) reserved \r\n\t101:(unused_101) reserved \r\n\t110:(max) 1024 ui  \r\n\t111:(disable) disable rx_wt_cu_pll_reset\r\n\tjfg
#define EDI_RX_WT_CU_PLL_LOCK                              0x800a30000000003f, 53,  1 // rx pll/dll locked\r\n\tjfg
#define EDI_RX_WT_PLL_REFCLKSEL                            0x800a30000000003f, 54,  1 // select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock\r\n\tdmb
#define EDI_RX_PLL_REFCLKSEL_SCOM_EN                       0x800a30000000003f, 55,  1 // selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock\r\n\tdmb
#define EDI_RX_WIRETEST_PLL_CNTL_PG                        0x800a30000000003f, 48, 16 // rx pll or dll reset and calibration controls -- description
#define EDI_RX_EO_ENABLE_LATCH_OFFSET_CAL                  0x800a38000000003f, 48,  1 // rx eye optimization latch offset adjustment enable\r\n\trjr
#define EDI_RX_EO_ENABLE_CTLE_CAL                          0x800a38000000003f, 49,  1 // rx eye optimization ctle/peakin enable\r\n\trjr
#define EDI_RX_EO_ENABLE_VGA_CAL                           0x800a38000000003f, 50,  1 // rx eye optimization vga gainand offset adjust enable\r\n\trjr
#define EDI_RX_EO_ENABLE_DFE_H1_CAL                        0x800a38000000003f, 52,  1 // rx eye optimization dfe h1  adjust enable\r\n\trjr
#define EDI_RX_EO_ENABLE_H1AP_TWEAK                        0x800a38000000003f, 53,  1 // rx eye optimization h1/an pr adjust enable\r\n\trjr
#define EDI_RX_EO_ENABLE_DDC                               0x800a38000000003f, 54,  1 // rx eye optimization dynamic data centering enable\r\n\trjr
#define EDI_RX_EO_ENABLE_FINAL_L2U_ADJ                     0x800a38000000003f, 56,  1 // rx eye optimization final rx fifo load-to-unload delay adjustment enable\r\n\trjr
#define EDI_RX_EO_ENABLE_BER_TEST                          0x800a38000000003f, 57,  1 // rx eye optimization bit error rate test enable\r\n\trjr
#define EDI_RX_EO_ENABLE_RESULT_CHECK                      0x800a38000000003f, 58,  1 // rx eye optimization final results check enable\r\n\trjr
#define EDI_RX_EO_ENABLE_CTLE_EDGE_TRACK_ONLY              0x800a38000000003f, 59,  1 // rx eye optimization ctle/peakin enable with edge tracking only\r\n\trjr
#define EDI_RX_EO_STEP_CNTL_PG                             0x800a38000000003f, 48, 16 // rx eye optimization step control -- description
#define EDI_RX_EO_LATCH_OFFSET_DONE                        0x800a40000000003f, 48,  1 // rx eye optimization latch offset adjustment done\r\n\trjr
#define EDI_RX_EO_CTLE_DONE                                0x800a40000000003f, 49,  1 // rx eye optimization ctle/peaking done\r\n\trjr
#define EDI_RX_EO_VGA_DONE                                 0x800a40000000003f, 50,  1 // rx eye optimization vga gain/offset adjust done\r\n\trjr
#define EDI_RX_EO_H1AP_TWEAK_DONE                          0x800a40000000003f, 53,  1 // rx eye optimization h1/an pr adjust done\r\n\trjr
#define EDI_RX_EO_DDC_DONE                                 0x800a40000000003f, 54,  1 // rx eye optimization dynamic data centering done\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_ADJ_DONE                       0x800a40000000003f, 56,  1 // rx eye optimization final rx fifo load-to-unload adjust done\r\n\trjr
#define EDI_RX_EO_DFE_FLAG                                 0x800a40000000003f, 57,  1 // rx eye optimization dfe mode flag\r\n\trjr
#define EDI_RX_EO_BER_TEST_DONE                            0x800a40000000003f, 58,  1 // rx eye optimization bit error rate test done\r\n\trjr
#define EDI_RX_EO_RESULT_CHECK_DONE                        0x800a40000000003f, 59,  1 // rx eye optimization eye width/heighter check done\r\n\trjr
#define EDI_RX_EO_STEP_STAT_PG                             0x800a40000000003f, 48, 16 // rx eye optimization step status -- description
#define EDI_RX_EO_LATCH_OFFSET_FAILED                      0x800a48000000003f, 48,  1 // rx eye optimization latch offset adjustment  failed\r\n\trjr
#define EDI_RX_EO_CTLE_FAILED                              0x800a48000000003f, 49,  1 // rx eye optimization ctle/peaking  failed\r\n\trjr
#define EDI_RX_EO_VGA_FAILED                               0x800a48000000003f, 50,  1 // rx eye optimization vga gain/offset adjust  failed\r\n\trjr
#define EDI_RX_EO_DFE_H1_FAILED                            0x800a48000000003f, 52,  1 // rx eye optimization dfe h1  adjust failed\r\n\trjr
#define EDI_RX_EO_H1AP_TWEAK_FAILED                        0x800a48000000003f, 53,  1 // rx eye optimization h1/an pr adjust failed\r\n\trjr
#define EDI_RX_EO_DDC_FAILED                               0x800a48000000003f, 54,  1 // rx eye optimization dynamic data centering failed\r\n\trjr
#define EDI_RX_EO_FINAL_L2U_ADJ_FAILED                     0x800a48000000003f, 56,  1 // rx eye optimization final rx fifo load-to-unload adjust  failed\r\n\trjr
#define EDI_RX_EO_RESULT_CHECK_FAILED                      0x800a48000000003f, 57,  1 // rx eye optimization final result checking failed\r\n\trjr
#define EDI_RX_EO_STEP_FAIL_PG                             0x800a48000000003f, 48, 16 // rx eye optimization step fail flags -- description
#define EDI_RX_AP_EVEN_WORK                                0x800a50000000003f, 48,  8 // rx ap even working register\r\n\trjr
#define EDI_RX_AP_ODD_WORK                                 0x800a50000000003f, 56,  8 // rx ap odd  working register\r\n\trjr
#define EDI_RX_AP_PG                                       0x800a50000000003f, 48, 16 // rx eye optimization ap   working registers -- description
#define EDI_RX_AN_EVEN_WORK                                0x800a58000000003f, 48,  8 // rx an even working register\r\n\trjr
#define EDI_RX_AN_ODD_WORK                                 0x800a58000000003f, 56,  8 // rx an odd  working register\r\n\trjr
#define EDI_RX_AN_PG                                       0x800a58000000003f, 48, 16 // rx eye optimization an   working registers -- description
#define EDI_RX_AMIN_EVEN_WORK                              0x800a60000000003f, 48,  8 // rx amin even working register\r\n\trjr
#define EDI_RX_AMIN_ODD_WORK                               0x800a60000000003f, 56,  8 // rx amin odd  working register\r\n\trjr
#define EDI_RX_AMIN_PG                                     0x800a60000000003f, 48, 16 // rx eye optimization amin working registers -- description
#define EDI_RX_AMAX_HIGH                                   0x800a68000000003f, 48,  8 // rx amax high limit default 125\r\n\trjr
#define EDI_RX_AMAX_LOW                                    0x800a68000000003f, 56,  8 // rx amax low limit  default 75\r\n\trjr
#define EDI_RX_AMAX_PG                                     0x800a68000000003f, 48, 16 // rx eye optimization amax limit   registers -- description
#define EDI_RX_AMP_PEAK_WORK                               0x800a70000000003f, 48,  4 // rx amp peak working register\r\n\trjr
#define EDI_RX_AMP_GAIN_WORK                               0x800a70000000003f, 52,  4 // rx amp gain working register\r\n\trjr
#define EDI_RX_AMP_OFFSET_WORK                             0x800a70000000003f, 58,  6 // rx amp offset working register\r\n\trjr
#define EDI_RX_AMP_VAL_PG                                  0x800a70000000003f, 48, 16 // rx eye optimization amp  working registers -- description
#define EDI_RX_AMP_OFFSET_MAX                              0x800a78000000003f, 48,  6 // rx amp maximum allowable offset\r\n\trjr
#define EDI_RX_AMP_OFFSET_MIN                              0x800a78000000003f, 54,  6 // rx amp minimum allowable offset\r\n\trjr
#define EDI_RX_AMP_OFFSET_PG                               0x800a78000000003f, 48, 16 // rx eye optimization amp  offset limts      -- description
#define EDI_RX_EO_CONVERGED_COUNT                          0x800a80000000003f, 48,  4 // rx eye optimization convergence counter current value\r\n\trjr
#define EDI_RX_EO_CONVERGED_END_COUNT                      0x800a80000000003f, 52,  4 // rx eye optimization covergence counter end value\r\n\trjr
#define EDI_RX_EO_CONVERGENCE_PG                           0x800a80000000003f, 48, 16 // rx eye optimization convergence control regs -- description
#define EDI_RX_SLS_RCVY_DISABLE                            0x800a88000000003f, 48,  1 // disable sls recovery\r\n\tsmr
#define EDI_RX_SLS_RCVY_STATE                              0x800a88000000003f, 51,  5 // sls recovery state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_rcvy_state\r\n\tsmr
#define EDI_RX_SLS_RCVY_PG                                 0x800a88000000003f, 48, 16 // rx sls handshake recovery register -- description
#define EDI_RX_SLS_RCVY_REQ_GCRMSG                         0x800a90000000003f, 48,  1 // gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair req has been issued.\r\n\tsmr
#define EDI_RX_SLS_RCVY_IP_GCRMSG                          0x800a90000000003f, 49,  1 // gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair is in progress.\r\n\tsmr
#define EDI_RX_SLS_RCVY_DONE_GCRMSG                        0x800a90000000003f, 50,  1 // gcr message: sls rcvy; the current sls lane has failed to receive a valid sls command when it otherwise should be so a rx lane repair has been issued and is now done.\r\n\tsmr
#define EDI_RX_SLS_RCVY_GCRMSG_PG                          0x800a90000000003f, 48, 16 // rx sls handshake recovery gcr messages -- description
#define EDI_RX_TX_BAD_LANE_CNTR_GCRMSG                     0x800a98000000003f, 48,  2 // gcr message: rx side tx bad lane counter\r\n\tsmr
#define EDI_RX_TX_LANE_INFO_GCRMSG_PG                      0x800a98000000003f, 48, 16 // rx: tx lane info -- description
#define EDI_RX_DIS_SYND_TALLYING_GCRMSG                    0x800aa0000000003f, 48,  1 // gcr message: internal logic has disabled the syndrome tallying feature for reasons such as the current rx sls lane is in the process of moving.\r\n\tsmr
#define EDI_RX_ERR_TALLYING_GCRMSG_PG                      0x800aa0000000003f, 48, 16 // crc/ecc syndrome tallying gcr message reg -- description
#define EDI_RX_TRC_MODE                                    0x800aa8000000003f, 48,  4 // rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd\r\n\tsmr
#define EDI_RX_TRC_GRP                                     0x800aa8000000003f, 54,  6 // rx clock group to be traced\r\n\t111111 will trace whichever clk group currently contains the rx sls lane\r\n\tsmr
#define EDI_RX_TRACE_PG                                    0x800aa8000000003f, 48, 16 // rx trace mode reg -- description
#define EDI_RX_RC_ENABLE_LATCH_OFFSET_CAL                  0x800ab8000000003f, 48,  1 // rx recalibration    latch offset adjustment enable\r\n\trjr
#define EDI_RX_RC_ENABLE_CTLE_CAL                          0x800ab8000000003f, 49,  1 // rx recalibration    ctle/peaking enable\r\n\trjr
#define EDI_RX_RC_ENABLE_VGA_CAL                           0x800ab8000000003f, 50,  1 // rx recalibration    vga gainand offset adjust enable\r\n\trjr
#define EDI_RX_RC_ENABLE_DFE_H1_CAL                        0x800ab8000000003f, 52,  1 // rx recalibration    dfe h1  adjust enable\r\n\trjr
#define EDI_RX_RC_ENABLE_H1AP_TWEAK                        0x800ab8000000003f, 53,  1 // rx recalibration    h1/an pr adjust enable\r\n\trjr
#define EDI_RX_RC_ENABLE_DDC                               0x800ab8000000003f, 54,  1 // rx recalibration    dynamic data centering enable\r\n\trjr
#define EDI_RX_RC_ENABLE_BER_TEST                          0x800ab8000000003f, 56,  1 // rx recalibration    bit error rate test enable\r\n\trjr
#define EDI_RX_RC_ENABLE_RESULT_CHECK                      0x800ab8000000003f, 57,  1 // rx recalibration    final results check enable\r\n\trjr
#define EDI_RX_RC_ENABLE_CTLE_EDGE_TRACK_ONLY              0x800ab8000000003f, 59,  1 // rx recalibration    ctle/peaking enable with edge tracking only\r\n\trjr
#define EDI_RX_RC_STEP_CNTL_PG                             0x800ab8000000003f, 48, 16 // rx recalibraton     step control -- description
#define EDI_RX_EYE_OPT_STATE                               0x800ac0000000003f, 48,  8 // common edi/ei4 eye optimizaton state machine \r\n\t00000000: idle \r\n\t00000001: init latch offset cal done \r\n\t00000010: vref/dcd cal done \r\n\t00000011: vga done \r\n\t00000100: unused \r\n\t00000101: unused \r\n\t00000110: unused \r\n\t00000111: ctle done \r\n\t00001000: h1ap adjust done \r\n\t00001001: ddc done \r\n\t00001010: measure eye width done \r\n\t00001011: final l2u adjust done \r\n\t00001100: unused \r\n\t00001101: results check done \r\n\t00001110: eye opt all done \r\n\t00001111: unused \r\n\t00010000: start latch offset cal \r\n\t00010001: start latch offset cal 0 \r\n\t00010010: read latch offset cal 0 status \r\n\t00010011: check latch offset cal 0 status \r\n\t00010100: start latch offset cal 1 \r\n\t00010101: read latch offset cal 1 status \r\n\t00010110: check latch offset cal 1 status \r\n\t00010111: bist latch offset cal done \r\n\t00011000: unused \r\n\t00011001: unused \r\n\t00011010: unused \r\n\t00011011: unused \r\n\t00011100: unused \r\n\t00011101: unused \r\n\t00011110: unused \r\n\t00011111: unused \r\n\t00100000: start vref cal \r\n\t00100001: start vref servo \r\n\t00100010: read vref servo status \r\n\t00100011: check vref servo status \r\n\t00100100: start dcd adjust servo \r\n\t00100101: read dcd adjust servo status \r\n\t00100110: check dcd adjust servo status \r\n\t00100111: unused \r\n\t00101000: unused \r\n\t00101001: unused \r\n\t00101010: unused \r\n\t00101011: unused \r\n\t00101100: unused \r\n\t00101101: unused \r\n\t00101110: unused \r\n\t00101111: unused \r\n\t00110000: vga start-clear done flags \r\n\t00110001: vga measure ape/apo \r\n\t00110010: vga read ape/apo status \r\n\t00110011: vga check ape/apo status \r\n\t00110100: vga measure ane/ano \r\n\t00110101: vga read ane/ano status \r\n\t00110110: vga check ane/ano status \r\n\t00110111: vga measure ape dfe \r\n\t00111000: vga read ape dfe status \r\n\t00111001: vga check ape dfe status \r\n\t00111010: vga measure ane dfe \r\n\t00111011: vga read ane dfe status \r\n\t00111100: vga check ane dfe status \r\n\t00111101: vga measure apo dfe \r\n\t00111110: vga read apo dfe status \r\n\t00111111: vga check apo dfe status \r\n\t01000000: vga measure ano dfe \r\n\t01000001: vga read ano dfe status \r\n\t01000010: vga check ano dfe status \r\n\t01000011: vga measure amin no dfe \r\n\t01000100: vga read amin no dfe status \r\n\t01000101: vga check amin no dfe status \r\n\t01000110: vga measure amin dfe \r\n\t01000111: vga read amin dfe status \r\n\t01001000: vga check amin dfestatus \r\n\t01001001: vga clear lane address \r\n\t01001010: vga check lane valid \r\n\t01001011: vga read rx amp cntl \r\n\t01001100: vga read rx amp values \r\n\t01001101: vga read ape and apo \r\n\t01001110: vga read ane and ano \r\n\t01001111: vga read amine and amino \r\n\t01010000: vga check offset \r\n\t01010001: vga check amax \r\n\t01010010: vga write vga done control \r\n\t01010011: vga write all done status \r\n\t01010100: vga write vga adjust value \r\n\t01010101: vga check done \r\n\t01010110: unused \r\n\t01010111: unused \r\n\t01011000: unused \r\n\t01011001: unused \r\n\t01011010: unused \r\n\t01011011: unused \r\n\t01011100: unused \r\n\t01011101: unused \r\n\t01011110: unused \r\n\t01011111: unused \r\n\t01100000: unused \r\n\t01100001: unused \r\n\t01100010: unused \r\n\t01100011: unused \r\n\t01100100: unused \r\n\t01100101: unused \r\n\t01100110: unused \r\n\t01100111: unused \r\n\t01101000: unused \r\n\t01101001: unused \r\n\t01101010: unused \r\n\t01101011: unused \r\n\t01101100: unused \r\n\t01101101: unused \r\n\t01101110: unused \r\n\t01101111: unused \r\n\t01110000: ctle start \r\n\t01110001: ctle bump left \r\n\t01110010: ctle read bump left status \r\n\t01110011: ctle check bump left status \r\n\t01110100: ctle start servo \r\n\t01110101: ctle read servo status \r\n\t01110110: ctle check servo status \r\n\t01110111: ctle bump right \r\n\t01111000: ctle read bump right status \r\n\t01111001: ctle check bump rightstatus \r\n\t01111010: unused \r\n\t01111011: unused \r\n\t01111100: unused \r\n\t01111101: unused \r\n\t01111110: unused \r\n\t01111111: unused \r\n\t10000000: h1ap tweak start \r\n\t10000001: h1ap tweak run servo \r\n\t10000010: h1ap tweak read servo status \r\n\t10000011: h1ap tweak check servo status \r\n\t10000100: unused \r\n\t10000101: unused \r\n\t10000110: unused \r\n\t10000111: unused \r\n\t10001000: unused \r\n\t10001001: unused \r\n\t10001010: unused \r\n\t10001011: unused \r\n\t10001100: unused \r\n\t10001101: unused \r\n\t10001110: unused \r\n\t10001111: unused \r\n\t10010000: ddc start \r\n\t10010001: ddc run servo \r\n\t10010010: ddc read servo status \r\n\t10010011: ddc check servo status \r\n\t10010100: ddc check clear counter \r\n\t10010101: ddc check fly state \r\n\t10010110: ddc check lane \r\n\t10010111: ddc read  lane status \r\n\t10011000: ddc check lane status \r\n\t10011001: ddc write bad ddc \r\n\t10011010: ddc check if all done \r\n\t10011011: unused \r\n\t10011100: unused \r\n\t10011101: unused \r\n\t10011110: unused \r\n\t10011111: unused \r\n\t10100000: eye measure start \r\n\t10100001: eye measure start edge track \r\n\t10100010: eye measure read edge track status \r\n\t10100011: eye measure check edge track status \r\n\t10100100: eye measure fly state \r\n\t10100101: eye measure start eye track \r\n\t10100110: eye measure read eye track status \r\n\t10100111: eye measure check eye track status \r\n\t10101000: unused \r\n\t10101001: unused \r\n\t10101010: unused \r\n\t10101011: unused \r\n\t10101100: unused \r\n\t10101101: unused \r\n\t10101110: unused \r\n\t10101111: unused \r\n\t10110000: final l2u set sls checkers \r\n\t10110001: final l2u run err check timer \r\n\t10110010: final l2u dec l2u delay \r\n\t10110011: final l2u inc prbs \r\n\t10110100: final l2u inc l2u delay \r\n\t10110101: final l2u dec prbs \r\n\t10110110: unused \r\n\t10110111: final l2u run err check timer \r\n\t10111000: final l2u clear l2u counter \r\n\t10111001: final l2u check final delay \r\n\t10111010: final l2u inc l2u final delay \r\n\t10111011: final l2u dec prbs \r\n\t10111100: unused \r\n\t10111101: unused \r\n\t10111110: final l2u done \r\n\t10111111: final l2u fail \r\n\t11000000: final l2u wait for prev group status \r\n\t11000001: final l2u send status to next group \r\n\t11000010: final l2u wait for all group status \r\n\t11000011: unused \r\n\t11000100: unused \r\n\t11000101: unused \r\n\t11000110: unused \r\n\t11000111: unused \r\n\t11001000: unused \r\n\t11001001: unused \r\n\t11001010: unused \r\n\t11001011: unused \r\n\t11001100: unused \r\n\t11001101: unused \r\n\t11001110: final l2u max change send fail \r\n\t11001111: final l2u max change recv fail \r\n\t11010000: result check clear and start \r\n\t11010001: result check fly state \r\n\t11010010: result check for valid lane \r\n\t11010011: result check read eye width \r\n\t11010100: result check write bad width \r\n\t11010101: result check read amin values \r\n\t11010110: result check check height \r\n\t11010111: result check write bad height \r\n\t11011000: result check start ber servo \r\n\t11011001: result check read ber servo stat \r\n\t11011010: result check checkber status \r\n\t11011011: result check read ber count \r\n\t11011100: result checkcheck ber \r\n\t11011101: result check write bad ber \r\n\t11011110: result checkcheck if done \r\n\t11011111: result check fail \r\n\t11100000: completion start \r\n\t11100001: completion enable driving all \r\n\t11100010: completion drive eye opt done \r\n\t11100011: completion set up sls rcvr \r\n\t11100100: completion watch for sls nop \r\n\t11100101: completion drive sls nop ds \r\n\t11100110: completion wait for sls nop \r\n\t11100111: completion undrive lanes \r\n\t11101000: completion drive bogus sls nop \r\n\t11101001: completion wait non-sls data \r\n\t11101010: completion enable receive sls \r\n\t11101011: completion eye opt done \r\n\t11101100: unused \r\n\t11101101: unused \r\n\t11101110: unused \r\n\t11101111: unused \r\n\t11110000: latch offset fail \r\n\t11110001: vref fail \r\n\t11110010: vga measure ape/o fail \r\n\t11110011: vga measure ane/o fail \r\n\t11110100: vga measure ape dfe fail \r\n\t11110101: vga measure ane/o fail \r\n\t11110110: vga measure ane/o fail \r\n\t11110111: vga measure ano dfe fail \r\n\t11111000: vga measure amine fail \r\n\t11111001: vga measure amine fail \r\n\t11111010: ctle adjust fail \r\n\t11111011: h1ap tweak fail \r\n\t11111100: ddc fail \r\n\t11111101: measure eye fail \r\n\t11111110: dcd duty cycle fail \r\n\t11111111: unused \r\n\trjr
#define EDI_RX_RECAL_STATE                                 0x800ac0000000003f, 56,  8 // common edi/ei4 recalibration state machine\r\n\trjr
#define EDI_RX_EO_RECAL_PG                                 0x800ac0000000003f, 48, 16 // rx eye opt and recal status -- description
#define EDI_RX_SERVO_BER_COUNT_WORK                        0x800ac8000000003f, 48, 12 // rx servo-based bit error rate count working register\r\n\trjr
#define EDI_RX_SERVO_BER_COUNT_PG                          0x800ac8000000003f, 48, 16 // rx recal bit error rate count working register -- description
#define EDI_RX_FUNC_MODE_STATE                             0x800ad0000000003f, 48,  4 // functional mode state machine(rjr):\r\n\trjr
#define EDI_RX_FUNC_STATE_PG                               0x800ad0000000003f, 48, 16 // rx func mode status -- description
#define EDI_RX_DYN_RPR_BAD_LANE_VALID_DEBUG                0x800ad8000000003f, 48,  1 // for testfloor/debug purposes, the specified encoded bad data lane will be tallied as having one cycle of a valid crc/ecc error (this is a write-only pulse register)\r\n\tsmr
#define EDI_RX_DYN_RPR_ENC_BAD_DATA_LANE_DEBUG             0x800ad8000000003f, 49,  7 // for testfloor/debug purposes, specify the encoded bad data lane to report to the dynamic repair tally logic\r\n\tsmr
#define EDI_RX_BAD_BUS_ERR_CNTR                            0x800ad8000000003f, 57,  7 // bad bus error counter (aka counter2)\r\n\tsmr
#define EDI_RX_DYN_RPR_DEBUG_PG                            0x800ad8000000003f, 48, 16 // dynamic repair testfloor/debug register -- description
#define EDI_RX_DYN_RPR_BAD_BUS_MAX                         0x800ae0000000003f, 48,  7 // crc/ecc dynamic repair: max number of times crc or ecc errors can be found on the bus (not included in the bad lane cntr1 tally) before setting a fir error\r\n\tsmr
#define EDI_RX_DYN_RPR_ERR_CNTR2_DURATION                  0x800ae0000000003f, 55,  4 // crc/ecc dynamic repair: duration the bad bus cntr2 error counter can run before being divided by 2 (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite\r\n\tsmr
#define EDI_RX_DYN_RPR_CLR_ERR_CNTR2                       0x800ae0000000003f, 59,  1 // crc/ecc dynamic repair: firmware-based clear of bus error counter2 register\r\n\tsmr
#define EDI_RX_DYN_RPR_DISABLE2                            0x800ae0000000003f, 60,  1 // crc/ecc dynamic repair: when set, disables the repair from the dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2), however leaves the counters running\r\n\tsmr
#define EDI_RX_DYN_RPR_ERR_TALLYING2_PG                    0x800ae0000000003f, 48, 16 // crc/ecc dynamic repair bus error frequency settings -- description
#define EDI_RX_MIN_EYE_WIDTH                               0x800ae8000000003f, 50,  6 // minimum acceptable eye width used during init or recal results checking--edi or ei4\r\n\tdmb
#define EDI_RX_MIN_EYE_HEIGHT                              0x800ae8000000003f, 56,  8 // minimum acceptable eye height used during init or recal results checking--edi only\r\n\tdmb
#define EDI_RX_RESULT_CHK_PG                               0x800ae8000000003f, 48, 16 // eye widhth/height results check limits -- description
#define EDI_RX_MAX_BER_CHECK_COUNT                         0x800af0000000003f, 56,  8 // maximum acceptable number of bit errors allowable after recal. it is used in both edi and ei-4 for initialization, but not used during ei4 recal. it is used during recal checks on edi.\r\n\trjr
#define EDI_RX_BER_CHK_PG                                  0x800af0000000003f, 48, 16 // bit error rate check max rate k limits -- description
#define EDI_RX_SLV_SHDW_DONE_FIN_GCRMSG                    0x800af8000000003f, 48,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_done\r\n\tsmr
#define EDI_RX_SLV_SHDW_NOP_FIN_GCRMSG                     0x800af8000000003f, 49,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_SHDW_RPR_DONE_FIN_GCRMSG                0x800af8000000003f, 50,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for shdw_rpr_done\r\n\tsmr
#define EDI_RX_SLV_SHDW_RPR_NOP_FIN_GCRMSG                 0x800af8000000003f, 51,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_DONE_FIN_GCRMSG                  0x800af8000000003f, 52,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_done\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_NOP_FIN_GCRMSG                   0x800af8000000003f, 53,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_RPR_DONE_FIN_GCRMSG              0x800af8000000003f, 54,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for unshdw_rpr_done\r\n\tsmr
#define EDI_RX_SLV_UNSHDW_RPR_NOP_FIN_GCRMSG               0x800af8000000003f, 55,  1 // gcr message: slave rx sls lane repaired; need to finish slave shadow handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_DONE_NOP_FIN_GCRMSG               0x800af8000000003f, 56,  1 // gcr message: slave recal done; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_FAIL_NOP_FIN_GCRMSG               0x800af8000000003f, 57,  1 // gcr message: slave recal fail; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_FRESULTS_FIN_GCRMSG               0x800af8000000003f, 59,  1 // gcr message: slave recal fail results; need to finish slave recal handshake starting with waiting for results\r\n\tsmr
#define EDI_RX_SLV_RECAL_ABORT_ACK_FIN_GCRMSG              0x800af8000000003f, 60,  1 // gcr message: slave recal abort; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_ABORT_MNOP_FIN_GCRMSG             0x800af8000000003f, 61,  1 // gcr message: slave recal abort; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLV_RECAL_ABORT_SNOP_FIN_GCRMSG             0x800af8000000003f, 62,  1 // gcr message: slave recal abort; need to finish slave recal handshake starting with waiting for nop\r\n\tsmr
#define EDI_RX_SLS_RCVY_FIN_GCRMSG_PG                      0x800af8000000003f, 48, 16 // rx sls handshake recovery finish gcr messages -- description
#define EDI_RX_REDUCED_SCRAMBLE_MODE                       0x800b08000000003f, 48,  2 // sets reduced density of scramble pattern. this must be set consistent with tx_reduced_scramble_mode.  \r\n\t00:(disable_0) disable reduced density \r\n\t01:(disable_1) disable reduced density \r\n\t10:(enable_div2) enable div2 reduced density \r\n\t11:(enable_div4) enable div4 reduced density (div4 is edi only) \r\n\tmbs
#define EDI_RX_PRBS_SCRAMBLE_MODE                          0x800b08000000003f, 50,  2 // selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EDI_RX_ACT_CHECK_TIMEOUT_SEL                       0x800b08000000003f, 52,  3 // sets activity check timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(128ui) 128 ui \r\n\t010:(256ui) 256 ui \r\n\t011:(512ui) 512 ui \r\n\t100:(1024ui) 1024 ui \r\n\t101:(2048ui) 2048 ui \r\n\t110:(4096ui) 4096 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EDI_RX_BLOCK_LOCK_TIMEOUT_SEL                      0x800b08000000003f, 55,  3 // sets block lock timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(1024ui) 1024 ui \r\n\t010:(2048ui) 2048 ui \r\n\t011:(4096ui) 4096 ui \r\n\t100:(8192ui) 8192 ui \r\n\t101:(16384ui) 16384 ui \r\n\t110:(32768ui) 32768 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EDI_RX_BIT_LOCK_TIMEOUT_SEL                        0x800b08000000003f, 58,  3 // sets bit lock/edge detect timeout value. \r\n\t000:(16ui) 16ui \r\n\t001:(512ui) 512 ui \r\n\t010:(1024ui) 1024 ui \r\n\t011:(2048ui) 2048 ui \r\n\t100:(4096ui) 4096 ui \r\n\t101:(8192ui) 8192 ui \r\n\t110:(16384ui) 16384 ui \r\n\t111:(infinite) infinite\r\n\tmbs
#define EDI_RX_ENABLE_DFE_V1                               0x800b08000000003f, 61,  1 // rx cal sm chicken switch. when this bit is set we will revert dfe back to the v1 implememntation\r\n\tcpg
#define EDI_RX_AMIN_ALL                                    0x800b08000000003f, 62,  1 // rx cal sm, a chicken switch of sorts. when this bit is a one we not only use the sp1 latch in generating amin but also sp0. this is helpfull in very short channels which tend to be over peaked.\r\n\tcpg
#define EDI_RX_MODE1_PP                                    0x800b08000000003f, 48, 16 // rx mode per-pack shadow reg -- description
#define EDI_RX_PRBS_CHECK_SYNC                             0x800b10000000003f, 49,  1 // enables checking for the 12 ui scramble sync pattern. \r\n\t0:(disabled) disable checking (forces prbs_synced_b to 1)\r\n\t1:(enabled) enable checking (prbs_synced_b can go to 0)\r\n\trjr
#define EDI_RX_ENABLE_REDUCED_SCRAMBLE                     0x800b10000000003f, 50,  1 // enables reduced density of scramble pattern. \r\n\t0:(disabled) disable reduced density \r\n\t1:(enabled) enable reduced density per the rx_reduced_scramble_mode setting\r\n\trjr
#define EDI_RX_PRBS_INC                                    0x800b10000000003f, 51,  1 // shift the prbs pattern forward in time by one extra local cycle (4ui for edi, 2ui for ei4).\r\n\tmbs
#define EDI_RX_PRBS_DEC                                    0x800b10000000003f, 52,  1 // shift the prbs pattern back in time by holding it one local cycle (4ui for edi, 2ui for ei4).\r\n\tmbs
#define EDI_RX_CNTL_FAST_PP                                0x800b10000000003f, 48, 16 // rx cntl per-pack shadow reg -- description
#define EDI_RX_DYN_RECAL_INTERVAL_TIMEOUT_SEL              0x800b40000000003f, 49,  3 // rx dynamic recalibration interval timeout selects\r\n\t000:(tap0) 1024ui or 106.5ns\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite\r\n\tsmr
#define EDI_RX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL            0x800b40000000003f, 52,  2 // rx dynamic recalibration status reporting timeout selects\r\n\tthis value must be longer than the sls_cntr_tap_sel!\r\n\t00:(tap0) 512ui or 53.2ns\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns\r\n\tsmr
#define EDI_RX_DYN_RECAL_TIMEOUTS_PP                       0x800b40000000003f, 48, 16 // rx dynamic recalibration timeout selects -- description
#define EDI_RX_BER_EN                                      0x800b50000000003f, 48,  1 // per-pack (pp) diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.\r\n\tpmt
#define EDI_RX_BER_COUNT_CLR                               0x800b50000000003f, 49,  1 // pp diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.\r\n\tpmt
#define EDI_RX_BER_TIMER_CLR                               0x800b50000000003f, 50,  1 // pp diag ber timer clear pulse. when written to a 1 the per-pack timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.\r\n\tpmt
#define EDI_RX_BER_CNTL_PP                                 0x800b50000000003f, 48, 16 // rx ber control reg -- description
#define EDI_RX_BER_TIMER_FREEZE_EN                         0x800b58000000003f, 48,  1 // per-pack (pp) diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the per-pack timer is frozen when any lane error count saturates in that pack.\r\n\tpmt
#define EDI_RX_BER_COUNT_FREEZE_EN                         0x800b58000000003f, 49,  1 // pp diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.\r\n\tpmt
#define EDI_RX_BER_COUNT_SEL                               0x800b58000000003f, 51,  3 // pp diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. \r\n\t000:(1) 1\r\n\t001:(2) 2\r\n\t010:(4) 4\r\n\t011:(8) 8\r\n\t100:(16) 16\r\n\t101:(32) 32\r\n\t110:(64) 64\r\n\t111:(128) 128\r\n\tpmt
#define EDI_RX_BER_TIMER_SEL                               0x800b58000000003f, 54,  3 // pp diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. \r\n\t000:(2tothe39th) 2^39\r\n\t001:(2tothe35th) 2^35\r\n\t010:(2tothe31st) 2^31\r\n\t011:(2tothe27th) 2^27\r\n\t100:(2tothe25th) 2^25\r\n\t101:(2tothe21th) 2^21\r\n\t110:(2tothe17th) 2^17\r\n\t111:(2tothe13th) 2^13\r\n\tpmt
#define EDI_RX_BER_CLR_COUNT_ON_READ_EN                    0x800b58000000003f, 57,  1 // pp diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.\r\n\tpmt
#define EDI_RX_BER_CLR_TIMER_ON_READ_EN                    0x800b58000000003f, 58,  1 // pp diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes per-pack timer when it is read from any lane in the pack.\r\n\tpmt
#define EDI_RX_BER_MODE_PP                                 0x800b58000000003f, 48, 16 // rx ber mode reg -- description
#define EDI_RX_SERVO_TIMEOUT_SEL_A                         0x800b60000000003f, 48,  4 // rx servo operation timeout a used to time latch offset calibration.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_B                         0x800b60000000003f, 52,  4 // rx servo operation timeout b used to time ctle/peaking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_C                         0x800b60000000003f, 56,  4 // rx servo operation timeout c used to time vref adjustment.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_D                         0x800b60000000003f, 60,  4 // rx servo operation timeout d used to time block locking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TO1_PP                                0x800b60000000003f, 48, 16 // rx servo timeout select regs 1 -- description
#define EDI_RX_SERVO_TIMEOUT_SEL_E                         0x800b68000000003f, 48,  4 // rx servo operation timeout e used to time edge tracking .\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_F                         0x800b68000000003f, 52,  4 // rx servo operation timeout f used to time eye tracking.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_G                         0x800b68000000003f, 56,  4 // rx servo operation timeout g used to time ber testing.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_H                         0x800b68000000003f, 60,  4 // rx servo operation timeout h used to time edi dynamic data centering and ei-4 clock duty cycle distortion adjust.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TO2_PP                                0x800b68000000003f, 48, 16 // rx servo timeout select regs 2 -- description
#define EDI_RX_SERVO_TIMEOUT_SEL_I                         0x800b70000000003f, 48,  4 // rx servo operation timeout i used to time ap and an measurements without dfe.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_J                         0x800b70000000003f, 52,  4 // rx servo operation timeout j used to time ap and an measurements with dfe.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_K                         0x800b70000000003f, 56,  4 // rx servo operation timeout k used to time amin measurements with or without dfe.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TIMEOUT_SEL_L                         0x800b70000000003f, 60,  4 // rx servo operation timeout l used to time phase rotator bump commands.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_SERVO_TO3_PP                                0x800b70000000003f, 48, 16 // rx servo timeout select regs 3 -- description
#define EDI_RX_PEAK_CFG                                    0x800b78000000003f, 48,  2 // this register controls the servo inc/dec settings for adjusting peaking. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the peak setting. this is also the number of decrements it takes to get an underflow. once we have the proper setting ideally the incs and decs will cancel out and we will stay at that value. unfortunately it is not a perfect world and we will either have a little too much or little too little causing the servo to eventually over or underflow. however we also control the length of time we run the servo which may mean we timeout before we need to make an adjustment. remainder values in the servo are not kept so each time we startour peaking adjusment the counter starts at zero.\r\n\thss recommendation is to set this filter to 256. this will be the lab initial setting and we have the capability to increase or decrease this by one step, either doubling or halving the value. \r\n\tcpg
#define EDI_RX_AMIN_CFG                                    0x800b78000000003f, 50,  3 // this register controls the servo inc setting for measuring amin. amin is the level of the inner eye. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the amin register value. unlike other servo operations, amin has a fixed filter setting for the decrement. any time we get a servo decrement we will decrement by 4096 causing an immediate underflow. so for amin all we can adjust is the speed we increment, not decrement. that is just the way amin works.\r\n\thss recommendation is to set this filter to 1024. this will be the lab initial setting and we have the capability to decrease this by one step, halving the value.\r\n\tcpg
#define EDI_RX_ANAP_CFG                                    0x800b78000000003f, 53,  2 // this register controls the servo inc/dec settings for measuring an and ap. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the value of an or ap.. this is also the number of decrements it takes to get an underflow. once we have the proper setting ideally the incs and decs will cancel out and we will stay at that value. unfortunately it is not a perfect world and we will either have a little too much or little too little causing the servo to eventually over or underflow. however we also control the length of time we run the servo which may mean we timeout before we need to make an adjustment. remainder values in the servo are not kept so each time we startour peaking adjusment the counter starts at zero.\r\n\thss recommendation is to set this filter to 32. this will be the lab initial setting and we have the capability to increase or decrease this by one step, either doubling or halving the value. \r\n\tcpg
#define EDI_RX_H1_CFG                                      0x800b78000000003f, 55,  2 // this register controls the servo inc/dec settings for adjusting the h1 coefficients. the details of this adjustment is found later. the filter value is how many increments of the servo it takes to get it to overflow and actually cause an increase in the value of the h1 cooeficient. this is also the number of decrements it takes to get an underflow. once we have the proper setting ideally the incs and decs will cancel out and we will stay at that value. unfortunately it is not a perfect world and we will either have a little too much or little too little causing the servo to eventually over or underflow. however we also control the length of time we run the servo which may mean we timeout before we need to make an adjustment. remainder values in the servo are not kept so each time we startour peaking adjusment the counter starts at zero.\r\n\tthe h1 filter setting is done a little different than the others in that it is time into the adjustment of anap. in this we increasing or decreasing this register will have an effect in the filtering that is independent of anap while adjusting the anap_cfg will change the h1 filter setting in unison.\r\n\thss recommendation is to set this filter to 256. this makes it 8 times the anap value. this is necessary as the h1 coefficients must be adjusted slower than anap to keep it from chasing the ap values this will be the lab initial setting and we have the capability to increase or decrease this by one step, either doubling or halving the value. \r\n\tcpg
#define EDI_RX_H1AP_CFG                                    0x800b78000000003f, 57,  3 // this register controls the maximum allowed ration of h1 and ap. this is not a servo setting but rather the setting of a ration between h1 and the value of ap. if we are under the limit set by this register we are allowed to encrease the h1 servo value. this could then eventually result in an increase in the h1 cooeficient. if this ratio is greater than the limits set by this register, the servo will be decremented and this will continue to happen as long as the ratio remains too high. this will then eventually cause a decrease in the h1 cooeficient. as long as we are below the limit it is business as usual and when we are above the limit we will react slowly to get us back within the limits.\r\n\thss recommendation is to set this ratio to 0.5 with the ability to go to 0.6 and 0.7. implementation was done to allow adjustment in steps of 1/16 for minimum logic taking us from 0.5 up to 0.6875. register settings 100 through 111 were added in case we really wanted to restrict the ratio because of some unknown thing. encode 100 should be 0.25 but a typo in dd1 resulted in the ratio of 0.125.\r\n\tcpg
#define EDI_RX_DFE_CA_CFG                                  0x800b78000000003f, 60,  2 // rx dfe clock adjust settings\r\n\tthis 2 bit register contains an encoded value for of k as follows\r\n\t00 - 10\r\n\t01 - 12\r\n\t10 - 14\r\n\t11 - 16\r\n\t hss has determined that the recommended k value be 14 but our ams simulations look more like 10. lab testing will be required to determine the proper value of k.\r\n\tcpg
#define EDI_RX_SPMUX_CFG                                   0x800b78000000003f, 62,  2 // this register is used to take control of the spec mux and select which of the two speculation latches you wish to use. this would only be used for charactorization when we want complete control. bit 0 is set to a 0b1 to override spec mux control and bit 1 is used to select the 1 or 0 latch\r\n\tcpg
#define EDI_RX_DFE_CONFIG_PP                               0x800b78000000003f, 48, 16 // rx dfe configuration register -- description
#define EDI_RX_INIT_TMR_CFG                                0x800b80000000003f, 48,  3 // this register controls the time we will take to do the initial block lock. this is the number of cycles we wait for the phase rotator to align on the edge before we check for block lock. during the block lock phase we have a 2 up 2 down square wave coming in to lock on. this should be a fairly easy target. keep in mind that since we are using nothing but data to represent both data and edge we could need to move as much as 32 phase rotator steps to find the edge. while way off the edge we should only be limited by the filter setting. the phase rotator filter will normally be set to 16 meaning it will take at least 512 cycles to slew to the edge. as we approach the edge it may take longer per step. in retrospect we maybe should have spread this across a wider range. something we may wish to do for dd2.\r\n\tto be on the safe side i suggest the max value for bringup. it only takes 2.346 us at the longest setting. \r\n\tcpg
#define EDI_RX_BER_CFG                                     0x800b80000000003f, 51,  3 // this register controls the bit error rate threshold used for ddc. during ddc we quickly move out of the eye and then slowly move back till we are back into the eye. this is the bit error rate threshold used to determine we are back in the eye. to be on the safe side we have to figure on 4 x this time as the time needed to run ddc. hss recommends that we run ddc looking for a 1e-6 bit error rate as our criteria. this could take as much as 477us in a 9.6gbit link. this is way too long so we must pick a shorter time.\r\n\tthe following table shows the bit error rate for the settings. recommended setting is 0b100 and we can evaluate in the lab. please note that the setting 0b110 is slightly off. it should have been 333328 but is off 6.8% due to a typo. this is no issue.\r\n\treg setting   error free bits\r\n\t000     336\r\n\t001  1000\r\n\t010 3328\r\n\t011 10000\r\n\t100     33328\r\n\t101     100000\r\n\t110    355856\r\n\t111    1000000\r\n\tcpg
#define EDI_RX_FIFO_DLY_CFG                                0x800b80000000003f, 54,  2 // this register controls how long we wait after every change to the phase rotator before we begin using the data again. this is to allow the data time to flow throught the receive fifo so we are looking at new data. this is the number of c8 cycles we wait giving us the ability to wait 48 to 72 ui. if we miss it a bit, no problem, as filtering will still hide most of the edge effects when shifting the rotator. therefore i suggest we set it to the fastest setting until we prove we need more time.\r\n\tcpg
#define EDI_RX_DDC_CFG                                     0x800b80000000003f, 56,  2 // this register controls how long we wait looking for errors as we march further into the edge. this is using the same timer as the fifo delay so you really should subtract that out if you want to see how long we are really waiting. complete details in the ddc section but during this phase we are marching further to the edge if we do not find an error in a rather short period of time.\r\n\tcpg
#define EDI_RX_DAC_BO_CFG                                  0x800b80000000003f, 58,  3 // this register controls the time of the dac black out time. when the dac code is changed it takes some time for the dac to reach its new value. even though we usually only make single step adjustments to the dac we have to allow time for the dac output to settle. this timer blocks all usage of data until the dac has settled. current estimate for dac settling time is aobut 75 ns. this timer is not exact. we are using higher order bits of a free running timer and we do not know where the counter is at the time the data switches. as an example, if the timer was about to overflow when the dac code changed it may only take a cycle or two for us to get another switch. the timer is counting the number of times the low order three bits of a free running counter are 0b111 so the timer period is 0 to 64 ui per count\r\n\trecommending a starting value of 100 and we will characterize from there.\r\n\tcpg
#define EDI_RX_PROT_CFG                                    0x800b80000000003f, 61,  2 // this register controls the filtering we do when searching for the edge of the data window and also when tracking the edge during ctle. due to a typo dd1 does not have the intended values. although very close in the range we use this should still be changed to be consistant with all other designs. the normal recommended value is a shift 16 selected by a register setting of 0b10. it is very unlikely that any amount of hardware testing would be able to tell the difference between a shift 15 and a shift 16.\r\n\tthe normal useful settings are 8, 16, and 32. 4 should only be used in sumulation as it is not as stable as the others. we do block the use of the data for a period of time after moving the phase rotator to ensure we are only using the correct data for our next move. this adds stability but there is really no good reason to ever use 4. \r\n\tcpg
#define EDI_RX_DFE_TIMERS_PP                               0x800b80000000003f, 48, 16 // rx dfe timers configuration register -- description
#define EDI_RX_RESET_CFG_HLD                               0x800b88000000003f, 48, 16 // reserved: this is not implemented. original description follows: configurable reset hold list\r\n\tlist of functions and values to preserve state or hold value over a configurable reset (via rx_reset_cfg_ena). any 1 excludes that value/function from a reset action.\r\n\tlist tbd.\r\n\tjfg
#define EDI_RX_RESET_CFG_PP                                0x800b88000000003f, 48, 16 // rx configurable reset control register (crcr) -- list of features or value which are selectively preserved thru a configurable reset.
#define EDI_RX_RECAL_TIMEOUT_SEL_A                         0x800b90000000003f, 48,  4 // rx recal servo operation timeout a used to time latch offset calibration during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_B                         0x800b90000000003f, 52,  4 // rx recal servo operation timeout b used to time ctle measurements during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TO1_PP                                0x800b90000000003f, 48, 16 // rx recal servo timeout select regs 1 -- description
#define EDI_RX_RECAL_TIMEOUT_SEL_E                         0x800b98000000003f, 48,  4 // rx recal servo operation timeout e used to time edge tracking during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_G                         0x800b98000000003f, 56,  4 // rx recal servo operation timeout g used to time ber testing during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_H                         0x800b98000000003f, 60,  4 // rx recal servo operation timeout h used to time dynamic data centering during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TO2_PP                                0x800b98000000003f, 48, 16 // rx recal servo timeout select regs 2 -- description
#define EDI_RX_RECAL_TIMEOUT_SEL_I                         0x800ba0000000003f, 48,  4 // rx recal servo operation timeout i used to time ap and an measurements without dfe during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_J                         0x800ba0000000003f, 52,  4 // rx recal servo operation timeout j used to time ap and an measurements with dfe during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_K                         0x800ba0000000003f, 56,  4 // rx recal servo operation timeout k used to time amin measurements during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TIMEOUT_SEL_L                         0x800ba0000000003f, 60,  4 // rx recal servo operation timeout l used to time bump commands during recal.\r\n\t0000:(16ui) \r\n\t0001:(512ui) 512 ui \r\n\t0010:(1kui) 1k ui \r\n\t0011:(2kui) 2k ui \r\n\t0100:(4kui) 4096 ui \r\n\t0101:(8kui) 8k ui \r\n\t0110:(16kui) 16k ui \r\n\t0111:(32kui) 32k ui \r\n\t1000:(64kui) 64k ui \r\n\t1001:(128kui) 128k ui \r\n\t1010:(256kui) 256k ui \r\n\t1011:(512kui) 512k ui \r\n\t1100:(1mui) 1m ui \r\n\t1101:(2mui) 2m ui \r\n\t1110:(4mui) 4m ui\r\n\t11110:(infinite) infinite\r\n\trjr
#define EDI_RX_RECAL_TO3_PP                                0x800ba0000000003f, 48, 16 // rx recal servo timeout select regs 3 -- description
#define EDI_RX_PP_TRC_EN                                   0x800bb0000000003f, 48,  1 // per pack rx trace mode enable \r\n\t0:(disabled) per pack trace mode is disabled \r\n\t1:(enabled) per pack trace mode is enabled \r\n\tsmr
#define EDI_RX_PP_TRC_MODE                                 0x800bb0000000003f, 49,  3 // per pack rx trace mode\r\n\t000:(tap0) tbd\r\n\t001:(tap1) tbd\r\n\t010:(tap2) tbd\r\n\t011:(tap3) tbd\r\n\t100:(tap4) tbd\r\n\t101:(tap5) tbd\r\n\t110:(tap6) tbd\r\n\t111:(tap7) tbd\r\n\tsmr
#define EDI_RX_BIST_JITTER_PULSE_SEL                       0x800bb0000000003f, 52,  2 // rx bist jitter select\r\n\tthis setting induces artificial jitter into the data of the prbs generator during bist to ensure the deadzone between the two eyes of the bist pattern is at least two pr steps wide.\r\n\t00:(steps4) four jitter steps\r\n\t01: (steps2) two jitter steps\r\n\t10: (steps8) eight jitter steps\r\n\t11: (steps0) no jitter\r\n\tjgr
#define EDI_RX_BIST_MIN_EYE_WIDTH                          0x800bb0000000003f, 54,  6 // rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass phybist.\r\n\tjgr
#define EDI_RX_WT_PATTERN_LENGTH                           0x800bb0000000003f, 62,  2 // rx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024\r\n\trjr
#define EDI_RX_MODE2_PP                                    0x800bb0000000003f, 48, 16 // rx mode2 per-pack shadow reg -- description
#define EDI_RX_BIST_EN                                     0x800bb8000000003f, 48,  1 // this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.\r\n\tjgr
#define EDI_RX_BIST_GCRMSG_PP                              0x800bb8000000003f, 48, 16 // rx bist cntl reg -- description
#define EDI_RX_SCOPE_CONTROL                               0x800bc0000000003f, 48,  2 // bit 0 odd/even (1 is odd) bit 1 speculation latch 0=0 1=1.\r\n\tcpg
#define EDI_RX_BUMP_SCOPE                                  0x800bc0000000003f, 50,  1 // when written to a 1 it will bump the scope sync counter one notch.\r\n\tcpg
#define EDI_RX_H1_CLKADJ_CFG                               0x800bc0000000003f, 51,  3 // this is the config bits for the h1 ap clock adjust logic\r\n\tcpg
#define EDI_RX_SCOPE_CNTL_PP                               0x800bc0000000003f, 48, 16 // rx scope cntl reg -- description
#define EDI_RX_BIST_STEP_INTERVAL_EN                       0x800bc8000000003f, 48,  1 // \r\n\tjgr
#define EDI_RX_BIST_STEP_INTERVAL                          0x800bc8000000003f, 49,  2 // \r\n\tjgr
#define EDI_RX_BIST_PHASEROT_OFFSET_EN                     0x800bc8000000003f, 51,  1 // \r\n\tjgr
#define EDI_RX_BIST_PHASEROT_OFFSET                        0x800bc8000000003f, 52,  2 // \r\n\tjgr
#define EDI_RX_BIST_BUFFER_SEL                             0x800bc8000000003f, 54,  3 // \r\n\tjgr
#define EDI_RX_MODE3_PP                                    0x800bc8000000003f, 48, 16 // rx mode3 per-pack shadow reg -- description
#define EDI_RX_PB_CLR_PAR_ERRS                             0x800f80000000003f, 62,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.\r\n\tpmt
#define EDI_RX_PB_FIR_RESET                                0x800f80000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.\r\n\tpmt
#define EDI_RX_FIR_RESET_PB                                0x800f80000000003f, 48, 16 // per-bus busctl fir error reset reg -- description
#define EDI_RX_PB_FIR_ERRS_FULL_REG                        0x800f88000000003f, 48, 10 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS                                 0x800f88000000003f, 48, 10 // a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_PB_REGS                          0x800f88000000003f, 48,  1 // iotk alias: parity error has occurred in the per-bus busctl registers.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCR_BUFF0                        0x800f88000000003f, 49,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr buffer.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCR_BUFF1                        0x800f88000000003f, 50,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCR_BUFF2                        0x800f88000000003f, 51,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_LD_SM0                      0x800f88000000003f, 52,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_LD_SM1                      0x800f88000000003f, 53,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_LD_SM2                      0x800f88000000003f, 54,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_UNLD_SM0                    0x800f88000000003f, 55,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_UNLD_SM1                    0x800f88000000003f, 56,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_GCRS_UNLD_SM2                    0x800f88000000003f, 57,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EDI_RX_FIR_PB                                      0x800f88000000003f, 48, 16 // per-bus fir error source-isolation reg -- description
#define EDI_RX_PB_FIR_ERRS_MASK_FULL_REG                   0x800f90000000003f, 48, 10 // iotk alias: fir mask for rx_fir_pb errors.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_MASK                            0x800f90000000003f, 48, 10 // fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_PB_REGS                     0x800f90000000003f, 48,  1 // iotk alias: fir mask for the per-bus busctl registers.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCR_BUFF0                   0x800f90000000003f, 49,  1 // iotk alias: fir mask for the per-bus busctl gcr buffer.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCR_BUFF1                   0x800f90000000003f, 50,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCR_BUFF2                   0x800f90000000003f, 51,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                 0x800f90000000003f, 52,  1 // iotk alias: fir mask for the per-bus busctl gcr load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                 0x800f90000000003f, 53,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                 0x800f90000000003f, 54,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0               0x800f90000000003f, 55,  1 // iotk alias: fir mask for the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1               0x800f90000000003f, 56,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2               0x800f90000000003f, 57,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EDI_RX_FIR_MASK_PB                                 0x800f90000000003f, 48, 16 // per-bus fir error source-isolation mask reg -- description
#define EDI_RX_PB_FIR_ERRS_INJ_FULL_REG                    0x800f98000000003f, 48, 10 // iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\tpmt
#define EDI_RX_PB_FIR_ERRS_INJ                             0x800f98000000003f, 48, 10 // rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_PB_REGS                      0x800f98000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCR_BUFF0                    0x800f98000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr buffer.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCR_BUFF1                    0x800f98000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCR_BUFF2                    0x800f98000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                  0x800f98000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                  0x800f98000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                  0x800f98000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0                0x800f98000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1                0x800f98000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.\r\n\tpmt
#define EDI_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2                0x800f98000000003f, 57,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.\r\n\tpmt
#define EDI_RX_FIR_ERROR_INJECT_PB                         0x800f98000000003f, 48, 16 // per-bus fir error injection reg -- description
#define EDI_RX_FIR_MSG                                     0x800ff8000000003f, 48,  8 // dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.\r\n\tpmt
#define EDI_RX_FIR_MSG_PB                                  0x800ff8000000003f, 48, 16 // per-bus fir register write alias -- for testing master gcr fir packet decode logic
#define EDI_GCR_TEST_MODE                                  0x0000000000000020,  0,  1 // gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.\r\n\tpmt
#define EDI_ENABLE_GCR_OFL_BUFF                            0x0000000000000020,  1,  1 // enables 2nd gcr overflow buffer, one is used by default.\r\n\tdmb
#define EDI_IORESET_HARD_BUS0                              0x0000000000000020,  2,  6 // io hard reset per-bus and gcr reset\r\n\tenables a hard reset on bus 0 thru 5 (this is application dependent and bus 1-5 may not be present). a gcr reset affects all busses since any of them may be corrupted.\r\n\t000000:(functional) functional (default)\r\n\t100000:(reset0) reset bus 0\r\n\t010000:(reset1) reset bus 1\r\n\t001000:(reset2) reset bus 2\r\n\t000100:(reset3) reset bus 3\r\n\t000010:(reset4) reset bus 4\r\n\t000001:(reset5) reset bus 5\r\n\t111111:(resetgcr) reset all local busses and perform a gcr reset.\r\n\tjfg
#define EDI_GCR_HANG_DET_SEL                               0x0000000000000020,  8,  3 // gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 31 cycles\r\n\t010: 63 cycles\r\n\t011: 127 cycles\r\n\t100: 255 cycles\r\n\t101: 511 cycles\r\n\t110: 1023 cycles\r\n\t111: 2047 cycles.\r\n\tdmb
#define EDI_GCR_BUFFER_ENABLED                             0x0000000000000020, 11,  1 // flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.\r\n\tdmb
#define EDI_GCR_HANG_ERROR_MASK                            0x0000000000000020, 12,  1 // mask for gcr hang error when 2nd buffer is enabled.\r\n\tdmb
#define EDI_GCR_HANG_ERROR_INJ                             0x0000000000000020, 13,  1 // inject for gcr hang error.\r\n\tdmb
#define EDI_SCOM_MODE_PB_SPARES                            0x0000000000000020, 14,  8 // scom mode reg spares.\r\n\tdmb
#define EDI_SCOM_MODE_PB                                   0x0000000000000020,  0, 64 // normal scom mode reg -- description
#define EDI_SCOM_FIR_PB                                    0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define EDI_SCOM_FIR_CLR_PB                                0x0000000000000001,  0, 64 // fir scom clear reg -- description
#define EDI_SCOM_FIR_SET_PB                                0x0000000000000002,  0, 64 // fir scom set reg -- description
#define EDI_SCOM_FIR_MASK_PB                               0x0000000000000003,  0, 64 // fir scom mask rw reg -- description
#define EDI_SCOM_FIR_MASK_CLR_PB                           0x0000000000000004,  0, 64 // fir scom mask clear reg -- description
#define EDI_SCOM_FIR_MASK_SET_PB                           0x0000000000000005,  0, 64 // fir scom mask seet reg -- description
#define EDI_SCOM_FIR_ACTION0_PB                            0x0000000000000006,  0, 64 // fir scom action0 reg -- description
#define EDI_SCOM_FIR_ACTION1_PB                            0x0000000000000007,  0, 64 // fir scom action1 reg -- description
#define EDI_SCOM_FIR_WOF_PB                                0x0000000000000008,  0, 64 // fir scom wof reg -- description
*/

/*
 * Leaving these as comments until we close out EDI+ RAS discussions
 *
#define EDIP_TX_MODE1_PL_FULL_REG                          0x800404000000003f, 48, 16 // iotk alias: for entire tx_mode1_pl register
#define EDIP_TX_LANE_PDWN                                  0x800404000000003f, 48,  1 // used to drive inhibit (tristate) and fully power down a lane independent of the logical lane disable.  \r\n\t0:(enabled) lane powered up \r\n\t1:(disabled) lane drive inhibited (tristated) and powered down (default).
#define EDIP_TX_LANE_INVERT                                0x800404000000003f, 49,  1 // used to invert the polarity of a lane.\r\n\t0:(normal) normal lane polarity (default)\r\n\t1:(inverted) lane inverted.
#define EDIP_TX_LANE_QUIESCE                               0x800404000000003f, 50,  2 // used to force the output of a lane to a particular logical value.\r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state lane output.
#define EDIP_TX_LANE_SCRAMBLE_DISABLE                      0x800404000000003f, 54,  1 // used to disable the tx scrambler on a specific lane or all lanes by using a per-lane/per-group global write.
#define EDIP_TX_ERR_INJ_A_ENABLE                           0x800404000000003f, 55,  1 // control to enable the random bit error injection pattern a for this lane.(default)\r\n\t0:(disabled) pattern a error injection is masked for this lane. \r\n\t1:(enabled) pattern a error injection is enabled for this lane.
#define EDIP_TX_ERR_INJ_B_ENABLE                           0x800404000000003f, 56,  1 // control to enable the random bit error injection pattern b for this lane.(default)\r\n\t0:(disabled) pattern b error injection is masked for this lane. \r\n\t1:(enabled) pattern b error injection is enabled for this lane.
#define EDIP_TX_PSAVE_MODE_DISABLE                         0x800404000000003f, 57,  1 // disable psave mode for this physical lane
#define EDIP_TX_ERR_INJ_A_SLS_ENABLE                       0x800404000000003f, 58,  1 // control to enable the random bit error injection pattern a for this lane only when it is an active sls lane (tx_cal_lane_sel = 1).(default)\r\n\t0:(disabled) pattern a error injection is not enabled for this lane when tx_cal_lane_sel is 1. \r\n\t1:(enabled) pattern a error injection is enabled for this lane when tx_cal_lane_sel is 1.
#define EDIP_TX_PL_SPARE_MODE_0                            0x800404000000003f, 60,  1 // per-lane spare mode latch.
#define EDIP_TX_PL_SPARE_MODE_1                            0x800404000000003f, 61,  1 // per-lane spare mode latch.
#define EDIP_TX_PL_SPARE_MODE_2                            0x800404000000003f, 62,  1 // per-lane spare mode latch.
#define EDIP_TX_PL_SPARE_MODE_3                            0x800404000000003f, 63,  1 // per-lane spare mode latch.
#define EDIP_TX_MODE1_PL                                   0x800404000000003f, 48, 16 // register -- description
#define EDIP_TX_FIFO_L2U_DLY                               0x80040c000000003f, 48,  3 // this field is used to read or set the tx fifo load to unload delay according to the following.\r\n\t000:(0_to_2_ui) 0 to 2 ui \r\n\t001:(4_to_6_ui) 4 to 6 ui (default) \r\n\t010:(8_to_10_ui) 8 to 10 ui\r\n\t011:(12_to_14_ui) 12 to 14 ui \r\n\t100:(16_to_18_ui) 16 to 18 ui \r\n\t101:(20_to_22_ui) 20 to 22 ui\r\n\t110:(24_to_26_ui) 24 to 26 ui\r\n\t111:(28_to_30_ui) 28 to 30 ui\r\n\trjr
#define EDIP_TX_NEXT_CAL_LANE_SEL                          0x80040c000000003f, 53,  1 // when set, negates the action of tx_pdwn_lite in a similar way to tx_cal_lane_sel solely to enable the driver ahead of sls shadowing.
#define EDIP_TX_PRBS_SCRAMBLE_MODE                         0x80040c000000003f, 54,  2 // selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by tx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15 \r\n\tmbs
#define EDIP_TX_UNLOAD_CLK_DISABLE                         0x80040c000000003f, 56,  1 // set to 0 to enable sync of tx custom serializer via tx_fifo_init register.  set to 1 to clock off sync logic and save power.
#define EDIP_TX_UNLOAD_SEL                                 0x80040c000000003f, 58,  3 // controls the preset value of the tx slice unload counter, which effectively gives subcycle control of the offset of tx unload clock from grid clock.
#define EDIP_TX_PDWN_LITE                                  0x80040c000000003f, 61,  1 // when set, gates tx data path (post fifo) to 0s on unused spare lanes when not being recalibrated.
#define EDIP_TX_CAL_LANE_SEL                               0x80040c000000003f, 62,  1 // sls commands & recalibration\r\n\t0: sls commands & recalibration data gated and functional data ungated \r\n\t1: send sls command or recalibration data and functional data gated
#define EDIP_TX_FIFO_HALF_WIDTH_MODE                       0x80040c000000003f, 63,  1 // selects half width mode for tx fifo for slower frequency connections. \r\n\t0: normal width \r\n\t1: half width (bits starting from 0 used, and the second half is unused)
#define EDIP_TX_MODE2_PL                                   0x80040c000000003f, 48, 16 // register -- description
#define EDIP_TX_ERR_INJECT                                 0x800414000000003f, 48,  5 // inject one beat of error on this lane.  set code 1yyyy where yyyy is the beat in the deserialized cycle to inject on.
#define EDIP_TX_FIFO_INIT                                  0x800414000000003f, 53,  1 // used to initialize the tx fifo and put it into a known reset state. this will cause the load to unload delay of the fifo to be set to the value in the tx_fifo_l2u_dly field of the tx_mode_pp register.
#define EDIP_TX_SET_PDWN_LITE                              0x800414000000003f, 54,  1 // set tx_pdwn_lite register
#define EDIP_TX_CLR_PDWN_LITE                              0x800414000000003f, 55,  1 // clear tx_pdwn_lite register
#define EDIP_TX_SET_CAL_LANE_SEL                           0x800414000000003f, 56,  1 // set tx_cal_lane_sel register
#define EDIP_TX_CLR_CAL_LANE_SEL                           0x800414000000003f, 57,  1 // clear tx_cal_lane_sel register
#define EDIP_TX_SET_NEXT_CAL_LANE_SEL                      0x800414000000003f, 58,  1 // set tx_next_cal_lane_sel register
#define EDIP_TX_CLR_NEXT_CAL_LANE_SEL                      0x800414000000003f, 59,  1 // clear tx_next_cal_lane_sel register
#define EDIP_TX_SET_UNLOAD_CLK_DISABLE                     0x800414000000003f, 60,  1 // set tx_unload_clk_disable register
#define EDIP_TX_CLR_UNLOAD_CLK_DISABLE                     0x800414000000003f, 61,  1 // clear tx_unload_clk_disable register
#define EDIP_TX_CNTL1G_PL                                  0x800414000000003f, 48, 16 // register -- description
#define EDIP_TX_LANE_BIST_ERR                              0x80041c000000003f, 48,  1 // indicates txbist has found an error.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has been found during txbist.
#define EDIP_TX_LANE_BIST_ACTVITY_DET                      0x80041c000000003f, 49,  1 // indicates that activity was detected in prbs checker. \r\n\t0:(no_error) no activity \r\n\t1:(error) activity has been found during txbist.
#define EDIP_TX_SEG_TEST_STATUS                            0x80041c000000003f, 50,  2 // driver segment test result. bit0 for pad p, bit1 for pad n
#define EDIP_TX_TDR_CAPT_VAL                               0x80041c000000003f, 63,  1 // value captured by tdr function, 1-bit shared over a pack, so this value should be the same for each lane.
#define EDIP_TX_STAT1_PL                                   0x80041c000000003f, 48, 16 // register -- description
#define EDIP_TX_PL_FIR_ERRS_FULL_REG                       0x800424000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define EDIP_TX_PL_FIR_ERRS                                0x800424000000003f, 48,  1 // a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.\r\n\t0:no fir error.\r\n\t1:par_err_tx_databit_regs
#define EDIP_TX_PL_FIR_ERR_PL_REGS                         0x800424000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane tx register logic.
#define EDIP_TX_FIR_PL                                     0x800424000000003f, 48, 16 // register -- description
#define EDIP_TX_PL_FIR_ERRS_MASK_FULL_REG                  0x80042c000000003f, 48, 16 // iotk alias: fir mask for all per-lane register or per-lane state machine parity errors.
#define EDIP_TX_PL_FIR_ERRS_MASK                           0x80042c000000003f, 48,  1 // fir mask for all per-lane register or per-lane state machine parity errors.\r\n\t0:fir error unmasked.\r\n\t1:par_err_mask_tx_databit_regs
#define EDIP_TX_PL_FIR_ERR_MASK_PL_REGS                    0x80042c000000003f, 48,  1 // iotk alias: fir mask for the per-lane tx register checker.
#define EDIP_TX_FIR_MASK_PL                                0x80042c000000003f, 48, 16 // register -- description
#define EDIP_TX_PL_FIR_ERR_INJ_FULL_REG                    0x800434000000003f, 48, 16 // iotk alias: for tx_fir_error_inject_pl register
#define EDIP_TX_PL_FIR_ERR_INJ                             0x800434000000003f, 48,  1 // tx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker
#define EDIP_TX_PL_FIR_ERR_INJ_PL_REGS                     0x800434000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane tx register logic.
#define EDIP_TX_FIR_ERROR_INJECT_PL                        0x800434000000003f, 48, 16 // register -- description
#define EDIP_TX_PRBS_SEED_VALUE_0_15                       0x80043c000000003f, 48, 16 // tx per-lane prbs seed value\r\n\tused to specify loading value of the prbs scramble pattern when the sync pattern is detected.  this must be set consistent with rx_prbs_seed_value.  see data scrambling workbook section for details.  \r\n\twhen connected to legacy centaur parts, the seed must load such that it matches the sequence of those legacy parts.  the patterns listed here match that, including variants required to seed in full or half-width mode.\r\n\t0000000000000000:(pattern_tx_ab_half_a_0_15) tx prbs tap points a and b, and tx half-width tap point a\r\n\t0000000000011110:(pattern_tx_c_0_15) tx prbs tap point c\r\n\t0000000000011111:(pattern_tx_d_0_15) tx prbs tap point d\r\n\t0000000000001111:(pattern_tx_e_half_b_0_15) tx prbs tap point e, and tx half-width tap point b\r\n\t0000000001111100:(pattern_tx_f_0_15) tx prbs tap point f\r\n\t0000110001100011:(pattern_tx_g_0_15) tx prbs tap point g\r\n\t0000111001110011:(pattern_tx_h_0_15) tx prbs tap point h\r\n\t0000000111101111:(pattern_tx_half_c_0_15) tx half width prbs tap point c\r\n\t0000000111110001:(pattern_tx_half_d_0_15) tx half width prbs tap point d\r\n\t0000000011111011:(pattern_tx_half_e_0_15) tx half width prbs tap point e\r\n\t0000011111000010:(pattern_tx_half_f_0_15) tx half width prbs tap point f\r\n\t1100011000110001:(pattern_tx_half_g_0_15) tx half width prbs tap point g\r\n\t1110011100111001:(pattern_tx_half_h_0_15) tx half width prbs tap point h
#define EDIP_TX_BIT_MODE1_E_PL                             0x80043c000000003f, 48, 16 // register -- description
#define EDIP_TX_PRBS_SEED_VALUE_16_22                      0x800444000000003f, 48,  7 // tx per-lane prbs seed value lsbs\r\n\tsee rx_prbs_seed_value_0_15 for details.\r\n\t0000001:(pattern_tx_a_16_22) tx prbs tap point a\r\n\t1111100:(pattern_tx_b_16_22) tx prbs tap point b\r\n\t1111011:(pattern_tx_c_16_22) tx prbs tap point c\r\n\t0001100:(pattern_tx_dg_16_22) tx prbs tap points d and g\r\n\t1011110:(pattern_tx_e_16_22) tx prbs tap point e\r\n\t0010000:(pattern_tx_f_half_a_16_22) tx prbs tap point f, and tx half-width tap point a\r\n\t1001110:(pattern_tx_h_half_b_16_22) tx prbs tap point h, and tx half-width tap point b\r\n\t0111101:(pattern_tx_half_c_16_22) tx half width prbs tap point c\r\n\t1000110:(pattern_tx_half_dg_16_22) tx half width prbs tap points d and g\r\n\t1101111:(pattern_tx_half_e_16_22) tx half width prbs tap point e\r\n\t0001000:(pattern_tx_half_f_16_22) tx half width prbs tap point f\r\n\t1100111:(pattern_tx_half_h_16_22) tx half width prbs tap point h
#define EDIP_TX_BIT_MODE2_E_PL                             0x800444000000003f, 48, 16 // register -- description
#define EDIP_TX_TDR_ENABLE                                 0x800454000000003f, 48,  1 // enable tdr on the given tx lane\r\n\tgap
#define EDIP_TX_CNTL3_EO_PL                                0x800454000000003f, 48, 16 // register -- description
#define EDIP_TX_PG_SPARE_MODE_0                            0x800c04000000003f, 48,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_1                            0x800c04000000003f, 49,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_2                            0x800c04000000003f, 50,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_3                            0x800c04000000003f, 51,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_4                            0x800c04000000003f, 52,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_5                            0x800c04000000003f, 53,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_6                            0x800c04000000003f, 54,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_7                            0x800c04000000003f, 55,  1 // per-group spare mode latch.
#define EDIP_TX_PG_SPARE_MODE_8_9                          0x800c04000000003f, 56,  2 // per-group spare mode latch.
#define EDIP_TX_SPARE_MODE_PG                              0x800c04000000003f, 48, 16 // register -- description
#define EDIP_TX_BUS_ID                                     0x800c0c000000003f, 48,  6 // this field is used to programmably set the bus number that a group belongs to.
#define EDIP_TX_ID1_PG                                     0x800c0c000000003f, 48, 16 // register -- description
#define EDIP_TX_CLKDIST_PDWN                               0x800c14000000003f, 48,  1 // used to disable the tx group clocks and put them into a low power state. this does not control per-lane circuits or logic.
#define EDIP_TX_BIST_EN                                    0x800c14000000003f, 51,  1 // this bit enables the tx bist state machine to begin testing.
#define EDIP_TX_EXBIST_MODE                                0x800c14000000003f, 52,  1 // this bit is the chicken switch to diable the bist enable through external io.
#define EDIP_TX_MAX_BAD_LANES                              0x800c14000000003f, 53,  5 // static repair, dynamic repair & recal max number of bad lanes per tx bus (note: should match rx side)
#define EDIP_TX_MSBSWAP                                    0x800c14000000003f, 58,  1 // used to enable end-for-end or msb swap of tx lanes.  for example, lanes 0 and n-1 swap, lanes 1 and n-2 swap, etc. \r\n\t0:(nomsbswap) no swap (default)\r\n\t1:(msbswap) end-for-end swap mode
#define EDIP_TX_PDWN_LITE_DISABLE                          0x800c14000000003f, 59,  1 // disables the power down lite feature of unused spare lanes (generally should match rx_pdwn_lite_disable)
#define EDIP_TX_WT_PATTERN_LENGTH                          0x800c14000000003f, 60,  2 // tx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024
#define EDIP_TX_DESKEW_RATE                                0x800c14000000003f, 62,  1 // tx deskew rate\r\n\tselects between a div1 (1100) and div2 (11110000) deskew pattern rate for both pattern a and b. \r\n\t0: (div2) divided deskew pattern for p9\r\n\t1: (div1) regular deskew pattern for centaur
#define EDIP_TX_CTL_MODE1_EO_PG                            0x800c14000000003f, 48, 16 // register -- description
#define EDIP_TX_SLS_SCRAMBLE_MODE                          0x800c1c000000003f, 48,  2 // selects sls prbs scramble mode for 9th pattern. \r\n\t00:(prbs23) use prbs23\r\n\t01:(prbs7) use prbs7\r\n\t10:(prbs11) use prbs11\r\n\t11:(prbs15) use prbs15
#define EDIP_TX_CLK_UNLOAD_CLK_DISABLE                     0x800c1c000000003f, 50,  1 // set to 0 to clock off sync logic on the clock slice and save power.  it should not be necessary to use the sync logic on the clock slice since it has no fifo but control is available just in case.
#define EDIP_TX_CLK_RUN_COUNT                              0x800c1c000000003f, 51,  1 // set to 1 to enable the tx clock slice serializer.  this should be enabled at all times but control is available just in case.
#define EDIP_TX_CLK_UNLOAD_SEL                             0x800c1c000000003f, 52,  3 // controls the preset value of the tx clock slice unload counter.  this should not be necessary to use on the clock slice but is available just in case.
#define EDIP_TX_CLK_HALF_WIDTH_MODE                        0x800c1c000000003f, 55,  1 // controls the 4to1 pin on tx clock slice.  this should remain 0 but is provided as a chicken switch just in case.
#define EDIP_TX_BUS_WIDTH                                  0x800c1c000000003f, 56,  7 // tx bus width
#define EDIP_TX_CTL_MODE2_EO_PG                            0x800c1c000000003f, 48, 16 // register -- description
#define EDIP_TX_DRV_CLK_PATTERN_GCRMSG                     0x800c24000000003f, 48,  2 // tx clock drive patterns\r\n\t00:(drv_0s) drive all 0s pattern\r\n\t01:(drv_wt) drive wiretest pattern\r\n\t10:(drv_clk) drive clock pattern\r\n\t11:(unused) unused
#define EDIP_TX_DRV_DATA_PATTERN_GCRMSG                    0x800c24000000003f, 50,  4 // tx drive patterns\r\n\t0000:(drv_0s) drive all 0s pattern\r\n\t0001:(drv_wt) drive wiretest pattern\r\n\t0010:(drv_1s) drive all 1s pattern\r\n\t0011:(drv_deskew_a) drive deskew pattern a\r\n\t0100:(drv_deskew_b) drive deskew pattern b\r\n\t0101:(drv_full_prbs) prbs full speed scramble pattern (see tx_prbs_tap_id)\r\n\t0110:(drv_rxbist) alternate prbs7 pattern for rx bist \r\n\t0111:(drv_cal_prbs) prbs calibration or 9th pattern\r\n\t1000:(drv_prbs7) prbs7 pattern\r\n\t1001:(drv_prbs11) prbs11 pattern\r\n\t1010:(tdr_square_wave) drives tdr pulse-square waves\r\n\t1011:(drv_prbs15) prbs15 pattern\r\n\t1100:(drv_nvbus) alternate prbs23 for nvbus\r\n\t1101:(drv_prbs31) prbs31 pattern\r\n\t1110:(drv_clk) 1 to 1 clock pattern\r\n\t1111:(unused_b) unused\r\n\trjr
#define EDIP_TX_CTL_CNTLG1_EO_PG                           0x800c24000000003f, 48, 16 // register -- description
#define EDIP_TX_ERR_INJ_A_FINE_SEL                         0x800c2c000000003f, 48,  3 // random lsb/fine-grained cycle offset variation control for pattern a, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define EDIP_TX_ERR_INJ_A_COARSE_SEL                       0x800c2c000000003f, 51,  4 // random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern a.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define EDIP_TX_ERR_INJ_A_BER_SEL                          0x800c2c000000003f, 55,  6 // used to set the random bit error injection rate for pattern a.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)).
#define EDIP_TX_ERR_INJ_ENABLE                             0x800c2c000000003f, 61,  1 // overall error injection enable.  when set to 0, all other injection is gated.
#define EDIP_TX_ERR_INJ_CLOCK_ENABLE                       0x800c2c000000003f, 62,  1 // enable clocks to larger counter and prbs logic.  use this to stagger start times and effectively seed the injection mechanism randomly.
#define EDIP_TX_CTL_CNTL2_EO_PG                            0x800c2c000000003f, 48, 16 // register -- description
#define EDIP_TX_ERR_INJ_B_FINE_SEL                         0x800c34000000003f, 48,  3 // random lsb/fine-grained cycle offset variation control for pattern b, where cycles are deserialized domain cycles. \r\n\t000:(1_33) random offset in range of 1-32 cycles(default)\r\n\t001:(1_16) random offset in range of 1-16 cycles\r\n\t010:(1_8) random offset in range of 1-8 cycles\r\n\t011:(1_4) random offset in range of 1-4 cycles\r\n\t100:(1_2) random offset in range of 1-2 cycles\r\n\t101:(fixed1) fixed offset of 1 cycle\r\n\t110:(fixed3) fixed offset of 3 cycles \r\n\t111:(fixed7) fixed offset of 7 cycles.
#define EDIP_TX_ERR_INJ_B_COARSE_SEL                       0x800c34000000003f, 51,  4 // random msb/coarse-grained multiplier for the base error rate counter, which controls bit error rate variation for pattern b.  there are also a number of nonrandom settings which are specifically chosen to avoid powers of two.  \r\n\t0000:(1_32) range of 1-32, mean of 16.5 (default)\r\n\t0001:(9_24) range of 9-24, mean of 16.5\r\n\t0010:(13_20) range of 13-20, mean of 16.5\r\n\t0011:(16_19) range of 16-19, mean of 16.5\r\n\t100:(17_18) range of 16-17, mean of 16.5\r\n\t0101:(1_8) range of 1-8, mean of 4.5\r\n\t0110:(3_6)  range of 3-6, mean of 4.5\r\n\t0111:(4_5)  range of 4-5, mean of 4.5\r\n\t1000:(fixed1) fixed 1\r\n\t1001:(fixed3) fixed 3\r\n\t1010:(fixed5) fixed 5\r\n\t1011:(fixed6) fixed 6\r\n\t1100:(fixed7) fixed 7\r\n\t1101:(fixed17) fixed 17\r\n\t1110:(fixed21) fixed 21\r\n\t1111:(fixed25) fixed 25
#define EDIP_TX_ERR_INJ_B_BER_SEL                          0x800c34000000003f, 55,  6 // used to set the random bit error injection rate for pattern b.  when set to a binary value of n, the average bit error rate is 1/(2^n*beats*mean(msb)).
#define EDIP_TX_CTL_CNTL3_EO_PG                            0x800c34000000003f, 48, 16 // register -- description
#define EDIP_TX_START_LANE_ID                              0x800c84000000003f, 49,  7 // this field is used to programmably set the first lane position in the group but relative to the bus.
#define EDIP_TX_END_LANE_ID                                0x800c84000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.
#define EDIP_TX_ID2_PG                                     0x800c84000000003f, 48, 16 // register -- description
#define EDIP_TX_CLK_INVERT                                 0x800c8c000000003f, 48,  1 // used to invert the polarity of the clock.\r\n\t0:(normal_clk) normal clk polarity (default)\r\n\t1:(invert_clk) invert clk
#define EDIP_TX_CLK_QUIESCE                                0x800c8c000000003f, 49,  2 // used to force the output of the clock lane to a particular value. \r\n\t00:(functional) functional data (default)\r\n\t01:(quiesce_to_0) quiesce clock lane to a static 0 value\r\n\t10:(quiesce_to_1) quiesce clock lane to a static 1 value\r\n\t11:(quiesce_to_z) tri-state clock lane output.
#define EDIP_TX_CLK_RATE                                   0x800c8c000000003f, 53,  2 // used to select tx bus clock rate. \r\n\t00:(odr) odr/c8 mode \r\n\t01:(qdr) qdr/c4 mode\r\n\t10:(ddr) ddr/c2 mode\r\n\t11:(unused) unused
#define EDIP_TX_DYN_RECAL_INTERVAL_TIMEOUT_SEL             0x800c8c000000003f, 55,  3 // tx dynamic recalibration interval timeout selects \r\n\t  this timeout determines the time between status reporting timeouts. \r\n\t the actual time of sending a message is selected with rx_dyn_recal_status_rpt_timeout_sel. \r\n\t000:(tap0) 1024ui or 106.5ns very small value for sim only\r\n\t001:(tap1) 64kui or 3.4us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite
#define EDIP_TX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL           0x800c8c000000003f, 58,  2 // tx dynamic recalibration status reporting timeout selects \r\n\t  this timeout determines the time that a status reporting timeout lasts.  the first 1/4 is a blank period, the middle 1/2 is the command message, and the last 1/4 is another blank period. \r\n\t the time between messages is selected with rx_dyn_recal_interval_timeout_sel. \r\n\t00:(tap0) 512ui or 53.2ns\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns\r\n\t(note that the first 1/4 and last 1/4 of this time are actually sending the prbs pattern, so the actual time the sls command is on the lane is 1/2 of this value.  for more info see figure 2.4 eye-opening initialization step/recalibration timing description in the workbook.)
#define EDIP_TX_CTL_MODE1_E_PG                             0x800c8c000000003f, 48, 16 // register -- description
#define EDIP_TX_IORESET                                    0x800c9c000000003f, 48,  1 // reset the given tx clock group and gcr slave
#define EDIP_TX_ERR_INJ_SLS_MODE                           0x800c9c000000003f, 51,  1 // used to set the random bit error injection for pattern a to work during sls transmission only.
#define EDIP_TX_ERR_INJ_SLS_ALL_CMD                        0x800c9c000000003f, 52,  1 // used to qualify the sls mode error injection for pattern a, to inject on all sls command transmissions.
#define EDIP_TX_ERR_INJ_SLS_RECAL                          0x800c9c000000003f, 53,  1 // used to qualify the sls mode error injection for pattern a, to inject on the calibration lane only when not sending an sls command. see workbook for details.
#define EDIP_TX_ERR_INJ_SLS_CMD                            0x800c9c000000003f, 54,  6 // used to qualify the sls mode error injection for pattern a, to inject on only this sls command transmission. see workbook for sls command codes.
#define EDIP_TX_CTL_CNTL2_E_PG                             0x800c9c000000003f, 48, 16 // register -- description
#define EDIP_TX_SND_SLS_CMD_GCRMSG                         0x800ca4000000003f, 48,  1 // send sls command or recalibration data
#define EDIP_TX_DYN_RECAL_TSR_IGNORE_GCRMSG                0x800ca4000000003f, 49,  1 // send dynamic recal sls commands all the time (not just during the status reporting interval)
#define EDIP_TX_SLS_CMD_GCRMSG                             0x800ca4000000003f, 50,  6 // tx sls command
#define EDIP_TX_SND_SLS_CMD_PREV_GCRMSG                    0x800ca4000000003f, 56,  1 // revert to sending previous sls command or recalibration data after recovery repair made
#define EDIP_TX_SND_SLS_USING_REG_SCRAMBLE                 0x800ca4000000003f, 57,  1 // send sls command using normal scramble pattern instead of calibration or 9th pattern
#define EDIP_TX_CTL_CNTLG3_E_PG                            0x800ca4000000003f, 48, 16 // register -- description
#define EDIP_TX_SLS_LANE_GCRMSG                            0x800cac000000003f, 48,  7 // encoded sls lane in relation to the entire tx bus
#define EDIP_TX_SLS_LANE_VAL_GCRMSG                        0x800cac000000003f, 55,  1 // tx sls lane valid
#define EDIP_TX_SLS_LANE_ENC_SPR1_GCRMSG                   0x800cac000000003f, 56,  1 // tx sls lane control spare signal
#define EDIP_TX_CTL_CNTLG4_E_PG                            0x800cac000000003f, 48, 16 // register -- description
#define EDIP_TX_SLS_LANE_SHDW_GCRMSG                       0x800cb4000000003f, 48,  1 // sls lane shadowing or unshadowing functional data (used to set up tx mux controls and enable powerup of next sls lane)
#define EDIP_TX_SLS_LANE_SHDW_RPR_GCRMSG                   0x800cb4000000003f, 49,  1 // sls lane shadowing or unshadowing functional data during a repair action (used to set up tx mux controls and enable powerup of last good sls lane)
#define EDIP_TX_SLS_LANE_MUX_SPR1_GCRMSG                   0x800cb4000000003f, 50,  1 // sls lane shadowing, unshadowing, or muxing spare control signal 1 to which the tx_set_sls_ln controller is sensitive.
#define EDIP_TX_SLS_LANE_MUX_SPR2_GCRMSG                   0x800cb4000000003f, 51,  1 // sls lane shadowing, unshadowing, or muxing spare control signal 2 to which the tx_set_sls_ln controller is sensitive.
#define EDIP_TX_CTL_CNTLG5_E_PG                            0x800cb4000000003f, 48, 16 // register -- description
#define EDIP_TX_SLV_MV_SLS_SHDW_REQ_GCRMSG                 0x800cbc000000003f, 48,  1 // request to tx slave to move sls lane
#define EDIP_TX_SLV_MV_SLS_SHDW_RPR_REQ_GCRMSG             0x800cbc000000003f, 49,  1 // request to tx slave to move sls lane & set bad lane register
#define EDIP_TX_SLV_MV_SLS_UNSHDW_REQ_GCRMSG               0x800cbc000000003f, 50,  1 // request to tx slave to move sls lane
#define EDIP_TX_SLV_MV_SLS_UNSHDW_RPR_REQ_GCRMSG           0x800cbc000000003f, 51,  1 // request to tx slave to move sls lane & set bad lane register
#define EDIP_TX_SLV_MV_SLS_SPR1_GCRMSG                     0x800cbc000000003f, 52,  1 // spare request 1 to tx slave to which sls lane movement is sensitive
#define EDIP_TX_SLV_MV_SLS_SPR2_GCRMSG                     0x800cbc000000003f, 53,  1 // spare request 2 to tx slave to which sls lane movement is sensitive
#define EDIP_TX_SLV_MV_SLS_RPR_REQ_GCRMSG                  0x800cbc000000003f, 59,  1 // request to tx slave to move sls lane & set bad lane register
#define EDIP_TX_SLS_LANE_SEL_LG_GCRMSG                     0x800cbc000000003f, 60,  1 // sets the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios
#define EDIP_TX_SLS_LANE_UNSEL_LG_GCRMSG                   0x800cbc000000003f, 61,  1 // clears the tx_sls_lane_sel_gcrmsg for the last good lane per bus during recal bad lane scenarios
#define EDIP_TX_SPR_LNS_PDWN_LITE_GCRMSG                   0x800cbc000000003f, 62,  1 // signals the tx side to power down lite (data gate) unused spare lanes at the end of static repair
#define EDIP_TX_SLV_LGL_RPR_REQ_GCRMSG                     0x800cbc000000003f, 63,  1 // request to tx slave to set bad lane register to last good lane of the bus (during recal bad lane scenarios)
#define EDIP_TX_CTL_CNTLG6_E_PG                            0x800cbc000000003f, 48, 16 // register -- description
#define EDIP_TX_WT_EN_ALL_CLK_SEGS_GCRMSG                  0x800cc4000000003f, 48,  1 // tx clock wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.
#define EDIP_TX_WT_EN_ALL_DATA_SEGS_GCRMSG                 0x800cc4000000003f, 49,  1 // tx data  wiretest driver segnments enable\r\n\t0: drive normally]n1:drive all segments for wiretest.
#define EDIP_TX_CTL_CNTLG7_E_PG                            0x800cc4000000003f, 48, 16 // register -- description
#define EDIP_TX_TDR_DAC_CNTL                               0x800ccc000000003f, 48,  8 // controls variable threshold receiver for tdr function
#define EDIP_TX_TDR_PHASE_SEL                              0x800ccc000000003f, 57,  1 // controls phase select for tdr function, 0 is for _n leg, 1 is for _p leg.
#define EDIP_TX_CTL_CNTL8_EO_PG                            0x800ccc000000003f, 48, 16 // register -- description
#define EDIP_TX_TDR_PULSE_OFFSET                           0x800cd4000000003f, 48, 14 // offset value for tdr pulse.
#define EDIP_TX_CTL_CNTL9_EO_PG                            0x800cd4000000003f, 48, 16 // register -- description
#define EDIP_TX_TDR_PULSE_WIDTH                            0x800cdc000000003f, 48,  9 // width of tdr pulse.
#define EDIP_TX_CTL_CNTL10_EO_PG                           0x800cdc000000003f, 48, 16 // register -- description
#define EDIP_TX_BAD_LANE1_GCRMSG                           0x800ce4000000003f, 48,  7 // encoded bad lane one in relation to the entire tx bus
#define EDIP_TX_BAD_LANE2_GCRMSG                           0x800ce4000000003f, 55,  7 // encoded bad lane two in relation to the entire tx bus
#define EDIP_TX_BAD_LANE_CODE_GCRMSG                       0x800ce4000000003f, 62,  2 // tx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes
#define EDIP_TX_CTL_STATG1_E_PG                            0x800ce4000000003f, 48, 16 // register -- description
#define EDIP_TX_LANE_DISABLED_VEC_0_15                     0x800cec000000003f, 48, 16 // used to set which of group lanes 0-15 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_TX_CTL_MODE2_E_PG                             0x800cec000000003f, 48, 16 // register -- description
#define EDIP_TX_LANE_DISABLED_VEC_16_23                    0x800cf4000000003f, 48,  8 // used to set which of group lanes 16-23 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_TX_CTL_MODE3_E_PG                             0x800cf4000000003f, 48, 16 // register -- description
#define EDIP_TX_PG_FIR_ERRS_FULL_REG                       0x800d04000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in the per-group txctl logic.
#define EDIP_TX_PG_FIR_ERR_TX_SM_REGS                      0x800d04000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group txctl registers.
#define EDIP_TX_PG_FIR_ERR_GCR_BUFF                        0x800d04000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group gcr buffer.
#define EDIP_TX_PG_FIR_ERR_GCRS_LD_SM                      0x800d04000000003f, 50,  1 // iotk alias: parity error has occurred in the per-group txctl gcr load state machine.
#define EDIP_TX_PG_FIR_ERR_GCRS_UNLD_SM                    0x800d04000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_CTL_REGS                        0x800d04000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group txctl gcr unload state machine.
#define EDIP_TX_PL_FIR_ERR                                 0x800d04000000003f, 63,  1 // summary bit indicating a tx per-lane register or state machine parity error has occurred in one or more lanes. the tx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define EDIP_TX_FIR_PG                                     0x800d04000000003f, 48, 16 // tx group fir error source-isolation reg -- description
#define EDIP_TX_PG_FIR_ERR_MASK_FULL_REG                   0x800d0c000000003f, 48, 16 // iotk alias: fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.
#define EDIP_TX_PG_FIR_ERRS_MASK                           0x800d0c000000003f, 48,  5 // fir mask for register or state machine parity checkers in per-group txctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: par_err_mask_txctl_regs\r\n\tbit1: par_err_mask_gcr_buff\r\n\tbit2: reserved.\r\n\tbit3: par_err_mask_tx_stt_rpr_snd_msg_state.\r\n\tbit4: par_err_mask_gcrs_ld_state\r\n\tbit5: par_err_mask_gcrs_unld_state\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define EDIP_TX_PG_FIR_ERR_MASK_TX_SM_REGS                 0x800d0c000000003f, 48,  1 // iotk alias: fir mask for the per-group txctl registers.
#define EDIP_TX_PG_FIR_ERR_MASK_GCR_BUFF                   0x800d0c000000003f, 49,  1 // iotk alias: fir mask for the per-group txctl gcr buffer.
#define EDIP_TX_PG_FIR_ERR_MASK_GCRS_LD_SM                 0x800d0c000000003f, 50,  1 // iotk alias: fir mask for the per-group txctl gcr load state machine.
#define EDIP_TX_PG_FIR_ERR_MASK_GCRS_UNLD_SM               0x800d0c000000003f, 51,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_MASK_CTL_REGS                   0x800d0c000000003f, 52,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_MASK_BIST                       0x800d0c000000003f, 53,  1 // iotk alias: fir mask for the per-group txctl gcr unload state machine.
#define EDIP_TX_PL_FIR_ERR_MASK                            0x800d0c000000003f, 63,  1 // fir mask for the summary bit that indicates a per-lane tx register or state machine parity error has occurred. this mask bit is used to block all per-lane tx parity errors from causing a fir error.
#define EDIP_TX_FIR_MASK_PG                                0x800d0c000000003f, 48, 16 // tx group fir error mask reg -- description
#define EDIP_TX_CLR_PAR_ERRS                               0x800d14000000003f, 62,  1 // clear all tx parity error latches\r\n\ttoggle this field 0->1->0 to clear all tx parity error latches.
#define EDIP_TX_FIR_RESET                                  0x800d14000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all tx fir related latches including parity error latches, including the parity error latches.
#define EDIP_TX_FIR_RESET_PG                               0x800d14000000003f, 48, 16 // tx reset control action register -- description
#define EDIP_TX_PG_FIR_ERR_INJ_FULL_REG                    0x800d1c000000003f, 48, 16 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl register or state machine parity checkers.
#define EDIP_TX_PG_FIR_ERR_INJ                             0x800d1c000000003f, 48,  5 // tx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or state machine latch banks. the register or state value is not affected.\r\n\t0:(clr_par_err) no parity error being injected.\r\n\t1:(inj_par_err) causes a parity flip in the specific parity checker.\r\n\tbit0 - txctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: reserved.\r\n\tbit4 - txctl gcr load state machine parity error inject.\r\n\tbit5 - txctl gcr unload state machine parity error inject.\r\n\tbit6: reserved.\r\n\tbit7: reserved.
#define EDIP_TX_PG_FIR_ERR_INJ_TX_SM_REGS                  0x800d1c000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl registers.
#define EDIP_TX_PG_FIR_ERR_INJ_GCR_BUFF                    0x800d1c000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr buff.
#define EDIP_TX_PG_FIR_ERR_INJ_GCRS_LD_SM                  0x800d1c000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr load state machine.
#define EDIP_TX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                0x800d1c000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_INJ_CTL_REGS                    0x800d1c000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define EDIP_TX_PG_FIR_ERR_INJ_BIST                        0x800d1c000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group txctl gcr unload state machine.
#define EDIP_TX_FIR_ERROR_INJECT_PG                        0x800d1c000000003f, 48, 16 // tx group fir error injection reg -- description
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_0                     0x800d24000000003f, 48,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_1                     0x800d24000000003f, 49,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_2                     0x800d24000000003f, 50,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_3                     0x800d24000000003f, 51,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_4                     0x800d24000000003f, 52,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_5                     0x800d24000000003f, 53,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_6                     0x800d24000000003f, 54,  1 // per-group spare mode latch.
#define EDIP_TX_PG_CTL_SM_SPARE_MODE_7                     0x800d24000000003f, 55,  1 // per-group spare mode latch.
#define EDIP_TX_CTLSM_SPARE_MODE_PG                        0x800d24000000003f, 48, 16 // register -- description
#define EDIP_TX_PSAVE_WAKEUP_LANE0_ENABLE                  0x800d2c000000003f, 48,  1 // enable lane 0 at all times as the wakeup lane from psave mode
#define EDIP_TX_PSAVE_FENCE_ENABLE                         0x800d2c000000003f, 49,  1 // enable fencing of transmitter when psave_mode_ip output of rx is high
#define EDIP_TX_SEG_TEST_MODE                              0x800d2c000000003f, 50,  8 // driver segment test mode: all 0 means normal function mode, when this is not 0, segment test begins
#define EDIP_TX_FFE_BOOST_EN                               0x800d2c000000003f, 59,  1 // driver segment test: to enable boost function of nvlink tx
#define EDIP_TX_SEG_TEST_LEAKAGE_CTRL                      0x800d2c000000003f, 61,  1 // control txr_txc_sst_ctl_dc in every tx slice. 1 means run segment test in low leakage mode.
#define EDIP_TX_HALF_RATE_MODE                             0x800d2c000000003f, 62,  1 // when set to 1, enables timers on the slow clock domain to consistently count ui when in 4-bit legacy mode.  otherwise, slow clock domain counts only half of the ui noted in the timeouts documentation when in 4-bit legacy mode.
#define EDIP_TX_CTLSM_MODE1_EO_PG                          0x800d2c000000003f, 48, 16 // register -- description
#define EDIP_TX_PSEG_PRE_EN                                0x800d34000000003f, 51,  5 // pre bank pseg enable
#define EDIP_TX_PSEG_PRE_SEL                               0x800d34000000003f, 56,  5 // pre bank pseg mode selection
#define EDIP_TX_CTLSM_CNTL1_EO_PG                          0x800d34000000003f, 48, 16 // register -- description
#define EDIP_TX_NSEG_PRE_EN                                0x800d3c000000003f, 51,  5 // pre bank nseg enable
#define EDIP_TX_NSEG_PRE_SEL                               0x800d3c000000003f, 56,  5 // pre bank nseg mode selection
#define EDIP_TX_CTLSM_CNTL2_EO_PG                          0x800d3c000000003f, 48, 16 // register -- description
#define EDIP_TX_PSEG_MARGINPU_EN                           0x800d44000000003f, 48,  8 // margin pull-up bank pseg enable
#define EDIP_TX_PSEG_MARGINPD_EN                           0x800d44000000003f, 56,  8 // margin pull-down bank pseg enable
#define EDIP_TX_CTLSM_CNTL3_EO_PG                          0x800d44000000003f, 48, 16 // register -- description
#define EDIP_TX_NSEG_MARGINPU_EN                           0x800d4c000000003f, 48,  8 // margin pull-up bank nseg enable
#define EDIP_TX_NSEG_MARGINPD_EN                           0x800d4c000000003f, 56,  8 // margin pull-down bank nseg enable
#define EDIP_TX_CTLSM_CNTL4_EO_PG                          0x800d4c000000003f, 48, 16 // register -- description
#define EDIP_TX_MARGINPU_SEL                               0x800d54000000003f, 48,  8 // margin pull-up bank mode selection
#define EDIP_TX_MARGINPD_SEL                               0x800d54000000003f, 56,  8 // margin pull-down bank mode selection
#define EDIP_TX_CTLSM_CNTL5_EO_PG                          0x800d54000000003f, 48, 16 // register -- description
#define EDIP_TX_PSEG_MAIN_EN                               0x800d5c000000003f, 51, 13 // main bank pseg enable
#define EDIP_TX_CTLSM_CNTL6_EO_PG                          0x800d5c000000003f, 48, 16 // register -- description
#define EDIP_TX_NSEG_MAIN_EN                               0x800d64000000003f, 51, 13 // main bank nseg enable
#define EDIP_TX_CTLSM_CNTL7_EO_PG                          0x800d64000000003f, 48, 16 // register -- description
#define EDIP_TX_CLK_BIST_ERR                               0x800d6c000000003f, 48,  1 // indicates a txbist clock side error occurred.\r\n\t0:(no_error) no error\r\n\t1:(error) a clock side error has has been found
#define EDIP_TX_CLK_BIST_ACTIVITY_DET                      0x800d6c000000003f, 49,  1 // indicates that activity was detected in prbs checker for clk pattern. \r\n\t0:(no_error) no activity \r\n\t1:(error) activity has been found during txbist.
#define EDIP_TX_BIST_DONE                                  0x800d6c000000003f, 50,  1 // indicates txbist has completed. \r\n\t0:(not_finished) bist has not completed\r\n\t1:(finished) bist has completed running
#define EDIP_TX_SLS_HNDSHK_STATE                           0x800d6c000000003f, 51,  5 // sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for tx_sls_hndshk_state
#define EDIP_TX_CTLSM_STAT1_EO_PG                          0x800d6c000000003f, 48, 16 // register -- description
#define EDIP_TX_DRV_SYNC_PATTERN_GCRMSG                    0x800d84000000003f, 48,  1 // sync pattern command\r\n\t used to reset the tx prbs register and send an all ones sync pattern followed by changing tx_drv_data_pattern_gcrmsg to send full prbs (code 0101).  the rx prbs register is then reset after seeing the twelve ones if the rx_prbs_check_sync bit is set.  this is set by the training machine after sending the deskew pattern.   \r\n\t0:(sync_gated) sync pattern gated\r\n\t1:(snd_sync) send sync pattern
#define EDIP_TX_CTLSM_CNTLG1_E_PG                          0x800d84000000003f, 48, 16 // register -- description
#define EDIP_TX_SEG_TEST_CLK_STATUS                        0x800d8c000000003f, 50,  2 // driver segment test result for clock lane. bit0 for pad p, bit1 for pad n
#define EDIP_TX_CTLSM_STAT1_E_PG                           0x800d8c000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_REQ                                   0x800f04000000003f, 49,  1 // impedance calibration sequence enable\r\n\t rising edge initiates calibration seqeunce and clears all status. tx_zcal_done indicates completion and valid results available(default)\r\n\t0:(disabled) inactive. must be set prior to enable. \r\n\t1:(enabled) enable.
#define EDIP_TX_ZCAL_DONE                                  0x800f04000000003f, 50,  1 // impedance calibration sequence complete\r\n\t results are valid when 1.
#define EDIP_TX_ZCAL_ERROR                                 0x800f04000000003f, 51,  1 // impedance calibration sequence error\r\n\t indicates, independent of tx_zcal_done, whether no calibration answer was found, or state machine failed. cleared on tx_zcal_req.
#define EDIP_TX_ZCAL_BUSY                                  0x800f04000000003f, 52,  1 // impedance calibration sequence busy\r\n\t processing tx_zcal_req, or tx_zcal_swo_en, or an internal bist mode. look for tx_zcal_done.
#define EDIP_TX_ZCAL_FORCE_SAMPLE                          0x800f04000000003f, 53,  1 // impedance comparison sample force\r\n\t initiates single cycle sample of the calibration circuit comparison output. accumulated in tx_zcal_sample_cnt(default)\r\n\t0:(disabled) inactive. \r\n\t1:(enabled) enable
#define EDIP_TX_ZCAL_CMP_OUT                               0x800f04000000003f, 54,  1 // calibration circuit unqualified sample\r\n\t this is an unconditional sample of the calibration circuit comparison output.
#define EDIP_TX_ZCAL_SAMPLE_CNT                            0x800f04000000003f, 55,  9 // calibration circuit qualified sample\r\n\t count of conditional samples of the calibration circuit comparison output properly async staged, inverted with tx_zcal_cya_data_inv, and enabled with tx_zcal_force_sample or normal calibration sequence. cleared on any new request.
#define EDIP_TX_IMPCAL_PB                                  0x800f04000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_ANS_NOT_FOUND_ERROR                   0x800f3c000000003f, 49,  1 // impedance calibration sequence answer not found error\r\n\t indicates, independent of tx_zcal_done, no calibration answer was found. cleared on tx_zcal_req.
#define EDIP_TX_ZCAL_ANS_RANGE_ERROR                       0x800f3c000000003f, 50,  1 // impedance calibration sequence range check error\r\n\t indicates, independent of tx_zcal_done, the ans is not in max/min range, only works when tx_zcal_range_check is 1. cleared on tx_zcal_req.
#define EDIP_TX_ZCAL_TEST_ENABLE                           0x800f3c000000003f, 53,  1 // start impedance bist
#define EDIP_TX_ZCAL_TEST_STATUS                           0x800f3c000000003f, 54,  1 // this register stores the result of impedance bist
#define EDIP_TX_ZCAL_TEST_DONE                             0x800f3c000000003f, 55,  1 // this register is set to 1 when impedance bist is finished
#define EDIP_TX_IMPCAL2_PB                                 0x800f3c000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_N                                     0x800f0c000000003f, 48,  9 // calibration circuit nseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_IMPCAL_NVAL_PB                             0x800f0c000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_P                                     0x800f14000000003f, 48,  9 // calibration circuit pseg enable value this holds the current value of the enabled segments and is 4x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0xa1 is maximum slices).
#define EDIP_TX_IMPCAL_PVAL_PB                             0x800f14000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_P_4X                                  0x800f1c000000003f, 48,  5 // calibration circuit pseg-4x enable value this holds the current value of the enabled segments and is 2x multiple of the actual segment count. may be read for current calibration result set during calibration sequence. may be written to immediately update circuit enables on each write. used with tx_zcal_swo_* for manual calibration. do not write when tx_zcal_req = 1. (binary code - 0x00 is zero slices and 0x15 is maximum slices).
#define EDIP_TX_IMPCAL_P_4X_PB                             0x800f1c000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_SWO_EN                                0x800f24000000003f, 48,  1 // impedance calibration software override\r\n\t steers all calibration controls directly from these register fields. effectively disables state machine logic.(default)\r\n\t0:(inactive) inactive. \r\n\t1:(enabled) enable.
#define EDIP_TX_ZCAL_SWO_CAL_SEGS                          0x800f24000000003f, 49,  1 // impedance calibration software bank select\r\n\t enable pseg calibration. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define EDIP_TX_ZCAL_SWO_CMP_INV                           0x800f24000000003f, 50,  1 // impedance calibration software compare invert\r\n\t swap calibration circuit comparator inputs. see documentation.(default)\r\n\t0:(nsegcal) select nseg bank comparison. \r\n\t1:(psegcal) select pseg bank comparison.
#define EDIP_TX_ZCAL_SWO_CMP_OFFSET                        0x800f24000000003f, 51,  1 // impedance calibration software offset flush\r\n\t equalize comparator offset in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable offset \r\n\t1:(enable) enable offset.
#define EDIP_TX_ZCAL_SWO_CMP_RESET                         0x800f24000000003f, 52,  1 // impedance calibration software comparator reset\r\n\t reset comparator in calibration circuit.  see documentation.(default)\r\n\t0:(disable) disable reset \r\n\t1:(enable) enable reset.
#define EDIP_TX_ZCAL_SWO_POWERDOWN                         0x800f24000000003f, 53,  1 // impedance calibration software circuit powerdown\r\n\t powerdown calibration circuit. (default)\r\n\t0:(disable) disable powerdown \r\n\t1:(enable) enable powerdown.
#define EDIP_TX_ZCAL_SWO_TCOIL                             0x800f24000000003f, 54,  1 // impedance calibration software circuit tcoil\r\n\t
#define EDIP_TX_ZCAL_RANGE_CHECK                           0x800f24000000003f, 55,  1 // controls the usage of tx_zcal_sm_min/max_val, 0 means these two registers are used to define the range of zcal. if 1, the calibration range is from 1 to 80, and the min/max registers are only used to check whether the result is in range
#define EDIP_TX_ZCAL_CYA_DATA_INV                          0x800f24000000003f, 56,  1 // impedance calibration cya sample inversion\r\n\t select inverted comparator values in case of hardware error. see documentation.(default)\r\n\t0:(true) no sample inversion \r\n\t1:(invert) invert samples.
#define EDIP_TX_ZCAL_TEST_OVR_2R                           0x800f24000000003f, 57,  1 // impedance calibration test-only 2r segment override\r\n\t
#define EDIP_TX_ZCAL_TEST_OVR_1R                           0x800f24000000003f, 58,  1 // impedance calibration test-only 1r segment override\r\n\t
#define EDIP_TX_ZCAL_TEST_OVR_4X_SEG                       0x800f24000000003f, 59,  1 // impedance calibration test-only 4x segment override\r\n\t
#define EDIP_TX_ZCAL_TEST_CLK_DIV                          0x800f24000000003f, 60,  1 // this register controls the clock for impedance bist. 1 means the clock is divided by 32. when this register is 0, pll bypass mode is needed.
#define EDIP_TX_IMPCAL_SWO1_PB                             0x800f24000000003f, 48, 16 // register -- description
#define EDIP_TX_ZCAL_SM_MIN_VAL                            0x800f2c000000003f, 48,  7 // impedance calibration minimum search threshold low-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_ZCAL_SM_MAX_VAL                            0x800f2c000000003f, 55,  7 // impedance calibration maximum search threshold high-side segment count limit used in calibration process. see circuit spec (binary code - 0x00 is zero slices and 0x50 is maximum slices).
#define EDIP_TX_IMPCAL_SWO2_PB                             0x800f2c000000003f, 48, 16 // register -- description
#define EDIP_PB_SPARE_MODE_0                               0x800f34000000003f, 48,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_1                               0x800f34000000003f, 49,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_2                               0x800f34000000003f, 50,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_3                               0x800f34000000003f, 51,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_4                               0x800f34000000003f, 52,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_5                               0x800f34000000003f, 53,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_6                               0x800f34000000003f, 54,  1 // per-bus spare mode latch.
#define EDIP_PB_SPARE_MODE_7                               0x800f34000000003f, 55,  1 // per-bus spare mode latch.
#define EDIP_SPARE_MODE_PB                                 0x800f34000000003f, 48, 16 // register -- description
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_0                   0x800000000000003f, 48,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_1                   0x800000000000003f, 49,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_2                   0x800000000000003f, 50,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_3                   0x800000000000003f, 51,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_4                   0x800000000000003f, 52,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_5                   0x800000000000003f, 53,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_6                   0x800000000000003f, 54,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_DAC_SPARE_MODE_7                   0x800000000000003f, 55,  1 // per-lane spare mode latch.
#define EDIP_RX_DATA_DAC_SPARE_MODE_PL                     0x800000000000003f, 48, 16 // register -- description
#define EDIP_RX_PDWN_LITE_CONTROLS                         0x800008000000003f, 48,  6 // power down pins, 0=cml2cmos, 1=ctle, 2=dac, 3=deserializer, 4=integrator, 5=phase rotator
#define EDIP_RX_LANE_ANA_PDWN                              0x800008000000003f, 54,  1 // lane power down of analog and custom circuits
#define EDIP_RX_PRBS_TEST_DATA                             0x800008000000003f, 55,  3 // prbs test data
#define EDIP_RX_DAC_CNTL1_EO_PL                            0x800008000000003f, 48, 16 // register -- description
#define EDIP_RX_A_CONTROLS                                 0x800010000000003f, 48,  6 // bit0 dfe h1 speculation mux select override enables speculation\r\n\tbit1 dfe h1 speculation mux select override\r\n\tbit2 when set, put this lanes front end into offset cancellation mode. also needed for common mode calibration.\r\n\tbit3 enables the amp dac for measurements in this bank/nbit4 enables fence for initloff\r\n\tbit5 disables all the h-dacs when a 1\r\n\tcpg
#define EDIP_RX_CM_CNTL                                    0x800010000000003f, 54,  3 // bit0 enables integrator common mode cal, used in conjunction with integrator cal enable\r\n\tbit1 is the polarity bit\r\n\tbit 2 is common mode even when 1, odd when 0 /ncpg
#define EDIP_RX_DAC_CNTL2_EO_PL                            0x800010000000003f, 48, 16 // register -- description
#define EDIP_RX_A_OFFSET_E0                                0x800018000000003f, 48,  7 // this is the vertical offset of the even low threshold sampling latch.
#define EDIP_RX_A_OFFSET_E1                                0x800018000000003f, 56,  7 // this is the vertical offset of the even high threshold sampling latch.
#define EDIP_RX_DAC_CNTL3_EO_PL                            0x800018000000003f, 48, 16 // register -- description
#define EDIP_RX_A_OFFSET_O0                                0x800020000000003f, 48,  7 // this is the vertical offset of the odd low threshold sampling latch.
#define EDIP_RX_A_OFFSET_O1                                0x800020000000003f, 56,  7 // this is the vertical offset of the odd high threshold sampling latch.
#define EDIP_RX_DAC_CNTL4_EO_PL                            0x800020000000003f, 48, 16 // register -- description
#define EDIP_RX_A_EVEN_INTEG_FINE_GAIN                     0x800028000000003f, 52,  5 // this is integrator gain control used in making common mode adjustments.
#define EDIP_RX_A_ODD_INTEG_FINE_GAIN                      0x800028000000003f, 57,  5 // this is integrator gain control used in making common mode adjustments.
#define EDIP_RX_DAC_CNTL5_EO_PL                            0x800028000000003f, 48, 16 // register -- description
#define EDIP_RX_A_CTLE_PEAK                                0x800030000000003f, 48,  5 // this is the ctle coarse peak value, only 4 bits currently used thinking future
#define EDIP_RX_A_CTLE_GAIN                                0x800030000000003f, 53,  4 // this is the ctle gain setting
#define EDIP_RX_DAC_CNTL6_EO_PL                            0x800030000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H1E_VAL                                  0x800038000000003f, 48,  7 // dfe h1 value for even samplers
#define EDIP_RX_A_H1O_VAL                                  0x800038000000003f, 56,  7 // dfe h1 value for odd samplers
#define EDIP_RX_DAC_CNTL7_EO_PL                            0x800038000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP_VAL                                    0x800040000000003f, 48,  8 // rx ampdac value stored as sign magnitude
#define EDIP_RX_DAC_CNTL8_EO_PL                            0x800040000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H2E_VAL                                  0x800080000000003f, 48,  6 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H2O_VAL                                  0x800080000000003f, 56,  6 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL1_E_PL                             0x800080000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H3E_VAL                                  0x800088000000003f, 48,  5 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H3O_VAL                                  0x800088000000003f, 56,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL2_E_PL                             0x800088000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H4E_VAL                                  0x800090000000003f, 48,  5 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H4O_VAL                                  0x800090000000003f, 56,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL3_E_PL                             0x800090000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H5E_VAL                                  0x800098000000003f, 48,  5 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H5O_VAL                                  0x800098000000003f, 56,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL4_E_PL                             0x800098000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H6_VAL                                   0x8000a0000000003f, 48,  5 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H7_VAL                                   0x8000a0000000003f, 56,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL5_E_PL                             0x8000a0000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H8_VAL                                   0x8000a8000000003f, 48,  5 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H9_VAL                                   0x8000a8000000003f, 56,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL6_E_PL                             0x8000a8000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H10_VAL                                  0x8000b0000000003f, 48,  5 // dfe h1 value for even sampler 1
#define EDIP_RX_A_H11_VAL                                  0x8000b0000000003f, 56,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL7_E_PL                             0x8000b0000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H12_VAL                                  0x8000b8000000003f, 48,  5 // dfe h1 value for even sampler 0
#define EDIP_RX_DAC_CNTL8_E_PL                             0x8000b8000000003f, 48, 16 // register -- description
#define EDIP_RX_A_H1ARATIO_VAL                             0x8000c0000000003f, 48,  7 // this feeds the dac which is used to make the h1 dac and offset dac match the rest of the dacs
#define EDIP_RX_A_H1CAL_VAL                                0x8000c0000000003f, 55,  6 // this feeds the dac which is used to make the h1 dac match a precision referance current
#define EDIP_RX_A_H1CAL_EN                                 0x8000c0000000003f, 61,  1 // this goes to the analog to set its circuits in a mode for calibrating the h1 dac
#define EDIP_RX_DAC_CNTL9_E_PL                             0x8000c0000000003f, 48, 16 // register -- description
#define EDIP_RX_PL_SPARE_MODE_0                            0x800200000000003f, 48,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_1                            0x800200000000003f, 49,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_2                            0x800200000000003f, 50,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_3                            0x800200000000003f, 51,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_4                            0x800200000000003f, 52,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_5                            0x800200000000003f, 53,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_6                            0x800200000000003f, 54,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_SPARE_MODE_7                            0x800200000000003f, 55,  1 // per-lane spare mode latch.
#define EDIP_RX_SPARE_MODE_PL                              0x800200000000003f, 48, 16 // register -- description
#define EDIP_RX_PL_FIR_ERRS_FULL_REG                       0x800208000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-lane logic.
#define EDIP_RX_PL_FIR_ERRS                                0x800208000000003f, 48,  3 // a per-lane register or state machine parity error has occurred.\r\n\tbit0: parity error in rx data bit regs.\r\n\tbit1: parity error in ddc sm.
#define EDIP_RX_PL_FIR_ERR_PL_REGS                         0x800208000000003f, 48,  1 // iotk alias: parity error has occurred in the per-lane rx registers.
#define EDIP_RX_PL_FIR_ERR_DDC_SM                          0x800208000000003f, 49,  1 // iotk alias: parity error has occurred in the per-lane rx ddc state machine.
#define EDIP_RX_PL_FIR_ERR_DAC_REGS                        0x800208000000003f, 50,  1 // iotk alias: parity error has occurred in the per-lane rx data dac regs.
#define EDIP_RX_FIR_PL                                     0x800208000000003f, 48, 16 // register -- description
#define EDIP_RX_PL_FIR_ERRS_MASK_FULL_REG                  0x800210000000003f, 48, 16 // iotk alias: fir mask for rx_fir_pl errors.
#define EDIP_RX_PL_FIR_ERRS_MASK                           0x800210000000003f, 48,  3 // fir mask for register or state machine parity checkers in per-lane logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0 - (err_pl_mask_regs) per-lane register parity error.\r\n\tbit1 - (err_pl_mask_ddc_sm) per-lane ddc sm parity error.
#define EDIP_RX_PL_FIR_ERR_MASK_PL_REGS                    0x800210000000003f, 48,  1 // iotk alias: fir mask for per-lane register parity errors.
#define EDIP_RX_PL_FIR_ERR_MASK_DDC_SM                     0x800210000000003f, 49,  1 // iotk alias: fir mask for per-lane rx ddc state machine parity error.
#define EDIP_RX_PL_FIR_ERR_MASK_DAC_REGS                   0x800210000000003f, 50,  1 // iotk alias: fir mask for per-lane rx data dac regs parity error.
#define EDIP_RX_FIR_MASK_PL                                0x800210000000003f, 48, 16 // register -- description
#define EDIP_RX_PL_FIR_ERR_INJ_FULL_REG                    0x800218000000003f, 48, 16 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define EDIP_RX_PL_FIR_ERR_INJ                             0x800218000000003f, 48,  3 // rx per-lane parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0:(no_par_err) no parity errors being injected.\r\n\t1:(inj_par_err) while this value is a 1, the parity bit is inverted in the specific parity checker.\r\n\tbit0: rx per-lane register parity error inject.\r\n\tbit1: rx per-lane ddc sm parity error inject.\r\n\tbit2: rx per-lane data dac regs parity error inject.
#define EDIP_RX_PL_FIR_ERR_INJ_PL_REGS                     0x800218000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx registers.
#define EDIP_RX_PL_FIR_ERR_INJ_DDC_SM                      0x800218000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx ddc state machine.
#define EDIP_RX_PL_FIR_ERR_INJ_DAC_REGS                    0x800218000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-lane rx data dac regs.
#define EDIP_RX_FIR_ERROR_INJECT_PL                        0x800218000000003f, 48, 16 // register -- description
#define EDIP_RX_MODE_PL_FULL_REG                           0x800220000000003f, 48, 16 // alias for entire rx_mode_pl register
#define EDIP_RX_LANE_DIG_PDWN                              0x800220000000003f, 48,  1 // used to power down digital logic for a lane.
#define EDIP_RX_BER_DPIPE_MUX_SEL                          0x800220000000003f, 49,  1 // diag ber data pipe mux select. when set to a 1 the xor of the main and alt data is muxed onto the main data path feeding the data pipe.
#define EDIP_RX_LANE_SCRAMBLE_DISABLE                      0x800220000000003f, 52,  1 // used to disable the rx descrambler on a specific lane or all lanes by using a per-lane/per-group global write.
#define EDIP_RX_PRBS_SCRAMBLE_MODE                         0x800220000000003f, 56,  2 // selects prbs scramble sequence length.  \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15
#define EDIP_RX_FIFO_HALF_WIDTH_MODE                       0x800220000000003f, 58,  1 // selects half width mode for rx fifo for slower frequency connections. \r\n\t0: normal width \r\n\t1: half width (bits starting from 0 used, and the second half is unused)
#define EDIP_RX_PRBS_SYNC_MODE                             0x800220000000003f, 60,  1 // selects prbs sync sequence length.  \r\n\t0: 24-bit ones sequence (default) \r\n\t1: 12-bit ones sequence (legacy)
#define EDIP_RX_PRBS_RXBIST_MODE                           0x800220000000003f, 61,  1 // force prbs_en on for running edi+ rx_bist.  \r\n\t0: off (default) \r\n\t1: on stay whole time rx_bist is running
#define EDIP_RX_BIT_MODE1_EO_PL                            0x800220000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_PHASE_STEP                              0x800228000000003f, 60,  4 // amount to be added or subtracted from to phase rotator accumulator on each shift left or right.  0000: decoded as b10000 in logic, so pr will update every 4 shifts; other values will update with every 4*(16/phase_step) shifts.
#define EDIP_RX_BIT_MODE2_EO_PL                            0x800228000000003f, 48, 16 // register -- description
#define EDIP_RX_BER_CFG                                    0x800230000000003f, 48,  3 // this register controls the bit error rate threshold used for ddc.
#define EDIP_RX_FIFO_DLY_CFG                               0x800230000000003f, 51,  2 // this register controls how many parallel clock cycles we wait after every change to the phase rotator before we begin using the data again.
#define EDIP_RX_DDC_CFG                                    0x800230000000003f, 53,  2 // this register controls how many parallel clock cycles we wait looking for errors as we march further into the edge.
#define EDIP_RX_BIT_MODE3_EO_PL                            0x800230000000003f, 48, 16 // register -- description
#define EDIP_RX_BIT_MODE4_EO_PL                            0x800238000000003f, 48, 16 // register -- description
#define EDIP_RX_CAL_LANE_SEL                               0x800240000000003f, 48,  1 // selects which lane to recalibrate.
#define EDIP_RX_LANE_INVERT                                0x800240000000003f, 49,  1 // invert the rx lane data
#define EDIP_RX_LANE_INVALID                               0x800240000000003f, 50,  1 // marks this rx slice as invalid and fences other operations.  use this bit, for example, to broadcast a setting to all good lanes but not bad or disabled ones.
#define EDIP_RX_PIPE_SEL                                   0x800240000000003f, 51,  1 // selects what to mux onto the data pipe bus going to the calibration logic. \r\n\t0:(disabled) data \r\n\t1:(enabled) descrambler output
#define EDIP_RX_PDWN_LITE                                  0x800240000000003f, 53,  1 // when set, partially powers down unused spare lanes when not being recalibrated
#define EDIP_RX_PRBS_CHECK_SYNC                            0x800240000000003f, 54,  1 // enables checking for the 12/24 ui scramble sync pulse in the descramble prbs block. \r\n\t0:(disabled) disable checking (forces prbs_sync_done to 0)\r\n\t1:(enabled) enable checking (prbs_sync_done may go to 1 after identifying the sync pulse)
#define EDIP_RX_PRBS_SEED_DDC                              0x800240000000003f, 55,  1 // set this bit to enable seeding of the ddc prbs block from the data pipe output (either the data stream or the descramble prbs block depending on the value of rx_pipe_sel).
#define EDIP_RX_PRBS_SEED_DFE                              0x800240000000003f, 56,  1 // set this bit to enable seeding of the dfe prbs block.  related to this is rx_dfe_force_load_seed, which will load from the incoming data stream when 0 or the rx_prbs_seed_value_* when 1.
#define EDIP_RX_DFE_FORCE_LOAD_SEED                        0x800240000000003f, 57,  1 // set this bit to force rx_prbs_seed_value_0_15 & rx_prbs_seed_value_16_22 to load directly into the dfe history vector in the analog front-end for this lane.  note that the rx_prbs_seed_value_* bits are extended by 1 bit and shifted by a fixed value to match the pipeline delays between the analog front end and the rx prbs descrambler.  for a user who wishes to set the dfe history vector to a specific value, they will need to reverse that transformation to determine the value they should write to rx_prbs_seed_value_* to get the result they want in the vector.
#define EDIP_RX_PSAVE_MODE_DISABLE                         0x800240000000003f, 58,  1 // disable psave mode for this physical lane
#define EDIP_RX_IOCLK_SLIP                                 0x800240000000003f, 59,  2 // software control of rx slice deserializer ioclk slip control.  use this to slip the deserilizer by 2n beats.
#define EDIP_RX_IOCLK_SLIP_STROBE                          0x800240000000003f, 61,  1 // software control to execute ioclk slip control.
#define EDIP_RX_HISTORY_PRBS_POWER_UP                      0x800240000000003f, 62,  1 // force powerup of the additional analog histor latches used for prbs generation when doing h2-12 calibrationl.
#define EDIP_RX_PSAVE_RESYNC_DISABLE                       0x800240000000003f, 63,  1 // disable resync machien for this physical lane without disabling psave mode entirely
#define EDIP_RX_BIT_CNTLX1_EO_PL                           0x800240000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_EDGE_TRACK_CNTL                         0x800248000000003f, 48,  2 // runs edge tracking on the selected bank.  00: no edge tracking, 01: tracks against a data, 10: tracks against b data, 11: unused.
#define EDIP_RX_PR_WOBBLE_A                                0x800248000000003f, 50,  1 // wobbles the pr position for pr a for offset function.  done by first shifting 1 ui away in one direction, and then back and forth 2 ui to cover the entire range of pr values.  when de-asserted, the pr will then return to the original value.
#define EDIP_RX_PR_DDC_A                                   0x800248000000003f, 53,  1 // enables ddc state machine to go through its ddc routine on pr a.  works by shifting to the left and right looking for errors to find the edges, then adds an offset that centers the data between the 2 edges.
#define EDIP_RX_PR_BUMP_TO_EDGE_A                          0x800248000000003f, 55,  1 // bumps pr a position to the edge => +(16 - clkadj).
#define EDIP_RX_PR_BUMP_TO_CENTER                          0x800248000000003f, 56,  1 // bumps pr a position to the center => -(16-clkadj).
#define EDIP_RX_PR_BUMP_SL_1UI                             0x800248000000003f, 57,  1 // bumps the pr position of all prs to the next eye by shifting 32-steps. (not supported)
#define EDIP_RX_PR_BUMP_SR_1UI                             0x800248000000003f, 58,  1 // bumps the pr position to the previous eye by shifting 32-steps. (not supported)
#define EDIP_RX_PR_DATA_OFFSET_DISABLE_A                   0x800248000000003f, 59,  1 // disables phase rotator offset for a bank (dd2
#define EDIP_RX_PR_USE_DFE_CLOCK_A                         0x800248000000003f, 61,  1 // rx use a-bank dfe (h1/ap-adjusted clock\r\n\t0: use ddc clock.\r\n\t1: use dfe clock.\r\n\trjrdmb
#define EDIP_RX_BIT_CNTL2_EO_PL                            0x800248000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_DATA_A_OFFSET                           0x800250000000003f, 48,  6 // offset value applied to pr a
#define EDIP_RX_PR_BIT_LOCK_DONE                           0x800250000000003f, 60,  1 // indicates that bit lock is done, used to gate invalid lock in the cdr logic
#define EDIP_RX_PR_INVALID_LOCK_FILTER_EN                  0x800250000000003f, 61,  1 // enables the filtered invalid_lock phase rotator shift_right. default is on.
#define EDIP_RX_PR_INVALID_LOCK_BUMP_SIZE                  0x800250000000003f, 62,  2 // sets the size of the invalid_lock_bump\r\n\t00: 0 steps\r\n\t01: 1 step\r\n\t10: 2 steps\r\n\t11: 4 steps
#define EDIP_RX_BIT_CNTL3_EO_PL                            0x800250000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_TRACE_DDC_STOP                          0x800258000000003f, 48,  1 // enables the trace debug ddc state to stop the state machines.
#define EDIP_RX_PR_TRACE_DDC_SM                            0x800258000000003f, 49,  5 // determines when to stop the state machine for trace debug.
#define EDIP_RX_PR_TRACE_WOBBLE_STOP                       0x800258000000003f, 54,  1 // enables the trace debug wobble state to stop the state machines.
#define EDIP_RX_PR_TRACE_WOBBLE_SM                         0x800258000000003f, 55,  3 // determines when to stop the state machine for trace debug.
#define EDIP_RX_DDC_DFE_OFFSET_SWITCH_STOP                 0x800258000000003f, 58,  1 // enables the trace debug ddc-dfe offset switch state to stop the state machines.
#define EDIP_RX_DDC_DFE_OFFSET_SWITCH_SM                   0x800258000000003f, 59,  3 // determines when to stop the state machine for trace debug.
#define EDIP_RX_BIT_CNTL4_EO_PL                            0x800258000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_BUMP_SL_1STEP                           0x800260000000003f, 48,  1 // rx manual phase rotator shift right pulse\r\n\twriting this bit to a 1 adds one to the binary pr value. an increase in pr value has the effect of moving the c2 clocks to the samplat earlier in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_right_half servo command.
#define EDIP_RX_PR_BUMP_SR_1STEP                           0x800260000000003f, 49,  1 // rx manual phase rotator shift left pulse\r\n\twriting this bit to a 1 subtracts one from the binary pr value. a decrease in pr value has the effect of moving the c2 clocks to the samplat later in time relative to the data.\r\n\tthis is just the opposite of what you might think and is also opposite the definition of bump_left_half servo command.
#define EDIP_RX_BIT_CNTL5_EO_PL                            0x800260000000003f, 48, 16 // register -- description
#define EDIP_RX_PRBS_SYNC_DONE                             0x800268000000003f, 48,  1 // indicates that sync is done for the descramble prbs block.
#define EDIP_RX_PRBS_SYNC_DONE_B                           0x800268000000003f, 49,  1 // indicates that sync is done for the descramble prbs block. inverted version for use by broadcast reads. forced to 0 by rx_lane_invalid.
#define EDIP_RX_PRBS_SEED_DDC_DONE                         0x800268000000003f, 50,  1 // indicates that seed is done for the ddc prbs block.
#define EDIP_RX_PRBS_SEED_DDC_DONE_B                       0x800268000000003f, 51,  1 // indicates that seed is done for the ddc prbs block. active low to enable global reads. forced to 0 by rx_lane_invalid.
#define EDIP_RX_PR_NIBBLE_FOUND                            0x800268000000003f, 52,  1 // indicates that nibble alignment is done by the cdr logic.  sticky latch.
#define EDIP_RX_DFE_SYNC_DONE                              0x800268000000003f, 54,  1 // indicates that sync or seed is done for the prbs function of the analog front end.
#define EDIP_RX_DFE_SYNC_DONE_B                            0x800268000000003f, 55,  1 // indicates that sync or seed is done for the prbs function of the analog front end. inverted version for use by broadcast reads. forced to 0 by rx_lane_invalid.
#define EDIP_RX_PSAVE_MODE_ACTIVE                          0x800268000000003f, 56,  1 // indicates that psave mode has been requested for this lane
#define EDIP_RX_PSAVE_RESYNC_BUSY                          0x800268000000003f, 57,  1 // indicates that this lanes psave resync state machine is currently busy
#define EDIP_RX_BIT_STAT1_EO_PL                            0x800268000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_WOBBLE_A_IP                             0x800270000000003f, 50,  1 // wobble in progress on pr a.  this is active from when the wobble_a is asserted, through the time it is de-asserted, and turns off when the pr position returns to its original value
#define EDIP_RX_PR_DDC_DONE                                0x800270000000003f, 53,  1 // dynamic data centering in done on pr a or b.
#define EDIP_RX_PR_DDC_FAILED                              0x800270000000003f, 54,  1 // dynamic data centering in failed on pr a or b.
#define EDIP_RX_PR_BUMP_TO_FROM_EDGE_A_DONE                0x800270000000003f, 55,  1 // operation to move data pr a to or from the edge is done. (not supported)
#define EDIP_RX_PR_BUMP_SL_1UI_DONE                        0x800270000000003f, 56,  1 // bump forward 1-ui into the next eye done.  becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away.
#define EDIP_RX_PR_BUMP_SR_1UI_DONE                        0x800270000000003f, 57,  1 // bump minus 1-ui into the next eye done   becomes active when the bump_ui op is set, turns off when the pr has been moved 32 steps away.
#define EDIP_RX_PR_TRACE_STOPPED                           0x800270000000003f, 58,  1 // indicates that the trace bus stop command has asserted.
#define EDIP_RX_DDC_DFE_OFFSET_SWITCH_IP                   0x800270000000003f, 59,  1 // ddc to dfe offset switch in progress on pr.
#define EDIP_RX_BIT_STAT2_EO_PL                            0x800270000000003f, 48, 16 // register -- description
#define EDIP_RX_PR_L_R_EDGE_A_ALIAS                        0x800278000000003f, 48, 12 // rx phase rotator a bank leftand right edge alias
#define EDIP_RX_PR_LEFT_EDGE_A                             0x800278000000003f, 48,  6 // rx phase rotator a bank left edge
#define EDIP_RX_PR_RIGHT_EDGE_A                            0x800278000000003f, 54,  6 // rx phase rotator a bankright edge
#define EDIP_RX_A_PR_DFE_CLKADJ                            0x800278000000003f, 60,  4 // tweak value in phase rotator steps for the bank a clock offset when doing dfe calibration
#define EDIP_RX_BIT_STAT3_EO_PL                            0x800278000000003f, 48, 16 // register -- description
#define EDIP_RX_BIT_STAT4_EO_PL                            0x800280000000003f, 48, 16 // register -- description
#define EDIP_RX_PRBS_SEED_VALUE_0_15                       0x8002c0000000003f, 48, 16 // rx per-lane prbs seed value\r\n\tused to specify loading value of the prbs scramble pattern when the sync pattern is detected.  this must be set consistent with tx_prbs_seed_value.  see data scrambling workbook section for details.\r\n\twhen connected to legacy centaur parts, the seed must load such that it matches the sequence of those legacy parts.  the patterns listed here match that, including variants required to seed in 12-bit or 24-bit sync mode.\r\n\t0001000000000000:(pattern_24_a_0_15) 24-bit prbs tap point a\r\n\t1111000000111110:(pattern_24_b_0_15) 24-bit prbs tap point b\r\n\t0000011110111100:(pattern_24_c_0_15) 24-bit prbs tap point c\r\n\t0000011111000111:(pattern_24_d_0_15) 24-bit prbs tap point d\r\n\t0000001111101111:(pattern_24_e_0_15) 24-bit prbs tap point e\r\n\t0001111100001111:(pattern_24_f_0_15) 24-bit prbs tap point f\r\n\t0001100000000000:(pattern_24_g_0_15) 24-bit prbs tap point g\r\n\t1001110000000000:(pattern_24_h_0_15) 24-bit prbs tap point h\r\n\t1000010000000000:(pattern_12_a_0_15) 12-bit prbs tap point a\r\n\t0111110000000000:(pattern_12_b_0_15) 12-bit prbs tap point b\r\n\t0000000000001111:(pattern_12_c_0_15) 12-bit prbs tap point c\r\n\t1100000000001111:(pattern_12_d_0_15) 12-bit prbs tap point d\r\n\t1000000000000111:(pattern_12_e_0_15) 12-bit prbs tap point e\r\n\t1000000000111111:(pattern_12_f_0_15) 12-bit prbs tap point f\r\n\t0000011000000000:(pattern_12_g_0_15) 12-bit prbs tap point g\r\n\t0000011100000000:(pattern_12_h_0_15) 12-bit prbs tap point h
#define EDIP_RX_BIT_MODE1_E_PL                             0x8002c0000000003f, 48, 16 // register -- description
#define EDIP_RX_PRBS_SEED_VALUE_16_22                      0x8002c8000000003f, 48,  7 // rx per-lane prbs seed value lsbs\r\n\tsee rx_prbs_seed_value_0_15 for details.\r\n\t1000010:(pattern_24_a_16_22) 24-bit prbs tap point a\r\n\t0111110:(pattern_24_b_16_22) 24-bit prbs tap point b\r\n\t0000000:(pattern_24_c_12_acgh_16_22) 24-bit prbs tap point c, and 12-bit prbs tap points a, c, g, and h\r\n\t1100000:(pattern_24_d_16_22) 24-bit prbs tap point d\r\n\t1000000:(pattern_24_ef_16_22) 24-bit prbs tap points e and f\r\n\t0000011:(pattern_24_gh_16_22) 24-bit prbs tap points g and h\r\n\t0111111:(pattern_12_b_16_22) 12-bit prbs tap point b\r\n\t1111000:(pattern_12_d_16_22) 12-bit prbs tap point d\r\n\t1110000:(pattern_12_ef_16_22) 12-bit prbs tap points e and f
#define EDIP_RX_BIT_MODE2_E_PL                             0x8002c8000000003f, 48, 16 // register -- description
#define EDIP_RX_FIFO_INIT                                  0x800300000000003f, 48,  1 // initializes the fifo unload counter with the load counter and initializes the fifo load to unload delay
#define EDIP_RX_FIFO_INC_L2U_DLY                           0x800300000000003f, 49,  1 // increment existing fifo load-to-unload delay register
#define EDIP_RX_FIFO_DEC_L2U_DLY                           0x800300000000003f, 50,  1 // decrement existing fifo load-to-unload delay register
#define EDIP_RX_PRBS_INC                                   0x800300000000003f, 51,  1 // shift the prbs pattern forward in time by one extra local cycle (4ui for edi, 2ui for ei4).
#define EDIP_RX_PRBS_DEC                                   0x800300000000003f, 52,  1 // shift the prbs pattern back in time by holding it one local cycle (4ui for edi, 2ui for ei4).
#define EDIP_RX_SET_CAL_LANE_SEL                           0x800300000000003f, 53,  1 // set rx_cal_lane_sel register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_CAL_LANE_SEL                           0x800300000000003f, 54,  1 // clear rx_cal_lane_sel register bit
#define EDIP_RX_SET_PRBS_CHECK_SYNC                        0x800300000000003f, 55,  1 // set rx_prbs_check_sync register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_PRBS_CHECK_SYNC                        0x800300000000003f, 56,  1 // clear rx_prbs_check_sync register bit
#define EDIP_RX_SET_EDGE_TRACK_CNTL                        0x800300000000003f, 57,  1 // set rx_edge_track_cntl register bits to 11 if rx_lane_invalid is not set
#define EDIP_RX_CLR_EDGE_TRACK_CNTL                        0x800300000000003f, 58,  1 // clear rx_edge_track_cntl register bits to 00
#define EDIP_RX_SET_PRBS_SEED_DDC                          0x800300000000003f, 59,  1 // set rx_prbs_seed_ddc register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_PRBS_SEED_DDC                          0x800300000000003f, 60,  1 // clear rx_prbs_seed_ddc register bit
#define EDIP_RX_SET_BER_DPIPE_MUX_SEL                      0x800300000000003f, 61,  1 // set rx_ber_dpipe_mux_sel register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_BER_DPIPE_MUX_SEL                      0x800300000000003f, 62,  1 // clear rx_ber_dpipe_mux_sel register bit
#define EDIP_RX_BIT_CNTL1_E_PL                             0x800300000000003f, 48, 16 // register -- description
#define EDIP_RX_FIFO_L2U_DLY                               0x800308000000003f, 48,  4 // rx fifo load-to-unload delay, initailed during fifo init and modified thereafter by the deskew machine.  for setting x, the latency is 4*x to 4*x+4 ui.  default is 20-24 ui
#define EDIP_RX_BIT_CNTL2_E_PL                             0x800308000000003f, 48, 16 // register -- description
#define EDIP_RX_SET_PIPE_SEL                               0x800310000000003f, 48,  1 // set rx_pipe_sel register bit
#define EDIP_RX_CLR_PIPE_SEL                               0x800310000000003f, 49,  1 // clear rx_pipe_sel register bit
#define EDIP_RX_SET_PRBS_SEED_DFE                          0x800310000000003f, 50,  1 // set rx_prbs_seed_dfe register bit if rx_lane_invalid is not set
#define EDIP_RX_CLR_PRBS_SEED_DFE                          0x800310000000003f, 51,  1 // clear rx_prbs_seed_dfe register bit
#define EDIP_RX_SET_DFE_FORCE_LOAD_SEED                    0x800310000000003f, 52,  1 // used to set rx_dfe_force_load_seed for rx_bist
#define EDIP_RX_CLR_DFE_FORCE_LOAD_SEED                    0x800310000000003f, 53,  1 // used to clr rx_dfe_force_load_seed for rx_bist
#define EDIP_RX_FIFO_L2U_DEC                               0x800310000000003f, 54,  2 // decrement raw_unld_ptr_mesh latch by 0, 1, or 2 cycles (3 is not allowed)
#define EDIP_RX_SET_PDWN_LITE                              0x800310000000003f, 56,  1 // set rx_pdwn_lite register bit
#define EDIP_RX_CLR_PDWN_LITE                              0x800310000000003f, 57,  1 // clear rx_pdwn_lite register bit
#define EDIP_RX_BIT_CNTL3_E_PL                             0x800310000000003f, 48, 16 // register -- description
#define EDIP_RX_BIT_STAT1_O_PL                             0x800318000000003f, 48, 16 // register -- description
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_0                  0x800380000000003f, 48,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_1                  0x800380000000003f, 49,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_2                  0x800380000000003f, 50,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_3                  0x800380000000003f, 51,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_4                  0x800380000000003f, 52,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_5                  0x800380000000003f, 53,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_6                  0x800380000000003f, 54,  1 // per-lane spare mode latch.
#define EDIP_RX_PL_DATA_WORK_SPARE_MODE_7                  0x800380000000003f, 55,  1 // per-lane spare mode latch.
#define EDIP_RX_DATA_WORK_SPARE_MODE_PL                    0x800380000000003f, 48, 16 // register -- description
#define EDIP_RX_BAD_EYE_OPT_BER                            0x800388000000003f, 48,  1 // eye opt step failed ber test--lane marked bad
#define EDIP_RX_BAD_EYE_OPT_WIDTH                          0x800388000000003f, 49,  1 // eye opt step failed width test--lane marked bad
#define EDIP_RX_BAD_EYE_OPT_HEIGHT                         0x800388000000003f, 50,  1 // eye opt step failed height test--lane marked bad
#define EDIP_RX_WT_LANE_DISABLED                           0x800388000000003f, 52,  1 // wiretest has disabled this lane
#define EDIP_RX_WT_LANE_BAD_CODE                           0x800388000000003f, 54,  3 // wiretest lane bad code concatenate rx_wt_lane_inverted with rx_wt_lane_bad_code to get a full status: \r\n\t0000--good lane--not inverted (edi and ei-4)\r\n\t0001--bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010--bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011--bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100--bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101--bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110--bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111--bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000--good lane--inverted (edi and ei-4) \r\n\t1001--bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010--bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011--bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100--bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101--bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110--bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111--bad lane--unknown reason--inversion undetermined (edi and ei-4)
#define EDIP_RX_WT_LANE_STATUS_ALIAS                       0x800388000000003f, 53,  4 // alias for rx_wt_lane_inverted concatenated with rx_wt_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)
#define EDIP_RX_BAD_BLOCK_LOCK                             0x800388000000003f, 57,  1 // deskew step block lock not established--lane marked bad
#define EDIP_RX_BAD_SKEW                                   0x800388000000003f, 58,  1 // deskew step skew value not detected--lane marked bad
#define EDIP_RX_BAD_DESKEW                                 0x800388000000003f, 59,  1 // deskew step deskew value
#define EDIP_RX_BIST_ERR                                   0x800388000000003f, 63,  1 // indicates that rxbist did not find two data eyes of sufficient width.\r\n\t0:(no_error) no error\r\n\t1:(error) an error has occured during rxbist
#define EDIP_RX_WORK_STAT1_EO_PL                           0x800388000000003f, 48, 16 // register -- description
#define EDIP_RX_A_BAD_DFE_CONV                             0x800390000000003f, 48,  1 // eye opt step failed dfd convergence on bank a--not less than rx_ap110_ap010_delta_max \r\n\t0: converged \r\n\t1: not converged
#define EDIP_RX_A_H1AP_AT_LIMIT                            0x800390000000003f, 50,  1 // eye opt h1/ap ratio limit hit bank a--limit used instead of kh1/ap value \r\n\t0: not hit \r\n\t1: hit
#define EDIP_RX_A_AP                                       0x800390000000003f, 52,  8 // eye opt stored ap value
#define EDIP_RX_WORK_STAT2_EO_PL                           0x800390000000003f, 48, 16 // register -- description
#define EDIP_RX_A_PATH_OFF_EVEN                            0x800398000000003f, 48,  6 // eye opt a bank even path offset
#define EDIP_RX_A_PATH_OFF_ODD                             0x800398000000003f, 54,  6 // eye opt a bank odd  path offset
#define EDIP_RX_WORK_STAT3_EO_PL                           0x800398000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_SPARE_MODE_3                            0x800800000000003f, 51,  1 // per-group spare mode latch.
#define EDIP_RX_PG_SPARE_MODE_4                            0x800800000000003f, 52,  1 // chicken switch for hw219893.  fix is to prevent the rx_sls_hndshk_state sm and the rx_dyn_recal_hndshk_state sm from ever being allowed to run at the same time.  setting the cs turns this feature off.
#define EDIP_RX_SPARE_MODE_PG                              0x800800000000003f, 48, 16 // register -- description
#define EDIP_RX_BUS_ID                                     0x800808000000003f, 48,  6 // this field is used to programmably set the bus number that a clkgrp belongs to.
#define EDIP_RX_ID1_PG                                     0x800808000000003f, 48, 16 // register -- description
#define EDIP_RX_CLKDIST_PDWN                               0x800810000000003f, 48,  1 // used to disable the rx group clocks and put them into a low power state.
#define EDIP_RX_BIST_MIN_EYE_WIDTH                         0x800810000000003f, 51,  6 // rx bist min eye width\r\n\tsets the minimum eye width value in phase rotator steps considered acceptable in order to pass.
#define EDIP_RX_A_BIST_EN                                  0x800810000000003f, 57,  1 // bist enable pin
#define EDIP_RX_CTL_MODE1_EO_PG                            0x800810000000003f, 48, 16 // register -- description
#define EDIP_RX_DFE_CA_CFG                                 0x800818000000003f, 48,  2 // rx dfe clock adjust settings\r\n\tthis 2 bit register contains an encoded value for of k as follows\r\n\t00 - 8\r\n\t01 - 10\r\n\t10 - 12\r\n\t11 - 14\r\n\t  lab testing will be required to determine the proper value of k.
#define EDIP_RX_SCOPE_CONTROL                              0x800818000000003f, 50,  4 // 4 bit value telling which scope bit we are capturing, valid values 0 through 9
#define EDIP_RX_DATA_PIPE_CLR_ON_READ_MODE                 0x800818000000003f, 59,  1 // data pipe capture on read mode.  when set, reading rx_data_pipe_16_31 will automatically capture new data.  otherwise rx_data_pipe_capture must be written.
#define EDIP_RX_CTL_MODE2_EO_PG                            0x800818000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_THRESH3                              0x800820000000003f, 48,  4 // threshold used to end dfe servo ops early
#define EDIP_RX_DFE_HTAP_CFG                               0x800820000000003f, 52,  2 // multiplier used when running h2-h12 ops
#define EDIP_RX_DFE_INIT_TIMEOUT                           0x800820000000003f, 54,  4 // timeout for dfe 2-12 ops during init
#define EDIP_RX_DFE_RECAL_TIMEOUT                          0x800820000000003f, 58,  4 // timeout for dfe 2-12 ops during recal
#define EDIP_RX_CTL_MODE3_EO_PG                            0x800820000000003f, 48, 16 // register -- description
#define EDIP_RX_DISABLE_2TO12_CLEAR                        0x800828000000003f, 48,  1 // connect a config bit to disable the clear function when running h1a_ratio cal
#define EDIP_RX_PEAK_ENABLE_DAC_CFG                        0x800828000000003f, 49,  1 // connect to a config bit to allow us to disable the dac disable during peaking
#define EDIP_RX_AMIN_ENABLE_HDAC                           0x800828000000003f, 50,  1 // to enable hdacs during amin measurements.
#define EDIP_RX_USE_PREV_COARSE_VAL                        0x800828000000003f, 51,  1 // to cause us to read previous integ coarse value as starting point
#define EDIP_RX_CTL_MODE4_EO_PG                            0x800828000000003f, 48, 16 // register -- description
#define EDIP_RX_DYN_RECAL_INTERVAL_TIMEOUT_SEL             0x800830000000003f, 51,  3 // rx dynamic recalibration interval timeout selects \r\n\t this timeout determines the time between status reporting timeouts. \r\n\t the actual time of sending a message is selected with rx_dyn_recal_status_rpt_timeout_sel. \r\n\t000:(tap0) 1024ui or 106.5ns\r\n\t001:(tap1) 16kui or 1.7us\r\n\t010:(tap2) 32kui or 3.4us\r\n\t011:(tap3) 64kui or 6.8us\r\n\t100:(tap4) 128kui or 13.6us\r\n\t101:(tap5) 256kui or 27.3us\r\n\t110:(tap6) 8192kui or 872.4us\r\n\t111:(tap7) infinite
#define EDIP_RX_DYN_RECAL_STATUS_RPT_TIMEOUT_SEL           0x800830000000003f, 54,  2 // rx dynamic recalibration status reporting timeout selects\r\n\t this timeout determines the time that a status reporting timeout lasts.  the first 1/4 is a blank period, the middle 1/2 is the command message, and the last 1/4 is another blank period. \r\n\t the time between messages is selected with rx_dyn_recal_interval_timeout_sel. \r\n\t00:(tap0) 512ui or 53.2ns\r\n\t01:(tap1) 1024ui or 106.5ns\r\n\t10:(tap2) 2048ui or 212.9ns\r\n\t11:(tap3) 4096ui or 426.0ns
#define EDIP_RX_TRACKING_TIMEOUT_SEL                       0x800830000000003f, 56,  4 // time to wait for phase tracking to lock on the edge before proceding in the state machine (see workbook table 4.10 for timer settings)
#define EDIP_RX_PUP_LITE_WAIT_SEL                          0x800830000000003f, 60,  4 // how long to wait for analog logic to power up an unused spare lane for recal and repair (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE5_EO_PG                            0x800830000000003f, 48, 16 // register -- description
#define EDIP_RX_EO_CONVERGED_END_COUNT                     0x800838000000003f, 48,  4 // rx eye optimization covergence counter end value--number of times through the vga + ctle peaking substeps before giving up\r\n\t0000:16 \r\n\t0001: 1 \r\n\t0010:2  \r\n\t0011: 3 \r\n\t0100: 4 \r\n\t0101: 5 \r\n\t0110:6 \r\n\t0111:7  \r\n\t1000:8  \r\n\t1001:9   \r\n\t1010:10  \r\n\t1011:11  \r\n\t1100:12 \r\n\t1101:13 \r\n\t1110:14 \r\n\t1111:15 \r\n\trjr
#define EDIP_RX_HIST_MIN_EYE_WIDTH_MODE                    0x800838000000003f, 52,  2 // rx historic eye width and height minimum measurement mode \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_width_lane and  rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define EDIP_RX_HIST_MIN_EYE_HEIGHT_MODE                   0x800838000000003f, 54,  2 // rx historic eye height minimum measurement mode--inoperative on naples dd1 hardware--use the rx_hist_min_eye_width_mode control instead--set both the width and height_mode controls to the same value in test routines to maintain compatibiliy \r\n\t00: check all lanes on bus\r\n\t01: check only the designated rx_hist_min_eye_height_lane \r\n\t10: unused \r\n\t11: unused
#define EDIP_RX_AMP_GAIN_CNT_MAX                           0x800838000000003f, 56,  4 // maximum number of attempts to adjust vga gain before doing a peaking operation. \r\n\t0000:16 \r\n\t0001: 1 \r\n\t0010:2  \r\n\t0011: 3 \r\n\t0100: 4 \r\n\t0101: 5 \r\n\t0110:6 \r\n\t0111:7  \r\n\t1000:8  \r\n\t1001:9   \r\n\t1010:10  \r\n\t1011:11  \r\n\t1100:12 \r\n\t1101:13 \r\n\t1110:14 \r\n\t1111:15 \r\n\trjr
#define EDIP_RX_CTL_MODE6_EO_PG                            0x800838000000003f, 48, 16 // register -- description
#define EDIP_RX_ABORT_CHECK_TIMEOUT_SEL                    0x800840000000003f, 48,  4 // selects abort check timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_POLLING_TIMEOUT_SEL                        0x800840000000003f, 52,  4 // selects polling read timeout. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite\r\n\trjr
#define EDIP_RX_PSAVE_MODE_TIMEOUT_SEL                     0x800840000000003f, 56,  4 // how long to wait for analog logic to power up an unused spare lane for recal and repair (see workbook table 4.10 for timer settings and divide by 8)
#define EDIP_RX_DYN_RECAL_OVERALL_TIMEOUT_SEL              0x800840000000003f, 60,  4 // dynamic recalibration overall timeout selects \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:infinite\r\n\trjr
#define EDIP_RX_CTL_MODE7_EO_PG                            0x800840000000003f, 48, 16 // register -- description
#define EDIP_RX_MAX_BER_CHECK_COUNT                        0x800848000000003f, 56,  8 // maximum acceptable number of bit errors allowable after recal.
#define EDIP_RX_CTL_MODE8_EO_PG                            0x800848000000003f, 48, 16 // register -- description
#define EDIP_RX_MIN_EYE_WIDTH                              0x800850000000003f, 50,  6 // minimum acceptable eye width used during init or recal results checking--edi or ei4
#define EDIP_RX_MIN_EYE_HEIGHT                             0x800850000000003f, 56,  8 // minimum acceptable eye height used during init or recal results checking--edi only
#define EDIP_RX_CTL_MODE9_EO_PG                            0x800850000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP_INIT_CFG                               0x800858000000003f, 48,  3 // rx_amp_init_cfg   this register controls the servo filter for amplitude measurements during init. see workbook table 4.4 for settings
#define EDIP_RX_AMP_RECAL_CFG                              0x800858000000003f, 51,  3 // rx_amp_recal_cfg      this register controls the servo filter for amplitude measurements during recal. see workbook table 4.4 for settings
#define EDIP_RX_PEAK_INIT_CFG                              0x800858000000003f, 54,  3 // rx_peak_init_cfg  this register controls the servo filter for peaking during init. see workbook table 4.4 for settings
#define EDIP_RX_PEAK_RECAL_CFG                             0x800858000000003f, 57,  3 // rx_peak_recal_cfg      this register controls the servo filter for peaking during recal. see workbook table 4.4 for settings
#define EDIP_RX_AMP_CFG                                    0x800858000000003f, 60,  4 // rx_amp_cfg   this register controls the servo filter for rx_amp_0 and rx_amp_1 servo ops. see workbook table 4.4 for settings
#define EDIP_RX_CTL_MODE10_EO_PG                           0x800858000000003f, 48, 16 // register -- description
#define EDIP_RX_OFF_INIT_CFG                               0x800860000000003f, 48,  3 // rx_off_init_cfg   this register controls the servo filter for offset measurements during init. see workbook table 4.4 for settings
#define EDIP_RX_OFF_RECAL_CFG                              0x800860000000003f, 51,  3 // rx_off_recal_cfg  this register controls the servo filter for offset measurements during recal. see workbook table 4.4 for settings
#define EDIP_RX_CM_CFG                                     0x800860000000003f, 54,  3 // rx_cm_cfg          this register controls the servo during common mode measurement. see workbook table 4.4 for settings
#define EDIP_RX_AMIN_CFG                                   0x800860000000003f, 57,  3 // rx_amin_cfg        this register controls the servo filtering used for amin measuremnts. see workbook table 4.4 for settings
#define EDIP_RX_USERDEF_CFG                                0x800860000000003f, 60,  4 // rx_user_cfg      this register controls the servo filtering when running the user defined servo ops table 4.4 for settings
#define EDIP_RX_CTL_MODE11_EO_PG                           0x800860000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_CHG_CFG                              0x800868000000003f, 48,  4 // this register controls the minimum acceptable changes of the accum for a valid servo op. assures we have reached a stable point.
#define EDIP_RX_DAC_BO_CFG                                 0x800868000000003f, 52,  3 // this register controls the time of the dac black out time.  see workbook dfe section
#define EDIP_RX_FILTER_MODE                                0x800868000000003f, 55,  2 // servo filter mode. 00 means normal filter duirng entire op. 01 means use the 1/4-1/2 mode, 10 means 1/8-1/4 mode and 11 means the automatic convergence detect mode
#define EDIP_RX_MISC_CFG                                   0x800868000000003f, 57,  2 // per group rx misc configureation bits, bit 0 is chicken bit to re-enable the progressive filter mode for peaking, bit 1 when a 1 will enable the clearing of h1 during the amp0, amp1, and usrdef servo ops
#define EDIP_RX_DISABLE_H1_CLEAR                           0x800868000000003f, 59,  1 // per group when set will disable the clearing when running servo ops which normally clear and restore the h1 registers
#define EDIP_RX_VOFF_CFG                                   0x800868000000003f, 60,  3 // per group configuration regiseter for setting the filter value when running the vref version of offset on edge latches
#define EDIP_RX_LOFF_AMP_EN                                0x800868000000003f, 63,  1 // when set to a 1 the amp dac will be enabled during the loff versions of local latch offset cancellation
#define EDIP_RX_CTL_MODE12_EO_PG                           0x800868000000003f, 48, 16 // register -- description
#define EDIP_RX_CM_OFFSET_VAL                              0x800870000000003f, 49,  7 // value used to offset the amp dac when running common mode
#define EDIP_RX_SERVO_THRESH1                              0x800870000000003f, 56,  4 // value used as threshold of when to switch to normal filtering mode
#define EDIP_RX_SERVO_THRESH2                              0x800870000000003f, 60,  4 // value used as threshold of when we think the servo has converged
#define EDIP_RX_CTL_MODE13_EO_PG                           0x800870000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP_INIT_TIMEOUT                           0x800878000000003f, 48,  4 // rx_amp_init_timeout   used for amplitude masurements during init.  (see workbook table 4.10 for timer settings)
#define EDIP_RX_AMP_RECAL_TIMEOUT                          0x800878000000003f, 52,  4 // rx_amp_recal_timeout  used for amplitude masurements during recal. (see workbook table 4.10 for timer settings)
#define EDIP_RX_PEAK_INIT_TIMEOUT                          0x800878000000003f, 56,  4 // rx_peak_init_timeout  used for peaking masurements during init.    (see workbook table 4.10 for timer settings)
#define EDIP_RX_PEAK_RECAL_TIMEOUT                         0x800878000000003f, 60,  4 // rx_peak_recal_timeout  used for peaking masurements during recal   (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE14_EO_PG                           0x800878000000003f, 48, 16 // register -- description
#define EDIP_RX_OFF_INIT_TIMEOUT                           0x800880000000003f, 48,  4 // rx_off_init_timeout   used for offset masurements during init.     (see workbook table 4.10 for timer settings)
#define EDIP_RX_OFF_RECAL_TIMEOUT                          0x800880000000003f, 52,  4 // rx_off_recal_timeout  used for offset masurements during recal.    (see workbook table 4.10 for timer settings)
#define EDIP_RX_CM_TIMEOUT                                 0x800880000000003f, 56,  4 // rx_cm_timeout            used for common mode measurements         (see workbook table 4.10 for timer settings)
#define EDIP_RX_AMIN_TIMEOUT                               0x800880000000003f, 60,  4 // rx_amin_timeout        used for amin masurements                   (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE15_EO_PG                           0x800880000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP_TIMEOUT                                0x800888000000003f, 48,  4 // rx_amp_timeout timeout used when running the generic amplitude servo ops    (see workbook table 4.10 for timer settings)
#define EDIP_RX_USERDEF_TIMEOUT                            0x800888000000003f, 52,  4 // rx_userdef_timeout timeout used when using the user defined servo ops       (see workbook table 4.10 for timer settings)
#define EDIP_RX_BER_TIMEOUT                                0x800888000000003f, 56,  4 // rx_ber_timeout, used for when making bit error measurements with a servo op (see workbook table 4.10 for timer settings)
#define EDIP_RX_SPARE4_TIMEOUT                             0x800888000000003f, 60,  4 // rx_spare4_timeout just a spare for now                              (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE16_EO_PG                           0x800888000000003f, 48, 16 // register -- description
#define EDIP_RX_AMAX_HIGH                                  0x800890000000003f, 48,  8 // rx amax high target in amplitude dac steps (as measured by 2ap-amin method) default d120
#define EDIP_RX_AMAX_LOW                                   0x800890000000003f, 56,  8 // rx amax low target in amplitude dac steps (as measured by 2ap-amin method)  default d80
#define EDIP_RX_CTL_MODE17_EO_PG                           0x800890000000003f, 48, 16 // register -- description
#define EDIP_RX_AMP0_FILTER_MASK                           0x800898000000003f, 48,  8 // rx_amp_0_filter_mask   this register controls the filter and mask for the amp_0 servo ops.
#define EDIP_RX_AMP1_FILTER_MASK                           0x800898000000003f, 56,  8 // rx_amp_1_filter_mask   this register controls the filter and mask for the amp_1 servo ops.
#define EDIP_RX_CTL_MODE18_EO_PG                           0x800898000000003f, 48, 16 // register -- description
#define EDIP_RX_CTLE_GAIN_MAX                              0x8008a0000000003f, 48,  4 // rx ctle (vga) gain maximum allowable gain value
#define EDIP_RX_AMP_START_VAL                              0x8008a0000000003f, 56,  8 // rx amp start value, used when making amplitude measurements as the starting point
#define EDIP_RX_CTL_MODE19_EO_PG                           0x8008a0000000003f, 48, 16 // register -- description
#define EDIP_RX_DFE_CONVERGED_CNT_MAX                      0x8008a8000000003f, 48,  4 // number of iterations through dfe h1 and kh1ap adjust before ending dfe unless ended by rx_ap110ap010_delta criteria met\r\n\trjr
#define EDIP_RX_AP110_AP010_DELTA_MAX                      0x8008a8000000003f, 52,  4 // maximum delta between apx110 and apx010 measurements to end dfe h1 and kh1ap adjust unless ended by dfe_converged_cnt_max\r\n\trjr
#define EDIP_RX_CTL_MODE20_EO_PG                           0x8008a8000000003f, 48, 16 // register -- description
#define EDIP_RX_EO_STEP_CNTL_EDI_ALIAS                     0x8008b0000000003f, 48, 16 // rx eye optimization step control edi alias
#define EDIP_RX_EO_ENABLE_INTEG_LATCH_OFFSET_CAL           0x8008b0000000003f, 48,  1 // rx eye optimization latch offset adjustment enable with integrator-based disable
#define EDIP_RX_EO_ENABLE_CTLE_COARSE_CAL                  0x8008b0000000003f, 49,  1 // rx eye optimization coarse ctle/peakin enable
#define EDIP_RX_EO_ENABLE_VGA_CAL                          0x8008b0000000003f, 51,  1 // rx eye optimization vga gainand offset adjust enable
#define EDIP_RX_EO_ENABLE_DFE_H1_CAL                       0x8008b0000000003f, 52,  1 // rx eye optimization dfe h1  adjust enable
#define EDIP_RX_EO_ENABLE_H1AP_TWEAK                       0x8008b0000000003f, 53,  1 // rx eye optimization h1/an pr adjust enable
#define EDIP_RX_EO_ENABLE_DDC                              0x8008b0000000003f, 54,  1 // rx eye optimization dynamic data centering enable
#define EDIP_RX_EO_ENABLE_CM_COARSE_CAL                    0x8008b0000000003f, 55,  1 // rx eye optimization common mode coarse calibration enable
#define EDIP_RX_EO_ENABLE_CM_FINE_CAL                      0x8008b0000000003f, 56,  1 // rx eye optimization common mode fine calibration enable
#define EDIP_RX_EO_ENABLE_BER_TEST                         0x8008b0000000003f, 57,  1 // rx eye optimization bit error rate test enable
#define EDIP_RX_EO_ENABLE_RESULT_CHECK                     0x8008b0000000003f, 58,  1 // rx eye optimization final results check enable
#define EDIP_RX_EO_ENABLE_CTLE_EDGE_TRACK_ONLY             0x8008b0000000003f, 59,  1 // rx eye optimization ctle/peakin enable with edge tracking only
#define EDIP_RX_EO_ENABLE_DFE_H2_H12_CAL                   0x8008b0000000003f, 60,  1 // rx eye optimization dfe h2 to h12 calibration enable
#define EDIP_RX_EO_ENABLE_FINAL_L2U_ADJ                    0x8008b0000000003f, 62,  1 // rx eye optimization final rx fifo load-to-unload delay adjustment enable
#define EDIP_RX_EO_ENABLE_DONE_SIGNALING                   0x8008b0000000003f, 63,  1 // rx eye optimization eye opt done signaling enable
#define EDIP_RX_CTL_MODE21_EO_PG                           0x8008b0000000003f, 48, 16 // register -- description
#define EDIP_RX_RC_STEP_CNTL_EDI_ALIAS                     0x8008b8000000003f, 48, 14 // rx recalibration    step control edi alias
#define EDIP_RX_RC_ENABLE_INTEG_LATCH_OFFSET_CAL           0x8008b8000000003f, 48,  1 // rx recalibration    latch offset adjustment enable with integrator-based disable
#define EDIP_RX_RC_ENABLE_CTLE_COARSE_CAL                  0x8008b8000000003f, 49,  1 // rx recalibration    coarse ctle/peakin enable
#define EDIP_RX_RC_ENABLE_DAC_H1_CAL                       0x8008b8000000003f, 50,  1 // rx recalibration    h! dac calibration to reference
#define EDIP_RX_RC_ENABLE_VGA_CAL                          0x8008b8000000003f, 51,  1 // rx recalibration    vga gainand offset adjust enable
#define EDIP_RX_RC_ENABLE_DFE_H1_CAL                       0x8008b8000000003f, 52,  1 // rx recalibration    dfe h1  adjust enable
#define EDIP_RX_RC_ENABLE_H1AP_TWEAK                       0x8008b8000000003f, 53,  1 // rx recalibration    h1/an pr adjust enable
#define EDIP_RX_RC_ENABLE_DDC                              0x8008b8000000003f, 54,  1 // rx recalibration    dynamic data centering enable
#define EDIP_RX_RC_ENABLE_CM_COARSE_CAL                    0x8008b8000000003f, 55,  1 // rx recalibration    common mode coarse calibration enable
#define EDIP_RX_RC_ENABLE_BER_TEST                         0x8008b8000000003f, 57,  1 // rx recalibration    unsupported, leave at 0. bit error rate test enable
#define EDIP_RX_RC_ENABLE_RESULT_CHECK                     0x8008b8000000003f, 58,  1 // rx recalibration    unsupported, leave at 0. final results check enable
#define EDIP_RX_RC_ENABLE_CTLE_EDGE_TRACK_ONLY             0x8008b8000000003f, 59,  1 // rx recalibration    ctle/peaking enable with edge tracking only
#define EDIP_RX_RC_ENABLE_DFE_H2_H12_CAL                   0x8008b8000000003f, 60,  1 // rx recalibration    dfe h2 to h12 calibration enable
#define EDIP_RX_RC_ENABLE_DAC_H1_TO_A_CAL                  0x8008b8000000003f, 61,  1 // rx recalibration    h! dac to amplitude dac cross-calibration
#define EDIP_RX_CTL_MODE22_EO_PG                           0x8008b8000000003f, 48, 16 // register -- description
#define EDIP_RX_QUAD_SEL                                   0x8008c0000000003f, 48,  2 // select 1 of 4 possible phases for the deserialized rx io clock to send along with the data for integration flexibility and tuning for slack into the rx digital logic.
#define EDIP_RX_PEAK_TUNE                                  0x8008c0000000003f, 55,  1 // peak tune bit to analog
#define EDIP_RX_LTE_EN                                     0x8008c0000000003f, 56,  1 // lte enable
#define EDIP_RX_IQSPD_CFG                                  0x8008c0000000003f, 57,  2 // when 00 7.8gb/s to < 9.6gb/s, 01 9.6gb/s to 12gb/s, 10 unused, 11 > 12gb/s to 16gb/s
#define EDIP_RX_DFEHISPD_EN                                0x8008c0000000003f, 59,  1 // when 1, put the dfe in high speed mode according to per-system settings in customer_matrix.xls
#define EDIP_RX_DFE12_EN                                   0x8008c0000000003f, 60,  1 // when 1, we enable logic for dfe h2-h12
#define EDIP_RX_CTL_MODE23_EO_PG                           0x8008c0000000003f, 48, 16 // register -- description
#define EDIP_RX_H1AP_CFG                                   0x8008c8000000003f, 48,  2 // this register controls the maximum allowed ration of h1 and ap. this is not a servo setting but rather the setting of a ration between h1 and the value of ap. \r\n\t00:.5 \r\n\t01:.625 \r\n\t10:.25 \r\n\t11:.375
#define EDIP_RX_CTLE_UPDATE_MODE                           0x8008c8000000003f, 50,  1 // controls updating of ctle_coarse (peaking) values: \r\n\t0: update edge and a or b peaking values while servoing \r\n\t1: update a or b peaking values after edge bank servoing complete
#define EDIP_RX_USER_FILTER_MASK                           0x8008c8000000003f, 56,  8 // rx_user_filter_mask   this register controls the filter and mask for user defined servo ops.
#define EDIP_RX_CTL_MODE24_EO_PG                           0x8008c8000000003f, 48, 16 // register -- description
#define EDIP_RX_APX111_HIGH                                0x8008d0000000003f, 48,  8 // rx amax high target in amplitude dac steps (as measured by ap_x111 and an_x000) default d102
#define EDIP_RX_APX111_LOW                                 0x8008d0000000003f, 56,  8 // rx amax low target in amplitude dac steps (as measured by ap_x111 and an_x000)  default d68
#define EDIP_RX_CTL_MODE29_EO_PG                           0x8008d0000000003f, 48, 16 // register -- description
#define EDIP_RX_BER_EN                                     0x8008d8000000003f, 48,  1 // diagnostic bit error rate (ber) error checking enable control. when 1 enables error checking. when 0 the error checking is disabled. this control enables the ber timer as well as enables the error checker and ber counters. the assumption is that the driver(s) are currently driving prbs23 and the link has been trained before enabling ber checking.
#define EDIP_RX_BER_TIMER_FREEZE_EN                        0x8008d8000000003f, 49,  1 // diagnostic bit error rate (ber) timer freeze enable. when set to a 1 the timer is frozen when any lane error count saturates in that pack.
#define EDIP_RX_BER_COUNT_FREEZE_EN                        0x8008d8000000003f, 50,  1 // diag ber lane error counter freeze enable. when set to a 1 the per-lane error counters are frozen when the timer saturates in that pack.
#define EDIP_RX_BER_COUNT_SEL                              0x8008d8000000003f, 51,  4 // diag ber lane error counter saturation select. selects the number of errors that will saturate the counter and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t0000:(1) 1\r\n\t0001:(2) 2\r\n\t0010:(4) 4\r\n\t0011:(8) 8\r\n\t0100:(16) 16\r\n\t0101:(32) 32\r\n\t0110:(64) 64\r\n\t0111:(128) 128\r\n\t1000: (256) 256\r\n\t1001: (512) 512\r\n\t1010: (1024) 1024\r\n\t1011: (unused1) unused1\r\n\t1100: (unused2) unused2\r\n\t1101: (unused3) unused3\r\n\t1110: (unused4) unused4\r\n\t1111: (unused5) unused5
#define EDIP_RX_BER_TIMER_SEL                              0x8008d8000000003f, 56,  3 // diag ber timer saturation select. selects the timer value that will saturate the timer and cause a freeze event. the default value is used during initialization and should only be changed post init. \r\n\t000:(2tothe31st) 2^31\r\n\t001:(2tothe27th) 2^27\r\n\t010:(2tothe23rd) 2^23\r\n\t011:(2tothe19th) 2^19\r\n\t100:(2tothe17th) 2^17\r\n\t101:(2tothe13th) 2^13\r\n\t110:(2tothe9th) 2^9\r\n\t111:(2tothe5th) 2^5
#define EDIP_RX_BER_CLR_COUNT_ON_READ_EN                   0x8008d8000000003f, 59,  1 // diag ber lane error counter clear on read. when set to a 1 this enables the clearing of a lanes error counter when it is read.
#define EDIP_RX_BER_CLR_TIMER_ON_READ_EN                   0x8008d8000000003f, 60,  1 // diag ber timer clear on read. when set to a 1 this enables the clearing of a lanes timer when it is read from any lane in the pack.
#define EDIP_RX_CTL_CNTL1_EO_PG                            0x8008d8000000003f, 48, 16 // register -- description
#define EDIP_RX_TRC_MODE                                   0x8008e0000000003f, 48,  4 // rx trace mode\r\n\t0000:(tap0) training state machines\r\n\t0001:(tap1) dynamic repair state machines\r\n\t0010:(tap2) sls handshake state machines with recovery\r\n\t0011:(tap3) dynamic recal state machines\r\n\t0100:(tap4) recal handshake state machine with recovery\r\n\t0101:(tap5) crc or ecc tallying logic\r\n\t0110:(tap6) rx sls commands\r\n\t0111:(tap7) rx bad lanes\r\n\t1000:(tap8) rx sls lanes\r\n\t1001:(tap9) gcr\r\n\t1010:(tap10) per lane / per pack trace (see rx_pp_trc_mode for details)\r\n\t1011:(tap11) tbd\r\n\t1100:(tap12) tbd\r\n\t1101:(tap13) tbd\r\n\t1110:(tap14) tbd\r\n\t1111:(tap15) tbd
#define EDIP_RX_CTL_CNTL2_EO_PG                            0x8008e0000000003f, 48, 16 // register -- description
#define EDIP_RX_INT_MODE                                   0x8008e8000000003f, 48,  4 // rx interrupt mode setting
#define EDIP_RX_INT_CURRENT_STATE                          0x8008e8000000003f, 52, 12 // rx interrupt current state to stop on
#define EDIP_RX_CTL_CNTL3_EO_PG                            0x8008e8000000003f, 48, 16 // register -- description
#define EDIP_RX_INT_ENABLE_ENC                             0x8008f0000000003f, 48,  4 // rx interrupt encoded enable
#define EDIP_RX_INT_NEXT_STATE                             0x8008f0000000003f, 52, 12 // rx interrupt next state to stop on
#define EDIP_RX_CTL_CNTL4_EO_PG                            0x8008f0000000003f, 48, 16 // register -- description
#define EDIP_RX_INT_GOTO_STATE                             0x8008f8000000003f, 52, 12 // rx interrupt state to go to upon interrupt trigger
#define EDIP_RX_CTL_CNTL5_EO_PG                            0x8008f8000000003f, 48, 16 // register -- description
#define EDIP_RX_INT_RETURN_STATE                           0x800900000000003f, 52, 12 // rx interrupt state to go to upon return from interrupt code
#define EDIP_RX_CTL_CNTL6_EO_PG                            0x800900000000003f, 48, 16 // register -- description
#define EDIP_RX_CAL_LANE_GCRMSG                            0x800908000000003f, 48,  7 // encoded calibration lane in relation to the entire rx bus (including multi-groups or partial groups)
#define EDIP_RX_CAL_LANE_VAL_GCRMSG                        0x800908000000003f, 55,  1 // rx calibration lane valid
#define EDIP_RX_CAL_LANE_PG_PHY_GCRMSG                     0x800908000000003f, 56,  5 // encoded calibration lane in relation to the local, physical group.
#define EDIP_RX_CTL_CNTLX7_EO_PG                           0x800908000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_OP                                   0x800910000000003f, 48, 15 // servo operation code, written by global training state machine
#define EDIP_RX_SERVO_DONE                                 0x800910000000003f, 63,  1 // servo op completed, read by global training state machine
#define EDIP_RX_CTL_CNTL8_EO_PG                            0x800910000000003f, 48, 16 // register -- description
#define EDIP_RX_BIST_EN                                    0x800918000000003f, 48,  1 // this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define EDIP_RX_BIST_EXT_START_MODE                        0x800918000000003f, 49,  1 // this bit enables the rx bist state machine to begin testing. it is set by the bist helper sequencer through a gcr message. to properly initialize and run rx bist set the rx_start_bist reg bit.
#define EDIP_RX_BIST_INIT_DISABLE                          0x800918000000003f, 50,  3 // each bit disables an individual step of the rx bist init state machine when raised; bit 0 disables the cu pll lock, bit 1 disables the rx fifo init, and bit 2 disables eye opt/training
#define EDIP_RX_BIST_CUPLL_LOCK_CHECK_EN                   0x800918000000003f, 53,  1 // this bit enables the cu pll lock check mode of the rx bist init state machine. when set high, the test will check for the pll lock signal and set an error if it is not present.
#define EDIP_RX_BIST_STORE_EYES_LANE_SEL                   0x800918000000003f, 54,  6 // this register selects which lane to store rx bist eye width data from. the data is stored in the rx_bist_eye_a_width and rx_bist_eye_b_width registers.
#define EDIP_RX_BIST_STORE_EYES_BANK_SEL                   0x800918000000003f, 60,  2 // this register selects which bank to store rx bist eye width data from. \r\n\t00:(bank_a) store bank a widths\r\n\t01:(bank_b) store bank b widths\r\n\t10:(bank_e) store bank e widths\r\n\t11:(bank_a_edi) edi+ bank a
#define EDIP_RX_PERVASIVE_CAPT                             0x800918000000003f, 62,  1 // this bit latches glb_ctl and jtag_bndy pervasive signals in iocrc_pervasive_capt when set high. ro reg bit rx_prvcpt_change_det goes high when latched values differ from pervasive inputs.
#define EDIP_RX_CTL_CNTL9_EO_PG                            0x800918000000003f, 48, 16 // register -- description
#define EDIP_RX_BIST_PRBS_TEST_TIME                        0x800920000000003f, 48,  4 // controls how long rx bist will test the prbs7 data for errors. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define EDIP_RX_BIST_BUS_DATA_MODE                         0x800920000000003f, 52,  1 // this bit enables a mode where rx bist tests data from the bus
#define EDIP_RX_BIST_PRBS_PROP_TIME                        0x800920000000003f, 53,  4 // controls how long rx bist waits between incrementing a phaserot and begining to test the prbs data. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define EDIP_RX_BIST_PLL_LOCK_TIMEOUT                      0x800920000000003f, 57,  4 // controls how long rx bist init will wait for pll lock signal before timing out. \r\n\t0000:(tap0) 1k ui or 53.3ns \r\n\t0001:(tap1) 64k ui or 3.4us \r\n\t0010:(tap2) 128k ui or 6.8us \r\n\t0011:(tap3) 256k ui or 13.7us \r\n\t0100:(tap4) 512k ui or 27.3us \r\n\t0101:(tap5) 1m ui or 54,6us \r\n\t0110:(tap6) 2m ui or 109.2us \r\n\t0111:(tap7) 4m ui or 218.4us \r\n\t1000:(tap8) 8m ui or 436.7us \r\n\t1001:(tap9) 16m ui or 873.7us \r\n\t1010:(tap10) 32 ui or 1.7ms \r\n\t1011:(tap11) 64m ui or 3.5ms \r\n\t1100:(tap12) 8k us or 426.0ns \r\n\t1101:(tap13) 16k us or 852.0ns \r\n\t1110:(tap14) 32k us or 1.7us \r\n\t1111:inifinite
#define EDIP_RX_CTL_CNTL10_EO_PG                           0x800920000000003f, 48, 16 // register -- description
#define EDIP_RX_DACTEST_LLMT                               0x800928000000003f, 48,  9 // rx dactest control register : lower threshold limit
#define EDIP_RX_DACTEST_RESET                              0x800928000000003f, 57,  1 // rx dactest control register : reset
#define EDIP_RX_DACTEST_START                              0x800928000000003f, 58,  1 // rx dactest control register : start
#define EDIP_RX_CTL_CNTL11_EO_PG                           0x800928000000003f, 48, 16 // register -- description
#define EDIP_RX_DACTEST_HLMT                               0x800930000000003f, 48,  9 // rx dactest control register : higher threshold limit
#define EDIP_RX_CTL_CNTL12_EO_PG                           0x800930000000003f, 48, 16 // register -- description
#define EDIP_RX_HIST_MIN_EYE_WIDTH_VALID                   0x800938000000003f, 48,  1 // rx historic eye width minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_WIDTH_LANE                    0x800938000000003f, 49,  5 // rx historic eye width lane number
#define EDIP_RX_HIST_MIN_EYE_WIDTH                         0x800938000000003f, 54,  8 // rx historic eye width minimum value.
#define EDIP_RX_CTL_CNTL13_EO_PG                           0x800938000000003f, 48, 16 // register -- description
#define EDIP_RX_HIST_MIN_EYE_HEIGHT_VALID                  0x800940000000003f, 48,  1 // rx historic eye height minimum value and lane are valid.
#define EDIP_RX_HIST_MIN_EYE_HEIGHT_LANE                   0x800940000000003f, 49,  5 // rx historic eye height lane number.
#define EDIP_RX_HIST_MIN_EYE_HEIGHT                        0x800940000000003f, 54,  8 // rx historic eye height minimum value (peak-to-peak).
#define EDIP_RX_CTL_CNTL14_EO_PG                           0x800940000000003f, 48, 16 // register -- description
#define EDIP_RX_WTL_TEST_CLOCK                             0x800948000000003f, 48,  1 // signal from main wt machine to start testing clock lane
#define EDIP_RX_WTL_TEST_DATA                              0x800948000000003f, 49,  1 // signal from main wt machine to start testing data lane
#define EDIP_RX_WT_BS_CLOCK_EN_BYP                         0x800948000000003f, 50,  1 // when asserted, will force the bs enable for the clock, can be used to override the wt state machine controls
#define EDIP_RX_WT_BS_DATA_EN_BYP                          0x800948000000003f, 51,  1 // when asserted, will force the bs enable for the data, can be used to override the wt state machine controls
#define EDIP_RX_CTL_CNTL15_EO_PG                           0x800948000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_RESULT                               0x800950000000003f, 48,  8 // servo op result, read by global training state machine
#define EDIP_RX_CTL_STAT1_EO_PG                            0x800950000000003f, 48, 16 // register -- description
#define EDIP_RX_BIST_INIT_DONE                             0x800958000000003f, 48,  1 // this bit signals completion of the rx bist init state machine.
#define EDIP_RX_BIST_DONE                                  0x800958000000003f, 49,  1 // this bit signals completion of the entire rx bist procedure.
#define EDIP_RX_BIST_CU_PLL_ERR                            0x800958000000003f, 50,  1 // this bit indicates an error was detected during rx_cu_pll lock error \r\n\t0 no error \r\n\t1 error
#define EDIP_RX_BIST_NO_EDGE_DET                           0x800958000000003f, 51,  1 // this bit indicates that one eye was counted to be significantly large (over 60 phase rotator steps).
#define EDIP_RX_BIST_EYE_A_WIDTH                           0x800958000000003f, 52,  6 // this register holds the counted eye a width of one particular lane.
#define EDIP_RX_BIST_EYE_B_WIDTH                           0x800958000000003f, 58,  6 // this register holds the counted eye b width of one particular lane.
#define EDIP_RX_CTL_STAT2_EO_PG                            0x800958000000003f, 48, 16 // register -- description
#define EDIP_RX_WTL_SM_STATUS                              0x800960000000003f, 48,  5 // wiretest lane machine status
#define EDIP_RX_CTL_STAT3_EO_PG                            0x800960000000003f, 48, 16 // register -- description
#define EDIP_RX_EO_STEP_CNTL2_EDI_ALIAS                    0x800968000000003f, 48, 16 // rx eye optimization step control edi alias
#define EDIP_RX_EO_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL        0x800968000000003f, 48,  1 // rx eye optimization first latch offsett adjustment enable with ctle-based disable
#define EDIP_RX_EO_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL        0x800968000000003f, 49,  1 // rx eye optimization second latch offsett adjustment enable with ctle-based disable
#define EDIP_RX_EO_ENABLE_VGA_AMAX_MODE                    0x800968000000003f, 50,  1 // rx eye optimization vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define EDIP_RX_EO_ENABLE_DFE_H2_H12_SUBSTEP               0x800968000000003f, 51, 11 // rx eye optimization individual controls for dfe h2 to h12 tap optimization
#define EDIP_RX_EO_ENABLE_DFE_VOLTAGE_MODE                 0x800968000000003f, 62,  1 // rx eye optimization dfe h2 to h12 voltage-mode adjustment enable \r\n\t0: ap an h dual servo mode \r\n\t1: ap1 and ap0 measure mode
#define EDIP_RX_EO_ENABLE_DFE_H6_H12_FAST_MODE             0x800968000000003f, 63,  1 // rx eye optimization dfe h6 to h12 fast mode \r\n\t0: calibrate using both even and odd latches\r\n\t1: calibrate using even latches only
#define EDIP_RX_CTL_MODE26_EO_PG                           0x800968000000003f, 48, 16 // register -- description
#define EDIP_RX_RC_STEP_CNTL2_EDI_ALIAS                    0x800970000000003f, 48, 16 // rx recalibration    step control edi alias
#define EDIP_RX_RC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL        0x800970000000003f, 48,  1 // rx recalibration    first latch offset adjustment enable with ctle-based disable
#define EDIP_RX_RC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL        0x800970000000003f, 49,  1 // rx recalibratoin    second latch offset adjustment enable with ctle-based disable
#define EDIP_RX_RC_ENABLE_VGA_AMAX_MODE                    0x800970000000003f, 50,  1 // rx recalibration    vga ap measurement mode  \r\n\t0: apx111 - anx000 mode \r\n\t1: 2ap-amin mode
#define EDIP_RX_RC_ENABLE_DFE_H2_H12_SUBSTEP               0x800970000000003f, 51, 11 // rx recalibration    individual controls for dfe h2 to h12 tap optimization
#define EDIP_RX_RC_ENABLE_DFE_VOLTAGE_MODE                 0x800970000000003f, 62,  1 // rx recalibration    dfe h2 to h12 voltage-mode adjustment enable \r\n\t0: ap an h dual servo mode \r\n\t1: ap1 and ap0 measure mode
#define EDIP_RX_RC_ENABLE_DFE_H6_H12_FAST_MODE             0x800970000000003f, 63,  1 // rx recalibration    dfe h6 to h12 fast mode \r\n\t0: calibrate using both even and odd latches\r\n\t1: calibrate using even latches only
#define EDIP_RX_CTL_MODE27_EO_PG                           0x800970000000003f, 48, 16 // register -- description
#define EDIP_RX_DC_STEP_CNTL_EDI_ALIAS                     0x800978000000003f, 48,  7 // rx dc step control edi alias
#define EDIP_RX_DC_ENABLE_CM_COARSE_CAL                    0x800978000000003f, 48,  1 // rx dc cal eye optimization common mode coarse calibration enable
#define EDIP_RX_DC_ENABLE_CM_FINE_CAL                      0x800978000000003f, 49,  1 // rx dc cal eye optimization common mode fine calibration enable
#define EDIP_RX_DC_ENABLE_CTLE_1ST_LATCH_OFFSET_CAL        0x800978000000003f, 50,  1 // rx dc cal eye optimization latch offset adjustment enable done prior to ctle
#define EDIP_RX_DC_ENABLE_CTLE_2ND_LATCH_OFFSET_CAL        0x800978000000003f, 51,  1 // rx dc cal eye optimization latch offset adjustment enable done after to ctle
#define EDIP_RX_DC_ENABLE_INTEG_LATCH_OFFSET_CAL           0x800978000000003f, 52,  1 // rx dc cal eye optimization latch offset adjustment enable done prior to integrator
#define EDIP_RX_DC_ENABLE_DAC_H1_CAL                       0x800978000000003f, 53,  1 // rx dc cal eye optimization h1 dac calibration
#define EDIP_RX_DC_ENABLE_DAC_H1_TO_A_CAL                  0x800978000000003f, 54,  1 // rx dc cal eye optimization h1 dac to amplitude dac calibration
#define EDIP_RX_CTL_MODE28_EO_PG                           0x800978000000003f, 48, 16 // register -- description
#define EDIP_RX_START_LANE_ID                              0x800980000000003f, 49,  7 // this field is used to programmably set the first lane position in the group but relative to the bus.
#define EDIP_RX_END_LANE_ID                                0x800980000000003f, 57,  7 // this field is used to programmably set the last lane position in the group but relative to the bus.
#define EDIP_RX_ID2_PG                                     0x800980000000003f, 48, 16 // register -- description
#define EDIP_RX_MASTER_MODE                                0x800990000000003f, 48,  1 // master mode\r\n\tused to set a chip bus as the master side of the interface. the master side of the interface is where training is kicked off and coordinated in the logic.\r\n\t0:(slave) slave\r\n\t1:(master) master
#define EDIP_RX_DISABLE_FENCE_RESET                        0x800990000000003f, 49,  1 // set to disable clearing of the rx and tx fence controls at the end of training. \r\n\t0:(enable) clear the fence bit (default) \r\n\t1:(disable) leave the fence in its current state
#define EDIP_RX_FENCE                                      0x800990000000003f, 57,  1 // rx & tx fence bit\r\n\t0:(unfenced) functional data is being driven to & front nest logic\r\n\t1:(fenced) functional data is gated to zeroes to & from nest logic. also indicates that link training not yet complete.
#define EDIP_RX_PDWN_LITE_DISABLE                          0x800990000000003f, 58,  1 // disables the power down lite feature of unused spare lanes (generally should match tx_pdwn_lite_disable)
#define EDIP_RX_USE_SLS_AS_SPR                             0x800990000000003f, 59,  1 // determines whether the rx sls lane can be used as a spare lane on the bus to repair bad lanes (note: if yes, recal is disabled once the sls lane has been used as a spare lane.)\r\n\t(note: applies to tx side as well)
#define EDIP_RX_DYN_RECAL_SUSPEND                          0x800990000000003f, 60,  1 // suspend dynamic recalibration; otherwise starts automatically after link training
#define EDIP_RX_WT_PATTERN_LENGTH                          0x800990000000003f, 62,  2 // rx wiretest pattern length\r\n\tspecifies the length of n in the 3n-up/1n-down wiretest pattern.\r\n\t00:(128) 128 (default)\r\n\t01:(256) 256\r\n\t10:(512) 512\r\n\t11:(1024) 1024
#define EDIP_RX_CTL_MODE1_E_PG                             0x800990000000003f, 48, 16 // register -- description
#define EDIP_RX_WTR_MAX_BAD_LANES                          0x800998000000003f, 48,  5 // wiretest max number of bad lanes allowed per clk group\r\n\talso static repair, dynamic repair & recal max number of bad lanes per rx bus (note: should match tx side)
#define EDIP_RX_SLS_EXTEND_SEL                             0x800998000000003f, 53,  4 // how long to extend sending of the tx sls command (i.e. delay the gcr_wrt_done to the sending sm, see workbook table 4.10 for timer settings)
#define EDIP_RX_DYN_RPR_ENC_BAD_DATA_LANE_SHFT_AMT         0x800998000000003f, 57,  7 // crc/ecc dynamic repair: programmable register value that is subtracted from the enc_bad_data_lane value provided from the crc/ecc check logic (except for the all 1s clear pattern).  (e.g. should be set to 0x07 for the zmci logic to compensate for disabled lanes, but otherwise generally 0x00.  note: always check figtree for current settings, though, and not this comment!).
#define EDIP_RX_CTL_MODE2_E_PG                             0x800998000000003f, 48, 16 // register -- description
#define EDIP_RX_SLS_TIMEOUT_SEL                            0x8009a0000000003f, 48,  4 // selects spare lane signaling timeout value (how long to wait for a sls handshake command).  value must be 4x larger than tx_dyn_recal_interval_timeout_sel when doing recal aborts and 4x rx_dyn_recal_overall_timeout_sel. (see workbook table 4.4 for timer settings)
#define EDIP_RX_CL_TIMEOUT_SEL                             0x8009a0000000003f, 52,  4 // selects clock lock timeout value. (see workbook table 4.4 for timer settings)
#define EDIP_RX_DS_SKEW_TIMEOUT_SEL                        0x8009a0000000003f, 56,  4 // selects deskew  timeout value. (see workbook table 4.4 for timer settings)
#define EDIP_RX_DS_TIMEOUT_SEL                             0x8009a0000000003f, 60,  4 // selects deskew  timeout value. (see workbook table 4.4 for timer settings)
#define EDIP_RX_CTL_MODE3_E_PG                             0x8009a0000000003f, 48, 16 // register -- description
#define EDIP_RX_WT_CHECK_COUNT                             0x8009a8000000003f, 48,  5 // selects number of extra times the wiretest pattern is checked for a good lane
#define EDIP_RX_PGOOD_TIMEOUT_SEL                          0x8009a8000000003f, 53,  4 // selects pll pgood reset timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite
#define EDIP_RX_PLL_LOCK_TIMEOUT_SEL                       0x8009a8000000003f, 57,  4 // selects pll lock timeout value. \r\n\t000:(tap0) 64k ui or 6.8us \r\n\t001:(tap1) 128k ui or 13.6us \r\n\t010:(tap2) 256k ui or 27.3us \r\n\t011:(tap3) 1m ui or 109.2us \r\n\t100:(tap4) 2m ui or 218.5us \r\n\t101:(tap5) 4m ui or 436.9us \r\n\t110:(tap6) 8m ui or 873.8us \r\n\t111:(tap7) infinite
#define EDIP_RX_PSAVE_TIMER_WAKEUP_MODE                    0x8009a8000000003f, 61,  1 // enable wakeup timer on psave mode wakeup
#define EDIP_RX_PSAVE_WAKEUP_LANE0_ENABLE                  0x8009a8000000003f, 62,  1 // enable lane 0 at all times as the wakeup lane from psave mode
#define EDIP_RX_CTL_MODE4_E_PG                             0x8009a8000000003f, 48, 16 // register -- description
#define EDIP_RX_FIFO_INITIAL_L2U_DLY                       0x8009b0000000003f, 48,  4 // rx fifo initial load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 16-20 ui
#define EDIP_RX_FIFO_FINAL_L2U_DLY                         0x8009b0000000003f, 52,  4 // rx fifo final load to unload delay. for setting x, the latency is 4*x to 4*x+4 ui.  default is 8-12 ui
#define EDIP_RX_WT_TIMEOUT_SEL                             0x8009b0000000003f, 56,  4 // selects wiretest timeout value. (see workbook table 4.10 for timer settings)
#define EDIP_RX_CTL_MODE5_E_PG                             0x8009b0000000003f, 48, 16 // register -- description
#define EDIP_RX_TX_BUS_WIDTH                               0x8009b8000000003f, 48,  7 // tx bus width
#define EDIP_RX_RX_BUS_WIDTH                               0x8009b8000000003f, 55,  7 // rx bus width
#define EDIP_RX_CTL_MODE6_E_PG                             0x8009b8000000003f, 48, 16 // register -- description
#define EDIP_RX_SLS_DISABLE                                0x8009c0000000003f, 48,  1 // disables receiving & decoding of sls commands
#define EDIP_TX_SLS_DISABLE                                0x8009c0000000003f, 49,  1 // if set, the sls command being sent will always just be a nop.  to truly disable the full sls logic path, also do some combination of the following : set the rx_sls_disable, manually override the tx_snd_sls_cmd_gcrmsg per pack registers (if you do not also disable the various sending sms, though, this will eventually get overwritten), set tx_sls_lane_val_gcrmsg to 0 (if there is no valid tx sls lane, no sls command will get sent on it), and/or disable the recal, repair, recovery sms (rx_dyn_recal_suspend, rx_dyn_rpr_disable, rx_sls_rcvy_disable) that initiate the sending of sls commands
#define EDIP_RX_SLS_CNTR_TAP_PTS                           0x8009c0000000003f, 50,  2 // how long the sls rx command needs to be stable for.\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) 8 c16 clks\r\n\t01:(tap2) 16 c16 clks\r\n\t10:(tap3) 32 c16 clks\r\n\t11:(tap4) 64 c16 clks
#define EDIP_RX_NONSLS_CNTR_TAP_PTS                        0x8009c0000000003f, 52,  2 // how long a non-sls rx command needs to be stable for (to know we have switched from an sls command to data).\r\n\tneed to make sure this scales with tx_dyn_recal_interval_timeout & status_rpt_timeout\r\n\t00:(tap1) 16 c16 clks\r\n\t01:(tap2) 32 c16 clks\r\n\t10:(tap3) 64 c16 clks\r\n\t11:(tap4) 128 c16 clks
#define EDIP_RX_SLS_EXCEPTION2_CS                          0x8009c0000000003f, 59,  1 // hw235842: added chicken switch for new sls exception2 command.  need to set this when mixing allv3 and later logic with logic previous to allv3\r\n\tif set to 1, should set rx_sls_timeout_sel > 4x recal_overall_timeout_sel so avoid sending exception on sr interval and seeing false exception resmr
#define EDIP_RX_DYN_RPR_ERR_CNTR1_FILTER_MODE              0x8009c0000000003f, 60,  2 // to counteract possible dfe error ringing, select a filter that will ignore syndrome tally errors for a number of fast clock cycles after a counted error.\r\n\t00:(none) no filter, counts all errors \r\n\t01:(div2) skips 1 cycle after any error cycle \r\n\t10:(div4) skips 3 cycles after any error cycle \r\n\t11:(div8) skips 7 cycles after any error cycle
#define EDIP_RX_CTL_MODE7_E_PG                             0x8009c0000000003f, 48, 16 // register -- description
#define EDIP_RX_DYN_RPR_BAD_LANE_MAX                       0x8009c8000000003f, 48,  7 // crc/ecc dynamic repair: max number of times a lane can be found bad before repaired
#define EDIP_RX_DYN_RPR_ERR_CNTR1_DURATION                 0x8009c8000000003f, 55,  4 // crc/ecc dynamic repair: duration the lane error counter1 can run before being cleared (determines the allowed error frequency)\r\n\tin slow clock cycles:\r\n\t0000:(tap0)   32\r\n\t0001:(tap1) 1024\r\n\t0010:(tap2)   32k\r\n\t0011:(tap3)    1m\r\n\t0100:(tap4)    2m\r\n\t0101:(tap5)    4m\r\n\t0110:(tap6)    8m\r\n\t0111:(tap7)   16m\r\n\t1000:(tap8)   32m\r\n\t1001:(tap9)   64m\r\n\t1010:(tap10)  128m\r\n\t1011:(tap11)  256m\r\n\t1100:(tap12)  512m\r\n\t1101:(tap13)    1g\r\n\t1110:(tap14)    2g\r\n\t1111:(tap15) infinite
#define EDIP_RX_DYN_RPR_CLR_ERR_CNTR1                      0x8009c8000000003f, 59,  1 // crc/ecc dynamic repair: firmware-based clear of lane error counter1 register
#define EDIP_RX_DYN_RPR_DISABLE                            0x8009c8000000003f, 60,  1 // crc/ecc dynamic repair: when set, disables dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2)
#define EDIP_RX_DYN_RPR_ENC_BAD_DATA_LANE_WIDTH            0x8009c8000000003f, 61,  3 // crc/ecc dynamic repair: width of the enc_bad_data_lane vector used to determine number of 1s in clear code
#define EDIP_RX_CTL_MODE8_E_PG                             0x8009c8000000003f, 48, 16 // register -- description
#define EDIP_RX_DYN_RPR_BAD_BUS_MAX                        0x8009d0000000003f, 48,  7 // crc/ecc dynamic repair: max number of times crc or ecc errors can be found on the bus (not included in the bad lane cntr1 tally) before setting a fir error
#define EDIP_RX_DYN_RPR_ERR_CNTR2_DURATION                 0x8009d0000000003f, 55,  4 // crc/ecc dynamic repair: duration the bad bus cntr2 error counter can run before being divided by 2 (determines the allowed error frequency)\r\n\ton a 833ps & 1250ps slow clk:\r\n\t0000:(tap0) 26.7ns & 40.0ns\r\n\t0001:(tap1) 853.0ns & 1.3us\r\n\t0010:(tap2) 27.3us & 41.0us\r\n\t0011:(tap3) 873.5us & 1.3ms\r\n\t0100:(tap4) 1.7ms & 2.6ms\r\n\t0101:(tap5) 3.5ms & 5.1ms\r\n\t0110:(tap6) 7.0ms & 10.5ms\r\n\t0111:(tap7) 14.0ms & 21.0ms\r\n\t1000:(tap8) 28.0ms & 41.9ms\r\n\t1001:(tap9) 55.9ms & 83.9ms\r\n\t1010:(tap10) 111.8ms & 167.8ms\r\n\t1011:(tap11) 223.6ms & 335.5ms\r\n\t1100:(tap12) 447.2ms & 671.1ms\r\n\t1101:(tap13) 894.4ms & 1.3 s\r\n\t1110:(tap14) 1.8 s & 2.7 s\r\n\t1111:(tap15) infinite
#define EDIP_RX_DYN_RPR_CLR_ERR_CNTR2                      0x8009d0000000003f, 59,  1 // crc/ecc dynamic repair: firmware-based clear of bus error counter2 register
#define EDIP_RX_DYN_RPR_DISABLE2                           0x8009d0000000003f, 60,  1 // crc/ecc dynamic repair: when set, disables the repair from the dynamic repair error tallying (both per lane and per bus error counters...cntr1 & cntr2), however leaves the counters running
#define EDIP_RX_CTL_MODE9_E_PG                             0x8009d0000000003f, 48, 16 // register -- description
#define EDIP_RX_DESKEW_MAX_LIMIT                           0x8009d8000000003f, 48,  4 // maximum deskewable skew fail threshold \r\n\t000000:   0 ui \r\n\t000001:   2 ui \r\n\t000010:   4 ui \r\n\t000011:   6 ui \r\n\t000100:   8 ui \r\n\t000101:  10 ui \r\n\t000110:  12 ui \r\n\t000111:  14 ui \r\n\t001000:  16 ui \r\n\t001001:  18 ui \r\n\t001010:  20 ui \r\n\t001011:  22 ui > ei-4 max \r\n\t001100:  24 ui > ei-4 max \r\n\t001101:  26 ui > ei-4 max \r\n\t001110:  28 ui > ei-4 max \r\n\t001111:  30 ui > ei-4 max \r\n\t010000:  32 ui > ei-4 max \r\n\t010001:  34 ui > ei-4 max \r\n\t010010:  36 ui > ei-4 max \r\n\t010011:  38 ui > ei-4 max \r\n\t010100:  40 ui > ei-4 max \r\n\t010101:  42 ui > ei-4 max \r\n\t010110:  44 ui > ei-4 max \r\n\t010111:  46 ui > ei-4 & edi max \r\n\t011000:  48 ui > ei-4 & edi max \r\n\t011001:  50 ui > ei-4 & edi max \r\n\t011010:  52 ui > ei-4 & edi max \r\n\t011011:  54 ui > ei-4 & edi max \r\n\t011100:  56 ui > ei-4 & edi max \r\n\t011101:  58 ui > ei-4 & edi max \r\n\t011110:  60 ui > ei-4 & edi max \r\n\t011111:  62 ui > ei-4 & edi max \r\n\t100000:  64 ui > ei-4 & edi max \r\n\t100001:  66 ui > ei-4 & edi max \r\n\t100010:  68 ui > ei-4 & edi max \r\n\t100011:  70 ui > ei-4 & edi max \r\n\t100100:  72 ui > ei-4 & edi max \r\n\t100101:  74 ui > ei-4 & edi max \r\n\t100110:  76 ui > ei-4 & edi max \r\n\t100111:  78 ui > ei-4 & edi max \r\n\t101000:  80 ui > ei-4 & edi max \r\n\t101001:  82 ui > ei-4 & edi max \r\n\t101010:  84 ui > ei-4 & edi max \r\n\t101011:  86 ui > ei-4 & edi max \r\n\t101100:  88 ui > ei-4 max \r\n\t101101:  90 ui > ei-4 max \r\n\t101110:  92 ui > ei-4 max \r\n\t101111:  94 ui > ei-4 max \r\n\t110000:  96 ui > ei-4 max \r\n\t110001:  98 ui > ei-4 max \r\n\t110010: 100 ui > ei-4 max \r\n\t110011: 102 ui > ei-4 max \r\n\t110100: 104 ui > ei-4 max \r\n\t110101: 106 ui > ei-4 max \r\n\t110110: 108 ui > ei-4 max \r\n\t110111: 110 ui > ei-4 max \r\n\t111000: 112 ui > ei-4 & edi max \r\n\t111001: 114 ui > ei-4 & edi max \r\n\t111010: 116 ui > ei-4 & edi max \r\n\t111011: 118 ui > ei-4 & edi max \r\n\t111100: 120 ui > ei-4 & edi max \r\n\t111101: 122 ui > ei-4 & edi max \r\n\t111110: 124 ui > ei-4 & edi max \r\n\t111111: 126 ui > ei-4 & edi max
#define EDIP_RX_CTL_MODE10_E_PG                            0x8009d8000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_DISABLED_VEC_0_15                     0x8009e0000000003f, 48, 16 // used to set which of group lanes 0-15 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_RX_CTL_MODE11_E_PG                            0x8009e0000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_DISABLED_VEC_16_23                    0x8009e8000000003f, 48,  8 // used to set which of group lanes 16-23 are ignored by training logic.  these do not affect powerdown. assumption: disabled lanes must be contiguous.
#define EDIP_RX_CTL_MODE12_E_PG                            0x8009e8000000003f, 48, 16 // register -- description
#define EDIP_RX_START_WDERF_ALIAS                          0x8009f0000000003f, 48,  5 // alias for rx_start_* bits
#define EDIP_RX_START_WIRETEST                             0x8009f0000000003f, 48,  1 // when this register is written to a 1 the training state machine will run the wiretest portion of the training states.
#define EDIP_RX_START_DESKEW                               0x8009f0000000003f, 49,  1 // when this register is written to a 1 the training state machine will run the deskew portion of the training states.
#define EDIP_RX_START_EYE_OPT                              0x8009f0000000003f, 50,  1 // when this register is written to a 1 the training state machine will run the data eye optimization portion of the training states.
#define EDIP_RX_START_REPAIR                               0x8009f0000000003f, 51,  1 // when this register is written to a 1 the training state machine will run the static lane repair portion of the training states.
#define EDIP_RX_START_FUNC_MODE                            0x8009f0000000003f, 52,  1 // when this register is written to a 1 the training state machine will run the transition to functional data portion of the training states.
#define EDIP_RX_START_DC_CALIBRATE                         0x8009f0000000003f, 53,  1 // when this register is written to a 1 the training state machine will run the dc calibrate substeps definedin eye optimizations.
#define EDIP_RX_CTL_CNTL1_E_PG                             0x8009f0000000003f, 48, 16 // register -- description
#define EDIP_RX_WT_CU_PLL_PGOOD                            0x8009f8000000003f, 48,  1 // rx pll/dll enable\r\n\t1:(pgood) sets pgood on rx pll for locking \r\n\t0:(reset) places rx pll in reset
#define EDIP_RX_WT_CU_BYP_PLL_LOCK                         0x8009f8000000003f, 49,  1 // override rx pll/dll lock.  this should be ored into places where pll locked is checked (i.e. wt state machine), used to bypass waiting for a pll lock
#define EDIP_RX_WT_PLL_REFCLKSEL                           0x8009f8000000003f, 50,  1 // select between io clock and bist/refclock\r\n\t0:(io_clock) selects io clock \r\n\t1:(alt_refclk) selects bist refclock
#define EDIP_RX_PLL_REFCLKSEL_SCOM_EN                      0x8009f8000000003f, 51,  1 // selects between pll controls and gcr register to select refclk\r\n\t0:(pll_refclk_cntl) uses pll control to select refclk \r\n\t1:(scom_refclk) uses gcr register, rx_wt_pll_refclksel, to select refclock
#define EDIP_RX_IORESET                                    0x8009f8000000003f, 52,  1 // reset the given rx clock group including gcr slave
#define EDIP_RX_CTL_CNTL4_E_PG                             0x8009f8000000003f, 48, 16 // register -- description
#define EDIP_RX_CTL_CNTL6_E_PG                             0x800a08000000003f, 48, 16 // register -- description
#define EDIP_RX_DESKEW_SEQ_GCRMSG                          0x800a30000000003f, 48,  3 // rx deskew sequencer gcr messages\r\n\t000:(dsprevdeskewed) indicate prior group deskewed.\r\n\t001:(dsalldeskewed) indicate all groups deskewed.\r\n\t010:(dsprevdone) indicate prior group completed deskew.\r\n\t011:(dsalldone) indicate all groups completed deskew.\r\n\t100:(dsprevskew) transmit skew values from prior group.\r\n\t101:(dsmaxskew) transmit max skew values to all groups.\r\n\t110:(unused) unused.\r\n\t111:(dsnomsg) no message.
#define EDIP_RX_DESKEW_SKMIN_GCRMSG                        0x800a30000000003f, 52,  4 // min skew value for deskew sequence.
#define EDIP_RX_DESKEW_SKMAX_GCRMSG                        0x800a30000000003f, 56,  4 // max skew value for deskew sequence.
#define EDIP_RX_CTL_CNTLX11_E_PG                           0x800a30000000003f, 48, 16 // register -- description
#define EDIP_RX_WDERF_DONE_ALIAS                           0x800a38000000003f, 48,  5 // alias for rx_*_done bits
#define EDIP_RX_WIRETEST_DONE                              0x800a38000000003f, 48,  1 // when this bit is read as a 1, the wiretest training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_DESKEW_DONE                                0x800a38000000003f, 49,  1 // when this bit is read as a 1, the deskew training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_EYE_OPT_DONE                               0x800a38000000003f, 50,  1 // when this bit is read as a 1, the eye optimization training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_REPAIR_DONE                                0x800a38000000003f, 51,  1 // when this bit is read as a 1, the static lane repair training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_FUNC_MODE_DONE                             0x800a38000000003f, 52,  1 // when this bit is read as a 1, the transition to functional data training state has completed. check the corresponding rx_ts_*_failed register field for the pass/fail status of this training state.
#define EDIP_RX_DC_CALIBRATE_DONE                          0x800a38000000003f, 53,  1 // when this bit is read as a 1, the dc calibration steps have been completed. check the corresponding rx_dc_calibration_failed register field for the pass/fail status of operation state.
#define EDIP_RX_WDERF_FAILED_ALIAS                         0x800a38000000003f, 56,  5 // alias for rx_*_failed bits
#define EDIP_RX_WIRETEST_FAILED                            0x800a38000000003f, 56,  1 // when this bit is read as a 1, the wiretest training state encountered an error.
#define EDIP_RX_DESKEW_FAILED                              0x800a38000000003f, 57,  1 // when this bit is read as a 1, the deskew training state encountered an error.
#define EDIP_RX_EYE_OPT_FAILED                             0x800a38000000003f, 58,  1 // when this bit is read as a 1, the eye optimization training state encountered an error.
#define EDIP_RX_REPAIR_FAILED                              0x800a38000000003f, 59,  1 // when this bit is read as a 1, the static lane repair training state encountered an error.
#define EDIP_RX_CTL_STAT1_E_PG                             0x800a38000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_BAD_VEC_0_15                          0x800a40000000003f, 48, 16 // lanes found bad by hw (status) or method to force lane bad from software (control).  the bad_lane vector is only updated during initial training.
#define EDIP_RX_CTL_STAT2_E_PG                             0x800a40000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_BAD_VEC_16_23                         0x800a50000000003f, 48,  8 // lanes found bad by hw (status) or method to force lane bad from software (control).
#define EDIP_RX_CTL_STAT4_E_PG                             0x800a50000000003f, 48, 16 // register -- description
#define EDIP_RX_WT_CLK_LANE_INVERTED                       0x800a58000000003f, 49,  1 // clock wiretest lane inverted/swapped status \r\n\t0:(now_swapped) not swapped or inverted \r\n\t1:(swapped) p-n swapped or inverted
#define EDIP_RX_WT_CLK_LANE_BAD_CODE                       0x800a58000000003f, 50,  3 // clock wiretest lane bad code\r\n\t000:(no_error) lane tested good \r\n\t001:(n_stuck_1) n leg stuck at 1 \r\n\t010:(n_stuck_0) n leg stuck at 0 \r\n\t011:(p_stuck_1) p leg stuck at 1 \r\n\t100:(p_stuck_0) p leg stuck at 0 \r\n\t101:(n_or_p_floating) n  or p leg floating or swapping undetermined \r\n\t110:(not_used_110)unused.\r\n\t111:(not_used_111)unused
#define EDIP_RX_WT_CLK_LANE_STATUS_ALIAS                   0x800a58000000003f, 49,  4 // alias for rx_wt_clk_lane_inverted concatenated with rx_wt_clk_lane_bad_code \r\n\t0000: good lane--not inverted (edi and ei-4)\r\n\t0001: bad lane--n leg stuck at 1--not inverted (edi-only) \r\n\t0010: bad lane--n leg stuck at 0--not inverted (edi-only) \r\n\t0011: bad lane--p leg stuck at 1--not inverted (edi-only) \r\n\t0100: bad lane--p leg stuck at 0--not swapped/inverted (edi-only) \r\n\t0101: bad lane--n/(p) leg floating if (not) inverted (edi-only) \r\n\t0110: bad lane--p/(n) leg floating if (not) inverted (edi-only) \r\n\t0111: bad lane--p and n legs stuck at same value, 0 or 1 (edi only) \r\n\t1000: good lane--inverted (edi and ei-4) \r\n\t1001: bad lane--n leg stuck at 1--swapped or inverted (edi only) \r\n\t1010: bad lane--n leg stuck at 0--swapped or inverted (edi only) \r\n\t1011: bad lane--p leg stuck at 1--swapped or inverted (edi only) \r\n\t1100: bad lane--p leg stuck at 0--swapped or inverted (edi only) \r\n\t1101: bad lane--p leg stuck at 0--n leg stuck at 1 (edi and ei-4) \r\n\t1110: bad lane--p leg stuck at 1--n leg stuck at 0 (edi and ei-4) \r\n\t1111: bad lane--unknown reason--inversion undetermined (edi and ei-4)
#define EDIP_RX_CTL_STAT5_E_PG                             0x800a58000000003f, 48, 16 // register -- description
#define EDIP_RX_DESKEW_MINSKEW_GRP                         0x800a60000000003f, 48,  4 // deskew per-group raw skew min
#define EDIP_RX_DESKEW_MAXSKEW_GRP                         0x800a60000000003f, 52,  4 // deskew per-group raw skew max
#define EDIP_RX_CTL_STAT6_E_PG                             0x800a60000000003f, 48, 16 // register -- description
#define EDIP_RX_WT_PREV_DONE_GCRMSG                        0x800a68000000003f, 48,  1 // previous clk group has completed wiretest
#define EDIP_RX_WT_ALL_DONE_GCRMSG                         0x800a68000000003f, 49,  1 // all clk groups have completed wiretest
#define EDIP_RX_CNTLS_PREV_LDED_GCRMSG                     0x800a68000000003f, 52,  1 // previous clk group has finished updating rx sls/bad lane & repair controls
#define EDIP_RX_CTL_STATX8_E_PG                            0x800a68000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_GLBSM_SPARE_MODE_0                      0x800a80000000003f, 48,  1 // per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_1                      0x800a80000000003f, 49,  1 // per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_2                      0x800a80000000003f, 50,  1 // per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_3                      0x800a80000000003f, 51,  1 // repurposed spare mode as rx_chksw_do_deskew_ddcseed. set 1 to restore risky behavior of seeding prbs scramble pattern from live bus data prior to eyeopt.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_4                      0x800a80000000003f, 52,  1 // per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_5                      0x800a80000000003f, 53,  1 // per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_6                      0x800a80000000003f, 54,  1 // per-group spare mode latch.
#define EDIP_RX_PG_GLBSM_SPARE_MODE_7                      0x800a80000000003f, 55,  1 // per-group spare mode latch.
#define EDIP_RX_DESKEW_BUMP_AFTER                          0x800a80000000003f, 56,  1 // during deskew, choose to bump clock to center of data after lane deskewing operations have completed. prior to prbs sync.\r\n\t0:(before) bump to center before deskew starts.\r\n\t1:(after) bump to center before prbs sync starts.
#define EDIP_RX_SLS_RCVY_DISABLE                           0x800a80000000003f, 57,  1 // disable sls recovery state machine
#define EDIP_RX_SLS_HNDSHK_DISABLE                         0x800a80000000003f, 58,  1 // disable sls handshake state machine
#define EDIP_RX_GLBSM_SPARE_MODE_PG                        0x800a80000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR1_ERRS_FULL_REG                      0x800a88000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.
#define EDIP_RX_PG_FIR_ERR_PG_REGS                         0x800a88000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group rxctl registers.
#define EDIP_RX_PG_FIR_ERR_GCR_BUFF                        0x800a88000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group gcr buffer.
#define EDIP_RX_PG_FIR_ERR_GCRS_LD_SM                      0x800a88000000003f, 50,  1 // iotk alias: parity error has occurred in the per-group gcr load state machine.
#define EDIP_RX_PG_FIR_ERR_GCRS_UNLD_SM                    0x800a88000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group gcr unload state machine.
#define EDIP_RX_PG_FIR_ERR_GLBSM_REGS                      0x800a88000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_GLBSM_REGRW                     0x800a88000000003f, 53,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_DATASM_REGS                     0x800a88000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_DATASM_REGRW                    0x800a88000000003f, 55,  1 // iotk alias: parity error has occurred in the per-group gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_EYEOPT_SM                       0x800a88000000003f, 56,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_BIST_MAIN_STATE                 0x800a88000000003f, 57,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_BIST_INIT_STATE                 0x800a88000000003f, 58,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_RX_SERVO_SM                     0x800a88000000003f, 59,  1 // iotk alias: parity error has occurred in the per-group eye opt state machine.
#define EDIP_RX_PG_FIR_ERR_WORK_REGS                       0x800a88000000003f, 60,  1 // iotk alias: parity error has occurred in the per-group rx work regs.
#define EDIP_RX_PG_FIR_ERR_SET_SLS_LN_STATE                0x800a88000000003f, 61,  1 // iotk alias: parity error has occurred in the per-group rx stat repair state machine.
#define EDIP_RX_PL_FIR_ERR                                 0x800a88000000003f, 62,  1 // summary bit indicating an rx per-lane register or state machine parity error has occurred in one or more lanes. the rx_fir_pl register from each lane should be read to isolate to a particular piece of logic. there is no mechanism to determine which lane had the fault without reading fir status from each lane.
#define EDIP_RX_FIR1_PG                                    0x800a88000000003f, 48, 16 // register -- description
#define EDIP_FIR1_ERRS_MASK_FULL_REG                       0x800a90000000003f, 48, 16 // iotk alias: fir mask for rx_fir1_pg errors.
#define EDIP_RX_PG_FIR1_ERRS_MASK                          0x800a90000000003f, 48, 15 // fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_pg_regs) rxctl register parity error mask.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (mask_gcrs_ld_sm) rxctl gcr load state machine parity error mask.\r\n\tbit4: (mask_gcrs_unld_sm) rxctl gcr unload state machine parity error mask.\r\n\tbit5: (mask_snd_msg_sm) rxctl send message parity error mask.\r\n\tbit6: (mask_main_init_sm) rxctl main init sm parity error mask.\r\n\tbit7: (mask_wtm_sm) rxctl wiretest main sm parity error mask.
#define EDIP_FIR_ERR_MASK_PG_REGS                          0x800a90000000003f, 48,  1 // iotk alias: fir mask for the per-group rxctl register checker.
#define EDIP_FIR_ERR_MASK_GCR_BUFF                         0x800a90000000003f, 49,  1 // iotk alias: fir mask for the per-group rxctl gcr buffer.
#define EDIP_RX_PG_FIR_ERR_MASK_GCRS_LD_SM                 0x800a90000000003f, 50,  1 // iotk alias: fir mask for the per-group rxctl gcr load state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GCRS_UNLD_SM               0x800a90000000003f, 51,  1 // iotk alias: fir mask for the per-group rxctl gcr unload state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GLBSM_REGS                 0x800a90000000003f, 52,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GLBSM_REGRW                0x800a90000000003f, 53,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_DATASM_REGS                0x800a90000000003f, 54,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_DATASM_REGRW               0x800a90000000003f, 55,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_EYEOPT_SM                  0x800a90000000003f, 56,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_BIST_MAIN_STATE            0x800a90000000003f, 57,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_BIST_INIT_STATE            0x800a90000000003f, 58,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_RX_SERVO_SM                0x800a90000000003f, 59,  1 // iotk alias: fir mask for the per-group rxctl eye opt state machine checker.
#define EDIP_RX_PG_FIR_ERR_MASK_WORK_REGS                  0x800a90000000003f, 60,  1 // iotk alias: fir mask for the per-group rxctl work regs checker.
#define EDIP_RX_PG_FIR_ERR_MASK_SET_SLS_LN_STATE           0x800a90000000003f, 61,  1 // iotk alias: parity error has occurred in the per-group rx stat repair state machine.
#define EDIP_RX_PL_FIR_ERR_MASK                            0x800a90000000003f, 62,  1 // fir mask for the summary bit that indicates an rx register or state machine parity error has occurred. this mask bit is used to block all per-lane parity errors from causing a fir error.
#define EDIP_RX_FIR1_MASK_PG                               0x800a90000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR1_ERR_INJ_FULL_REG                   0x800a98000000003f, 48, 16 // iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define EDIP_RX_PG_FIR1_ERR_INJ                            0x800a98000000003f, 48, 15 // rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_pg_regs) rxctl register parity error inject.\r\n\tbit1: reserved.\r\n\tbit2: reserved.\r\n\tbit3: (inj_gcrs_ld_sm) rxctl gcr load state machine parity error inject.\r\n\tbit4: (inj_gcrs_unld_sm) rxctl gcr unload state machine parity error inject.\r\n\tbit5: (inj_snd_msg_sm) rxctl send message parity error inject.\r\n\tbit6: (inj_main_init_sm) rxctl main init sm parity error inject).\r\n\tbit7: (inj_wtm_sm) rxctl wiretest main sm parity error inject.\r\n\tbit8: (inj_wtr_sm) rxctl wiretest rx sm parity error inject.\r\n\tbit9: (inj_wtl_sm) rxctl wiretest lane sm parity error inject.\r\n\tbit10: (inj_rpr_sm) rxctl repair sm parity error inject.\r\n\tbit11: (inj_eyeopt_sm) rxctl eyeopt sm parity error inject.\r\n\tbit12: (inj_dsm_sm) rxctl deskew sm parity error inject.\r\n\tbit13: (inj_rxdsm_sm) rxctl rx deskew sm parity error inject.
#define EDIP_RX_PG_FIR_ERR_INJ_PG_REGS                     0x800a98000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl mode registers parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GCR_BUFF                    0x800a98000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr bufferr.
#define EDIP_RX_PG_FIR_ERR_INJ_GCRS_LD_SM                  0x800a98000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr load state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GCRS_UNLD_SM                0x800a98000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr unload state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GLBSM_REGS                  0x800a98000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GLBSM_REGRW                 0x800a98000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DATASM_REGS                 0x800a98000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DATASM_REGRW                0x800a98000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_EYEOPT_SM                   0x800a98000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_BIST_MAIN_STATE             0x800a98000000003f, 57,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_BIST_INIT_STATE             0x800a98000000003f, 58,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RX_SERVO_SM                 0x800a98000000003f, 59,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WORK_REGS                   0x800a98000000003f, 60,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl work regs checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SET_SLS_LN_STATE            0x800a98000000003f, 61,  1 // iotk alias: parity error has occurred in the per-group rx stat repair state machine.
#define EDIP_RX_FIR1_ERROR_INJECT_PG                       0x800a98000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR_TRAINING_ERROR                      0x800aa0000000003f, 48,  1 // this field is now defunct and is permanently masked in the rx_fir_training_mask_pg fir isolation register.
#define EDIP_RX_PG_FIR_STATIC_SPARE_DEPLOYED               0x800aa0000000003f, 49,  1 // a spare lane has been deployed during training to heal a lane that was detected as bad. rx_static_spare_deployed (ssd) will be set after the repair training step if during training either wiretest, deskew, eyeopt or repair has detected one or more bad lanes have been detected. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed and the rx_bad_lane.
#define EDIP_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED          0x800aa0000000003f, 50,  1 // a lane has been detected as bad during training but there are no spare lanes available to heal it. this fir will not be set until the repair training step has been run. this is a catastrophic failure for the bus when in mission mode but all training steps will still be run on whatever good lanes there are. rx_static_max_spares_exceeded will be set if wiretest, deskew, eyeopt or repair find the excessive number of bad lanes.
#define EDIP_RX_PG_FIR_DYNAMIC_REPAIR_ERROR                0x800aa0000000003f, 51,  1 // a dynamic repair error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.
#define EDIP_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED              0x800aa0000000003f, 52,  1 // a spare lane has been deployed by ecc/crc logic to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.
#define EDIP_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED         0x800aa0000000003f, 53,  1 // a lane has been detected as bad by ecc/crc logic but there are no spare lanes to heal it. this is a catastrophic failure for the bus.
#define EDIP_RX_PG_FIR_RECAL_ERROR                         0x800aa0000000003f, 54,  1 // a recalibration error has occurred. the recal error ffdc registers should be read to help isolate to a particular piece of logic.
#define EDIP_RX_PG_FIR_RECAL_SPARE_DEPLOYED                0x800aa0000000003f, 55,  1 // a spare lane has been deployed during recal to heal a lane that was detected as bad. the rx_bad_lane_enc_gcrmsg_pg register can be read to isolate which lane(s) were healed.
#define EDIP_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED           0x800aa0000000003f, 56,  1 // a lane has been detected as bad during recal but there are no spare lanes to heal it. this is a catastrophic failure for the bus.
#define EDIP_RX_PG_FIR_TOO_MANY_BUS_ERRORS                 0x800aa0000000003f, 57,  1 // more than one lane has been detected as having too many errors during functional operation. this is a catastrophic failure for the bus.
#define EDIP_RX_FIR_TRAINING_PG                            0x800aa0000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR_TRAINING_ERROR_MASK                 0x800aa8000000003f, 48,  1 // fir mask for rx_pg_fir_training_error.
#define EDIP_RX_PG_FIR_STATIC_SPARE_DEPLOYED_MASK          0x800aa8000000003f, 49,  1 // fir mask for rx_pg_fir_static_spare_deployed.
#define EDIP_RX_PG_FIR_STATIC_MAX_SPARES_EXCEEDED_MASK     0x800aa8000000003f, 50,  1 // fir mask for rx_pg_fir_static_max_spares_exceeded.
#define EDIP_RX_PG_FIR_DYNAMIC_REPAIR_ERROR_MASK           0x800aa8000000003f, 51,  1 // fir mask for rx_pg_fir_dynamic_repair_error
#define EDIP_RX_PG_FIR_DYNAMIC_SPARE_DEPLOYED_MASK         0x800aa8000000003f, 52,  1 // fir mask for rx_pg_fir_dynamic_spare_deployed.
#define EDIP_RX_PG_FIR_DYNAMIC_MAX_SPARES_EXCEEDED_MASK    0x800aa8000000003f, 53,  1 // fir mask for rx_pg_fir_dynamic_max_spares_exceeded.
#define EDIP_RX_PG_FIR_RECAL_ERROR_MASK                    0x800aa8000000003f, 54,  1 // fir mask for rx_pg_fir_recal_error.
#define EDIP_RX_PG_FIR_RECAL_SPARE_DEPLOYED_MASK           0x800aa8000000003f, 55,  1 // fir mask for rx_pg_fir_recal_spare_deployed.
#define EDIP_RX_PG_FIR_RECAL_MAX_SPARES_EXCEEDED_MASK      0x800aa8000000003f, 56,  1 // fir mask for rx_pg_fir_recal_max_spares_exceeded.
#define EDIP_RX_PG_FIR_TOO_MANY_BUS_ERRORS_MASK            0x800aa8000000003f, 57,  1 // fir mask for rx_pg_fir_too_many_bus_errors.
#define EDIP_RX_FIR_TRAINING_MASK_PG                       0x800aa8000000003f, 48, 16 // register -- description
#define EDIP_RX_CLR_PAR_ERRS                               0x800ab0000000003f, 62,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define EDIP_RX_FIR_RESET                                  0x800ab0000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset all rx fir related latches including the isolation and parity error latches.
#define EDIP_RX_GLBSM_CNTLX1_EO_PG                         0x800ab0000000003f, 48, 16 // register -- description
#define EDIP_RX_EYE_OPT_STATE                              0x800ab8000000003f, 48, 12 // eye optimizaton state machine current state
#define EDIP_RX_GLBSM_STAT1_EO_PG                          0x800ab8000000003f, 48, 16 // register -- description
#define EDIP_RX_RECAL_CNT                                  0x800ac0000000003f, 48, 16 // number of times bus has been recalibrated since initialization
#define EDIP_RX_GLBSM_STAT2_EO_PG                          0x800ac0000000003f, 48, 16 // register -- description
#define EDIP_RX_DACTEST_ISGT                               0x800ac8000000003f, 48,  1 // rx dactest control register : is greater than
#define EDIP_RX_DACTEST_ISLT                               0x800ac8000000003f, 49,  1 // rx dactest control register : is lesser than
#define EDIP_RX_DACTEST_ISEQ                               0x800ac8000000003f, 50,  1 // rx dactest control register : is equal to
#define EDIP_RX_DACTEST_DIFF                               0x800ac8000000003f, 51,  9 // rx dactest control register : difference
#define EDIP_RX_GLBSM_STAT3_EO_PG                          0x800ac8000000003f, 48, 16 // register -- description
#define EDIP_RX_INT_REQ                                    0x800ad0000000003f, 48, 16 // rx interrupt request isolation latch
#define EDIP_RX_GLBSM_STAT4_EO_PG                          0x800ad0000000003f, 48, 16 // register -- description
#define EDIP_RX_LANE_CURRENTLY_INITIALIZING                0x800ad8000000003f, 48,  1 // rx_current_recal_init_lane is being initialized
#define EDIP_RX_LANE_CURRENTLY_RECALIBRATING               0x800ad8000000003f, 49,  1 // rx_current_recal_init_lane is being recalibrated
#define EDIP_RX_CURRENT_RECAL_INIT_LANE                    0x800ad8000000003f, 50,  5 // number oflane that currently being initialized or recalibrated
#define EDIP_RX_MANUAL_RECAL_DONE                          0x800ad8000000003f, 55,  1 // manual recalibration done handshake signal
#define EDIP_RX_GLBSM_STAT5_EO_PG                          0x800ad8000000003f, 48, 16 // register -- description
#define EDIP_RX_DYN_RPR_REQ_MANUAL                         0x800ae0000000003f, 48,  1 // when rx_dyn_rpr_sm_manual is set, this bit will request a dynamic repair of the encoded lane set in rx_enc_bus_lane2rpr_manual.
#define EDIP_RX_CNT_SINGLE_LANE_RECAL                      0x800ae0000000003f, 49,  1 // single lane recalibration monitor mode \r\n\t0:increment recalibration counter every time any lane completes recal\r\n\t1:increment recalibration counter only when recalibrating lane designated by rx_recal_lane_to_monitor
#define EDIP_RX_RECAL_LANE_TO_MONITOR                      0x800ae0000000003f, 50,  5 // designate lane to monitor when rx_cnt_single_lane_recal is 1
#define EDIP_RX_DYN_RPR_SM_MANUAL                          0x800ae0000000003f, 55,  1 // when set this bit only allows the dynamic repair state machine to respond to a repair request from the rx_dyn_rpr_req_manual register bit. to run syndrome tallying without triggering the dynamic repair state machine, set this bit and clear rx_dyn_rpr_disable.
#define EDIP_RX_DIS_SYND_TALLYING                          0x800ae0000000003f, 56,  1 // when set this bit prevents syndrome tallying logic from counting any incoming errors reported.
#define EDIP_RX_ENC_BUS_LANE2RPR_MANUAL                    0x800ae0000000003f, 57,  7 // if a manual dynamic repair is requested (rx_dyn_rpr_req_manual), this is the lane to repair.  this value should be set to the physical lane to repair, not the functional data lane.
#define EDIP_RX_GLBSM_CNTL2_EO_PG                          0x800ae0000000003f, 48, 16 // register -- description
#define EDIP_RX_MANUAL_RECAL_REQUEST                       0x800ae8000000003f, 48,  1 // recal request from microcontroller
#define EDIP_RX_MANUAL_RECAL_LANE                          0x800ae8000000003f, 51,  5 // recal lane from microcontroller
#define EDIP_RX_SLS_TIMEOUT_EXT_SEL                        0x800ae8000000003f, 56,  2 // selects an extension multiplier for the rx_sls_timeout_sel register\r\n\t00: no change to rx_sls_timeout_sel\r\n\t01: 2x rx_sls_timeout_sel\r\n\t10: 4x rx_sls_timeout_sel\r\n\t11: 8x rx_sls_timeout_sel
#define EDIP_RX_HALF_RATE_MODE_GLBSM                       0x800ae8000000003f, 58,  1 // when set to 1, enables timers on the slow clock domain to consistently count ui when in 4-bit legacy mode.  otherwise, slow clock domain counts only half of the ui noted in the timeouts documentation when in 4-bit legacy mode.
#define EDIP_RX_GLBSM_CNTL3_EO_PG                          0x800ae8000000003f, 48, 16 // register -- description
#define EDIP_RX_CLR_RECAL_CNT                              0x800af0000000003f, 48,  1 // clear recalibration counter to zero.\r\n\t0:normal incrementing\1:reset counter to zero
#define EDIP_RX_INT_RETURN                                 0x800af0000000003f, 49,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear all rx parity error latches.
#define EDIP_RX_MANUAL_RECAL_ABORT                         0x800af0000000003f, 50,  1 // recal abort from microcontroller
#define EDIP_RX_MANUAL_RECAL_CONTINUE                      0x800af0000000003f, 51,  1 // recal continue from microcontroller--pulsed version
#define EDIP_RX_GLBSM_CNTL4_EO_PG                          0x800af0000000003f, 48, 16 // register -- description
#define EDIP_RX_RPR_TX_LD_CNTLS_TIMEOUT_SEL                0x800af8000000003f, 48,  4 // selects timeout value for waiting for tx to load repair controls. (see workbook table 4.4 for timer settings)
#define EDIP_RX_TX_SLS_LN_MV_TIMEOUT_SEL                   0x800af8000000003f, 52,  4 // selects timeout value for waiting for tx to move the sls lane. (see workbook table 4.4 for timer settings)
#define EDIP_RX_DESKEW_SKIP_OFFSET                         0x800af8000000003f, 56,  1 // select to skip path offset cancellation step during early block lock. default state is disabled unless it is found block lock cannot reliably lock on large latch offset. \r\n\t0:(enable)   enable offset cancel\r\n\t1:(skip)   skip offset cancel (default)
#define EDIP_RX_GLBSM_MODE1_EO_PG                          0x800af8000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR2_ERRS_FULL_REG                      0x800b00000000003f, 48, 16 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-group logic.
#define EDIP_RX_PG_FIR_ERR_DYN_RPR_SM                      0x800b00000000003f, 48,  1 // iotk alias: parity error has occurred in the per-group lane repair logic state machine.
#define EDIP_RX_PG_FIR_ERR_DYN_RPR_SND_MSG_SM              0x800b00000000003f, 49,  1 // iotk alias: parity error has occurred in the per-group lane repair logic gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_SLS_ENC_SND_MSG_SM              0x800b00000000003f, 50,  1 // iotk alias: parity error has occurred in the per-group sls encode gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_SLS_HNDSHK_SM                   0x800b00000000003f, 51,  1 // iotk alias: parity error has occurred in the per-group lane repair logic sls state machine.
#define EDIP_RX_PG_FIR_ERR_SLS_RCVY_SM                     0x800b00000000003f, 52,  1 // iotk alias: parity error has occurred in the per-group stat repair sls recovery state machine.
#define EDIP_RX_PG_FIR_ERR_RECAL_SM                        0x800b00000000003f, 53,  1 // iotk alias: parity error has occurred in the per-group recalibration state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_DYN_RECAL_HNDSHK_SM             0x800b00000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group dynamic recalibration handshake state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_GLB_CAL_SND_MSG_SM              0x800b00000000003f, 55,  1 // iotk alias: parity error has occurred in the per-group global cal gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_STAT_RPR_SND_MSG_SM             0x800b00000000003f, 56,  1 // iotk alias: parity error has occurred in the per-group stat repair gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MAIN_INIT_SM                    0x800b00000000003f, 57,  1 // iotk alias: parity error has occurred in the per-group main init state machine.
#define EDIP_RX_PG_FIR_ERR_WTM_SM                          0x800b00000000003f, 58,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_WTR_SM                          0x800b00000000003f, 59,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_WTL_SM                          0x800b00000000003f, 60,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_RPR_SM                          0x800b00000000003f, 61,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_DSM_SM                          0x800b00000000003f, 62,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_RXDSM_SM                        0x800b00000000003f, 63,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.
#define EDIP_RX_FIR2_PG                                    0x800b00000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR2_ERRS_MASK_FULL_REG                 0x800b08000000003f, 48, 16 // iotk alias: fir mask for rx_fir2_pg errors.
#define EDIP_RX_PG_FIR2_ERRS_MASK                          0x800b08000000003f, 48, 16 // fir mask for register or state machine parity checkers in per-group rx logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (mask_dyn_rpr_sm) rxctl dynamic repair sm parity error mask.\r\n\tbit1: (mask_sls_hndshk_sm) rxctl sls handshake sm parity error mask.\r\n\tbit2: (mask_rpr_snd_msg_sm) rxctl repair send message sm parity error mask.\r\n\tbit3: (mask_recal_sm) rxctl recal state machine parity error mask.
#define EDIP_RX_PG_FIR_ERR_MASK_DYN_RPR_SM                 0x800b08000000003f, 48,  1 // iotk alias: fir mask for the per-group dynamic lane repair logic state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_DYN_RPR_SND_MSG_SM         0x800b08000000003f, 49,  1 // iotk alias: fir mask for the per-group dynamic lane repair logic gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_SLS_ENC_SND_MSG_SM         0x800b08000000003f, 50,  1 // iotk alias: fir mask for the per-group sls encode gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_SLS_HNDSHK_SM              0x800b08000000003f, 51,  1 // iotk alias: fir mask for the per-group lane repair logic sls state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_SLS_RCVY_SM                0x800b08000000003f, 52,  1 // iotk alias: fir mask for the per-group sls recovery state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_RECAL_SM                   0x800b08000000003f, 53,  1 // iotk alias: fir mask for the per-group recalibration state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_DYN_RECAL_HNDSHK_SM        0x800b08000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group dynamic recalibration handshake state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_GLB_CAL_SND_MSG_SM         0x800b08000000003f, 55,  1 // iotk alias: fir mask for the per-group global cal gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_STAT_RPR_SND_MSG_SM        0x800b08000000003f, 56,  1 // iotk alias: fir mask for the per-group stat repair gcr send message state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_MAIN_INIT_SM               0x800b08000000003f, 57,  1 // iotk alias: parity error has occurred in the per-group main init state machine.
#define EDIP_RX_PG_FIR_ERR_MASK_WTM_SM                     0x800b08000000003f, 58,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_WTR_SM                     0x800b08000000003f, 59,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_WTL_SM                     0x800b08000000003f, 60,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_RPR_SM                     0x800b08000000003f, 61,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_DSM_SM                     0x800b08000000003f, 62,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_MASK_RXDSM_SM                   0x800b08000000003f, 63,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.
#define EDIP_RX_FIR2_MASK_PG                               0x800b08000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_FIR2_ERR_INJ_FULL_REG                   0x800b10000000003f, 48, 16 // iotk alias: rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define EDIP_RX_PG_FIR2_ERR_INJ                            0x800b10000000003f, 48, 16 // rx per-group parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (inj_dyn_rpr_sm) rxctl dynamic repair sm parity error inject.\r\n\tbit1: (inj_sls_hndshk_sm) rxctl sls handshake sm parity error inject.\r\n\tbit2: (inj_rpr_snd_msg_sm) rxctl repair send message sm parity error inject.\r\n\tbit3: (inj_recal_sm) rxctl recal state machine parity error inject.
#define EDIP_RX_PG_FIR_ERR_INJ_DYN_RPR_SM                  0x800b10000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on per-group lane repair logic state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DYN_RPR_SND_MSG_SM          0x800b10000000003f, 49,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group dynamic lane repair logic gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SLS_ENC_SND_MSG_SM          0x800b10000000003f, 50,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls encode gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SLS_HNDSHK_SM               0x800b10000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group lane repair logic sls state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_SLS_RCVY_SM                 0x800b10000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group sls recovery state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RECAL_SM                    0x800b10000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group recalibration state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DYN_RECAL_HNDSHK_SM         0x800b10000000003f, 54,  1 // iotk alias: parity error has occurred in the per-group dynamic recalibration handshake state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_GLB_CAL_SND_MSG_SM          0x800b10000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group global cal gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_STAT_RPR_SND_MSG_SM         0x800b10000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group stat repair gcr send message state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_MAIN_INIT_SM                0x800b10000000003f, 57,  1 // iotk alias: parity error has occurred in the per-group main init state machine.
#define EDIP_RX_PG_FIR_ERR_INJ_WTM_SM                      0x800b10000000003f, 58,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl main wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WTR_SM                      0x800b10000000003f, 59,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl receiver wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_WTL_SM                      0x800b10000000003f, 60,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl lane wiretest state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RPR_SM                      0x800b10000000003f, 61,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rxctl repair state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_DSM_SM                      0x800b10000000003f, 62,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group main deskew state machine parity checker.
#define EDIP_RX_PG_FIR_ERR_INJ_RXDSM_SM                    0x800b10000000003f, 63,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-group rx deskew state machine parity checker.
#define EDIP_RX_FIR2_ERROR_INJECT_PG                       0x800b10000000003f, 48, 16 // register -- description
#define EDIP_RX_MAIN_INIT_STATE                            0x800b18000000003f, 48,  4 // main initialization state machine(rjr):\r\n\t0000: idle\r\n\t0001: wiretest running\r\n\t0010: deskew running\r\n\t0011: eye optimization running\r\n\t0100: repair running\r\n\t0101: go functional running\r\n\t1001: wiretest failed\r\n\t:1010: deskew failed\r\n\t1011: eye optimization failed\r\n\t1100: repair failed\r\n\t1101: go functional failed\r\n\tothers:  unused
#define EDIP_RX_WTM_STATE                                  0x800b18000000003f, 52,  6 // main wiretest state machine current state (rjr)): \r\n\tx00: idle \r\n\tx01: drv data  wt \r\n\tx02: drv clock wt \r\n\tx03: drv data  0 \r\n\tx04: drv clock 0 \r\n\tx05: rx wt \r\n\tx06: wait all ones \r\n\tx07: reset pll \r\n\tx08: wait pll \r\n\tx09: drive clock \r\n\tx0a: drive data 1 \r\n\tx0b: wait all zeroes \r\n\tx0c: drive data 0 \r\n\tx0d: done \r\n\tx0e: unused \r\n\tx0f: unused \r\n\tx10: wait prev done \r\n\tx11: drv prev done \r\n\tx12: drv all done \r\n\tx13: wait all done \r\n\tx14: init tx fifo \r\n\tx15: unused \r\n\tx16: unused \r\n\tx17: unused \r\n\tx18: set c & d dr strength \r\n\tx19: set data only dr strength \r\n\tx1a: clock fail \r\n\tx1b: all bad lanes \r\n\tx1c: wt timeout fail \r\n\tx1d: pll/dll fail \r\n\tx1e: all ones fail \r\n\tx1f: all zeroes fail
#define EDIP_RX_WTR_STATE                                  0x800b18000000003f, 58,  5 // receiver wiretest state machine current state (rjr):x0: idle\r\n\tx1: check clock\r\n\tx2: check lane disabled\r\n\tx3: check data lane\r\n\tx4: store data lane results\r\n\tx5: check if done\r\n\tx6: done--passed\r\n\t: done--failed\r\n\t:x8-xf: unused
#define EDIP_RX_WT_CU_PLL_LOCK                             0x800b18000000003f, 63,  1 // rx pll locked
#define EDIP_RX_GLBSM_STAT1_E_PG                           0x800b18000000003f, 48, 16 // register -- description
#define EDIP_RX_WTR_CUR_LANE                               0x800b20000000003f, 48,  5 // wiretest current lane under test
#define EDIP_RX_WTR_BAD_LANE_COUNT                         0x800b20000000003f, 59,  5 // wiretest current number of bad lanes in this clk group
#define EDIP_RX_GLBSM_STAT2_E_PG                           0x800b20000000003f, 48, 16 // register -- description
#define EDIP_RX_DSM_STATE                                  0x800b28000000003f, 50,  6 // main deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init tx fifo\r\n\tx02: master driver patt b\r\n\tx03:block lock\r\n\tx04: check skew\r\n\tx05:send skew to other groups\r\n\tx06: wait for max skew message\r\n\tx07: check max skew\r\n\tx08: deskew group\r\n\tx09: send deskewed message\r\n\tx0a: wait for all deskewd message\r\n\tx0b: deskew group\r\n\tx0c: drive prbs sync\r\n\tx0d: wait for prbs synced\r\n\tx0e: send done message\r\n\tx0f: wait for all done message\r\n\tx10: slave drive patt a\r\n\tx11: enable prbs sync checking\r\n\t:x12-x1e: unused\r\n\tx1f: deskew done\r\n\tx20-x22: unused\r\n\tx23: block lock failed\r\n\tx24: group skew measure fail--timeout\r\n\tx25: group skew fail-rxdsm fail\r\n\tx25: bus deskew fail\r\n\tx27: max skew in group fail\r\n\tx28: group deskew timeout fail\r\n\tx29: unused\r\n\tx2a: bus deskew timeout fail\r\n\tx2b-x2c: unused\r\n\tx2d: wait prbs sync timeout fail\r\n\tx2e: timeout while sending done message fail\r\n\tx2f: timeout waiting for bus deskew all done message fail\r\n\tx30-x3f: unused
#define EDIP_RX_RXDSM_STATE                                0x800b28000000003f, 57,  7 // rx deskew state machine current state (rjr):\r\n\tx00: idle\r\n\tx01: init rx fifo\r\n\tx02: start block lock\r\n\tx03:read block lock status\r\n\tx04: check block lock status\r\n\tx05:check lane valid\r\n\tx06: check max lane count\r\n\tx07: lane block lock status\r\n\tx08: write bad lane block lock\r\n\tx09: block lock done\r\n\tx0a: start check skew\r\n\tx0b: read skew status\r\n\tx0c: check skew status\r\n\tx0d: check valid lanes for skew\r\n\tx0e: check max lane count\r\n\tx0f: read first valid lane skew status\r\n\tx10: write bad skew status\r\n\tx11: check lane count\r\n\t:x12: check other lanes valid\r\n\tx13: read lane skew status\r\n\tx14: write lane bad skew stus\r\n\tx15: send rx skew valid to main deskew machine\r\n\tx16: check lane valid for deskew\r\n\tx17: read skew for deskewing\r\n\tx18:  write new rx fifo load-unload delay\r\n\tx19: write bad skew status\r\n\tx1a check last lane for done\r\n\tx1bb: clear skew status\r\n\tx1c: read global skew status\r\n\tx1d: check global skew status\r\n\tx1e: check lane valid for deskew check\r\n\tx1f: read lane deskew status\r\n\tx20: check lane count for done\r\n\tx21: stop checking skew\r\n\tx22: wait for check prbs sync signal\r\n\tx23: read prbs sync status\r\n\tx24: check prbs sync status\r\n\tx25: prbs synced/deskew done\r\n\tx26: clear deskew control\r\n\tx27: write bad deskew status\r\n\tx28-4d: unused\r\n\tx4e: skew error oddbadd fail\r\n\tx4f-7f: unused
#define EDIP_RX_GLBSM_STAT3_E_PG                           0x800b28000000003f, 48, 16 // register -- description
#define EDIP_RX_RPR_STATE                                  0x800b30000000003f, 48,  7 // static repair state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_rpr_state
#define EDIP_RX_SLS_RCVY_STATE                             0x800b30000000003f, 56,  5 // sls recovery state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_rcvy_state
#define EDIP_RX_GLBSM_STAT4_E_PG                           0x800b30000000003f, 48, 16 // register -- description
#define EDIP_RX_SLS_CMD_VAL                                0x800b48000000003f, 48,  1 // current sls command valid
#define EDIP_RX_NONSLS_CMD                                 0x800b48000000003f, 49,  1 // current data is non-sls command
#define EDIP_RX_SLS_CMD_ENCODE                             0x800b48000000003f, 50,  6 // current sls command
#define EDIP_RX_ENC_BUS_LANE2RPR                           0x800b48000000003f, 56,  7 // if a repair is requested, this is the lane to repair.
#define EDIP_RX_REPAIR_REQ                                 0x800b48000000003f, 63,  1 // when 1, dynamic repair of a bad lane is requested.
#define EDIP_RX_GLBSM_STAT7_E_PG                           0x800b48000000003f, 48, 16 // register -- description
#define EDIP_RX_SLS_USED_AS_SPR                            0x800b50000000003f, 48,  1 // when 1, indicates that the sls lane has been used as a spare lane, which disables recal on all lanes.  enabled by rx_use_sls_as_spr.
#define EDIP_RX_DYN_RPR_STATE                              0x800b50000000003f, 50,  6 // dynamic repair main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_rpr_state
#define EDIP_RX_SLS_HNDSHK_STATE                           0x800b50000000003f, 56,  8 // sls handshake state machine (for dynamic repair & recalibration)\r\n\tdetailed drawing can be found in the workbook by searching for rx_sls_hndshk_state
#define EDIP_RX_GLBSM_STAT8_E_PG                           0x800b50000000003f, 48, 16 // register -- description
#define EDIP_RX_BAD_LANE_ENC_ALIAS                         0x800b58000000003f, 48, 16 // encoded bad lane one, two, and code in relation to the entire rx bus
#define EDIP_RX_BAD_LANE1                                  0x800b58000000003f, 48,  7 // encoded bad lane one in relation to the entire rx bus
#define EDIP_RX_BAD_LANE2                                  0x800b58000000003f, 55,  7 // encoded bad lane two in relation to the entire rx bus
#define EDIP_RX_BAD_LANE_CODE                              0x800b58000000003f, 62,  2 // rx bad lane code\r\n\t00:(0_bad_lns) zero bad lanes\r\n\t01:(bad_ln1_val) bad lane 1 valid\r\n\t10:(bad_lns12_val) bad lanes 1 and 2 valid\r\n\t11:(3plus_bad_lns) 3+ bad lanes
#define EDIP_RX_GLBSM_STAT9_E_PG                           0x800b58000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_RECAL_IP                             0x800b60000000003f, 48,  1 // rx servo lane calibration in progress
#define EDIP_RX_DYN_RECAL_MAIN_STATE                       0x800b60000000003f, 50,  6 // dynamic recalibration main state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_main_state
#define EDIP_RX_DYN_RECAL_HNDSHK_STATE                     0x800b60000000003f, 57,  7 // dynamic recalibration handshake state machine\r\n\tdetailed drawing can be found in the workbook by searching for rx_dyn_recal_hndshk_state
#define EDIP_RX_GLBSM_STAT10_E_PG                          0x800b60000000003f, 48, 16 // register -- description
#define EDIP_RX_SLS_CMD_VAL_HLD                            0x800b68000000003f, 49,  1 // when asserted, the rx_sls_cmd_encode_hld contains the most recent valid sls command.
#define EDIP_RX_SLS_CMD_ENCODE_HLD                         0x800b68000000003f, 50,  6 // when rx_sls_cmd_val_hld is asserted, this register contains the most recent valid sls command.
#define EDIP_RX_GLBSM_STAT11_E_PG                          0x800b68000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_DATASM_SPARE_MODE_0                     0x800b80000000003f, 48,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_1                     0x800b80000000003f, 49,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_2                     0x800b80000000003f, 50,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_3                     0x800b80000000003f, 51,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_4                     0x800b80000000003f, 52,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_5                     0x800b80000000003f, 53,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_6                     0x800b80000000003f, 54,  1 // per-group spare mode latch.
#define EDIP_RX_PG_DATASM_SPARE_MODE_7                     0x800b80000000003f, 55,  1 // per-group spare mode latch.
#define EDIP_RX_SERVO_CONFIG                               0x800b80000000003f, 56,  4 // per-group servo configuration bits.
#define EDIP_RX_CTL_DATASM_CLKDIST_PDWN                    0x800b80000000003f, 60,  1 // used to put addtional rx_ctl_datasm_mac logic into clock off mode
#define EDIP_RX_DATASM_SPARE_MODE_PG                       0x800b80000000003f, 48, 16 // register -- description
#define EDIP_RX_BER_COUNT_CLR                              0x800b88000000003f, 49,  1 // diag ber error counter clear pulse. when written to a 1 the per-lane error counters are cleared to all zeroes. writing both this bit and the timer clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define EDIP_RX_BER_TIMER_CLR                              0x800b88000000003f, 50,  1 // diag ber timer clear pulse. when written to a 1 the timers are cleared to all zeroes. writing both this bit and the error counter clear bit to a 1 will clear both and allow a new set of measurements to be run.
#define EDIP_RX_SCOPE_CAPTURE                              0x800b88000000003f, 51,  1 // when written to a 1 it will cause the scope capture register to copy the current main input
#define EDIP_RX_DATA_PIPE_CAPTURE                          0x800b88000000003f, 52,  1 // data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define EDIP_RX_RESET_SERVO_STATUS                         0x800b88000000003f, 53,  1 // data pipe capture clear pulse. when written to a 1 it will capture and freeze new data pipe data.
#define EDIP_RX_BER_RESET                                  0x800b88000000003f, 54,  1 // diag ber reset pulse. when written to a 1 it will clear both the error counter and timer.
#define EDIP_RX_REPAIR_COMP                                0x800b88000000003f, 55,  1 // mark repair complete for synd tally logic. when written to a 1 it will clear both the error counter and timer.
#define EDIP_RX_DATASM_CNTLX1_EO_PG                        0x800b88000000003f, 48, 16 // register -- description
#define EDIP_RX_BER_COUNT                                  0x800b90000000003f, 48, 11 // per-lane (pl) diagnostic bit error rate (ber) error counter. increments when in diagnostic ber mode and the output of the descrambler is non-zero. this counter counts errors on every ui so it is a true ber counter.
#define EDIP_RX_BER_COUNT_SATURATED                        0x800b90000000003f, 59,  1 // pl diag ber error counter saturation indicator. when 1 indicates that the error counter has saturated to the selected max value. a global per-lane read of this field will indicate if any lane error counters in the group are saturated.
#define EDIP_RX_BER_COUNT_FROZEN_BY_ERR_CNT                0x800b90000000003f, 60,  1 // pl diag ber error counter and or pp timer has been frozen by another lanes error counter being saturated.
#define EDIP_RX_BER_COUNT_FROZEN_BY_TIMER                  0x800b90000000003f, 61,  1 // pl diag ber error counter has been frozen by a diag ber timer becoming saturated.
#define EDIP_RX_BER_TIMER_SATURATED                        0x800b90000000003f, 62,  1 // pl diag ber timer saturation indicator. when 1 indicates that the pack ber timer has saturated to the max value. a global per-lane read of this field will indicate if any timer in the group has saturated.
#define EDIP_RX_DATASM_STAT1_EO_PG                         0x800b90000000003f, 48, 16 // register -- description
#define EDIP_RX_BER_TIMER_VALUE_0_15                       0x800b98000000003f, 48, 16 // pl diag ber timer value for this lane, bits 0-15. all lanes in a pack share a timer and will have the same timer value. the value can either be read on one lane in a pack to save data collection time or all lanes can be read.
#define EDIP_RX_DATASM_STAT2_EO_PG                         0x800b98000000003f, 48, 16 // register -- description
#define EDIP_RX_BER_TIMER_VALUE_16_31                      0x800ba0000000003f, 48, 16 // pl diag ber timer value, bits 16-31.
#define EDIP_RX_DATASM_STAT3_EO_PG                         0x800ba0000000003f, 48, 16 // register -- description
#define EDIP_RX_DATA_PIPE_0_15                             0x800ba8000000003f, 48, 16 // data pipe captured output bits 0-15.
#define EDIP_RX_DATASM_STAT4_EO_PG                         0x800ba8000000003f, 48, 16 // register -- description
#define EDIP_RX_DATA_PIPE_16_31                            0x800bb0000000003f, 48, 16 // data pipe captured output bits 16-31.
#define EDIP_RX_DATASM_STAT5_EO_PG                         0x800bb0000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_STATUS                               0x800bb8000000003f, 48, 16 // per group servo status. , bits 0-10 are the servo op captured, bits 11-15 are the lane captured. no error if bits 0 to 10 are all zeroes
#define EDIP_RX_DATASM_STAT6_EO_PG                         0x800bb8000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_CHG_CNT                              0x800bc0000000003f, 48,  4 // per group servo status. 4 bit value of the number of times the accumulator reversed directions during op, value is fluid except when bit 0 of servo_status is a 1.
#define EDIP_RX_PRBS_DATA_RCV                              0x800bc0000000003f, 52,  1 // current data is pure expected prbs data
#define EDIP_RX_PG_PRBS_SEED_DONE                          0x800bc0000000003f, 53,  1 // indicates that seed is done for the group prbs block.
#define EDIP_RX_DYN_RECAL_TIMER_RUNNING                    0x800bc0000000003f, 54,  1 // indicates that dynamic recal interval timer is running.
#define EDIP_RX_PRVCPT_CHANGE_DET                          0x800bc0000000003f, 63,  1 // read only bit that signals when a change has been detected in the captured pervasive signals in iocrc_pervasive_capt
#define EDIP_RX_DATASM_STAT7_EO_PG                         0x800bc0000000003f, 48, 16 // register -- description
#define EDIP_RX_SCAN_P_0_15                                0x800bc8000000003f, 48, 16 // rx boundary scan ovservation : p  0 to 15
#define EDIP_RX_DATASM_STAT8_EO_PG                         0x800bc8000000003f, 48, 16 // register -- description
#define EDIP_RX_SCAN_P_16_23                               0x800bd0000000003f, 48,  9 // rx boundary scan ovservation : p 16 to 23
#define EDIP_RX_DATASM_STAT9_EO_PG                         0x800bd0000000003f, 48, 16 // register -- description
#define EDIP_RX_SCAN_N_16_23                               0x800bd8000000003f, 56,  8 // rx boundary scan ovservation : n 16 to 23
#define EDIP_RX_DATASM_STAT10_EO_PG                        0x800bd8000000003f, 48, 16 // register -- description
#define EDIP_RX_SCAN_N_0_15                                0x800be0000000003f, 48, 16 // rx boundary scan ovservation : n  0 to 15
#define EDIP_RX_DATASM_STAT11_EO_PG                        0x800be0000000003f, 48, 16 // register -- description
#define EDIP_RX_SERVO_STATUS2                              0x800bf0000000003f, 48, 16 // per group servo status. , bit 0 indicates error captured bits 1-4 are extended servo op bits 11-14, bits 11-15 are the lane captured. bit 5 indicates selfseed error during recal
#define EDIP_RX_DATASM_STAT12_EO_PG                        0x800bf0000000003f, 48, 16 // register -- description
#define EDIP_RX_BAD_BUS_LANE_ERR_CNTR_DIS_CLR              0x800bf8000000003f, 48,  1 // disable clearing of the bad bus lane error counter (aka counter1) when the next crc/ecc error comes in on a new lane
#define EDIP_RX_BAD_BUS_LANE_ERR_CNTR                      0x800bf8000000003f, 49,  7 // bad bus lane error counter (aka counter1)
#define EDIP_RX_LAST_BAD_BUS_LANE                          0x800bf8000000003f, 57,  7 // last bad bus lane (bus lane causing the last crc or ecc error)
#define EDIP_RX_DATASM_STAT13_E_PG                         0x800bf8000000003f, 48, 16 // register -- description
#define EDIP_RX_PG_PRBS_SCRAMBLE_MODE                      0x800be8000000003f, 48,  2 // selects prbs scramble sequence length. \r\n\t00:(prbs23) prbs 23 (default) \r\n\t01:(prbs7) prbs 7 (used by rx bist)\r\n\t10:(prbs11) prbs 11 \r\n\t11:(prbs15) prbs 15
#define EDIP_RX_PG_PRBS_SEED_MODE                          0x800be8000000003f, 50,  1 // set this bit to enable seeding of the descramble prbs block from the incoming data stream.
#define EDIP_RX_DESKEW_RATE                                0x800be8000000003f, 51,  1 // tx deskew rate\r\n\tselects between a div1 (1100) and div2 (11110000) deskew pattern rate for both pattern a and b. \r\n\t0: (div2) divided deskew pattern for p9\r\n\t1: (div1) regular deskew pattern for centaur
#define EDIP_RX_RUN_DYN_RECAL_TIMER                        0x800be8000000003f, 52,  1 // enables checking for the 12/24 ui scramble sync pulse that enables the sls status reporting timer. \r\n\tthis bit should remain set to 1 to run the dynamic recal interval timer until a new full initialization is attempted. \r\n\t0:(disabled) disable checking (forces run_dyn_recal_timer to 0)\r\n\t1:(enabled) enable checking (run_dyn_recal_timer may go to 1 and stay that way after identifying the sync pulse)
#define EDIP_RX_DESKEW_PATTCHK_TIMEOUT_SEL                 0x800be8000000003f, 53,  2 // generic timer control for purpose of setting deskew pattern checking search duration. allows multiple pattern periods (pattern length of 128ui) to be included for increasing confidence in error-free deskew alignment.(see workbook table 4.10 for timer settings)
#define EDIP_RX_PG_PRBS_SLS_EXPECT                         0x800be8000000003f, 55,  8 // when an sls message is expected on the incoming data stream but it must be masked to complete prbs seeding, write the expected value here and it will be reverted and the pure prbs pattern will enter the prbs block.
#define EDIP_RX_HALF_RATE_MODE_DATASM                      0x800be8000000003f, 63,  1 // when set to 1, enables timers on the slow clock domain to consistently count ui when in 4-bit legacy mode.  otherwise, slow clock domain counts only half of the ui noted in the timeouts documentation when in 4-bit legacy mode.
#define EDIP_RX_DATASM_CNTL1_E_PG                          0x800be8000000003f, 48, 16 // register -- description
#define EDIP_RX_POFF_EOFF_TIMEOUT                          0x800b78000000003f, 48,  4 // selects timeout value for running eoff and poff opps
#define EDIP_RX_POFF_EOFF_CFG                              0x800b78000000003f, 52,  3 // selects filter value  for running eoff and poff opps
#define EDIP_RX_POFF_EOFF_BLOCK_ERROR                      0x800b78000000003f, 55,  1 // when set to a 1 we will block error caused by servo op not reversing
#define EDIP_RX_FILTER_OPTIONS                             0x800b78000000003f, 56,  4 // servo filter options. bit zero will cause accelerated behavior of amplitude ops
#define EDIP_RX_DATASM_CNTL2_EO_PG                         0x800b78000000003f, 48, 16 // register -- description
#define EDIP_RX_PB_CLR_PAR_ERRS                            0x800f80000000003f, 62,  1 // clear all rx parity error latches\r\n\ttoggle this field 0->1->0 to clear parity error latches in the busctl logic.
#define EDIP_RX_PB_FIR_RESET                               0x800f80000000003f, 63,  1 // fir reset\r\n\ttoggle this field 0->1->0 to reset the busctl logic fir related latches, including the isolation and parity error latches.
#define EDIP_RX_FIR_RESET_PB                               0x800f80000000003f, 48, 16 // register -- description
#define EDIP_RX_PB_FIR_ERRS_FULL_REG                       0x800f88000000003f, 48, 10 // iotk alias: a 1 in this field indicates that a register or state machine parity error has occurred in per-bus logic.
#define EDIP_RX_PB_FIR_ERRS                                0x800f88000000003f, 48, 10 // a per-bus busctl register or state machine parity error has occurred.\r\n\tbit0: (err_pb_regs) busctl register parity error.\r\n\tbit1: (err_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (err_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (err_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_err_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_err_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_err_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_err_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_err_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_err_gcrs_unld_sm2.
#define EDIP_RX_PB_FIR_ERR_PB_REGS                         0x800f88000000003f, 48,  1 // iotk alias: parity error has occurred in the per-bus busctl registers.
#define EDIP_RX_PB_FIR_ERR_GCR_BUFF0                       0x800f88000000003f, 49,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr buffer.
#define EDIP_RX_PB_FIR_ERR_GCR_BUFF1                       0x800f88000000003f, 50,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1.
#define EDIP_RX_PB_FIR_ERR_GCR_BUFF2                       0x800f88000000003f, 51,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2.
#define EDIP_RX_PB_FIR_ERR_GCRS_LD_SM0                     0x800f88000000003f, 52,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr load state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_LD_SM1                     0x800f88000000003f, 53,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 load state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_LD_SM2                     0x800f88000000003f, 54,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 load state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_UNLD_SM0                   0x800f88000000003f, 55,  1 // iotk alias: parity error has occurred in the per-bus busctl gcr unload state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_UNLD_SM1                   0x800f88000000003f, 56,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 1 unload state machine.
#define EDIP_RX_PB_FIR_ERR_GCRS_UNLD_SM2                   0x800f88000000003f, 57,  1 // iotk alias: parity error has occurred in the per-bus extra gcr buffer 2 unload state machine.
#define EDIP_RX_FIR_PB                                     0x800f88000000003f, 48, 16 // register -- description
#define EDIP_RX_PB_FIR_ERRS_MASK_FULL_REG                  0x800f90000000003f, 48, 10 // iotk alias: fir mask for rx_fir_pb errors.
#define EDIP_RX_PB_FIR_ERRS_MASK                           0x800f90000000003f, 48, 10 // fir mask for register or state machine parity checkers in per-bus busctl logic. a value of 1 masks the error from generating a fir error.\r\n\tbit0: (rx_pb_fir_par_err_mask_pb_regs) busctl register parity error.\r\n\tbit1: (rx_pb_fir_par_err_mask_busctl_gcrs_ld_sm) busctl gcr load sm parity error.\r\n\tbit2: (rx_pb_fir_par_err_mask_busctl_gcrs_unld_sm) busctl gcr unload sm parity error.\r\n\tbit3: (rx_pb_fir_par_err_mask_busctl_gcr_buff) busctl gcr buffer parity error.\r\n\tbit4: rx_pb_fir_par_err_mask_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_mask_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_mask_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_mask_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_mask_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_mask_gcrs_unld_sm2.
#define EDIP_RX_PB_FIR_ERR_MASK_PB_REGS                    0x800f90000000003f, 48,  1 // iotk alias: fir mask for the per-bus busctl registers.
#define EDIP_RX_PB_FIR_ERR_MASK_GCR_BUFF0                  0x800f90000000003f, 49,  1 // iotk alias: fir mask for the per-bus busctl gcr buffer.
#define EDIP_RX_PB_FIR_ERR_MASK_GCR_BUFF1                  0x800f90000000003f, 50,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1.
#define EDIP_RX_PB_FIR_ERR_MASK_GCR_BUFF2                  0x800f90000000003f, 51,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_LD_SM0                0x800f90000000003f, 52,  1 // iotk alias: fir mask for the per-bus busctl gcr load state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_LD_SM1                0x800f90000000003f, 53,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1 load state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_LD_SM2                0x800f90000000003f, 54,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2 load state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM0              0x800f90000000003f, 55,  1 // iotk alias: fir mask for the per-bus busctl gcr unload state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM1              0x800f90000000003f, 56,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 1 unload state machine.
#define EDIP_RX_PB_FIR_ERR_MASK_GCRS_UNLD_SM2              0x800f90000000003f, 57,  1 // iotk alias: fir mask for the per-bus extra gcr buffer 2 unload state machine.
#define EDIP_RX_FIR_MASK_PB                                0x800f90000000003f, 48, 16 // register -- description
#define EDIP_RX_PB_FIR_ERRS_INJ_FULL_REG                   0x800f98000000003f, 48, 10 // iotk alias: rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.
#define EDIP_RX_PB_FIR_ERRS_INJ                            0x800f98000000003f, 48, 10 // rx per-bus parity error injection\r\n\tallows injection of non-destructive parity errors in either register or statemachine latch banks. the register or state value is not affected.\r\n\t0: no parity error being injected.\r\n\t1: causes a parity flip in the specific parity checker.\r\n\tbit0: (rx_pb_fir_par_err_inj_pb_regs) busctl register parity error inject.\r\n\tbit1: (rx_pb_fir_par_err_inj_busctl_gcrs_ld_sm) busctl gcr load sm parity error inject.\r\n\tbit2: (rx_pb_fir_par_err_inj_busctl_gcrs_unld_sm) busctl gcr unload sm parity error inject.\r\n\tbit3: (rx_pb_fir_par_err_inj_busctl_gcr_buff) busctl gcr buffer parity error inject.\r\n\tbit4: rx_pb_fir_par_err_inj_gcrs_ld_sm0.\r\n\tbit5: rx_pb_fir_par_err_inj_gcrs_ld_sm1.\r\n\tbit6: rx_pb_fir_par_err_inj_gcrs_ld_sm2.\r\n\tbit7: rx_pb_fir_par_err_inj_gcrs_unld_sm0.\r\n\tbit8: rx_pb_fir_par_err_inj_gcrs_unld_sm1.\r\n\tbit9: rx_pb_fir_par_err_inj_gcrs_unld_sm2.
#define EDIP_RX_PB_FIR_ERR_INJ_PB_REGS                     0x800f98000000003f, 48,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl registers.
#define EDIP_RX_PB_FIR_ERR_INJ_SPARE0                      0x800f98000000003f, 49,  1 // iotk alias: spare inject 0.
#define EDIP_RX_PB_FIR_ERR_INJ_SPARE1                      0x800f98000000003f, 50,  1 // iotk alias: spare inject 1.
#define EDIP_RX_PB_FIR_ERR_INJ_GCR_BUFF2                   0x800f98000000003f, 51,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 (bus control register interface)
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_LD_SM0                 0x800f98000000003f, 52,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr load state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_LD_SM1                 0x800f98000000003f, 53,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 load state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_LD_SM2                 0x800f98000000003f, 54,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 load state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM0               0x800f98000000003f, 55,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus busctl gcr unload state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM1               0x800f98000000003f, 56,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 1 unload state machine.
#define EDIP_RX_PB_FIR_ERR_INJ_GCRS_UNLD_SM2               0x800f98000000003f, 57,  1 // iotk alias: while a 1, invert the parity check bit to force an error on the per-bus extra gcr buffer 2 unload state machine.
#define EDIP_RX_FIR_ERROR_INJECT_PB                        0x800f98000000003f, 48, 16 // register -- description
#define EDIP_RX_INTR_MSG                                   0x800ff0000000003f, 48, 16 // dummy intr gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define EDIP_RX_INTR_MSG_PB                                0x800ff0000000003f, 48, 16 // register -- description
#define EDIP_RX_FIR_MSG                                    0x800ff8000000003f, 48,  8 // dummy fir gcr message field. used for auto generation of the rx_fir_msg_pb address in the register vhdl constants file. may be useful for testing the fir message decoder in the per-bus logic.
#define EDIP_RX_FIR_MSG_PB                                 0x800ff8000000003f, 48, 16 // register -- description
#define EDIP_GCR_TEST_MODE                                 0x0000000000000020,  0,  1 // gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define EDIP_ENABLE_GCR_OFL_BUFF                           0x0000000000000020,  1,  1 // enables 2nd gcr overflow buffer, one is used by default.
#define EDIP_IORESET_HARD_BUS0                             0x0000000000000020,  2,  1 // io hard reset per-bus and gcr reset
#define EDIP_MMIO_PG_REG_ACCESS                            0x0000000000000020,  3,  1 // mmio pg register access is blocked by default. setting this bit high grants mmio access to the pg regs.
#define EDIP_SCOM_MODE_PB_SPARES1                          0x0000000000000020,  4,  4 // scom mode reg spares.
#define EDIP_GCR_HANG_DET_SEL                              0x0000000000000020,  8,  3 // gcr hang detect threshold select\r\n\t000: disabled\r\n\t001: 63 cycles\r\n\t010: 127 cycles\r\n\t011: 255 cycles\r\n\t100: 511 cycles\r\n\t101: 1023 cycles\r\n\t110: 2047 cycles\r\n\t111: 4096 cycles.
#define EDIP_GCR_BUFFER_ENABLED                            0x0000000000000020, 11,  1 // flag indicating that the extra gcr buffer is active, if the scom gcr enable buffer is off it means the hang threshold was reached.
#define EDIP_GCR_HANG_ERROR_MASK                           0x0000000000000020, 12,  1 // mask for gcr hang error when 2nd buffer is enabled.
#define EDIP_GCR_HANG_ERROR_INJ                            0x0000000000000020, 13,  1 // inject for gcr hang error.
#define EDIP_PPE_GCR_MODE                                  0x0000000000000020, 14,  1 // gcr test mode\r\n\tput register logic into gcr test mode which allows all rw registers to be read and written by diagnostic code to verify all register acccesses. this mode gates off both logic inputs to the registers as well as the outputs from the logic. the outputs are gated to their scanflush value.
#define EDIP_CHAN_FAIL_MASK                                0x0000000000000020, 15,  8 // scom mode reg spares.
#define EDIP_SCOM_MODE_PB_SPARES2                          0x0000000000000020, 23,  8 // scom mode reg spares.
#define EDIP_SCOM_MODE_PB                                  0x0000000000000020,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_FIR_PB                                   0x0000000000000000,  0, 64 // fir scom rw reg -- description
#define EDIP_SCOM_FIR_CLR_PB                               0x0000000000000001,  0, 64 // fir scom clear reg -- description
#define EDIP_SCOM_FIR_SET_PB                               0x0000000000000002,  0, 64 // fir scom set reg -- description
#define EDIP_SCOM_FIR_MASK_PB                              0x0000000000000003,  0, 64 // fir scom mask rw reg -- description
#define EDIP_SCOM_FIR_MASK_CLR_PB                          0x0000000000000004,  0, 64 // fir scom mask clear reg -- description
#define EDIP_SCOM_FIR_MASK_SET_PB                          0x0000000000000005,  0, 64 // fir scom mask set reg -- description
#define EDIP_SCOM_FIR_ACTION0_PB                           0x0000000000000006,  0, 64 // fir scom action0 reg -- description
#define EDIP_SCOM_FIR_ACTION1_PB                           0x0000000000000007,  0, 64 // fir scom action1 reg -- description
#define EDIP_SCOM_FIR_WOF_PB                               0x0000000000000008,  0, 64 // fir scom wof reg -- description
#define EDIP_SCOM_PPE_XCR_NONE_0_63                        0x0000000000000010,  0, 64 // ppe register
#define EDIP_SCOM_PPE_XCR_NONE                             0x0000000000000010,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_XCR_SPRG0_0_63                       0x0000000000000011,  0, 64 // ppe register
#define EDIP_SCOM_PPE_XCR_SPRG0                            0x0000000000000011,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_IR_SPRG0_0_63                        0x0000000000000012,  0, 64 // ppe register
#define EDIP_SCOM_PPE_IR_SPRG0                             0x0000000000000012,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_XSR_SPRG0_0_63                       0x0000000000000013,  0, 64 // ppe register
#define EDIP_SCOM_PPE_XSR_SPRG0                            0x0000000000000013,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_IR_EDR_0_63                          0x0000000000000014,  0, 64 // ppe register
#define EDIP_SCOM_PPE_IR_EDR                               0x0000000000000014,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_XSR_IAR_0_63                         0x0000000000000015,  0, 64 // ppe register
#define EDIP_SCOM_PPE_XSR_IAR                              0x0000000000000015,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_MEM_ARB_SCR_0_63                     0x000000000000000a,  0, 64 // ppe register
#define EDIP_SCOM_PPE_MEM_ARB_SCR                          0x000000000000000a,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_MEM_ARB_CSAR_0_63                    0x000000000000000d,  0, 64 // ppe register
#define EDIP_SCOM_PPE_MEM_ARB_CSAR                         0x000000000000000d,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_MEM_ARB_CSDR_0_63                    0x000000000000000e,  0, 64 // ppe register
#define EDIP_SCOM_PPE_MEM_ARB_CSDR                         0x000000000000000e,  0, 64 // normal scom mode reg -- description
#define EDIP_SCOM_PPE_IORESET                              0x0000000000000020,  0,  1 // ppe register
#define EDIP_SCOM_PPE_PDWN                                 0x0000000000000020,  1,  1 // ppe register
#define EDIP_SCOM_PPE_INTERRUPT                            0x0000000000000020,  2,  1 // ppe register
#define EDIP_SCOM_PPE_ARB_ECC_INJECT_ERR                   0x0000000000000020,  3,  1 // ppe register
#define EDIP_SCOM_PPE_SPARES                               0x0000000000000020,  4, 12 // ppe register
#define EDIP_SCOM_PPE_CNTL                                 0x0000000000000020,  0, 64 // normal scom mode reg in ppe macro -- description
#define EDIP_SCOM_PPE_WORK1                                0x0000000000000021,  0, 32 // ppe register
#define EDIP_SCOM_PPE_WORK_REG1                            0x0000000000000021,  0, 64 // normal scom mode reg in ppe macro -- description
#define EDIP_SCOM_PPE_WORK2                                0x0000000000000022,  0, 32 // ppe register
#define EDIP_SCOM_PPE_WORK_REG2                            0x0000000000000022,  0, 64 // normal scom mode reg in ppe macro -- description
#define EDIP_SCOM_PPE_FLAGS                                0x0000000000000023,  0, 16 // ppe register
#define EDIP_SCOM_PPE_FLAGS_REG                            0x0000000000000023,  0, 64 // normal scom mode reg in ppe macro -- description
#define EDIP_SCOM_PPE_FLAGS_SET                            0x0000000000000024,  0, 16 // ppe register
#define EDIP_SCOM_PPE_FLAGS_SET_REG                        0x0000000000000024,  0, 64 // normal scom mode reg in ppe macro -- description
#define EDIP_SCOM_PPE_FLAGS_CLR                            0x0000000000000025,  0, 16 // ppe register
#define EDIP_SCOM_PPE_FLAGS_CLR_REG                        0x0000000000000025,  0, 64 // normal scom mode reg in ppe macro -- description
*/

#endif /*IO_HW_REGS_H_*/
