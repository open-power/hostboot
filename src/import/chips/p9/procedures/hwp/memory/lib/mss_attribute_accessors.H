/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: chips/p9/procedures/hwp/memory/lib/mss_attribute_accessors.H $ */
/*                                                                        */
/* IBM CONFIDENTIAL                                                       */
/*                                                                        */
/* EKB Project                                                            */
/*                                                                        */
/* COPYRIGHT 2016                                                         */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* The source code for this program is not published or otherwise         */
/* divested of its trade secrets, irrespective of what has been           */
/* deposited with the U.S. Copyright Office.                              */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_attribute_accessors.H
#ifndef MSS_ATTR_ACCESS_H_
#define MSS_ATTR_ACCESS_H_

#include <fapi2.H>
#include <lib/mss_utils.H>



namespace mss
{
///
/// @brief ATTR_MSS_VOLT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Voltage, each voltage rail would need to have a value. Computed in mss_volt
/// C code - in millivolts creator: mss_volt consumer: mss_eff_cnfg, others firmware
/// notes:
/// none
///
inline fapi2::ReturnCode volt(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_VPP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM VPP Voltage, each voltage rail would need to have a value. Computed in
/// mss_volt C code - in millivolts. 0V - DDR3, 2.5V - DDR4 creator: mss_volt
/// consumer: mss_eff_cnfg, others firmware notes:
/// none
///
inline fapi2::ReturnCode volt_vpp(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_VPP, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_VPP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  FOR LAB USE ONLY: Frequency override of this memory channel in MHz, comprising
/// of up to three DIMMs. Set by config file or an attribute writing program.
/// Consumed by mss_freq. The default of AUTO means mss_freq will find the best
/// frequencies given the DIMMs plugged in and other rules. Otherwise, this is the
/// system frequency. firmware notes: Platforms should initialize this attribute to
/// AUTO
/// (0)
///
inline fapi2::ReturnCode freq_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Frequency of this memory channel in MT/s (Mega Transfers per second), comprising
/// of three DIMMs. Computed in mss_freq creator: mss_freq consumer: mss_eff_cnfg,
/// others firmware notes:
/// none
///
inline fapi2::ReturnCode freq(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_FREQ_BIAS_PERCENTAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Percentage to increase/decrease MEM frequency - two's complement number.
/// Measured in 100's. So the value of 100 is one percent increase. This frequency
/// change comes from changing multipliers and dividers to get the desired
/// frequency. The supported frequencies come from Tim Diemoz. Creator: platform set
/// this to 0. Users can set this to a valid value. VALID Values: (TBD % to TBD %)
/// (Tuleta) (TBD % to TBD %) (Glacier) Set by: PLL settings written by Dave
/// Cadigan
///
inline fapi2::ReturnCode freq_bias_percentage(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_FREQ_BIAS_PERCENTAGE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_FREQ_BIAS_PERCENTAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MFG_ID_CODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Manufacturer ID Code RCD: bits(31:16), Module:
/// bits(15:0)
///
inline fapi2::ReturnCode dimm_mfg_id_code(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MFG_ID_CODE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MFG_ID_CODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MFG_ID_CODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Manufacturer ID Code RCD: bits(31:16), Module:
/// bits(15:0)
///
inline fapi2::ReturnCode dimm_mfg_id_code(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MFG_ID_CODE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MFG_ID_CODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MFG_ID_CODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Manufacturer ID Code RCD: bits(31:16), Module:
/// bits(15:0)
///
inline fapi2::ReturnCode dimm_mfg_id_code(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MFG_ID_CODE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MFG_ID_CODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Dimensions are
/// [port][dimm] A/B=Mba_0 C/D=Mba_1 There are only two DIMM ranks: DIMM0 and DIMM1
/// where DIMM0 is the furthest from the centaur. creator: mss_eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Dimensions are
/// [port][dimm] A/B=Mba_0 C/D=Mba_1 There are only two DIMM ranks: DIMM0 and DIMM1
/// where DIMM0 is the furthest from the centaur. creator: mss_eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RANKS_CONFIGED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit wise representation of master ranks in each DIMM that are used for reads and
/// writes. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Dimensions are
/// [port][dimm] A/B=Mba_0 C/D=Mba_1 There are only two DIMM ranks: DIMM0 and DIMM1
/// where DIMM0 is the furthest from the centaur. creator: mss_eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ranks_configed(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RANKS_CONFIGED, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RANKS_CONFIGED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of ranks in each DIMM. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. values are 0,1,2, 4 up to 32 creator: mss_eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of ranks in each DIMM. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. values are 0,1,2, 4 up to 32 creator: mss_eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of ranks in each DIMM. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. values are 0,1,2, 4 up to 32 creator: mss_eff_cnfg consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_num_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CUSTOM_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM is a custom DIMM. This is commonly known as a CDIMM, but technically, we
/// could support Custom DIMMs of different types than an UDIMM, such as RDIMM and
/// LRDIMM. Created in mss_eff_cnfg Use this attribute if you need to know if the
/// Centaur is on the DIMM instead of on a
/// planar.
///
inline fapi2::ReturnCode eff_custom_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CUSTOM_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CUSTOM_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CUSTOM_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM is a custom DIMM. This is commonly known as a CDIMM, but technically, we
/// could support Custom DIMMs of different types than an UDIMM, such as RDIMM and
/// LRDIMM. Created in mss_eff_cnfg Use this attribute if you need to know if the
/// Centaur is on the DIMM instead of on a
/// planar.
///
inline fapi2::ReturnCode eff_custom_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CUSTOM_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CUSTOM_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CUSTOM_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM is a custom DIMM. This is commonly known as a CDIMM, but technically, we
/// could support Custom DIMMs of different types than an UDIMM, such as RDIMM and
/// LRDIMM. Created in mss_eff_cnfg Use this attribute if you need to know if the
/// Centaur is on the DIMM instead of on a
/// planar.
///
inline fapi2::ReturnCode eff_custom_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CUSTOM_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CUSTOM_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Width: X4, X8, X16, X32. Used in various locations and is computed
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Width: X4, X8, X16, X32. Used in various locations and is computed
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Width: X4, X8, X16, X32. Used in various locations and is computed
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Used in various locations and is computed in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Used in various locations and is computed in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RANK_MIX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Rank Mix Used in various locations and is computed in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_rank_mix(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RANK_MIX, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RANK_MIX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIMARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_primary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIMARY_RANK_GROUP3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIMARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SECONDARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_secondary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SECONDARY_RANK_GROUP3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SECONDARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TERTIARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_tertiary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TERTIARY_RANK_GROUP3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TERTIARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_QUATERNARY_RANK_GROUP3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RankGroup. Used in various locations and is computed in mss_eff_cnfg_rank_group.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg.
/// creator: mss_eff_cnfg_rank_group consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_quaternary_rank_group3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_QUATERNARY_RANK_GROUP3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_QUATERNARY_RANK_GROUP3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SPARE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Spare DRAM availability. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes: load from
/// spd OBSOLETE: Use
/// ATTR_VPD_DIMM_SPARE
///
inline fapi2::ReturnCode eff_dimm_spare(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SPARE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SPARE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Write Vref. Used in various locations and comes from the MT keyword of the
/// VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfile firmware notes: none
/// This is the nominal value This is for
/// DDR3
///
inline fapi2::ReturnCode eff_dram_wr_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wr_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF to use on the WR Schmoo. The LSB corresponds to the
/// highest WR
/// Vref
///
inline fapi2::ReturnCode eff_dram_wrddr4_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WRDDR4_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Drive Impedance Used in various locations and comes from the
/// MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator:
/// VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware
/// notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_DQ_DQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Drive Impedance Used in various locations and comes from the
/// MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator:
/// VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware
/// notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_DQ_DQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Drive Impedance Used in various locations and comes from the
/// MT Keyword of the VPD or is computed in mss_eff_cnfg_termination. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. creator:
/// VPD(MT)/mss_eff_cnfg_termination consumer: initfile,various.C files firmware
/// notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_clk_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_clk_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_clk_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_CLK_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_spcke_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_spcke_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit
/// field.
///
inline fapi2::ReturnCode eff_cen_drv_imp_spcke_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_SPCKE_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit field. This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_drv_imp_cntl_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit field. This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_drv_imp_cntl_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible driver strengths and start
/// with the first value down to the last (largest) impedance as the LSB of the 8
/// bit field. This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_drv_imp_cntl_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_DRV_IMP_CNTL_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Receiver Impedance Used in various locations and it comes
/// from the VPD MT keyword for custom DIMMs or is computed in
/// mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the
/// PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile
/// + C code firmware notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RCV_IMP_DQ_DQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Receiver Impedance Used in various locations and it comes
/// from the VPD MT keyword for custom DIMMs or is computed in
/// mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the
/// PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile
/// + C code firmware notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RCV_IMP_DQ_DQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Receiver Impedance Used in various locations and it comes
/// from the VPD MT keyword for custom DIMMs or is computed in
/// mss_eff_cnfg_termination. Can be overwritten by ODM vendors if done from the
/// PNOR or odm_eff_cnfg. creator: VPD, mss_eff_cnfg_termination Consumer: initfile
/// + C code firmware notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible receiver termination and
/// start with the first value down to the last (largest) impedance as the LSB of
/// the 32 bit
/// field.
///
inline fapi2::ReturnCode eff_cen_rcv_imp_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible receiver termination and
/// start with the first value down to the last (largest) impedance as the LSB of
/// the 32 bit
/// field.
///
inline fapi2::ReturnCode eff_cen_rcv_imp_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which impedance values can be used and tested in a timing test. The
/// bits have a one to one correspondence to the possible receiver termination and
/// start with the first value down to the last (largest) impedance as the LSB of
/// the 32 bit
/// field.
///
inline fapi2::ReturnCode eff_cen_rcv_imp_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RCV_IMP_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT
/// keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate
/// is 0, incrementing by one. The lower the number the slower the slew rate the
/// higher the faster. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer:
/// initfiles,various.C firmware notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT
/// keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate
/// is 0, incrementing by one. The lower the number the slower the slew rate the
/// higher the faster. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer:
/// initfiles,various.C firmware notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur DQ and DQS Slew Rate Used in various locations and comes from the MT
/// keyword of the VPD or is computed in mss_eff_cnfg_termination. Slowest slew rate
/// is 0, incrementing by one. The lower the number the slower the slew rate the
/// higher the faster. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. creator: VPD(MT), mss_eff_cnfg_termination consumer:
/// initfiles,various.C firmware notes: none This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_dq_dqs_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_DQ_DQS_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_clk_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_clk_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_clk_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_CLK_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_spcke_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_spcke_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_spcke_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_SPCKE_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_addr_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_addr_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_addr_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_ADDR_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_cntl_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_cntl_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slew Rates that can be selected during timing adjustments. The fastest rate is
/// the
/// LSB
///
inline fapi2::ReturnCode eff_cen_slew_rate_cntl_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_SLEW_RATE_CNTL_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RD_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur Read Vref. Used in various locations and comes from the MT keyword of
/// the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none
/// This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_rd_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RD_VREF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RD_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RD_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur Read Vref. Used in various locations and comes from the MT keyword of
/// the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none
/// This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_rd_vref(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RD_VREF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RD_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RD_VREF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Centaur Read Vref. Used in various locations and comes from the MT keyword of
/// the VPD or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. Creator: VPD(MT) or
/// mss_eff_cnfg_termination consumer: various.C and initfiles firmware notes: none
/// This is the nominal
/// value
///
inline fapi2::ReturnCode eff_cen_rd_vref(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RD_VREF, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RD_VREF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RD_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF value can be used in timing adjustments. The highest
/// voltage corresponds to the
/// LSB
///
inline fapi2::ReturnCode eff_cen_rd_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RD_VREF_SCHMOO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RD_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RD_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF value can be used in timing adjustments. The highest
/// voltage corresponds to the
/// LSB
///
inline fapi2::ReturnCode eff_cen_rd_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RD_VREF_SCHMOO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RD_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CEN_RD_VREF_SCHMOO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables for which VREF value can be used in timing adjustments. The highest
/// voltage corresponds to the
/// LSB
///
inline fapi2::ReturnCode eff_cen_rd_vref_schmoo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CEN_RD_VREF_SCHMOO, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CEN_RD_VREF_SCHMOO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_SIZE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Size, in GB Used in various locations and is computed in
/// mss_eff_cnfg.
///
inline fapi2::ReturnCode eff_dimm_size(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_SIZE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_SIZE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RAS to CAS Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RAS to CAS Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRCD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RAS to CAS Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trcd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRCD, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRCD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row ACT to Row ACT Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row ACT to Row ACT Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRRD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row ACT to Row ACT Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trrd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRRD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRRD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_trp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRP, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ACT to Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ACT to Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRAS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ACT to Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer:
/// various
///
inline fapi2::ReturnCode eff_dram_tras(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRAS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRAS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ACT to ACT/Refresh Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ACT to ACT/Refresh Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ACT to ACT/Refresh Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Write to Read Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Write to Read Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TWTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Write to Read Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_twtr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TWTR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TWTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRTP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Read to Precharge Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trtp(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRTP, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRTP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Four ACT Window Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Four ACT Window Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TFAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Four ACT Window Delay. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tfaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TFAW, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TFAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Burst Length. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_burst_length(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Burst Length. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_burst_length(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Burst Length. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_burst_length(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cas_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cas_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latency. Each memory channel will have a value. creator: mss_freq consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cas_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CL, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_AL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additive Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_al(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_AL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_AL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_CWL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Write Latency. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_cwl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_CWL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_CWL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Can
/// be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_read_burst_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Can
/// be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_read_burst_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Burst Type. Used in various locations and is computed in mss_eff_cnfg. Can
/// be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_read_burst_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RBT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Test Mode. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_RESET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Reset. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_reset(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_RESET, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_RESET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Recovery. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendofrs if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_write_recovery(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Recovery. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendofrs if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_write_recovery(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Recovery. Used in various locations and is computed in
/// mss_eff_cnfg_timing. Can be overwritten by ODM vendofrs if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg_timing consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_write_recovery(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg. Can
/// be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg. Can
/// be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_PPD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Precharge PD. Used in various locations and is computed in mss_eff_cnfg. Can
/// be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_ppd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_PPD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_PPD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DLL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DLL Enable. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_dll_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DLL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DLL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TDQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TDQS. Used in various locations and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tdqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TDQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TDQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_WR_LVL_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Level Enable. Used in various locations and is computed in mss_eff_cnfg.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_wr_lvl_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_WR_LVL_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_WR_LVL_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
/// PNOR or odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
/// PNOR or odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_OUTPUT_BUFFER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Qoff. Enables or disables DRAM output. Used in various locations and is
/// computed in mss_eff_cnfg. Can be overwritten by ODM vendors if done from the
/// PNOR or odm_eff_cnfg. Each memory channel will have a value. creator:
/// mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_output_buffer(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_OUTPUT_BUFFER, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_OUTPUT_BUFFER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Partial Array Self-Refresh. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_pasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Auto Self-Refresh. Used in various locations and is computed in mss_eff_cnfg.
/// Can be overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_asr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SRT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self-Refresh Temperature Range. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_srt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SRT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SRT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_LOC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Location. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_loc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_LOC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_LOC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Multi Purpose Register Mode. Used in various locations and is computed in
/// mss_eff_cnfg. Can be overwritten by ODM vendors if done from the PNOR or
/// odm_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC00: Global Features Control Word.For normal operation, output inversion is
/// always enabled. For DIMM vendor test purpose, output inversion can be disabled.
/// When disabled, register tPDM is not guaranteed to be met. NOTE: Default value -
/// 0x00. Values Range from 0-8. 00 - Normal Operation; 01 - Output Inversion
/// Disabled; 02 - Weak Drive Enabled; 04 - A outputs disabled; 08 - B outputs
/// disabled; So on. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC01 - Clock Driver Enable Control Word.1. Output clocks may be individually
/// turned on or off to conserve power. The system must read the module SPD to
/// determine which clock outputs are used by the module. The PLL remains locked on
/// CK_t/CK_c unless the system stops the clock inputs to the DDR4RCD02 to enter the
/// lowest power mode. Default value - 0x00. Values Range from 0-8. No need to
/// calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC02: Timing and IBT Control Word; Default value - 0x00. Values Range from
/// 0-8. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC03 - CA and CS Signals Driver Characteristics Control Word; Default value -
/// 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD
/// byte 137, 1st Nibble for CS and CA. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC04 - ODT and CKE Signals Driver Characteristics Control Word; Default value
/// - 0x05 (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from
/// SPD byte 137, 2nd Nibble for ODT and CKE. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC05 - Clock Driver Characteristics Control Word; Default value - 0x05
/// (Moderate Drive). Values Range from 00 to 0F. Has to be picked up from SPD byte
/// 138, 2nd Nibble for CK. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc67(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc67(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC06_07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. F0RC07 not used. RDIMM creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc67(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC06_07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC06_07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0x03. Values
/// Range from 00 to 08 decimal. Check the stack height and calculate dynamically;
/// 00 = Stack height_8; 01 = Stack height_4; 02 = Stack height_2; creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC06: Command Space Control Word definition; Default value - 0xF0 (NOP).
/// Values Range from 00 to F0. No need to calculate; User can override with desired
/// experimental value. creator: mss_eff_cnfg consumer: mss_dram_init firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC10, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC10, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RDIMM Operating Speed; Read from ATTR_MSS_FREQ; Default value - 00. Values Range
/// from 00 to 09. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC10, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT.
/// Default value - 14. Values Range from 00 to 15 decimal. No need to calculate;
/// User can override with desired experimental value. creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC11, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT.
/// Default value - 14. Values Range from 00 to 15 decimal. No need to calculate;
/// User can override with desired experimental value. creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC11, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Operating Voltage VDD and VrefCA Source Control Word; Read from ATTR_MSS_VOLT.
/// Default value - 14. Values Range from 00 to 15 decimal. No need to calculate;
/// User can override with desired experimental value. creator: mss_eff_cnfg
/// consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC11, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC12, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC12, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0C - Training Control Word; Default value - 00. Values Range from 00 to 07
/// decimal.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC12, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC13, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC13, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0D - DIMM Configuration Control Word; Default value - 0B. Values Range from
/// 00 to 15 decimal. Dynamically calculated using 4 bits[0:3] Bit 0 - Address
/// Mirroring; Bit 1 - Rdimm(1)/Lrdimm (0) ; Bit 2 - N/A ; Bit 3 - CS Mode (Direct /
/// Quad CS mode etc); creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC13, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC14, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC14, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0E - Parity Control Word; Default value - 00. Check from ATTR_EFF_CA_PARITY
/// and assign; Values Range from 00 to 0F. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC14, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC15, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC15, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC0F - Command Latency Adder Control Word; Default value - 04. Values Range
/// from 00 to 04. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC15, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC1x - Internal VrefCA Control Word; Default value - 00. Values Range from 00
/// to 3F.No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC2x: I2C Bus Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC3x - Fine Granularity RDIMM Operating Speed; Default value = (Operating Freq
/// - 1250)/20. Values Range from 00 to 61 Hex. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC4x: CW Source Selection Control Word; Default value - 00. Values Range from
/// 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC5x: CW Destination Selection and Write/Read Additional QxODT[1:0] Signal
/// High; Default value - 00. Values Range from 00 to FF. No need to calculate; User
/// can override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC6x: CW Data Control Word; Default value - 00. Values Range from 00 to FF.No
/// need to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC7x: IBT Control Word; Default value - 00. Values Range from 00 to FF.No need
/// to calculate; User can override with desired experimental value. creator:
/// mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC8x: ODT Input Buffer/IBT, QxODT Output Buffer and Timing Control Word;
/// Default value - 00. Values Range from 00 to FF. No need to calculate; User can
/// override with desired experimental value. creator: mss_eff_cnfg consumer:
/// mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RC9x1: QxODT[1:0] Write Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF.No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Ax getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCAx1: QxODT[1:0] Read Pattern Control Word; Default value - 00. Values Range
/// from 00 to FF. No need to calculate; User can override with desired experimental
/// value. creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Ax, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Ax: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_RC_Bx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0RCBx: IBT and MRS Snoop Control Word; Default value - 07. Values Range from 00
/// to FF. No need to calculate; User can override with desired experimental value.
/// creator: mss_eff_cnfg consumer: mss_dram_init firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_ddr4_rcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_RC_Bx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_RC_Bx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_IBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD IBT. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_ibt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_IBT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_IBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_IBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD IBT. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_ibt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_IBT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_IBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_IBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD IBT. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_ibt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_IBT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_IBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_RCD_MIRROR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD Mirroring. Used in mss_dram_init and is computed in mss_eff_cnfg. Can be
/// overwritten by ODM vendors if done from the PNOR or odm_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: mss_dram_init
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_rcd_mirror_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_RCD_MIRROR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_RCD_MIRROR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv.
///
inline fapi2::ReturnCode eff_schmoo_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo mode to use during
/// draminit_train_adv
///
inline fapi2::ReturnCode eff_schmoo_addr_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_TEST_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo test to run during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_test_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_TEST_VALID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_TEST_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_PARAM_VALID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo parameters to use during draminit_train_adv. Bit
/// wise.
///
inline fapi2::ReturnCode eff_schmoo_param_valid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_PARAM_VALID, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_PARAM_VALID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_wr_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_WR_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_eye_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_EYE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_dqs_clk_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_DQS_CLK_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_rd_gate_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_RD_GATE_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the schmoo minimum margin to use during draminit_train_adv. Used to
/// signal possible SI issues in
/// memory.
///
inline fapi2::ReturnCode eff_schmoo_addr_cmd_min_margin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SCHMOO_ADDR_CMD_MIN_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MEMCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_memcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MEMCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MEMCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ZQCAL_INTERVAL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the zqcal interval in
/// clocks.
///
inline fapi2::ReturnCode eff_zqcal_interval(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ZQCAL_INTERVAL, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ZQCAL_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_IBM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the memory topology type. See centaur
/// workbook.
///
inline fapi2::ReturnCode eff_ibm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_IBM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_IBM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_DROPS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DIMM dimensions that are valid per
/// port.
///
inline fapi2::ReturnCode eff_num_drops_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_DROPS_PER_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_DROPS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_DROPS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DIMM dimensions that are valid per
/// port.
///
inline fapi2::ReturnCode eff_num_drops_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_DROPS_PER_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_DROPS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_DROPS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DIMM dimensions that are valid per
/// port.
///
inline fapi2::ReturnCode eff_num_drops_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_DROPS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_DROPS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per
/// DIMM.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per
/// DIMM.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of master ranks per
/// DIMM.
///
inline fapi2::ReturnCode eff_num_master_ranks_per_dimm(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_MASTER_RANKS_PER_DIMM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_PACKAGES_PER_RANK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM packages per
/// rank.
///
inline fapi2::ReturnCode eff_num_packages_per_rank(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_PACKAGES_PER_RANK, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_PACKAGES_PER_RANK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_PACKAGES_PER_RANK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM packages per
/// rank.
///
inline fapi2::ReturnCode eff_num_packages_per_rank(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_PACKAGES_PER_RANK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_PACKAGES_PER_RANK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_NUM_PACKAGES_PER_RANK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM packages per
/// rank.
///
inline fapi2::ReturnCode eff_num_packages_per_rank(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_NUM_PACKAGES_PER_RANK, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_NUM_PACKAGES_PER_RANK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_DIE_COUNT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Specifies the number of DRAM dies per
/// package.
///
inline fapi2::ReturnCode eff_prim_die_count(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_DIE_COUNT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_DIE_COUNT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled N commands per window of M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mc_config firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mc_config firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttled M DRAM clocks setting for cfg_nm_m. creator: mss_eff_cnfg
/// consumer: mc_config firmware notes:
/// none
///
inline fapi2::ReturnCode mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This is the throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power limit in cW for the dimms on the memory channel pair. Used to
/// compute the throttles on the channel and/or dimms. creator: unknown. consumer:
/// mss_eff_config. firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power limit in cW for the dimms on the memory channel pair. Used to
/// compute the throttles on the channel and/or dimms. creator: unknown. consumer:
/// mss_eff_config. firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MEM_WATT_TARGET getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total memory power limit in cW for the dimms on the memory channel pair. Used to
/// compute the throttles on the channel and/or dimms. creator: unknown. consumer:
/// mss_eff_config. firmware notes:
/// none.
///
inline fapi2::ReturnCode mem_watt_target(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MEM_WATT_TARGET, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MEM_WATT_TARGET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power slope value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_SLOPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power slope value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_SLOPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power slope value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_SLOPE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power slope value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_SLOPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power slope value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_SLOPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_SLOPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power slope value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_slope(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_SLOPE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_SLOPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power intercept value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_INTERCEPT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power intercept value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_INTERCEPT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MASTER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Master Power intercept value for
/// dimm
///
inline fapi2::ReturnCode master_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MASTER_PWR_INTERCEPT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MASTER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power intercept value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_INTERCEPT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power intercept value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_INTERCEPT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SUPPLIER_PWR_INTERCEPT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Supplier Power intercept value for
/// dimm
///
inline fapi2::ReturnCode supplier_pwr_intercept(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SUPPLIER_PWR_INTERCEPT, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SUPPLIER_PWR_INTERCEPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_GBS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Bandwidth in MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXBANDWIDTH_MRS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth in GBs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_gbs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_GBS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Bandwidth MRs output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxbandwidth_mrs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXBANDWIDTH_MRS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DIMM_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DIMM Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode dimm_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DIMM_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DIMM_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXPOWER, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXPOWER, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CHANNEL_PAIR_MAXPOWER getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Channel Pair Max Power output from thermal
/// procedures
///
inline fapi2::ReturnCode channel_pair_maxpower(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CHANNEL_PAIR_MAXPOWER, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CHANNEL_PAIR_MAXPOWER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttled N commands per M DRAM clocks setting for
/// cfg_nm_n_per_port.
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime for M DRAM clocks setting for
/// cfg_nm_m
///
inline fapi2::ReturnCode runtime_mem_m_dram_clocks(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_M_DRAM_CLOCKS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCA>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>&
        i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Runtime throttle numerator setting for
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode runtime_mem_throttled_n_commands_per_slot(const fapi2::Target<fapi2::TARGET_TYPE_MCS>&
        i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_RUNTIME_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This dial sets the Centaur address bits used to interleave addresses between
/// MBA01 and MBA23. Valid values are 23 through 32. See Centaur Spec Chapter 5 for
/// details. Used in the intifile. Will be obsolete when the
/// MSS_DERIVED_MBA_ADDR_INTERLEAVE_BIT is set This attribute will only be found in
/// a Tuelta
/// system.
///
inline fapi2::ReturnCode mba_addr_interleave_bit(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MBA_ADDR_INTERLEAVE_BIT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. On is 256 bit interleave. Off, the translation is on 128 bit
/// interleave mode. See centaur workbook chapter 5. Will be obsolete when
/// MSS_DERIVED_MBA_CACHELINE_INTERLEAVE_MODE is set. This attribute will only be
/// alive in the Tuelta
/// system.
///
inline fapi2::ReturnCode mba_cacheline_interleave_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_MBA_CACHELINE_INTERLEAVE_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_PREFETCH_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. Determines if prefetching enabled or not. See chapter 7 of
/// the Centaur
/// Workbook.
///
inline fapi2::ReturnCode prefetch_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_PREFETCH_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_PREFETCH_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CLEANER_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Value of on or off. Determines if the cleaner of the L4 cache (write modified
/// entries to memory on idle cycles) enabled or not. See chapter 7 of the Centaur
/// Workbook.
///
inline fapi2::ReturnCode cleaner_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CLEANER_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CLEANER_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. Each memory channel will have a
/// value. creator: mss_eff_cnfg consumer: various firmware notes: none This factors
/// in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. Each memory channel will have a
/// value. creator: mss_eff_cnfg consumer: various firmware notes: none This factors
/// in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector (per Dean's request) specifying if a DIMM is functional. DIMM
/// attributes, such as SIZE, are qualified by this bit vector. The attribute ANDed
/// 0x80 means port 0, DIMM 0 is functional, 0x40 means port 0, DIMM 1 is
/// functional. 0x08 means port 1, DIMM 0 is functional and 0x04 means port 1 DIMM 1
/// is functional. A fully populated system would have the value of 0xCC. Used in
/// various locations and is computed in mss_eff_cnfg. Can be overwritten by ODM
/// vendors if done from the PNOR or odm_eff_cnfg. Each memory channel will have a
/// value. creator: mss_eff_cnfg consumer: various firmware notes: none This factors
/// in
/// functionality
///
inline fapi2::ReturnCode eff_dimm_functional_vector(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_DIMM_FUNCTIONAL_VECTOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_LPASR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Low Power Auto Self-Refresh. This is for DDR4 MRS2. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_lpasr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_LPASR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_LPASR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_PAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR Page Selection This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_page(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_PAGE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_PAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_GEARDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Gear Down Mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_geardown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_GEARDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_GEARDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PER_DRAM_ACCESS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Per DRAM accessibility. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_per_dram_access(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PER_DRAM_ACCESS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PER_DRAM_ACCESS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_READOUT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temperature sensor readout. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_readout(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_READOUT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_READOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_WR_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  write latency for CRC and DM. This is for DDR4 MRS3. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_crc_wr_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_WR_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_WR_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MPR_RD_FORMAT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MPR READ FORMAT. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_mpr_rd_format(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MPR_RD_FORMAT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MPR_RD_FORMAT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_MAX_POWERDOWN_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max Power down mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_max_powerdown_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_MAX_POWERDOWN_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_MAX_POWERDOWN_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REF_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp controlled ref mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_ref_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REF_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REF_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REF_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp controlled ref mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_ref_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REF_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REF_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REF_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp controlled ref mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_ref_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REF_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REF_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INT_VREF_MON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_int_vref_mon(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INT_VREF_MON, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INT_VREF_MON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INT_VREF_MON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_int_vref_mon(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INT_VREF_MON, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INT_VREF_MON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_INT_VREF_MON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Internal Vref Monitor. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_int_vref_mon(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_INT_VREF_MON, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_INT_VREF_MON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CS_CMD_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CS to CMD/ADDR Latency. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_cs_cmd_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CS_CMD_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CS_CMD_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_SELF_REF_ABORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Self Refresh Abort. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_self_ref_abort(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_SELF_REF_ABORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_SELF_REF_ABORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE_TRAIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble Training Mode. This is for DDR4 MRS4. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble_train(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE_TRAIN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE_TRAIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RD_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rd_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RD_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RD_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WR_PREAMBLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write Pre amble. This is for DDR4 MRS4. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_wr_preamble(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WR_PREAMBLE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WR_PREAMBLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Latency Mode. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CRC_ERROR_CLEAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CRC Error Clear. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_crc_error_clear(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CRC_ERROR_CLEAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CRC_ERROR_CLEAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY_ERROR_STATUS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  C/A Parity Error Status. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity_error_status(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY_ERROR_STATUS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY_ERROR_STATUS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_INPUT_BUFF getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  ODT Input Buffer during power down. This is for DDR4 MRS5. Computed in
/// mss_eff_cnfg. Each memory channel will have a value. creator: mss_eff_cnfg
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_input_buff(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_INPUT_BUFF, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_INPUT_BUFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_Park value. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_Park value. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RTT_Park value. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_CA_PARITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA Parity Persistance Error. This is for DDR4 MRS5. Computed in mss_eff_cnfg.
/// Each memory channel will have a value. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_ca_parity(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_CA_PARITY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_CA_PARITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DATA_MASK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Data Mask. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_data_mask(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DATA_MASK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DATA_MASK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_READ_DBI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read DBI. This is for DDR4 MRS5. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_read_dbi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_READ_DBI, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_READ_DBI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_VALUE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_VALUE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train value. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_value(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_VALUE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_VALUE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_RANGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train range. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. Creator: mss_eff_cnfg Consumer:various Firmware
/// notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_range(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_RANGE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_ENABLE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VREF_DQ_TRAIN_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  vrefdq_train enable. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each
/// memory channel will have a value. Creator: mss_eff_cnfg Consumer:various
/// Firmware notes:
/// none
///
inline fapi2::ReturnCode vref_dq_train_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VREF_DQ_TRAIN_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VREF_DQ_TRAIN_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  tccd_l. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_TCCD_L, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  tccd_l. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_TCCD_L, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_TCCD_L getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  tccd_l. This is for DDR4 MRS6. Computed in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode tccd_l(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_TCCD_L, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_TCCD_L: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_WRITE_CRC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write CRC control for DDR4 in MRS2. Set in mss_eff_cnfg. Each memory channel
/// will have a value. Creator: mss_eff_cnfg Consumer:various Firmware notes:
/// none
///
inline fapi2::ReturnCode eff_write_crc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_WRITE_CRC, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_WRITE_CRC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting valid cal steps to run (0 is left most bit) [0] EXT_ZQCAL
/// [1] WR_LEVEL [2] DQS_ALIGN [3] RDCLK_ALIGN [4] READ_CTR [5] READ_CTR_2D_VREF [6]
/// WRITE_CTR [7] WRITE_CTR_2D_VREF [8] COARSE_WR [9] COARSE_RD [10]:[15] Reserved
/// for future use COARSE_WR and COARSE_RD will be consumed together to form
/// COARSE_LVL.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting valid cal steps to run (0 is left most bit) [0] EXT_ZQCAL
/// [1] WR_LEVEL [2] DQS_ALIGN [3] RDCLK_ALIGN [4] READ_CTR [5] READ_CTR_2D_VREF [6]
/// WRITE_CTR [7] WRITE_CTR_2D_VREF [8] COARSE_WR [9] COARSE_RD [10]:[15] Reserved
/// for future use COARSE_WR and COARSE_RD will be consumed together to form
/// COARSE_LVL.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_CAL_STEP_ENABLE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A bit vector denoting valid cal steps to run (0 is left most bit) [0] EXT_ZQCAL
/// [1] WR_LEVEL [2] DQS_ALIGN [3] RDCLK_ALIGN [4] READ_CTR [5] READ_CTR_2D_VREF [6]
/// WRITE_CTR [7] WRITE_CTR_2D_VREF [8] COARSE_WR [9] COARSE_RD [10]:[15] Reserved
/// for future use COARSE_WR and COARSE_RD will be consumed together to form
/// COARSE_LVL.
///
inline fapi2::ReturnCode cal_step_enable(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_CAL_STEP_ENABLE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_CAL_STEP_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DRAMINIT_RESET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  A disable switch for resetting the phy delay values at the beginning of calling
/// mss_draminit_training.
///
inline fapi2::ReturnCode draminit_reset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DRAMINIT_RESET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DRAMINIT_RESET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is port, the second is the impedance of
/// 24,30,34, and 40 Ohms. The 3rd dimension is the rate: 3,4,5 or 6 V/ns. Computed
/// and sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_DATA, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_SLEW_RATE_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The 4 bit result of running the slew calibration algorithm at various rates and
/// impedances. The first dimension is the port. The second is the impedance of 15,
/// 20, 30 and 40 Ohms. The 3rd dimension is the rate:3, 4,5 or 6 V/ns. Computed and
/// sent to the correct data blocks in phy_reset. Also used in advanced
/// training
///
inline fapi2::ReturnCode slew_rate_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][4][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_SLEW_RATE_ADR, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_SLEW_RATE_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_ALLOW_SINGLE_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  When this value is true, then mss_eff config will allow a single port to have
/// one dimm and will allow ports to have different sizes. Used in
/// eff_config
///
inline fapi2::ReturnCode allow_single_port(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_ALLOW_SINGLE_PORT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_ALLOW_SINGLE_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_ALLOW_SINGLE_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  When this value is true, then mss_eff config will allow a single port to have
/// one dimm and will allow ports to have different sizes. Used in
/// eff_config
///
inline fapi2::ReturnCode allow_single_port(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_ALLOW_SINGLE_PORT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_ALLOW_SINGLE_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_ALLOW_SINGLE_PORT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  When this value is true, then mss_eff config will allow a single port to have
/// one dimm and will allow ports to have different sizes. Used in
/// eff_config
///
inline fapi2::ReturnCode allow_single_port(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_ALLOW_SINGLE_PORT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_ALLOW_SINGLE_PORT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DQS_SWIZZLE_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQS Swizzle type is set by the platform to describe what kind of DQS connection
/// is being used for register acceses. Type 0 is normal, type 1 is for systems with
/// wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if
/// new boards have even different DQS swizzle
/// features
///
inline fapi2::ReturnCode dqs_swizzle_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DQS_SWIZZLE_TYPE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DQS_SWIZZLE_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DQS_SWIZZLE_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQS Swizzle type is set by the platform to describe what kind of DQS connection
/// is being used for register acceses. Type 0 is normal, type 1 is for systems with
/// wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if
/// new boards have even different DQS swizzle
/// features
///
inline fapi2::ReturnCode dqs_swizzle_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DQS_SWIZZLE_TYPE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DQS_SWIZZLE_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DQS_SWIZZLE_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQS Swizzle type is set by the platform to describe what kind of DQS connection
/// is being used for register acceses. Type 0 is normal, type 1 is for systems with
/// wiring like glacier 1, type 2 is for Pallmeto. Additional types maybe defined if
/// new boards have even different DQS swizzle
/// features
///
inline fapi2::ReturnCode dqs_swizzle_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DQS_SWIZZLE_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DQS_SWIZZLE_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SCHMOO_MULTIPLE_SETUP_CALL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MCBIST for multiple
/// setup
///
inline fapi2::ReturnCode schmoo_multiple_setup_call(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SCHMOO_MULTIPLE_SETUP_CALL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SCHMOO_MULTIPLE_SETUP_CALL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_BUFFER_LATENCY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer latency in the case of RDIMMs and LRDIMMs. It is expected that
/// this value will come from the
/// VPD
///
inline fapi2::ReturnCode eff_buffer_latency(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_BUFFER_LATENCY, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_BUFFER_LATENCY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_LRDIMM_WORD_X getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Additional buffer control word for LRDIMM building of the
/// BCW
///
inline fapi2::ReturnCode eff_lrdimm_word_x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_LRDIMM_WORD_X, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_LRDIMM_WORD_X: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_MR12_REG getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM MR1,2 register. DRAM Rtt_WR for all ranks, DRAM Rtt_Nom for ranks 0 and
/// 1, DRAM driver impedance for all ranks. Eff config should set this
/// up.
///
inline fapi2::ReturnCode lrdimm_mr12_reg(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_MR12_REG, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_MR12_REG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC10, F[3,4]RC11,
/// F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC10, F[3,4]RC11,
/// F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM additional RCD control words as set by DIMM SPD: F[3,4]RC10, F[3,4]RC11,
/// F[5,6]RC10, F[5,6]RC11, F[7,8]RC10, F[7,8]RC11, F[9,10]RC10, F[9,10]RC11,
/// F[1]RC8, F[3]RC9, F[3]RC8, F[1]RC11, F[1]RC12, F[1]RC13, F[1]RC14, F[1]RC15. Eff
/// config should set this
/// up
///
inline fapi2::ReturnCode lrdimm_additional_cntl_words(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_ADDITIONAL_CNTL_WORDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication mode. Will be set at an MBA level with one policy to
/// be
/// used
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication mode. Will be set at an MBA level with one policy to
/// be
/// used
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_LRDIMM_RANK_MULT_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM rank multiplication mode. Will be set at an MBA level with one policy to
/// be
/// used
///
inline fapi2::ReturnCode lrdimm_rank_mult_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_LRDIMM_RANK_MULT_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_LRDIMM_RANK_MULT_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RAS weight to use for memory throttle control - set in thermal
/// procedures
///
inline fapi2::ReturnCode throttle_control_ras_weight(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RAS weight to use for memory throttle control - set in thermal
/// procedures
///
inline fapi2::ReturnCode throttle_control_ras_weight(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RAS weight to use for memory throttle control - set in thermal
/// procedures
///
inline fapi2::ReturnCode throttle_control_ras_weight(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLE_CONTROL_RAS_WEIGHT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS weight to use for memory throttle control - set in thermal
/// procedures
///
inline fapi2::ReturnCode throttle_control_cas_weight(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS weight to use for memory throttle control - set in thermal
/// procedures
///
inline fapi2::ReturnCode throttle_control_cas_weight(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS weight to use for memory throttle control - set in thermal
/// procedures
///
inline fapi2::ReturnCode throttle_control_cas_weight(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLE_CONTROL_CAS_WEIGHT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_EFF_VPD_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The lowest VPD Version of the DIMMs attached to the MBA. Comes directly (in
/// ASCII) of the VINI VZ
/// keyword
///
inline fapi2::ReturnCode eff_vpd_version(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_EFF_VPD_VERSION, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_EFF_VPD_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_NEST_CAPABLE_FREQUENCIES getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint64_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The NEST frequencies the memory chip can run at computed by the mss_freq. The
/// possibilities are ORed together. The platform uses these value and the MRW to
/// determine what frequency to boot the fabric (nest) if it can. There are two
/// values: 8G and
/// 9.6G
///
inline fapi2::ReturnCode nest_capable_frequencies(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target,
        uint64_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_NEST_CAPABLE_FREQUENCIES, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_NEST_CAPABLE_FREQUENCIES: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_AVDD_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to AVDD. Supplied by
/// MRW.
///
inline fapi2::ReturnCode avdd_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_AVDD_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_AVDD_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VDD_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VDD. Supplied by
/// MRW.
///
inline fapi2::ReturnCode vdd_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VDD_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VDD_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VCS_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VCS. Supplied by
/// MRW.
///
inline fapi2::ReturnCode vcs_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VCS_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VCS_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VPP_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VCS. Supplied by
/// MRW.
///
inline fapi2::ReturnCode vpp_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VPP_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VPP_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VDDR_OFFSET_DISABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for to determine whether to apply an offset to VDDR. Supplied by
/// MRW.
///
inline fapi2::ReturnCode vddr_offset_disable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VDDR_OFFSET_DISABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VDDR_OFFSET_DISABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_AVDD_SLOPE_ACTIVE getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slope value used to determine the dynamic VID AVDD adjustment for ACTIVE parts.
/// In
/// uV/Centaur.
///
inline fapi2::ReturnCode avdd_slope_active(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_AVDD_SLOPE_ACTIVE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_AVDD_SLOPE_ACTIVE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_AVDD_SLOPE_INACTIVE getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Slope value used to determine the dynamic VID AVDD adjustment for INACTIVE
/// parts. In
/// uV/Centaur.
///
inline fapi2::ReturnCode avdd_slope_inactive(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_AVDD_SLOPE_INACTIVE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_AVDD_SLOPE_INACTIVE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_AVDD_SLOPE_INTERCEPT getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Intercept value used to determine the dynamic VID AVDD adjustment for all parts.
/// In
/// mV.
///
inline fapi2::ReturnCode avdd_slope_intercept(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_AVDD_SLOPE_INTERCEPT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_AVDD_SLOPE_INTERCEPT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_OVERRIDE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCBIST>
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (MCBIST A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Possible DRAM voltage
/// override.
///
inline fapi2::ReturnCode volt_override(const fapi2::Target<fapi2::TARGET_TYPE_MCBIST>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VOLT_COMPLIANT_DIMMS getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  List of Voltages that are compliant with the system. DIMMs that do not have
/// voltages listed in their SPD as supported are errored out. Procedure defined is
/// currently 1.2V and 1.35V
/// only.
///
inline fapi2::ReturnCode volt_compliant_dimms(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VOLT_COMPLIANT_DIMMS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VOLT_COMPLIANT_DIMMS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VDDR_OVERIDE_SPD getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Possible VDDR voltage
/// override.
///
inline fapi2::ReturnCode vddr_overide_spd(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VDDR_OVERIDE_SPD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VDDR_OVERIDE_SPD: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_ISDIMM_POWER_CURVE_ALGORITHM_VERSION getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Version of algorithm and dependent attributes used to calculate ISDIMM power
/// curve
/// attributes
///
inline fapi2::ReturnCode isdimm_power_curve_algorithm_version(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ISDIMM_POWER_CURVE_ALGORITHM_VERSION, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_ISDIMM_POWER_CURVE_ALGORITHM_VERSION: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum number of installed DIMMs per VMEM regulator for all VMEM regulators in
/// the
/// system.
///
inline fapi2::ReturnCode vmem_regulator_max_dimm_count(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_VMEM_REGULATOR_MAX_DIMM_COUNT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM data bus utilization percent to use to determine
/// ATTR_MSS_THROTTLED_N_COMMANDS creator: f/w consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM data bus utilization percent to use to determine
/// ATTR_MSS_THROTTLED_N_COMMANDS creator: f/w consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_DATABUS_UTIL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM data bus utilization percent to use to determine
/// ATTR_MSS_THROTTLED_N_COMMANDS creator: f/w consumer:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode databus_util(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_DATABUS_UTIL, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_DATABUS_UTIL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLED_N_COMMANDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Throttled N commands (address operations) that are allowed within a window of M
/// DRAM clocks. Nimbus workbook (Power and Thermal Controls). creator:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode throttled_n_commands(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLED_N_COMMANDS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLED_N_COMMANDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLED_N_COMMANDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Throttled N commands (address operations) that are allowed within a window of M
/// DRAM clocks. Nimbus workbook (Power and Thermal Controls). creator:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode throttled_n_commands(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLED_N_COMMANDS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLED_N_COMMANDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MSS_THROTTLED_N_COMMANDS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Throttled N commands (address operations) that are allowed within a window of M
/// DRAM clocks. Nimbus workbook (Power and Thermal Controls). creator:
/// mss_utils_to_throttle
///
inline fapi2::ReturnCode throttled_n_commands(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MSS_THROTTLED_N_COMMANDS, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MSS_THROTTLED_N_COMMANDS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Count. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_mac(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAC, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TMAW getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Activate Window. Used in various locations and is computed in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_tmaw(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TMAW, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TMAW: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Post Package Repair. Used in various locations and is evaluated in mss_eff_cnfg.
/// creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_SOFT_PPR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Soft Post Package Repair. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_soft_ppr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_SOFT_PPR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_SOFT_PPR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_MR_LAYOUT_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode layout_version(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_MR_LAYOUT_VERSION, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_MR_LAYOUT_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_MR_LAYOUT_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode layout_version(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_MR_LAYOUT_VERSION, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_MR_LAYOUT_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_MR_LAYOUT_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode layout_version(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_MR_LAYOUT_VERSION, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_MR_LAYOUT_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_MR_DATA_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode data_version(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_MR_DATA_VERSION, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_MR_DATA_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_MR_DATA_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode data_version(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_MR_DATA_VERSION, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_MR_DATA_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_MR_DATA_VERSION getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode data_version(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_MR_DATA_VERSION, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_MR_DATA_VERSION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A4 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A4 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a4(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A4, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A4: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A4 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A4 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a4(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A4, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A4: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A4 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A4 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a4(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A4, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A4: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A5 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A5 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a5(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A5, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A5: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A5 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A5 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a5(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A5, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A5: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A5 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A5 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a5(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A5, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A5: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A6 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A6 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a6(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A6, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A6: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A6 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A6 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a6(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A6, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A6: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A6 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A6 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a6(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A6, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A6: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A7 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A7 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a7(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A7, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A7: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A7 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A7 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a7(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A7, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A7: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A7 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A7 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a7(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A7, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A7: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A8 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A8 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a8(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A8, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A8: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A8 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A8 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a8(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A8, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A8: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A8 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A8 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a8(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A8, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A8: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A9 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A9 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a9(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A9, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A9: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A9 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A9 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a9(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A9, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A9: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A9 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A9 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a9(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A9, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A9: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A10 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A10, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A10 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A10, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A10 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A10, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A11 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A11, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A11 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A11, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A11 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A11, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A12 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A12, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A12 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A12, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A12 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A12, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A13 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A13, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A13 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A13, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A13 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A13, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A17 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A17, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A17 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A17, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_A17 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_A17, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_C2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_C2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BA0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BA0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BA0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BA1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BA1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BA1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BG0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BG0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BG0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BG1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BG1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_ADDR_BG1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CLK0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CLK0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_clk0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CLK0, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CLK0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CLK0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CLK0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_clk0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CLK0, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CLK0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CLK0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CLK0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_clk0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CLK0, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CLK0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CLK1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CLK1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_clk1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CLK1, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CLK1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CLK1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CLK1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_clk1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CLK1, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CLK1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CLK1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CLK1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_clk1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CLK1, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CLK1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ACTN creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ACTN creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ACTN creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_WEN_A14 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_WEN_A14 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_WEN_A14 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_CASN_A15 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_CASN_A15 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_CASN_A15 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_RASN_A16 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_RASN_A16 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_ADDR_RASN_A16 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_PAR creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_PAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_PAR creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_PAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CMD_PAR creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CMD_PAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CKE3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_cke3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CKE3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_CSN3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_csn3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_CSN3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT0 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT1 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT2 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phase rotator value that comes from MR keyword on the CDIMM VPD. This controls
/// the IO PHASE_ROT_CNTL_ODT3 creator:vpd consumer: various fw
/// notes:
///
inline fapi2::ReturnCode phase_rot_cntl_odt3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_CEN_PHASE_ROT_CNTL_ODT3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM
/// associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C
/// and 252 bits 4:7 for port
/// D
///
inline fapi2::ReturnCode vpd_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_RLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM
/// associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C
/// and 252 bits 4:7 for port
/// D
///
inline fapi2::ReturnCode vpd_rlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_RLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 4:7 for the Logical DIMM
/// associated with port A. Byte 124 bits 4:7 for port B, 188 bits 4:7 for port C
/// and 252 bits 4:7 for port
/// D
///
inline fapi2::ReturnCode vpd_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_RLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM
/// associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C
/// and 252 bits 0:3 for port
/// D
///
inline fapi2::ReturnCode vpd_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_WLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM
/// associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C
/// and 252 bits 0:3 for port
/// D
///
inline fapi2::ReturnCode vpd_wlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_WLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT byte 60 bits 0:3 for the Logical DIMM
/// associated with port A. Byte 124 bits 0:3 for port B, 188 bits 0:3 for port C
/// and 252 bits 0:3 for port
/// D
///
inline fapi2::ReturnCode vpd_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_WLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MODULE_BUS_WIDTH getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Memory Bus Width. Used in various locations and is evaluated in
/// mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_module_bus_width(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MODULE_BUS_WIDTH, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MODULE_BUS_WIDTH: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MIN_CYCLE_TIME getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Cycle time for SDRAM module. Used in various locations and is evaluated
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_min_cycle_time(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MIN_CYCLE_TIME, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MIN_CYCLE_TIME: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MIN_CYCLE_TIME getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Cycle time for SDRAM module. Used in various locations and is evaluated
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_min_cycle_time(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MIN_CYCLE_TIME, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MIN_CYCLE_TIME: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MIN_CYCLE_TIME getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum Cycle time for SDRAM module. Used in various locations and is evaluated
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_min_cycle_time(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MIN_CYCLE_TIME, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MIN_CYCLE_TIME: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAX_CYCLE_TIME getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Cycle time for SDRAM module. Used in various locations and is evaluated
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_max_cycle_time(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAX_CYCLE_TIME, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAX_CYCLE_TIME: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAX_CYCLE_TIME getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Cycle time for SDRAM module. Used in various locations and is evaluated
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_max_cycle_time(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAX_CYCLE_TIME, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAX_CYCLE_TIME: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_MAX_CYCLE_TIME getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum Cycle time for SDRAM module. Used in various locations and is evaluated
/// in mss_eff_cnfg. creator: mss_eff_cnfg consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_max_cycle_time(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_MAX_CYCLE_TIME, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_MAX_CYCLE_TIME: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW00 Host Interface DQ RTT_NOM
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC00, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW01 Host Interface DQ RTT_WR
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC01, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW02 Host Interface DQ RTT_PARK
/// Control
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC02, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW03 Host Interface DQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC03, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW04 DRAM Interface MDQ RTT Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC04, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW05 DRAM Interface MDQ Driver Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC05, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW06 Command Space Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC06, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW07 Rank Presence Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC07, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW08 RankSelection Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC08, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW09 Power Saving Settings Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC09, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0A getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0A LRDIMM Operating
/// Speed
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0a(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0A, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0B getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0B Operating Voltage Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0b(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0B, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0C getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0C Buffer Training Mode Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0c(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0C, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0C: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0D getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0D Reserved for future
/// use
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0d(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0D, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0D: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0E getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0E Parity Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0e(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0E, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0E: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_BC0F getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW0F Error Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_bc0f(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_BC0F, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_BC0F: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW1x Buffer Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW2x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW3x Lower Nibble DRAM Interface Receive Enable Training Control Word for
/// ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW4x Lower Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW5x Upper Nibble MDQS Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCW6x Fine Granularity Frequency Operating Speed Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F70BC7x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F70BCW7x Function Space Selector Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f70bc7x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F70BC7x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F70BC7x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW8x Lower Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCW9x Upper Nibble MDQ-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BC9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWAx Lower Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCAx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F30BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F30BCWBx Upper Nibble DRAM Interface Write Leveling Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f30bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F30BCBx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F30BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F0BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F0BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f0bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F0BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F0BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWCx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWDx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWEx Lower/Upper Nibble Additional Cycles of DRAM Interface Receive Enable
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F1BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F1BCWFx Lower/Upper Nibble Additional Cycles of DRAM Interface Write Leveling
/// Control Word for rank
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f1bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F1BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F1BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW0x MRS0 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW1x MRS1 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW2x MRS2 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW3x MRS3 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW4x MRS4 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW5x MRS5 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F4BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F4BCW6x MRS6 snooped
/// settings
///
inline fapi2::ReturnCode eff_dimm_ddr4_f4bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F4BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F4BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW0x Upper and Lower MPR bits[7:0] for
/// U0
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW1x Upper and Lower MPR bits[15:8] for
/// U1
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW2x Upper and Lower MPR bits[23:16] for
/// U2
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW3x Upper and Lower MPR bits[31:24] for
/// U3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW5x Host Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F5BC6x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F5BCW6x DRAM Interface Vref Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f5bc6x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F5BC6x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F5BC6x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC0x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW0x Upper and Lower MPR bits[39:32] for
/// U4
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc0x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC0x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC0x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC1x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW1x Upper and Lower MPR bits[47:40] for
/// U5
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc1x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC1x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC1x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC2x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW2x Upper and Lower MPR bits[55:48] for
/// U6
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc2x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC2x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC2x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC3x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW3x Upper and Lower MPR bits[63:56] for
/// U7
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc3x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC3x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC3x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC4x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW4x Buffer Training Configuration Control
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc4x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC4x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC4x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F6BC5x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F6BCW5x Buffer Training Status
/// Word
///
inline fapi2::ReturnCode eff_dimm_ddr4_f6bc5x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F6BC5x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F6BC5x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC8x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW8x MDQ0/4 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc8x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC8x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC8x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BC9x getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCW9x MDQ1/5 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bc9x(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BC9x, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BC9x: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCAx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWAx MDQ2/6 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCAx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCAx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCBx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWBx MDQ3/7 -Read Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcbx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCBx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCBx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCCx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWCx MDQ0/4-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bccx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCCx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCCx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCDx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWDx MDQ1/5-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcdx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCDx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCDx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCEx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWEx MDQ2/6-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcex(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCEx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCEx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_DDR4_F74BCFx getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  F74BCWFx MDQ3/7-MDQS Write Delay Control Word for ranks 0 to
/// 3
///
inline fapi2::ReturnCode eff_dimm_ddr4_f74bcfx(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_DDR4_F74BCFx, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_DDR4_F74BCFx: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_CAS_LATENCIES_SUPPORTED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latencies supported (bitmap). Located in DDR4 SPD byte 20 (LSB) through byte
/// 23 The raw data has different meanings for DDR3 and DDR4. HWPs must use this DDR
/// neutral enumeration to decode. Platform support must call an Accessor
/// HWP.
///
inline fapi2::ReturnCode cas_latencies_supported(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_CAS_LATENCIES_SUPPORTED, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_CAS_LATENCIES_SUPPORTED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_CAS_LATENCIES_SUPPORTED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latencies supported (bitmap). Located in DDR4 SPD byte 20 (LSB) through byte
/// 23 The raw data has different meanings for DDR3 and DDR4. HWPs must use this DDR
/// neutral enumeration to decode. Platform support must call an Accessor
/// HWP.
///
inline fapi2::ReturnCode cas_latencies_supported(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_CAS_LATENCIES_SUPPORTED, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_CAS_LATENCIES_SUPPORTED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_CAS_LATENCIES_SUPPORTED getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS Latencies supported (bitmap). Located in DDR4 SPD byte 20 (LSB) through byte
/// 23 The raw data has different meanings for DDR3 and DDR4. HWPs must use this DDR
/// neutral enumeration to decode. Platform support must call an Accessor
/// HWP.
///
inline fapi2::ReturnCode cas_latencies_supported(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_CAS_LATENCIES_SUPPORTED, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_CAS_LATENCIES_SUPPORTED: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_MODULE_THERMAL_SENSOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Thermal Sensor. Located in DDR4 SPD byte
/// 14.
///
inline fapi2::ReturnCode spd_module_thermal_sensor(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_MODULE_THERMAL_SENSOR, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_MODULE_THERMAL_SENSOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_MODULE_THERMAL_SENSOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Thermal Sensor. Located in DDR4 SPD byte
/// 14.
///
inline fapi2::ReturnCode spd_module_thermal_sensor(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_MODULE_THERMAL_SENSOR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_MODULE_THERMAL_SENSOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_MODULE_THERMAL_SENSOR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Module Thermal Sensor. Located in DDR4 SPD byte
/// 14.
///
inline fapi2::ReturnCode spd_module_thermal_sensor(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_MODULE_THERMAL_SENSOR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_MODULE_THERMAL_SENSOR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_MODULE_NOMINAL_VOLTAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  mss_eff_config should decode the nominal voltage in milivolts and write out the
/// value
///
inline fapi2::ReturnCode spd_module_nominal_voltage(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_MODULE_NOMINAL_VOLTAGE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_MODULE_NOMINAL_VOLTAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_MODULE_NOMINAL_VOLTAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  mss_eff_config should decode the nominal voltage in milivolts and write out the
/// value
///
inline fapi2::ReturnCode spd_module_nominal_voltage(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_MODULE_NOMINAL_VOLTAGE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_MODULE_NOMINAL_VOLTAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_SPD_MODULE_NOMINAL_VOLTAGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  mss_eff_config should decode the nominal voltage in milivolts and write out the
/// value
///
inline fapi2::ReturnCode spd_module_nominal_voltage(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_SPD_MODULE_NOMINAL_VOLTAGE, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_SPD_MODULE_NOMINAL_VOLTAGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read ODT. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination
/// consumer: various.C files and initfiles firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read ODT. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination
/// consumer: various.C files and initfiles firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Read ODT. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. creator: VPD(MT),mss_eff_cnfg_termination
/// consumer: various.C files and initfiles firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write ODT. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. Creator: VPD(MT)/ mss_eff_cnfg_termination
/// consumer: various.C and initfile firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write ODT. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. Creator: VPD(MT)/ mss_eff_cnfg_termination
/// consumer: various.C and initfile firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Write ODT. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. Creator: VPD(MT)/ mss_eff_cnfg_termination
/// consumer: various.C and initfile firmware notes:
/// none
///
inline fapi2::ReturnCode eff_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RON getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Ron. Used in various locations and comes from the MT keyword of the VPD or
/// is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or odm_eff_cnfg. OHM48 is for
/// DDR4.
///
inline fapi2::ReturnCode eff_dram_ron(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RON, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RON: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Rtt_Nom. Used in various locations and comes from the MT keyword of the VPD
/// or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or
/// odm_eff_cnfg.
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Rtt_Nom. Used in various locations and comes from the MT keyword of the VPD
/// or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or
/// odm_eff_cnfg.
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Rtt_Nom. Used in various locations and comes from the MT keyword of the VPD
/// or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or
/// odm_eff_cnfg.
///
inline fapi2::ReturnCode eff_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Rtt_WR. Used in various locations and comes from the MT keyword of the VPD
/// or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or
/// odm_eff_cnfg.
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Rtt_WR. Used in various locations and comes from the MT keyword of the VPD
/// or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or
/// odm_eff_cnfg.
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Rtt_WR. Used in various locations and comes from the MT keyword of the VPD
/// or is computed in mss_eff_cnfg_termination. Can be overwritten by ODM vendors if
/// done from the PNOR or
/// odm_eff_cnfg.
///
inline fapi2::ReturnCode eff_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM
/// associated with port A. Bytes 125 for port B, 189 for port C and 253 for port
/// D
///
inline fapi2::ReturnCode vpd_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_GPO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM
/// associated with port A. Bytes 125 for port B, 189 for port C and 253 for port
/// D
///
inline fapi2::ReturnCode vpd_gpo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_GPO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  This value comes from the VPD keyword MT bytes 61 MT(61) for the Logical DIMM
/// associated with port A. Bytes 125 for port B, 189 for port C and 253 for port
/// D
///
inline fapi2::ReturnCode vpd_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_GPO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_FREQ_PROC_REFCLOCK_KHZ getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of the processor refclock in kHz. Provided by the Machine Readable
/// Workbook. This can be overridden to adjust the refclock
/// frequency.
///
inline fapi2::ReturnCode freq_proc_refclock_khz(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_PROC_REFCLOCK_KHZ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_PROC_REFCLOCK_KHZ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_FREQ_MEM_REFCLOCK getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The frequency of the memory refclock in MHz. Provided by the Machine Readable
/// Workbook. This is read by the set_ref_clock HWP to find out the desired
/// frequency. This can be overridden to adjust the refclock
/// frequency.
///
inline fapi2::ReturnCode freq_mem_refclock(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_FREQ_MEM_REFCLOCK, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_FREQ_MEM_REFCLOCK: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_IN_SYNCH_MODE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Run the memory clocks in synchronous mode with the nest
/// clocks.
///
inline fapi2::ReturnCode mem_in_synch_mode(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_IN_SYNCH_MODE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MEM_IN_SYNCH_MODE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MAX_ALLOWED_DIMM_FREQ getter
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum frequency (in MHz) that this system can run the DIMMs at. There are 4
/// possible values determined by the dimm configuration. [0]=One rank, single drop
/// [1]=Two rank, single drop [2]=One rank, dual drop [3]=Two rank, dual drop A
/// value of zero would indicate an unsupported
/// configuration.
///
inline fapi2::ReturnCode max_allowed_dimm_freq(uint32_t* o_array)
{
    uint32_t l_value[4];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MAX_ALLOWED_DIMM_FREQ, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MAX_ALLOWED_DIMM_FREQ: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes byte 2 of SPD. Generation of memory: DDR3, DDR4.
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes byte 2 of SPD. Generation of memory: DDR3, DDR4.
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_GEN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Device Type. Decodes byte 2 of SPD. Generation of memory: DDR3, DDR4.
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_gen(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_GEN, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_GEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0) Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0) Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DIMM_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Base Module Type. Decodes SPD Byte 3 (bits 3~0) Type of DIMM: RDIMM, UDIMM,
/// LRDIMM as specified by the JEDIC standard. creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dimm_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DIMM_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DIMM_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID_MEMORY_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid Media. Decodes SPD Byte 3 (bits 6~4) creator: mss_eff_config consumer:
/// various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid_memory_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID_MEMORY_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID_MEMORY_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_HYBRID getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Hybrid. Decodes SPD Byte 3 (bit 7) creator: mss_eff_config consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_hybrid(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_HYBRID, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_HYBRID: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_DENSITY getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM Density. Decodes SPD Byte 4 (bits 3~0). Total SDRAM capacity per die. For
/// multi-die stacks (DDP, QDP, or 3DS), this represents the capacity of each DRAM
/// die in the stack. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_density(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_DENSITY, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_DENSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Number of DRAM bank address bits. Actual number of banks is 2^N, where N is the
/// number of bank address bits. Decodes SPD Byte 4 (bits 5~4). creator: spd_decoder
/// consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_BANK_GROUP_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bank Groups Bits. Decoded SPD Byte 4 (bits 7~6). Actual number of bank groups is
/// 2^N, where N is the number of bank address bits. This value represents the
/// number of bank groups into which the memory array is divided. creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_bank_group_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_BANK_GROUP_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_BANK_GROUP_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_COLUMN_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Column Address Bits. Decoded SPD Byte 5 (bits 2~0). Actual number of DRAM
/// columns is 2^N, where N is the number of column address bits creator:
/// mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_columns_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_COLUMN_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_COLUMN_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_ROW_BITS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Row Address Bits. Decodes Byte 5 (bits 5~3). Number of DRAM column address bits.
/// Actual number of DRAM rows is 2^N, where N is the number of row address bits
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_row_bits(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_ROW_BITS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_ROW_BITS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_PRIM_STACK_TYPE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Primary SDRAM Package Type. Decodes Byte 6. This byte defines the primary set of
/// SDRAMs. Monolithic = SPD, Multi-load stack = DDP/QDP, Single-load stack = 3DS
/// creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_prim_stack_type(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_PRIM_STACK_TYPE, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_PRIM_STACK_TYPE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REF_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp ref range. This is for DDR4 MRS4. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_ref_range(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REF_RANGE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REF_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REF_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp ref range. This is for DDR4 MRS4. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_ref_range(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REF_RANGE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REF_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_TEMP_REF_RANGE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Temp ref range. This is for DDR4 MRS4. creator: mss_eff_cnfg consumer: various
/// firmware notes:
/// none
///
inline fapi2::ReturnCode eff_temp_ref_range(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_TEMP_REF_RANGE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_TEMP_REF_RANGE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_FINE_REFRESH_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_fine_refresh_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_FINE_REFRESH_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_FINE_REFRESH_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_FINE_REFRESH_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_fine_refresh_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_FINE_REFRESH_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_FINE_REFRESH_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_FINE_REFRESH_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Fine refresh mode. This is for DDR4 MRS3. Computed in mss_eff_cnfg. Each memory
/// channel will have a value. creator: mss_eff_cnfg consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_fine_refresh_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_FINE_REFRESH_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_FINE_REFRESH_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Refresh Interval. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Refresh Interval. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TREFI getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Refresh Interval. creator: mss_eff_config consumer: various firmware notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trefi(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TREFI, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TREFI: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Refresh Recovery Delay. creator: mss_eff_config consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Refresh Recovery Delay. creator: mss_eff_config consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TRFC getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Refresh Recovery Delay. creator: mss_eff_config consumer: various firmware
/// notes:
/// none
///
inline fapi2::ReturnCode eff_dram_trfc(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TRFC, i_target, l_value) );
    memcpy(o_array, &l_value, 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TRFC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCKMIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum cycle time (tCKmin) in ps. Decoded using DDR4 SPD byte 18 and byte 125.
/// Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_tckmin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCKMIN, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCKMIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCKMIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum cycle time (tCKmin) in ps. Decoded using DDR4 SPD byte 18 and byte 125.
/// Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_tckmin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCKMIN, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCKMIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCKMIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum cycle time (tCKmin) in ps. Decoded using DDR4 SPD byte 18 and byte 125.
/// Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_tckmin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCKMIN, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCKMIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCKMAX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint64_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum cycle time (tCKmax) in ps. Decoded using DDR4 SPD byte 19 and byte 124.
/// Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_tckmax(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint64_t& o_value)
{
    uint64_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCKMAX, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCKMAX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCKMAX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum cycle time (tCKmax) in ps. Decoded using DDR4 SPD byte 19 and byte 124.
/// Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_tckmax(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCKMAX, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 16);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCKMAX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TCKMAX getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint64_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Maximum cycle time (tCKmax) in ps. Decoded using DDR4 SPD byte 19 and byte 124.
/// Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_tckmax(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint64_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint64_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TCKMAX, i_target, l_value) );
    memcpy(o_array, &l_value, 32);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TCKMAX: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TAAMIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS Latency Time (tAAmin) in nCK. Decoded using DDR4 SPD byte 24 and
/// byte 123. Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_taamin(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TAAMIN, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TAAMIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TAAMIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS Latency Time (tAAmin) in nCK. Decoded using DDR4 SPD byte 24 and
/// byte 123. Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_taamin(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TAAMIN, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TAAMIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_EFF_DRAM_TAAMIN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Minimum CAS Latency Time (tAAmin) in nCK. Decoded using DDR4 SPD byte 24 and
/// byte 123. Right aligned. Bit 0 is
/// rightmost.
///
inline fapi2::ReturnCode eff_dram_taamin(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_EFF_DRAM_TAAMIN, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_EFF_DRAM_TAAMIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook safe mode throttle value for numerator
/// cfg_nm_n_per_port
///
inline fapi2::ReturnCode mrw_safemode_mem_throttled_n_commands_per_port(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_PORT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_SLOT getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook safe mode throttle value for numerator
/// cfg_nm_n_per_slot
///
inline fapi2::ReturnCode mrw_safemode_mem_throttled_n_commands_per_slot(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_SLOT,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_SAFEMODE_MEM_THROTTLED_N_COMMANDS_PER_SLOT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_THERMAL_MEMORY_POWER_LIMIT getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook Thermal Memory Power
/// Limit
///
inline fapi2::ReturnCode mrw_thermal_memory_power_limit(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_THERMAL_MEMORY_POWER_LIMIT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_THERMAL_MEMORY_POWER_LIMIT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  At a system level, this attribute controls if interleaving is required,
/// requested or never. The
/// MRW.
///
inline fapi2::ReturnCode mrw_mba_cacheline_interleave_mode_control(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_MBA_CACHELINE_INTERLEAVE_MODE_CONTROL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at max
/// utilization.
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook DIMM power curve percent uplift for this system at
/// idle
/// utilization.
///
inline fapi2::ReturnCode mrw_dimm_power_curve_percent_uplift_idle(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_DIMM_POWER_CURVE_PERCENT_UPLIFT_IDLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_MEM_M_DRAM_CLOCKS getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook for the number of M DRAM clocks. One approach to
/// curbing DRAM power usage is by throttling traffic through a programmable N
/// commands over M
/// window.
///
inline fapi2::ReturnCode mrw_mem_m_dram_clocks(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_MEM_M_DRAM_CLOCKS, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_MEM_M_DRAM_CLOCKS: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_MAX_DRAM_DATABUS_UTIL getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for maximum dram data bus utilization in centi
/// percent (c%). Used to determine memory throttle
/// values.
///
inline fapi2::ReturnCode mrw_max_dram_databus_util(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_MAX_DRAM_DATABUS_UTIL, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_MAX_DRAM_DATABUS_UTIL: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_STRICT_MBA_PLUG_RULE_CHECKING getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The MRW for a system should set this to TRUE for systems that must obey plug
/// rules. Lab environments should default this to off and allow the user to
/// override using normal methods to
/// test.
///
inline fapi2::ReturnCode mrw_strict_mba_plug_rule_checking(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_STRICT_MBA_PLUG_RULE_CHECKING, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_STRICT_MBA_PLUG_RULE_CHECKING: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for Custom DIMMs to not enable the reading of the dimm temperature sensor
/// on the master i2c
/// bus
///
inline fapi2::ReturnCode mrw_cdimm_master_i2c_temp_sensor_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_CDIMM_MASTER_I2C_TEMP_SENSOR_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Used for Custom DIMMs to not enable the reading of the dimm temperature sensor
/// on the spare i2c
/// bus
///
inline fapi2::ReturnCode mrw_cdimm_spare_i2c_temp_sensor_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_CDIMM_SPARE_I2C_TEMP_SENSOR_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_MCS_PREFETCH_RETRY_THRESHOLD getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Option to control MCS prefetch retry threshold, for performance optimization.
/// This attribute controls the number of retries in the prefetch engine. Retry
/// threshold available ranges from 16 to 30. Note: Values outside those ranges will
/// default to 30. In
/// MRW.
///
inline fapi2::ReturnCode mrw_mcs_prefetch_retry_threshold(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_MCS_PREFETCH_RETRY_THRESHOLD, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_MCS_PREFETCH_RETRY_THRESHOLD: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_POWER_CONTROL_REQUESTED getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Capable power control settings. In
/// MRW.
///
inline fapi2::ReturnCode mrw_power_control_requested(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_POWER_CONTROL_REQUESTED, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_POWER_CONTROL_REQUESTED: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook enablement of the HWP code to adjust the VMEM
/// regulator power limit based on number of installed
/// DIMMs.
///
inline fapi2::ReturnCode mrw_vmem_regulator_power_limit_per_dimm_adj_enable(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_VMEM_REGULATOR_POWER_LIMIT_PER_DIMM_ADJ_ENABLE: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook value for the maximum possible number of dimms that
/// can be installed under any of the VMEM
/// regulators.
///
inline fapi2::ReturnCode mrw_max_number_dimms_possible_per_vmem_regulator(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_MAX_NUMBER_DIMMS_POSSIBLE_PER_VMEM_REGULATOR: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM getter
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Machine Readable Workbook VMEM regulator power limit per CDIMM assuming a full
/// configuration. Units in
/// cW.
///
inline fapi2::ReturnCode mrw_vmem_regulator_memory_power_limit_per_dimm(uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM,
                            fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_MRW_VMEM_REGULATOR_MEMORY_POWER_LIMIT_PER_DIMM: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}


///
/// @brief ATTR_VPD_MR_0_VERSION_LAYOUT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Layout Version Number. Increases when attributes are added, removed,
/// or redefined. Does not
/// reset.
///
inline fapi2::ReturnCode vpd_mr_0_version_layout(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_0_VERSION_LAYOUT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_0_VERSION_LAYOUT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_1_VERSION_DATA getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword Data Version Number. Increases when data changes with the above
/// layout version. Resets when layout version number
/// increments.
///
inline fapi2::ReturnCode vpd_mr_1_version_data(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_1_VERSION_DATA, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_1_VERSION_DATA: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_2_SIGNATURE_FREQ_DROP getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  MR Keyword type, nibble 0 = freq bin (0 = 1600, 1 = 1866, 2 = 2133, 3 = 2400, 4
/// = 2667, 5 = 2933, 6 = 3200), nibble 1 = num dimms per port (1 = single drop, 2 =
/// dual
/// drop)
///
inline fapi2::ReturnCode vpd_mr_2_signature_freq_drop(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_2_SIGNATURE_FREQ_DROP, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_2_SIGNATURE_FREQ_DROP: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_DRAM_2N_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_dram_2n_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_DRAM_2N_MODE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_DRAM_2N_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_DRAM_2N_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_dram_2n_mode(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_DRAM_2N_MODE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_DRAM_2N_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_DRAM_2N_MODE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_dram_2n_mode(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_DRAM_2N_MODE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_DRAM_2N_MODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a00(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A00: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a01(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A01: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a02(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A02: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a03(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A03: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a04(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A04: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a05(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A05: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a06(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A06: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a07(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A07: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a08(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A08: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a09(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A09: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a10(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A10: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a11(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A11: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a12(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A12: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a13(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A13: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_a17(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_A17: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_ba1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BA1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_bg1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_BG1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_addr_c2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_ADDR_C2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d0_p0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d0_p0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d0_p0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d0_p1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d0_p1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d0_p1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D0_P1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d1_p0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d1_p0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d1_p0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d1_p1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d1_p1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_clk_d1_p1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CLK_D1_P1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_actn(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ACTN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_casn_a15(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_CASN_A15: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_rasn_a16(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_RASN_A16: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_addr_wen_a14(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_ADDR_WEN_A14: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cmd_par(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CMD_PAR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_cke3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CKE3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_csn3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_CSN3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt0(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt0(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt1(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt1(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt2(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt2(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt2(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT2: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt3(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt3(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3 getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_mc_phase_rot_cntl_odt3(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_MC_PHASE_ROT_CNTL_ODT3: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_periodic_memcal_mode_options(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_periodic_memcal_mode_options(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_periodic_memcal_mode_options(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_PERIODIC_MEMCAL_MODE_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_TSYS_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_tsys_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_TSYS_ADR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_TSYS_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_TSYS_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_tsys_adr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_TSYS_ADR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_TSYS_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_TSYS_ADR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_tsys_adr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_TSYS_ADR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_TSYS_ADR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_TSYS_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_tsys_data(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_TSYS_DATA, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_TSYS_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_TSYS_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_tsys_data(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_TSYS_DATA, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_TSYS_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MR_TSYS_DATA getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mr_tsys_data(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MR_TSYS_DATA, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MR_TSYS_DATA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_VPD_MT_0_VERSION_LAYOUT getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_0_version_layout(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_0_VERSION_LAYOUT, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_0_VERSION_LAYOUT: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_1_VERSION_DATA getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_1_version_data(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_1_VERSION_DATA, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(), o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_1_VERSION_DATA: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_2_SIGNATURE_DIMM0RANK_DIMM1RANK getter
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generateParameters (SYSTEM)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_2_signature_dimm0rank_dimm1rank(uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_2_SIGNATURE_DIMM0RANK_DIMM1RANK, fapi2::Target<fapi2::TARGET_TYPE_SYSTEM>(),
                            o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_2_SIGNATURE_DIMM0RANK_DIMM1RANK: 0x%lx (system target)",
             uint64_t(fapi2::current_err));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_CKE_PRI_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_cke_pri_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_CKE_PRI_MAP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_CKE_PRI_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_CKE_PRI_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_cke_pri_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_CKE_PRI_MAP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_CKE_PRI_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_CKE_PRI_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_cke_pri_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_CKE_PRI_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_CKE_PRI_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_CKE_PWR_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_cke_pwr_map(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_CKE_PWR_MAP, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_CKE_PWR_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_CKE_PWR_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint32_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_cke_pwr_map(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint32_t& o_value)
{
    uint32_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_CKE_PWR_MAP, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_CKE_PWR_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_CKE_PWR_MAP getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint32_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_cke_pwr_map(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint32_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint32_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_CKE_PWR_MAP, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_CKE_PWR_MAP: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DIMM_RCD_IBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DIMM_RCD_IBT, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DIMM_RCD_IBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DIMM_RCD_IBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DIMM_RCD_IBT, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DIMM_RCD_IBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DIMM_RCD_IBT getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_ibt(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DIMM_RCD_IBT, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DIMM_RCD_IBT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (F)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_output_timing(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING, l_mcs, l_value) );
    o_value = l_value[mss::index(l_mca)][mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (G)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_output_timing(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (H)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dimm_rcd_output_timing(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DIMM_RCD_OUTPUT_TIMING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_NOM, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_NOM getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_nom(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_NOM, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_NOM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_PARK, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_PARK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_park(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_PARK, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_PARK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_DRAM_RTT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_dram_rtt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_DRAM_RTT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_DRAM_RTT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_ADDR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_ADDR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_ADDR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_CLK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_CLK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_CLK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_CNTL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_CNTL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_CNTL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_SPCKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_spcke(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_SPCKE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_SPCKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_SPCKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_spcke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_SPCKE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_SPCKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_DRV_IMP_SPCKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_drv_imp_spcke(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_DRV_IMP_SPCKE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_DRV_IMP_SPCKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_rcv_imp_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_RCV_IMP_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_ADDR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_addr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_ADDR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_ADDR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_addr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_ADDR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_ADDR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_CLK, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_clk(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_CLK, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_CLK getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_clk(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_CLK, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_CLK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_CNTL, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_cntl(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_CNTL, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_CNTL getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_cntl(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_CNTL, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_CNTL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS, i_target.getParent<fapi2::TARGET_TYPE_MCS>(),
                            l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_dq_dqs(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_DQ_DQS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_SPCKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_spcke(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_SPCKE, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_SPCKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_SPCKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_spcke(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_SPCKE, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_SPCKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_MC_SLEW_RATE_SPCKE getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_mc_slew_rate_spcke(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target,
        uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_MC_SLEW_RATE_SPCKE, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_MC_SLEW_RATE_SPCKE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_ODT_RD, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_ODT_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_odt_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_ODT_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_ODT_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (A)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();
    auto l_mcs = l_mca.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(l_mca)][mss::index(i_target)][0]), 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (B)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];
    auto l_mcs = i_target.getParent<fapi2::TARGET_TYPE_MCS>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_ODT_WR, l_mcs, l_value) );
    memcpy(o_array, &(l_value[mss::index(i_target)][0]), 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_ODT_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (C)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_odt_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2][2][2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_ODT_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_ODT_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_GPO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_gpo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_GPO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_GPO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_gpo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_GPO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_GPO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_RLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_rlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_RLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_RLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_rlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_RLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_RLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_WLO, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_wlo(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_WLO, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_OFFSET_WLO getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_offset_wlo(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_OFFSET_WLO, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_OFFSET_WLO: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_VREF_DRAM_WR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_VREF_DRAM_WR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_VREF_DRAM_WR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_vref_dram_wr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_VREF_DRAM_WR, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_VREF_DRAM_WR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_VREF_MC_RD, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint8_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint8_t& o_value)
{
    uint8_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_VREF_MC_RD, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_VREF_MC_RD getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint8_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_vref_mc_rd(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint8_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint8_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_VREF_MC_RD, i_target, l_value) );
    memcpy(o_array, &l_value, 2);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_VREF_MC_RD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCA>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCA>& i_target, uint16_t& o_value)
{
    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_WINDAGE_RD_CTR, i_target.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_DIMM>
/// @param[out] ref to the value uint16_t
/// @note Generated by gen_accessors.pl generateParameters (D.1)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint16_t& o_value)
{
    uint16_t l_value[2];
    auto l_mca = i_target.getParent<fapi2::TARGET_TYPE_MCA>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_WINDAGE_RD_CTR, l_mca.getParent<fapi2::TARGET_TYPE_MCS>(), l_value) );
    o_value = l_value[mss::index(l_mca)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_VPD_MT_WINDAGE_RD_CTR getter
/// @param[in] const ref to the fapi2::Target<fapi2::TARGET_TYPE_MCS>
/// @param[out] uint16_t* memory to store the value
/// @note Generated by gen_accessors.pl generateParameters (E)
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  No description
///
inline fapi2::ReturnCode vpd_mt_windage_rd_ctr(const fapi2::Target<fapi2::TARGET_TYPE_MCS>& i_target, uint16_t* o_array)
{
    if (o_array == nullptr)
    {
        FAPI_ERR("nullptr passed to attribute accessor %s", __func__);
        return fapi2::FAPI2_RC_INVALID_PARAMETER;
    }

    uint16_t l_value[2];

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_VPD_MT_WINDAGE_RD_CTR, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed accessing ATTR_VPD_MT_WINDAGE_RD_CTR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


}

#endif
