/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/ocmb/odyssey/procedures/hwp/memory/lib/mss_odyssey_attribute_getters.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2022,2023                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_odyssey_attribute_getters.H
#ifndef MSS_ODYSSEY_ATTR_GETTERS_H_
#define MSS_ODYSSEY_ATTR_GETTERS_H_

#include <fapi2.H>
#include <generic/memory/lib/utils/index.H>
#include <generic/memory/lib/utils/c_str.H>



namespace mss
{
namespace attr
{
///
/// @brief ATTR_ODY_MSG_BLOCK_DATA_SOURCE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Switch from using attribute control in PHY message block to using sim environment
/// hard codes.
///
inline fapi2::ReturnCode get_ody_msg_block_data_source(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_MSG_BLOCK_DATA_SOURCE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_MSG_BLOCK_DATA_SOURCE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_VERBOSITY getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls the number of debug messages sent by the Odyssey PHY firmware based on
/// verbosity field (HdtCtrl) in the training Message Block
///
inline fapi2::ReturnCode get_ody_draminit_verbosity(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DRAMINIT_VERBOSITY, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DRAMINIT_VERBOSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_PHY_GET_MAIL_TIMEOUT getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Timeout (in msec) polling for get_mail during ody draminit training. Default is
/// 20000msec.
///
inline fapi2::ReturnCode get_phy_get_mail_timeout(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_PHY_GET_MAIL_TIMEOUT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_PHY_GET_MAIL_TIMEOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_DRAMINIT_TRAINING_TIMEOUT getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Timeout (in msec) for polling completion of ody draminit training. Default is 20000msec.
///
inline fapi2::ReturnCode get_draminit_training_timeout(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_DRAMINIT_TRAINING_TIMEOUT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_DRAMINIT_TRAINING_TIMEOUT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_ARDPTRINITVAL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Initial pointer separation for the free-running FIFOs in the DBYTE and ACX4 macros,
/// in units of UI. Legal values are 0-10.
///
inline fapi2::ReturnCode get_ardptrinitval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_ARDPTRINITVAL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_ARDPTRINITVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_ARDPTRINITVALOVR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set this to 1 if the ARdPtrInitVal should be overriden via userInput.
///
inline fapi2::ReturnCode get_ardptrinitvalovr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_ARDPTRINITVALOVR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_ARDPTRINITVALOVR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DIS_PTRINITCLR_TXTRACKING getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Whether to disable PtrInit from clearing the TxTrkState csr during skip retrain.
///
inline fapi2::ReturnCode get_dis_ptrinitclr_txtracking(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DIS_PTRINITCLR_TXTRACKING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DIS_PTRINITCLR_TXTRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_EXTCALRESVAL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicates value of impedance calibration pull-down resistor connected to BP_ZN pin
/// of the Odyssey PHY.
///
inline fapi2::ReturnCode get_extcalresval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_EXTCALRESVAL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_EXTCALRESVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_MEMALERTEN getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Indicate how the ERR/ALERT signal (which communicates feedback such as an address/command
/// parity error) should be accommodated.
///
inline fapi2::ReturnCode get_memalerten(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_MEM_EFF_MEMALERTEN, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_MEM_EFF_MEMALERTEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_MSTRTRAIN_INTERVAL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Time between the end of one training step and the start of the next. It is the max
/// expected time from dfi_init_complete asserted to tdfi_phymstr_ack asserted.
///
inline fapi2::ReturnCode get_phy_mstrtrain_interval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_MSTRTRAIN_INTERVAL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_MSTRTRAIN_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_MSTRMAXREQTOACK getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Max time from tdfi_phymstr_req asserted to tdfi_phymstr_ack asserted.
///
inline fapi2::ReturnCode get_phy_mstrmaxreqtoack(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_MSTRMAXREQTOACK, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_MSTRMAXREQTOACK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_MSTRCTRLMODE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Phy Master Control Mode
///
inline fapi2::ReturnCode get_phy_mstrctrlmode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_MSTRCTRLMODE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_MSTRCTRLMODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CALINTERVAL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The interval between successive PHY impedance calibrations.
///
inline fapi2::ReturnCode get_phy_calinterval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_CALINTERVAL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_CALINTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CALONCE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Selects the behaviour of CSR CalRun. CALINTERVAL causes calibration to be initiated
/// at the CALINTERVAL interval. CALRUN causes it to be run once each time CALRUN transitions
/// from 0 to 1.
///
inline fapi2::ReturnCode get_phy_calonce(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_CALONCE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_CALONCE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_IS_HIGHVDD getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  When VDD=0.9V nominal, set this to 1'b1, otherwise set to 1'b0. This input is used
/// to program TxSlewRate[8] and ATxSlewRate[9].
///
inline fapi2::ReturnCode get_phy_is_highvdd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_IS_HIGHVDD, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_IS_HIGHVDD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_EN_TDQS2DQ_TRACKING getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable tracking of tDQS2DQ. Array[RANK]
///
inline fapi2::ReturnCode get_phy_en_tdqs2dq_tracking(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t& o_value)
{
    uint8_t l_value[4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_EN_TDQS2DQ_TRACKING, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_EN_TDQS2DQ_TRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_EN_TDQS2DQ_TRACKING getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable tracking of tDQS2DQ. Array[RANK]
///
inline fapi2::ReturnCode get_phy_en_tdqs2dq_tracking(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&o_array)[4])
{
    uint8_t l_value[4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_EN_TDQS2DQ_TRACKING, i_target, l_value) );
    memcpy(o_array, &l_value, 4);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_EN_TDQS2DQ_TRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DQS_OSC_RUNTIME_SEL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQS oscillator interval timer (in MEMCLK). Must match the value programmed to the
/// MR for DQS oscillator interval timer.
///
inline fapi2::ReturnCode get_phy_dqs_osc_runtime_sel(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DQS_OSC_RUNTIME_SEL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DQS_OSC_RUNTIME_SEL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_EN_RXDQS_TRACKING getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable tracking of the incoming read DQS to modify the read gate timing.
///
inline fapi2::ReturnCode get_phy_en_rxdqs_tracking(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_EN_RXDQS_TRACKING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_EN_RXDQS_TRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DISABLE_PMU_ECC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Disables ARC Microcontroller ECC.
///
inline fapi2::ReturnCode get_phy_disable_pmu_ecc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DISABLE_PMU_ECC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DISABLE_PMU_ECC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ENABLE_MALERT_ASYNC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables Async Path from MALERT_N to dfi_alert_n.
///
inline fapi2::ReturnCode get_phy_enable_malert_async(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ENABLE_MALERT_ASYNC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ENABLE_MALERT_ASYNC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ALERT_RECOV_ENABLE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enables logic that disables/resets RxTracking during an Alert.
///
inline fapi2::ReturnCode get_phy_alert_recov_enable(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ALERT_RECOV_ENABLE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ALERT_RECOV_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_RST_RXTRK_STATE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Controls Async Path from MALERT_N to dfi_alert_n. Controls whether an alert will
/// SUSPEND RxTracking until the next ctrlupd or an alert will RESET RxTracking state
///
inline fapi2::ReturnCode get_phy_rst_rxtrk_state(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_RST_RXTRK_STATE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_RST_RXTRK_STATE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TDQS2DQ getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DQ to DQS offset (tDQS2DQ, in integer number of ps) for sim.
///
inline fapi2::ReturnCode get_sim_tdqs2dq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TDQS2DQ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TDQS2DQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TDQSCK getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAM DQS device delay value (tDQSCK, in integer number of ps) for sim.
///
inline fapi2::ReturnCode get_sim_tdqsck(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TDQSCK, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TDQSCK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TSTAOFF getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RCD clock delay (integer number of ps) for sim.
///
inline fapi2::ReturnCode get_sim_tstaoff(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TSTAOFF, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TSTAOFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TPDM getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  LRDIMM data buffer delay (in integer number of ps) for sim.
///
inline fapi2::ReturnCode get_sim_tpdm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TPDM, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TPDM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TCASL_OVERRIDE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Disables automatically calculating userInputSim->tCASL_add (for sim).
///
inline fapi2::ReturnCode get_sim_tcasl_override(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TCASL_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TCASL_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TCASL_ADD getter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS latency added value for sim mode. userInputSim->tCASL_add (for sim). Valid only
/// if ATTR_ODY_SIM_TCASL_OVERRIDE is set. Array[RANK]
///
inline fapi2::ReturnCode get_sim_tcasl_add(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t& o_value)
{
    uint16_t l_value[4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TCASL_ADD, l_port, l_value) );
    o_value = l_value[mss::index(i_target)];
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TCASL_ADD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TCASL_ADD getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t&[] array reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CAS latency added value for sim mode. userInputSim->tCASL_add (for sim). Valid only
/// if ATTR_ODY_SIM_TCASL_OVERRIDE is set. Array[RANK]
///
inline fapi2::ReturnCode get_sim_tcasl_add(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&o_array)[4])
{
    uint16_t l_value[4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TCASL_ADD, i_target, l_value) );
    memcpy(o_array, &l_value, 8);
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SIM_TCASL_ADD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ADV_TRAIN_OPT getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Advanced training options for DDR5 training. AdvTrainOpt[7:0] in the message block
/// structure.
///
inline fapi2::ReturnCode get_phy_adv_train_opt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ADV_TRAIN_OPT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ADV_TRAIN_OPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_MSG_MISC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Misc training options for DDR5 training. MsgMisc[7:0] in the message block structure.
///
inline fapi2::ReturnCode get_phy_msg_misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_MSG_MISC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_MSG_MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PLL_BYPASS_EN getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Select if the PHY uses PLL bypass. PllBypassEn in the message block structure.
///
inline fapi2::ReturnCode get_phy_pll_bypass_en(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PLL_BYPASS_EN, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PLL_BYPASS_EN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_RX2D_DFE_MISC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Extra option for RX2D when DFE is set. RX2D_DFE_Misc in the message block structure.
///
inline fapi2::ReturnCode get_phy_rx2d_dfe_misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_RX2D_DFE_MISC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_RX2D_DFE_MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_D5MISC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DFI options for DDR5 training. D5Misc in the message block structure.
///
inline fapi2::ReturnCode get_phy_d5misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_D5MISC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_D5MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_WL_ADJ getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Offset to apply at the end of Write-Leveling (in fine steps). Signed value: if bit
/// 0 == '1' value is negative.
///
inline fapi2::ReturnCode get_phy_wl_adj(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_WL_ADJ, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_WL_ADJ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SEQUENCE_CTRL getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Training step enables for DDR5 training. SequenceCtrl in the message block structure.
/// Note that RCD_CSCA is only valid for RDIMM and will be disabled by the procedures
/// on a UDIMM.
///
inline fapi2::ReturnCode get_phy_sequence_ctrl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SEQUENCE_CTRL, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SEQUENCE_CTRL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CFG getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  PHY config settings for DDR5 training. PhyCfg in the message block structure.
///
inline fapi2::ReturnCode get_phy_cfg(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_CFG, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_CFG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_DFIMRL_MARGIN getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Margin added to the smallest passing trained DFI Max Read Latency value, in units
/// of DFI clocks. Recommended to be >= 1. DFIMRLMargin in the message block structure.
///
inline fapi2::ReturnCode get_dfimrl_margin(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_DFIMRL_MARGIN, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_DFIMRL_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_USE_BROADCAST_MR getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Set whether or not per rank MR values are used. UseBroadcastMR in the message block
/// structure.
///
inline fapi2::ReturnCode get_phy_use_broadcast_mr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_USE_BROADCAST_MR, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_USE_BROADCAST_MR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_DISABLED_DBYTE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bitmap to indicate which Dbytes are not connected (for DByte 0 to 7). Set DisabledDbyte[i]
/// to 1 to specify that DByte i does not need to be trained (DByte 8 and 9 can be disabled
/// via EnabledDQs setting). DisabledDbyte in the message block structure.
///
inline fapi2::ReturnCode get_disabled_dbyte(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_DISABLED_DBYTE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_DISABLED_DBYTE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CA_TRAIN_OPTIONS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA training options (bit 0 on the left): [7] Enable RDIMM/LRDIMM 2D CA training
/// (UDIMM: RFU, must be zero) [6] Enable RDIMM/LRDIMM CA DFE training (UDIMM: RFU,
/// must be zero) [4:5] step size for CS and CA training: 0 -> 1, 1 -> 2, 2 -> 4, 3
/// -> 8 [3] Set to 1 to Skip CA13 during CA training [2] Enable RDIMM/LRDIMM 2D CS
/// training (UDIMM: RFU, must be zero) [1] RFU, must be zero [0] Use multiple patterns
/// during CA training CATrainOpt in the message block structure.
///
inline fapi2::ReturnCode get_ca_train_options(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_CA_TRAIN_OPTIONS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_CA_TRAIN_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  CA DFE training options (bit 0 on the left): [6:7] NbTAPm1: Number of TAP (NbTAP)
/// to train is NbTAPm1 + 1 (TAP are trained from 1 to NbTAP) [4:5] BiasStepMode: delta
/// to use when iterating TAP BiasStep from min to max 0 = delta 1 for all trained TAP
/// 1 = delta 2 for all trained TAP 2 = delta 5 for all trained TAP 3 = delta 16 for
/// TAP1, 10 for TAP2, 7 for TAP3 and 7 for TAP4 (useful for simulation) [2:3] VStepSize:
/// VrefCA step size (2^n) 0 = step size of 1 1 = step size of 2 2 = step size of 4
/// 3 = step size of 8 [1] TrainDFEGain: when set, train the DFE Gain Offset [0] DFEVrefEnable:
/// when set, DFE Vref circuitry will be enabled during and after CA DFE training Reserved1E2
/// in the message block structure.
///
inline fapi2::ReturnCode get_ca_dfe_train_options(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_CA_DFE_TRAIN_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_TX2D_DFE_MISC getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TX2D DFE training options (bit 0 on the left): [6:7] Number of TAP to train, minus
/// one [4:5] Delta to use when iterating TAP BiasStep from min to max [2:3] StepSize
/// used for Voltage, 2^StepSize will be used [0:1] StepSize used for Delay, 2^StepSize
/// will be used TX2D_DFE_Misc in the message block structure.
///
inline fapi2::ReturnCode get_tx2d_dfe_misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_TX2D_DFE_MISC, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_TX2D_DFE_MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_RX2D_TRAIN_OPT getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  RX2D training options (bit 0 on the left): [7] Set to 1 to run rx2D with DFE [5:6]
/// Voltage Step Size (2^n) [3:4] Delay Step Size (2^n) [2] Voltage Step Size Multiplier
/// [1] Delay Step Size Multiplier [0] RFU, must be zero RX2D_TrainOpt in the message
/// block structure.
///
inline fapi2::ReturnCode get_rx2d_train_opt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_RX2D_TRAIN_OPT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_RX2D_TRAIN_OPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_TX2D_TRAIN_OPT getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  TX2D training options (bit 0 on the left): [7] Set to 1 to run tx2D with DFE [5:6]
/// Voltage Step Size (2^n) [3:4] Delay Step Size (2^n) [2] Voltage Step Size Multiplier
/// [1] Delay Step Size Multiplier [0] RFU, must be zero TX2D_TrainOpt in the message
/// block structure.
///
inline fapi2::ReturnCode get_tx2d_train_opt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_TX2D_TRAIN_OPT, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_TX2D_TRAIN_OPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Bit fields (bit 0 on the left): [7]: SingleBurstPDA: when set, use the single burst
/// PDA ID enumeration method [6]: DumpMR: when set, read and dump MR values after read
/// and write training stages (only when HdtCtrl is less than or equal to 4) [5]: KeepODT:
/// when set, ODT_on / off values in MR37, MR38 and MR39 are programmed as specified
/// in the message block during training [4]: ResetIntWL: when set, MR2[7] is set to
/// 0 during devinit [3]: ForceDPAR: when set, DPAR signal is forced to high during
/// RCD initialization, or RCD self-refresh exit [2] RFU, must be 0 [1]: ExtendWLrangeUpperLimit:
/// When set, avoid backoff during WL search based on WrPre setting to permit covering
/// a larger maximal WL skew [0]: tDqs2DqOverwrite (debug option only): when set, non-zero
/// VrefDq* field overwrite extracted tDQS2DQ delay associated with the corresponding
/// nibble before when starting wr2D training Reserved1E4 in the message block structure.
///
inline fapi2::ReturnCode get_debug_train_options(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_DEBUG_TRAIN_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CONFIG_OVERRIDE getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Override for PhyConfig CSR, or set to 0 to use the CSR value. PhyConfigOverride
/// in the message block structure.
///
inline fapi2::ReturnCode get_phy_config_override(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_CONFIG_OVERRIDE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_CONFIG_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_ENABLED_DQ_CHA getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of DQ bits enabled in PHY Channel A. EnabledDQsChA in the message block
/// structure.
///
inline fapi2::ReturnCode get_phy_enabled_dq_cha(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_ENABLED_DQ_CHA, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_ENABLED_DQ_CHA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_ENABLED_DQ_CHB getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Total number of DQ bits enabled in PHY Channel B. EnabledDQsChB in the message block
/// structure.
///
inline fapi2::ReturnCode get_phy_enabled_dq_chb(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PHY_ENABLED_DQ_CHB, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PHY_ENABLED_DQ_CHB: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_FW_REVISION getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAMINIT's firmware binary's revision
///
inline fapi2::ReturnCode get_ody_draminit_fw_revision(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DRAMINIT_FW_REVISION, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DRAMINIT_FW_REVISION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0 getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAMINIT's firmware internal binary's revision 0
///
inline fapi2::ReturnCode get_ody_draminit_internal_fw_revision0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1 getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAMINIT's firmware internal binary's revision 1
///
inline fapi2::ReturnCode get_ody_draminit_internal_fw_revision1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint16_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  DRAMINIT's firmware's address offset for additional data
///
inline fapi2::ReturnCode get_ody_draminit_fw_data_addr_offset(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DMEM_FIRST_LOAD getter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Keeps track if the Odyssey's DMEM has been loaded before As the DMEM can be reset
/// to all zeroes, this attribute can be used to speed up the DMEM loads by skipping
/// the any DMEM addresses that are zeroes
///
inline fapi2::ReturnCode get_ody_dmem_first_load(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_DMEM_FIRST_LOAD, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_DMEM_FIRST_LOAD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_ODY_ENABLE_US_TMPL_1 getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable Odyssey upstream transmit template 1. Should be disabled by default.
///
inline fapi2::ReturnCode get_ody_enable_us_tmpl_1(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ENABLE_US_TMPL_1, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ENABLE_US_TMPL_1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ENABLE_US_TMPL_5 getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable Odyssey upstream transmit template 5. Should be enabled by default.
///
inline fapi2::ReturnCode get_ody_enable_us_tmpl_5(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ENABLE_US_TMPL_5, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ENABLE_US_TMPL_5: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ENABLE_US_TMPL_9 getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable Odyssey upstream transmit template 9. Should be enabled by default.
///
inline fapi2::ReturnCode get_ody_enable_us_tmpl_9(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ENABLE_US_TMPL_9, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ENABLE_US_TMPL_9: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ENABLE_US_TMPL_A getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable Odyssey upstream transmit template A. Not supported by Axone
///
inline fapi2::ReturnCode get_ody_enable_us_tmpl_a(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ENABLE_US_TMPL_A, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ENABLE_US_TMPL_A: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ENABLE_US_TMPL_B getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable Odyssey upstream transmit template 11. Should be disabled by default.
///
inline fapi2::ReturnCode get_ody_enable_us_tmpl_b(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ENABLE_US_TMPL_B, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ENABLE_US_TMPL_B: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_TMPL_0_PACING getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Template 0 pacing
///
inline fapi2::ReturnCode get_ody_tmpl_0_pacing(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_TMPL_0_PACING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_TMPL_0_PACING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_TMPL_1_PACING getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Template 1 pacing
///
inline fapi2::ReturnCode get_ody_tmpl_1_pacing(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_TMPL_1_PACING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_TMPL_1_PACING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_TMPL_5_PACING getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Template 5 pacing
///
inline fapi2::ReturnCode get_ody_tmpl_5_pacing(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_TMPL_5_PACING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_TMPL_5_PACING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_TMPL_9_PACING getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Template 9 pacing
///
inline fapi2::ReturnCode get_ody_tmpl_9_pacing(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_TMPL_9_PACING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_TMPL_9_PACING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_TMPL_B_PACING getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Template B pacing
///
inline fapi2::ReturnCode get_ody_tmpl_b_pacing(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_TMPL_B_PACING, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_TMPL_B_PACING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SHRT_BACKOFF_TIMER getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Short back-off timer value.
///
inline fapi2::ReturnCode get_ody_shrt_backoff_timer(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SHRT_BACKOFF_TIMER, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_SHRT_BACKOFF_TIMER: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_METADATA_ENABLE getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  Enable OpenCAPI metadata
///
inline fapi2::ReturnCode get_ody_metadata_enable(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_METADATA_ENABLE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_METADATA_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PASID_BASE getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The PASID base
///
inline fapi2::ReturnCode get_ody_pasid_base(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PASID_BASE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PASID_BASE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ACTAG_BASE getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The desired actag base
///
inline fapi2::ReturnCode get_ody_actag_base(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_ACTAG_BASE, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_ACTAG_BASE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_AFU_ACTAG_LEN getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint32_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The expected number of actags to be supported by the ocmb. Must be 0 for Odyssey
/// Validate via OCTRLTAG 10518 OCTRLTAG_AFU_ACTAG_LENGTH_SUPPORTED
///
inline fapi2::ReturnCode get_ody_afu_actag_len(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint32_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_AFU_ACTAG_LEN, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_AFU_ACTAG_LEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PASID_LEN getter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[out] uint8_t& reference to store the value
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff get is OK
/// @note  The expected number of PASIDs to be supported by the ocmb. Number of consecutive
/// PASIDs this AFU supports is 2^pasid_length_supported Validate via OPASID 10100 OPASID_MAX_PASID_WIDTH
///
inline fapi2::ReturnCode get_ody_pasid_len(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t& o_value)
{

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_PASID_LEN, i_target, o_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed getting ATTR_ODY_PASID_LEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


} // attr
} // mss

#endif
