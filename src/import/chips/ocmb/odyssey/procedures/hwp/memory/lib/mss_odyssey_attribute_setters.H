/* IBM_PROLOG_BEGIN_TAG                                                   */
/* This is an automatically generated prolog.                             */
/*                                                                        */
/* $Source: src/import/chips/ocmb/odyssey/procedures/hwp/memory/lib/mss_odyssey_attribute_setters.H $ */
/*                                                                        */
/* OpenPOWER HostBoot Project                                             */
/*                                                                        */
/* Contributors Listed Below - COPYRIGHT 2022,2023                        */
/* [+] International Business Machines Corp.                              */
/*                                                                        */
/*                                                                        */
/* Licensed under the Apache License, Version 2.0 (the "License");        */
/* you may not use this file except in compliance with the License.       */
/* You may obtain a copy of the License at                                */
/*                                                                        */
/*     http://www.apache.org/licenses/LICENSE-2.0                         */
/*                                                                        */
/* Unless required by applicable law or agreed to in writing, software    */
/* distributed under the License is distributed on an "AS IS" BASIS,      */
/* WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        */
/* implied. See the License for the specific language governing           */
/* permissions and limitations under the License.                         */
/*                                                                        */
/* IBM_PROLOG_END_TAG                                                     */
// mss_odyssey_attribute_setters.H
#ifndef MSS_ODYSSEY_ATTR_SETTERS_H_
#define MSS_ODYSSEY_ATTR_SETTERS_H_

#include <fapi2.H>
#include <generic/memory/lib/utils/index.H>
#include <generic/memory/lib/utils/c_str.H>



namespace mss
{
namespace attr
{
///
/// @brief ATTR_MEM_EFF_ARDPTRINITVAL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Initial pointer separation for the free-running FIFOs in the DBYTE and ACX4 macros,
/// in units of UI. Legal values are 0-10.
///
inline fapi2::ReturnCode set_ardptrinitval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_ARDPTRINITVAL, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_MEM_EFF_ARDPTRINITVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_ARDPTRINITVALOVR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Set this to 1 if the ARdPtrInitVal should be overriden via userInput.
///
inline fapi2::ReturnCode set_ardptrinitvalovr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_ARDPTRINITVALOVR, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_MEM_EFF_ARDPTRINITVALOVR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DIS_PTRINITCLR_TXTRACKING setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Whether to disable PtrInit from clearing the TxTrkState csr during skip retrain.
///
inline fapi2::ReturnCode set_dis_ptrinitclr_txtracking(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DIS_PTRINITCLR_TXTRACKING, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DIS_PTRINITCLR_TXTRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_EXTCALRESVAL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Indicates value of impedance calibration pull-down resistor connected to BP_ZN pin
/// of the Odyssey PHY.
///
inline fapi2::ReturnCode set_extcalresval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_EXTCALRESVAL, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_MEM_EFF_EXTCALRESVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_MEM_EFF_MEMALERTEN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Indicate how the ERR/ALERT signal (which communicates feedback such as an address/command
/// parity error) should be accommodated.
///
inline fapi2::ReturnCode set_memalerten(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_MEM_EFF_MEMALERTEN, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_MEM_EFF_MEMALERTEN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_MSTRTRAIN_INTERVAL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Time between the end of one training step and the start of the next. It is the max
/// expected time from dfi_init_complete asserted to tdfi_phymstr_ack asserted.
///
inline fapi2::ReturnCode set_phy_mstrtrain_interval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_MSTRTRAIN_INTERVAL, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_MSTRTRAIN_INTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_MSTRMAXREQTOACK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Max time from tdfi_phymstr_req asserted to tdfi_phymstr_ack asserted.
///
inline fapi2::ReturnCode set_phy_mstrmaxreqtoack(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_MSTRMAXREQTOACK, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_MSTRMAXREQTOACK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_MSTRCTRLMODE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Phy Master Control Mode
///
inline fapi2::ReturnCode set_phy_mstrctrlmode(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_MSTRCTRLMODE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_MSTRCTRLMODE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CALINTERVAL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  The interval between successive PHY impedance calibrations.
///
inline fapi2::ReturnCode set_phy_calinterval(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_CALINTERVAL, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_CALINTERVAL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CALONCE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Selects the behaviour of CSR CalRun. CALINTERVAL causes calibration to be initiated
/// at the CALINTERVAL interval. CALRUN causes it to be run once each time CALRUN transitions
/// from 0 to 1.
///
inline fapi2::ReturnCode set_phy_calonce(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_CALONCE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_CALONCE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_IS_HIGHVDD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  When VDD=0.9V nominal, set this to 1'b1, otherwise set to 1'b0. This input is used
/// to program TxSlewRate[8] and ATxSlewRate[9].
///
inline fapi2::ReturnCode set_phy_is_highvdd(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_IS_HIGHVDD, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_IS_HIGHVDD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_EN_TDQS2DQ_TRACKING setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Enable tracking of tDQS2DQ. Array[RANK]
///
inline fapi2::ReturnCode set_phy_en_tdqs2dq_tracking(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target,
        uint8_t i_value)
{
    uint8_t l_value[4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_EN_TDQS2DQ_TRACKING, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_EN_TDQS2DQ_TRACKING, l_port, l_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_EN_TDQS2DQ_TRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_EN_TDQS2DQ_TRACKING setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Enable tracking of tDQS2DQ. Array[RANK]
///
inline fapi2::ReturnCode set_phy_en_tdqs2dq_tracking(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t (&i_array)[4])
{
    uint8_t l_value[4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_EN_TDQS2DQ_TRACKING, i_target, l_value) );
    memcpy(&l_value, i_array, 4);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_EN_TDQS2DQ_TRACKING, i_target, l_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_EN_TDQS2DQ_TRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DQS_OSC_RUNTIME_SEL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DQS oscillator interval timer (in MEMCLK). Must match the value programmed to the
/// MR for DQS oscillator interval timer.
///
inline fapi2::ReturnCode set_phy_dqs_osc_runtime_sel(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DQS_OSC_RUNTIME_SEL, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DQS_OSC_RUNTIME_SEL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_EN_RXDQS_TRACKING setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Enable tracking of the incoming read DQS to modify the read gate timing.
///
inline fapi2::ReturnCode set_phy_en_rxdqs_tracking(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_EN_RXDQS_TRACKING, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_EN_RXDQS_TRACKING: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DISABLE_PMU_ECC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Disables ARC Microcontroller ECC.
///
inline fapi2::ReturnCode set_phy_disable_pmu_ecc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DISABLE_PMU_ECC, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DISABLE_PMU_ECC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ENABLE_MALERT_ASYNC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Enables Async Path from MALERT_N to dfi_alert_n.
///
inline fapi2::ReturnCode set_phy_enable_malert_async(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_ENABLE_MALERT_ASYNC, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_ENABLE_MALERT_ASYNC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ALERT_RECOV_ENABLE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Enables logic that disables/resets RxTracking during an Alert.
///
inline fapi2::ReturnCode set_phy_alert_recov_enable(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_ALERT_RECOV_ENABLE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_ALERT_RECOV_ENABLE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_RST_RXTRK_STATE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Controls Async Path from MALERT_N to dfi_alert_n. Controls whether an alert will
/// SUSPEND RxTracking until the next ctrlupd or an alert will RESET RxTracking state
///
inline fapi2::ReturnCode set_phy_rst_rxtrk_state(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_RST_RXTRK_STATE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_RST_RXTRK_STATE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TDQS2DQ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DQ to DQS offset (tDQS2DQ, in integer number of ps) for sim.
///
inline fapi2::ReturnCode set_sim_tdqs2dq(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TDQS2DQ, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TDQS2DQ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TDQSCK setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAM DQS device delay value (tDQSCK, in integer number of ps) for sim.
///
inline fapi2::ReturnCode set_sim_tdqsck(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TDQSCK, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TDQSCK: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TSTAOFF setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RCD clock delay (integer number of ps) for sim.
///
inline fapi2::ReturnCode set_sim_tstaoff(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TSTAOFF, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TSTAOFF: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TPDM setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  LRDIMM data buffer delay (in integer number of ps) for sim.
///
inline fapi2::ReturnCode set_sim_tpdm(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TPDM, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TPDM: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TCASL_OVERRIDE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Disables automatically calculating userInputSim->tCASL_add (for sim).
///
inline fapi2::ReturnCode set_sim_tcasl_override(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TCASL_OVERRIDE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TCASL_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TCASL_ADD setter
/// @param[in] const ref to the TARGET_TYPE_DIMM
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  CAS latency added value for sim mode. userInputSim->tCASL_add (for sim). Valid only
/// if ATTR_ODY_SIM_TCASL_OVERRIDE is set. Array[RANK]
///
inline fapi2::ReturnCode set_sim_tcasl_add(const fapi2::Target<fapi2::TARGET_TYPE_DIMM>& i_target, uint16_t i_value)
{
    uint16_t l_value[4] = {};
    const auto l_port = i_target.getParent<fapi2::TARGET_TYPE_MEM_PORT>();

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TCASL_ADD, l_port, l_value) );
    l_value[mss::index(i_target)] = i_value;
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TCASL_ADD, l_port, l_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TCASL_ADD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SIM_TCASL_ADD setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t&[] ref to array of values to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  CAS latency added value for sim mode. userInputSim->tCASL_add (for sim). Valid only
/// if ATTR_ODY_SIM_TCASL_OVERRIDE is set. Array[RANK]
///
inline fapi2::ReturnCode set_sim_tcasl_add(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t (&i_array)[4])
{
    uint16_t l_value[4] = {};

    FAPI_TRY( FAPI_ATTR_GET(fapi2::ATTR_ODY_SIM_TCASL_ADD, i_target, l_value) );
    memcpy(&l_value, i_array, 8);
    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SIM_TCASL_ADD, i_target, l_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SIM_TCASL_ADD: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_ADV_TRAIN_OPT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Advanced training options for DDR5 training. AdvTrainOpt[7:0] in the message block
/// structure.
///
inline fapi2::ReturnCode set_phy_adv_train_opt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_ADV_TRAIN_OPT, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_ADV_TRAIN_OPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_MSG_MISC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Misc training options for DDR5 training. MsgMisc[7:0] in the message block structure.
///
inline fapi2::ReturnCode set_phy_msg_misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_MSG_MISC, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_MSG_MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PLL_BYPASS_EN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Select if the PHY uses PLL bypass. PllBypassEn in the message block structure.
///
inline fapi2::ReturnCode set_phy_pll_bypass_en(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PLL_BYPASS_EN, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PLL_BYPASS_EN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_RX2D_DFE_MISC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Extra option for RX2D when DFE is set. RX2D_DFE_Misc in the message block structure.
///
inline fapi2::ReturnCode set_phy_rx2d_dfe_misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_RX2D_DFE_MISC, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_RX2D_DFE_MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_D5MISC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DFI options for DDR5 training. D5Misc in the message block structure.
///
inline fapi2::ReturnCode set_phy_d5misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_D5MISC, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_D5MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_WL_ADJ setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Offset to apply at the end of Write-Leveling (in fine steps). Signed value: if bit
/// 0 == '1' value is negative.
///
inline fapi2::ReturnCode set_phy_wl_adj(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_WL_ADJ, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_WL_ADJ: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_SEQUENCE_CTRL setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Training step enables for DDR5 training. SequenceCtrl in the message block structure.
/// Note that RCD_CSCA is only valid for RDIMM and will be disabled by the procedures
/// on a UDIMM.
///
inline fapi2::ReturnCode set_phy_sequence_ctrl(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_SEQUENCE_CTRL, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_SEQUENCE_CTRL: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CFG setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  PHY config settings for DDR5 training. PhyCfg in the message block structure.
///
inline fapi2::ReturnCode set_phy_cfg(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_CFG, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_CFG: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_DFIMRL_MARGIN setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Margin added to the smallest passing trained DFI Max Read Latency value, in units
/// of DFI clocks. Recommended to be >= 1. DFIMRLMargin in the message block structure.
///
inline fapi2::ReturnCode set_dfimrl_margin(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_DFIMRL_MARGIN, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_DFIMRL_MARGIN: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_USE_BROADCAST_MR setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Set whether or not per rank MR values are used. UseBroadcastMR in the message block
/// structure.
///
inline fapi2::ReturnCode set_phy_use_broadcast_mr(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_USE_BROADCAST_MR, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_USE_BROADCAST_MR: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_DISABLED_DBYTE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Bitmap to indicate which Dbytes are not connected (for DByte 0 to 7). Set DisabledDbyte[i]
/// to 1 to specify that DByte i does not need to be trained (DByte 8 and 9 can be disabled
/// via EnabledDQs setting). DisabledDbyte in the message block structure.
///
inline fapi2::ReturnCode set_disabled_dbyte(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_DISABLED_DBYTE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_DISABLED_DBYTE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CA_TRAIN_OPTIONS setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  CA training options (bit 0 on the left): [7] Enable RDIMM/LRDIMM 2D CA training
/// (UDIMM: RFU, must be zero) [6] Enable RDIMM/LRDIMM CA DFE training (UDIMM: RFU,
/// must be zero) [4:5] step size for CS and CA training: 0 -> 1, 1 -> 2, 2 -> 4, 3
/// -> 8 [3] Set to 1 to Skip CA13 during CA training [2] Enable RDIMM/LRDIMM 2D CS
/// training (UDIMM: RFU, must be zero) [1] RFU, must be zero [0] Use multiple patterns
/// during CA training CATrainOpt in the message block structure.
///
inline fapi2::ReturnCode set_ca_train_options(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_CA_TRAIN_OPTIONS, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_CA_TRAIN_OPTIONS: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_TX2D_DFE_MISC setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  TX2D DFE training options (bit 0 on the left): [6:7] Number of TAP to train, minus
/// one [4:5] Delta to use when iterating TAP BiasStep from min to max [2:3] StepSize
/// used for Voltage, 2^StepSize will be used [0:1] StepSize used for Delay, 2^StepSize
/// will be used TX2D_DFE_Misc in the message block structure.
///
inline fapi2::ReturnCode set_tx2d_dfe_misc(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_TX2D_DFE_MISC, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_TX2D_DFE_MISC: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_RX2D_TRAIN_OPT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  RX2D training options (bit 0 on the left): [7] Set to 1 to run rx2D with DFE [5:6]
/// Voltage Step Size (2^n) [3:4] Delay Step Size (2^n) [2] Voltage Step Size Multiplier
/// [1] Delay Step Size Multiplier [0] RFU, must be zero RX2D_TrainOpt in the message
/// block structure.
///
inline fapi2::ReturnCode set_rx2d_train_opt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_RX2D_TRAIN_OPT, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_RX2D_TRAIN_OPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_TX2D_TRAIN_OPT setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  TX2D training options (bit 0 on the left): [7] Set to 1 to run tx2D with DFE [5:6]
/// Voltage Step Size (2^n) [3:4] Delay Step Size (2^n) [2] Voltage Step Size Multiplier
/// [1] Delay Step Size Multiplier [0] RFU, must be zero TX2D_TrainOpt in the message
/// block structure.
///
inline fapi2::ReturnCode set_tx2d_train_opt(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target, uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_TX2D_TRAIN_OPT, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_TX2D_TRAIN_OPT: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_CONFIG_OVERRIDE setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Override for PhyConfig CSR, or set to 0 to use the CSR value. PhyConfigOverride
/// in the message block structure.
///
inline fapi2::ReturnCode set_phy_config_override(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_CONFIG_OVERRIDE, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_CONFIG_OVERRIDE: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_ENABLED_DQ_CHA setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Total number of DQ bits enabled in PHY Channel A. EnabledDQsChA in the message block
/// structure.
///
inline fapi2::ReturnCode set_phy_enabled_dq_cha(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_ENABLED_DQ_CHA, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_ENABLED_DQ_CHA: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_PHY_ENABLED_DQ_CHB setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Total number of DQ bits enabled in PHY Channel B. EnabledDQsChB in the message block
/// structure.
///
inline fapi2::ReturnCode set_phy_enabled_dq_chb(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_PHY_ENABLED_DQ_CHB, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_PHY_ENABLED_DQ_CHB: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_FW_REVISION setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAMINIT's firmware binary's revision
///
inline fapi2::ReturnCode set_ody_draminit_fw_revision(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>& i_target,
        uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DRAMINIT_FW_REVISION, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DRAMINIT_FW_REVISION: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAMINIT's firmware internal binary's revision 0
///
inline fapi2::ReturnCode set_ody_draminit_internal_fw_revision0(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION0: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1 setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAMINIT's firmware internal binary's revision 1
///
inline fapi2::ReturnCode set_ody_draminit_internal_fw_revision1(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DRAMINIT_INTERNAL_FW_REVISION1: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}

///
/// @brief ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET setter
/// @param[in] const ref to the TARGET_TYPE_MEM_PORT
/// @param[in] uint16_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  DRAMINIT's firmware's address offset for additional data
///
inline fapi2::ReturnCode set_ody_draminit_fw_data_addr_offset(const fapi2::Target<fapi2::TARGET_TYPE_MEM_PORT>&
        i_target, uint16_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DRAMINIT_FW_DATA_ADDR_OFFSET: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


///
/// @brief ATTR_ODY_DRAMINIT_VERBOSITY setter
/// @param[in] const ref to the TARGET_TYPE_OCMB_CHIP
/// @param[in] uint8_t the value to set
/// @note Generated by gen_accessors.pl generate_mc_port_params
/// @return fapi2::ReturnCode - FAPI2_RC_SUCCESS iff set is OK
/// @note  Controls the number of debug messages sent by the Odyssey PHY firmware based on
/// verbosity field (HdtCtrl) in the training Message Block
///
inline fapi2::ReturnCode set_ody_draminit_verbosity(const fapi2::Target<fapi2::TARGET_TYPE_OCMB_CHIP>& i_target,
        uint8_t i_value)
{

    FAPI_TRY( FAPI_ATTR_SET(fapi2::ATTR_ODY_DRAMINIT_VERBOSITY, i_target, i_value) );
    return fapi2::current_err;

fapi_try_exit:
    FAPI_ERR("failed setting ATTR_ODY_DRAMINIT_VERBOSITY: 0x%lx (target: %s)",
             uint64_t(fapi2::current_err), mss::c_str(i_target));
    return fapi2::current_err;
}


} // attr
} // mss

#endif
