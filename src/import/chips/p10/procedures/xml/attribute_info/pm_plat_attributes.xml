<!-- IBM_PROLOG_BEGIN_TAG                                                   -->
<!-- This is an automatically generated prolog.                             -->
<!--                                                                        -->
<!-- $Source: src/import/chips/p10/procedures/xml/attribute_info/pm_plat_attributes.xml $ -->
<!--                                                                        -->
<!-- OpenPOWER HostBoot Project                                             -->
<!--                                                                        -->
<!-- Contributors Listed Below - COPYRIGHT 2018,2024                        -->
<!-- [+] International Business Machines Corp.                              -->
<!--                                                                        -->
<!--                                                                        -->
<!-- Licensed under the Apache License, Version 2.0 (the "License");        -->
<!-- you may not use this file except in compliance with the License.       -->
<!-- You may obtain a copy of the License at                                -->
<!--                                                                        -->
<!--     http://www.apache.org/licenses/LICENSE-2.0                         -->
<!--                                                                        -->
<!-- Unless required by applicable law or agreed to in writing, software    -->
<!-- distributed under the License is distributed on an "AS IS" BASIS,      -->
<!-- WITHOUT WARRANTIES OR CONDITIONS OF ANY KIND, either express or        -->
<!-- implied. See the License for the specific language governing           -->
<!-- permissions and limitations under the License.                         -->
<!--                                                                        -->
<!-- IBM_PROLOG_END_TAG                                                     -->

<attributes>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_AUX_FUNC_INVOCATION_TIME_MS</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Time between invocations of auxiliary function on GPE1. The time (in is
    as 2^ATTR_AUX_FUNC_INVOCATION_TIME_MS with 0 indicating the
    is OFF.

    Consumer: p10_hcode_image_build.c -> XGPE Header field

    Provided by the Machine Readable Workbook to tune the collection.

    Platform default:1
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <group>aux</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_FREQ_BIAS</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Frequency Bias - % of bias (signed twos complement in 0.5 percent steps) in
    the frequency associated with a Pstate. Applies to all #V points,

    Producer:Attribute Overrides by Lab/Mfg Characterization Team

    Consumer: p10_pstate_parameter_build
    </description>
    <valueType>int8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_VOLTAGE_EXT_BIAS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Voltage Bias - % of bias (signed twos complement in 0.5
    that is applied to the respective rail's (VDD, VCS) #V VPD point used in
    voltage values associated with Pstates..

    Array[Rail][Point]

    [Rail]->2 entries-:
        0: VDD;
        1: VCS

    [Point] ->9 entries-:
        0: CF0;
        1: CF1;
        2: CF2;
        3: CF3;
        4: CF4;
        5: CF5;
        6: CF6;
        7: CF7;
        8: Enable

    Producer:Attribute Overrides by Lab/Mfg Characterization Team

    Consumer: p10_pstate_parameter_build
    </description>
    <valueType>int8</valueType>
    <array>2,8</array>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_VOLTAGE_EXT_VDN_BIAS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    VDN Voltage Bias - % of bias (signed twos complement in 0.5 percent steps)
    applied to the VDN value stored in the VPD for setting the VDN rail.

    Producer: Attribute Overrides by Lab/Mfg Characterization Team

    Consumer: p10_pstate_parameter_build

    Platform default:0
    </description>
    <valueType>int8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>bias</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_DDR5_VDN_UPLIFT_MV</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>This attribute has no effect.
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <mrw/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_DCCR_VALUE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
        Value to set into the Droop Count Control Register (DCCR) to establish the
        light and heavy droop thresholds.

        0:3   DTT_LARGE_OFFSET
        Used for both DTT[01]_EVENT_SEL="100".This field is added to the
        Large Droop Bin (FDCR[LARGE_DROOP_DETECT]+ FDCR[TRIP_OFFSET] +
        FDCR[CAL_ADJ]) to select the target DDS_DATAbin location for "dirty"
        timing margin.

        4:7   DTT0_THRESH_SCALE
        Droop Throttle Threshold0 Scale Factor (4-bit) for use by the following field.

        8:15  DTT0_THRESH_VALUE
        Droop Throttle Threshold0 Compare Value (8-bit). When the 24-bit
        DroopThrottle Count0 meets or exceeds this field times 2^(16-DTT0_THRESH_SCALE),
        an encoded event corresponding toCUCR.QME_EVENTS_PENDING bit 60 is sent to QME
        to set the TTSR.

        16:19 DTT1_THRESH_SCALE
        Droop Throttle Threshold1 Scale Factor (4-bit) for use by the following field.

        20:17 DTT1_THRESH_VALUE
        Droop Throttle Threshold1 Compare Value (8-bit). When the 24-bit
        DroopThrottle Count1 meets or exceeds this field times 2^(16-DTT0_THRESH_SCALE),
        an encoded event corresponding toCUCR.QME_EVENTS_PENDING bit 60 is sent to QME
        to set the TTSR.

        28:30 DTT1_EVENT_SEL
        Chooses which event increments DMSR DROOP0_COUNT, when this field is:

        000: DROOP_COUNT0 disabled

        Single occurrence of a droop event leading to performance loss
        selects what to compare with FTC Event Data(4:6)

        001: "110" rising edge of a small throttle response
        010: "111" rising edge of a large throttle response
        011: "110" or "111" rising edge of a either throttle response

        Raw timing margin from 0 to 15 bins above the Large detect point.

        100: Cycles that the bin selected by LARGE_DROOP_DETECT plus
        TRIP_OFFSET plus 4-bit DTT_LARGE_OFFSET was '0' (indicating loss of
        timing margin).

        How long actually throttling at a "full rate"including due to predicted
        response (slope and adj and ddp) selects what to compare with
        FTC Event Data(4:6)

        101:"110" or ("01X" and NOT ("011" and Event Data(7))) meaning number of
        cycles that small throttle was present and not in recovery phase
        110: "111`" or 100" meaning number of cycles that large droop was
        presentand not in either recovery phase
        111: either small or large throttle present and not in recovery (OR
        of the twoabove)

        31:33 DTT1_EVENT_SEL
        Chooses which event increments DMSR DROOP0_COUNT.  See DTT0_EVENT_SEL

        Consumer: p10_pm_pgpe_init
    </description>
    <valueType>uint64</valueType>
    <platInit/>
    <default>0x282893E9C0000000</default>
    <overrideOnly/>
    <writeable/>
    <group>dds</group>
  </attribute>

 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_FLMR_VALUE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    0:5 LARGE_INITIAL_CYCLES
        How many Core cycles times 4 (or 2x 2:1 Core) to apply the
        LARGE_INITIAL_ACTION in response to a Large Droop event becoming
        active. A value of 0x0 is invalid and will cause the state machine and
        therefore core to hang.
    6:10 LARGE_INITIAL_ACTION
        Actions to assert when Large Droop Condition is active.
            1xxxx: ISSUE_NTC
            x1xxx: uARCH HALT
            xx1xx: FETCH_THROTTLE01( IGNORE_IFU_THROTTLE_ACTIVE should be set if
                        this is '0')xxx1x: SLOW_COMPLETION
            xxxx1: FLUSH pulse (not plan of record,type selected via LARGE_FLUSH_TYPE)
    11:12 LARGE_PREFETCH_ACTION
        Maximum of this value and the FDIR-enabled PREFETCH_THROTTLE(0:1) setting
        is applied when Large Droop Condition is initially active until the droop
        subsides and Phase1 Recoverybegins.
    13 LARGE_RESPONSE_DISABLE
        Master Control to disable all Large Throttle Response (i.e. reactions to the
        local level and slope-based DDS thresholds, Adjacent Warn, DDP, FDIRInject
        and Irritiate injection). Setting this bit disables any future LargeThrottle
        Sequencer responses but does not cause the Droop Statemachine to abort its
        current state (see FTC_RESET below) and does NOT disable the Detection of
        Large Droop Events from being reported to CPMS.
    14 LARGE_FLUSH_TYPE
        When 0, bit10 causes an NTC+1 Flush pulseWhen 1, bit10 causes an NTC Flush
        pulse
    15 LARGE_DITHER_WINDOW_SEL
        If uArch HALT is enabled as a LARGE_INITIAL_ACTION, then after
        LARGE_INITIAL_CYCLES, the Halt is gradually deasserted, or "dithered",to
        prevent hanging the core. (uarch_halt to LSU is NOT included in the dither
        and is constantly asserted until the dither completes to avoid misbehavior)

        Selects the size of the Dithering Window for disengaging the Large Droop
        Throttle.
        0: 8 core cycles
        1: 32 core cycles
    16:19 LARGE_DITHER_INITIAL
        Selects initial number of core cycles plus 1 to deassert Halt per Dither
        Iteration when disengaging the Large Droop Throttle. This value is loaded
        into the ReleaseCount as the starting value when Halt Dithering is first
        initiated by the Large Droop State Machine.
    20:23 LARGE_DITHER_REPEAT
        Selects how many additional times to repeat each dither setting when
        disengaging the Large Droop Throttle to form one iteration. A value of 0x0
        in this field causes each dither window to be applied only once. A value of
        0xF causes each dither window to be performed a total of 16 times.
    24:27 LARGE_DITHER_INCREASE
        Selects how much more to deassert Large Droop Throttle controls for each
        Dither iteration, by adding this value to the ReleaseCount.
        Note: When LARGE_DITHER_WINDOW_SEL=0, the top bit is discarded.A value of
        0x0 in this field is always invalid, and whenLARGE_DITHER_WINDOW_SEL=0,
        a value of 0x8 is also invalid.
    28:30 PHASE1_RECOVERY_ACTION
        Actions to assert during Phase1 Large Droop Recovery (when LargeDroop
        is no longer active)
            1xx: SLOW_COMPLETIONx1x: ISSUE_NTC (serialize issue)
            xx1: SLOW_FETCH (default)
    31:32 PHASE1_RECOVERY_PREFETCHR
        Maximum of this value and the FDIR-enabled PREFETCH_THROTTLE(0:1) settings
        is applied during Phase1 LargeDroop Recovery.
    33:35 PHASE1_RECOVERY_VECTORR
        Maximum of this value, the FDIR[VECTOR_LIMIT_INJECT], and efusee nforced
        VECTOR_LIMIT(0:2) settings is applied during Phase1 LargeDroop Recovery.
    36:38 PHASE2_RECOVERY_ACTION
        Actions to assert during Phase2 Large Droop Recovery (when LargeDroop is
        no longer active):
            1xx: SLOW_COMPLETION (default)
            x1x: RESERVED*
            xx1: SLOW_FETCH
    39:40 PHASE2_RECOVERY_PREFETCH
        Maximum of this value and the FDIR-enabled PREFETCH_THROTTLE(0:1) settings
        is applied during Phase2 LargeDroop Recovery.
    41:43 PHASE2_RECOVERY_VECTOR
        Maximum of this value, the FDIR-enabled, and efuse-enforced VECTOR_LIMIT(0:2)
        settings is applied during Phase2 Large Droop Recovery
    44:51 PHASE2_RECOVERY_CYCLES
        How many Core cycles times 4 (or 2x 2:1 Core cycles) to stay in
        LARGE_PHASE2_RECOVERY before returning to "full speed".A value of 0x0 skips
        this Phase.
    52 MMA_DROOP_PROTECT_ENABLE
        When set, the DDS timing margin uses the three DATA_DETECT thresholds,
        originally intended for DPLL usage, to set the PROTECT_MMA_LIMIT which is
        combined with the FDIR[MMA_LIMIT_INJECT] and MMAR[MMA_LIMIT] to control MMA
        throughput.

        If corresponding DDS bit is '0' as selected by:DATA0_DETECT then
            PROTECT_MMA_LIMIT = "11"
        else DATA1_DETECT then PROTECT_MMA_LIMIT = "10"
        else DATA2_DETECT then PROTECT_MMA_LIMIT = "01"
        otherwise PROTECT_MMA_LIMIT = "00"
    53:55 MMA_DROOP_PREDICT_SELECT
        Selects which threshold to send to ISU as the "mma margin good" signal,
        which disables the MMA didt droop predict feature. The signal to ISU is
        deasserted when there is insufficient timing margin, enabling the MMA
        microarch throttle protection. When 000: Ignore DDS excess timing margin
        (set to '0' to always engage, if enabled in ISU)else encode selects
        non-inverted DDS bit using:
            001: DATA2_DETECT
            010: DATA1_DETECT
            011: SMALL_DROOP
            100: SLOPEA_START
            101: SLOPEB_START
            110: SLOPEA_END
            111: SLOPEB_END
            Note that this mechanism is overridden when FDIR[MMA_UARCH_ENABLE_INJECT] = 1
    56 CORE_UCODE_IDLE_DISABLER
        When not set, any ucode request prevents FTC from leaving the idle state.
        When set, FTC does not prevent the droop throttle sequencer from leaving
        the idle state, overrides CORE_UCODE_EXIT_DISABLE, and the next field must be
        set to "11" to suppress grants for all requests, resulting in animmediate
        "0011" code sent to CPMS.
    57:58 CORE_UCODE_GRANT_SUPPRESS
        When set to 00, FTC pulses the ucode_grant in response to the both types
        of ucode_request when the Droop State is idle. Otherwise, the grant is
        suppressed for the the selected type and FTC instead sends 0011 encode
        on the FTC event bus, which in turn causes CPMS to send the QME an interrupt1
        via the CPMS Event Bus.
        When this field is:
            01: suppress grant for reconfig type (recovery_request=0)
            10: suppress grant for recovery type (recovery_ request=1)
            11: always suppress ucode_grant (both types)
    59 CORE_UCODE_GRANT_INJECT
        On rising edge of this bit being set, FTC will pulse the ucode grant signal to
        PC.
    60 FTC_RESET
        When set, all state internal to FTC is immediately reset (as outlined in
        FDCR[STICKY_CONTROL]="11") but also including FDIR-based Droop Injection and
        Irritation as well. Unlike the FDCR reset, this bit is a level,n ot a pulse,
        and so must be set then cleared by hcode.No DDS controls are affected by this field.
    61 IGNORE_IFU_THROTTLE_ACTIVE
        When set, the Large Droop Throttle sequencer ignores the active indication
        from IFU and exits Phase1 Recovery after waiting for thePHASE2_RECOVERY_CYCLES
        instead.
    62 PHASE1_DITHER_NTC
        When set, Phase1 recovery will dither NTC_ONLY via same settings used by the
        Small Droop Sequence in the FMMR[SMALL_DITHER_*].
    63 CORE_UCODE_EXIT_DISABLE
        When not set (default) AND CORE_UCODE_IDLE_DISABLE==0, ucode requests cause
        exit from Large or Small "Run Slow" states directly to Idle state, immediately
        releasing all throttle controls. When set, requires droop to go away and FTC
        return to Idle state beforereacting to the request. May cause a "prolonged droop"
        that will hang thecore if system is in an overcurrent state.
    </description>
    <valueType>uint64</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>dds</group>
  </attribute>

 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_FMMR_VALUE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    0 SMALL_STAGGER_ENABLE
        This field controls when the release of Small Droop throttles can occur.
        Small droop throttle deassert is controlled by this field, when:
            0: only when the local state machine detects the droop has subsided
            1: waits for bottom and right cores stagger release indication signals to
                clear before leaving the Small Run Slow state, causing the small throttle
                release to be staggered from bottom right to top left of the chip, using the
                SMALL_STAGGER_CYCLES counter.
    1 SMALL_STAGGER_SELECT
        Chooses which signal is used to transport the small stagger signal between cores,
        driven to '1' whenever SMALL_STAGGER_ENABLE=1 and either the Small "Initial Slowdown"
        state is active or the Small "RunSlow" state is active and a local Small Droop is
        present.
        When 0, the slower staged DDP Status bit 3 wire is used (TBD 4 cycles)
        When 1, the faster ADJ_WARN signal is used (TBD 2 cycles) in which case
            ADJ_WARN_OUTPUT_SELECT must be = "000".
    2:3 SMALL_STAGGER_CYCLES
        Power of 4 select from an 6-bit counter running at 2:1 to the Core. After
        the Adjacent bottom and right Cores warn signals clear, wait for 2^(7-2N+1)
        Core cycles where N is the value of this field before deasserting may stagger signal
        outputs.
        A value of 0 results in a maximum 512 core cycles, which is 128ns @4Ghz.
        A value of 7 results in a minimum 2 core cycles which is 0.5ns @ 4Ghz.
        All 32 cores in a 4x8 grid will take 11 stages to fully deassert.Allowing a range
        between 1.4us to 5.5ns @4Ghz Core.(default 0x2 = 44ns @4GHz) not including staging
        on each signalbetween cores, which may take on the order of 2 to 4 cycles additional
        perstage (TBD) or another additional ~10ns.
    4 ADJ_WARN_WEIGHT
        Number of Adjacent cores that must assert a warning before this core takes an action
        in response.
            0: one or more adjacent cores
            1: two or more adjacent cores
    5 ADJ_WARN_RESPONSE
        What to do in response to a warning as selected by the previous field:
            0: engage Small Droop State machine1: engage Large Droop State machine
    6:8 ADJ_WARN_OUTPUT_SELECT
        Source for the adjacent warn output of this Core:
            1xx: SlopeA Event Active (SLOPE_TYPEA_SEL cannot be 00)
            x1x: SlopeB Event Active (SLOPE_TYPEB_SEL cannot be 00)
            xx1: inverted value of DDS bit selected by LARGE_DETECT
            000: Disabled
    9:11 DDP_TRIP_SELECT
        Selects which DDS DETECT threshold to use in response the Digital Droop Prediction
        Alarm = "01". Engage the Small Droop when the selected DDS output activates (has a
        value of '0'), as defined in FDCR:
            000: Disabled
            001: DATA0_DETECT
            010: DATA1_DETECT
            011: DATA2_DETECT
            100: SLOPEA_START_DETECT
            101: SLOPEB_START_DETECT
            110: SLOPEA_END_DETECT
            111: SLOPEB_END_DETECT
    12:13 SLOPEA_TYPE_SELECT
        Selects behavior of Slope A Events, when:
            00: disabled (do not generate slope events to internal logic or CPMS).
            01: generate an event only, but do not engage Droop Throttle sequencer
            10: assert the Small Droop Condition, which can then engage the SmallDroop sequence
            11: assert the Large Droop Condition, which can then engage the LargeDroop sequence
    14:15 SLOPEB_TYPE_SELECT
        Selects behavior of Slope B Events, same encoding as above.
    16:17 SMALL_ASSERT_STABILITY
        How many additional 2:1 core clock cycles in a row that SMALL_DROOP_DETECT must
        be active before engaging the Small Droop Throttle Seqeunce. Disabled when an enabled
        Slope is detected.
            00: 0 cycles (disabled)
            01: 2 cycles
            10: 4 cycles
            11: 8 cycles
    18:19 SMALL_DEASSERT_STABILITY
        How many additional 2:1 core clock cycles in a row SMALL_DROOP_DETECT must be inactive
        before disengaging the SmallDroop State Machine.
            00: 0 cycle (disabled)
            01: 4 cycles
            10: 8 cycles
            11: 15 cycles
    20:23 SMALL_INITIAL_CYCLES
        How many Core cycles times 4 (or 2x 2:1 Core cycles) to apply theS MALL_INITIAL_ACTION
        in response to a Small Droop event becoming active. A value of 0x0 is invalid and will
        cause the state machine andtherefore core to hang.
    24:29 SMALL_INITIAL_ACTION
        Which throttle controls to temporarily assert on the initial small droop detection,
        for SMALL_INITIAL_CYCLES, until the selected SMALL_THROTTLE_ACTION can take full effect.
            1xxxxx: ISSUE_NTC
            x1xxxx: SLOW_FETCH
            xx1xxx: SLOW_COMPLETION
            xxx1xx: STOP_PREFETCH (THROTTLE_PREFETCH="11")
            xxxx1x: HALT
            xxxxx1: NTC+1 FLUSH pulse
    30:31 SMALL_PREFETCH_ACTION
        Maximum of this value and the FDIR-enabled PREFETCH_THROTTLE(0:1) settings is applied
        when Small Droop is active when in the "Run Slow" phase.
    32 SMALL_DITHER_WINDOW_SEL
        Defines the window for the SMALL_DITHER_* settings below, with similar functionality
        as LARGE_DITHER_WINDOW_SEL.
        Setting this field to '1' selects a 32 core 1:1 cycle window, else 8-cycle core 1:1
        clock window is used.
        This value is used for ISSUE_NTC Release in "Run Slow" state and for"Halt release"
        after performing optional Halt Toggle during Small Droopmitigation.
    33:35 SMALL_VECTOR_ACTION
        Maximum of this value and the FDIR-enabled or efuse-enforced VECTOR_LIMIT(0:2) settings
        is applied when Small Droop is active. This value is used in the "Initial Slowdown" and
        'Run Slow" states for Small Droop mitigation.
    36 SLOPE_TIMEOUT_SELECT
        When set, Slope A and B active use a timeout of 32 2:1 core cycles, else 1621: core cycles.
        This timeout cancels the large or small droop being considered active if a Small Droop
        has not occurred in the meantime and allows the Droop Throttle Sequencer to recover back
        to idle.
    37:39 SMALL_THROTTLE_ACTION
        Which throttle controls to assert while Small Droop is active.
            1xx: SLOW_FETCH
            x1x: TOGGLE_HALT (later dither when droop subsides)
            xx1: Dither ISSUE_NTC (otherwise deassert immediately)
    40:43 SMALL_DITHER_REPEAT
        Same functionality as LARGE_DITHER_REPEAT but for deassertingS mall throttle for both
        Halt and ISSUE_NTC. This value is used in the "Run Slow" state if Dither ISSUE_NTC is
        selected.T his value is used in the "Halt Release" state if TOGGLE_HALT isselected.
    44:47 SMALL_DITHER_INCREASE
        Same functionality as LARGE_DITHER_INCREASE but for optionally deasserting Small throttle
        Halt and ISSUE_NTC.
    48:52 SMALL_DITHER_INITIAL RW 0x8 Used when TOGGLE_HALT is enabled as a SMALL_THROTTLE_ACTION
        to select the number of cycles plus 1 todeassert Halt per Toggle Window. The same window
        is continuously repeated until the small droop goes away, at which point it will Dither back
        to full performance using this value again as the initial deassert amount.
        Note: Unlike LARGE_DITHER_INITIAL this field specifies 5 bits, where toptwo bits are discarded
        if SMALL_DITHER_WINDOW_SEL=0 (after adding 1 to the value).Note: a value of 0x07, 0x0F, or
        0x17 is illegal whenS MALL_DITHER_WINDOW_SEL=0, and a value of 0x1F is always illegal.
    53 DPLL_DATA2_SEL
        Selects which event drives DPLL_ENCODED_DATA(2)0: Disabled (sets to '1')1: FDCR[DATA2_DETECT]
        This signal is AND'd with all other Cores and used by the DPLL to control frequency when
        DPLL_CTRL.DYNAMIC_SLEW_MODE=1 but is not used when DPLL_CTRL.ENABLE_JUMP_PROTECT=1.
    54:55 DPLL_DATA1_SEL
        Selects which additional events combine (Invert then AND) with DATA1_DETECT to also drive
        zero on DPLL_ENCODED_DATA(1):
            00: None (use FDCR[DATA1_DETECT] directly)
            01: Small Droop State Machine Drooped (Not Halt Release)
            10: SlopeA Event Active(SLOPEA_TYPE_SELECT cannot be00)
            11: SlopeB Event Active (SLOPEB_TYPE_SELECT cannot be00)
    56:57 DPLL_DATA0_SEL
        Selects which additional events combine (Invert then AND) with DATA0_DETECT to also drive
        zero on DPLL_ENCODED_DATA(0):
            00: None (use FDCR[DATA0_DETECT] directly)
            01: Small Droop State Machine Drooped (not Halt Release)
            10: Large Droop State Machine Drooped (Not Phase1or2 Rcvy)
            11: SlopeB Event Active (SLOPE_TYPEB_SEL cannot be 00)
    58 DDS_ERROR_ENCODE_DISABLE
        When set, disables reporting 0x1E encode when a non-thermometer codeis seen from the DDS,
        and instead reports a "garbage" reading.
    59 SMALL_RESPONSE_DISABLE
        Master Control to disable all Small Throttle Response (i.e. reactions to thelocal level
        and slope-based DDS thresholds, Adjacent Warn, DDP, FDIR Inject and Irritate injection).
        Setting this bit disables any future Small Throttle Sequencer responses but does not cause
        the Droop Statemachine to abort its current state (see FTC_RESET in FLMR) and does NOT
        disable the Detection of Small Droop Events from being reported to CPMS.
    60 SLOPE_REPORT_SEL
        Enables Slope detects that occur on the same cycle as a SMALL or LARGE DROOP_DETECT to be
        reported to CPMS for accounting in the TRIP and SLOPE events to the DHCR and characterization
        counters,despite not setting the Slope Active indication.
    61:63 OVERRIDE_VECTOR_LIMIT
        May be used by some systems or by WOF to limit possible max currents wing under certain
        scenarios.
        The throttle amount provided to the VSU is given by the "maximum" of this field, eFuse setting,
        droop inject, and droop recovery state machine outputs.Bit(0) of this field drives vsu_throttle,
        and is an OR of all requests Bits(1:2) of this field drive flop_limit, and is the MAX value of
        all requests
            000: No FLOP limit
            001: 16 FLOPS (only subset of VSU ops)
            010: 8 FLOPS (only subset of VSU ops)
            011: 4 FLOPS (only subset of VSU ops)
            10X: 2 VSU ops (any type) per cycle
            11X: 1 VSU op (any type) per cycle
    </description>
    <valueType>uint64</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_DELAY_ADJUST</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Integer adjustment value applied to the #W DELAY value of the respective
    curve fit (CF) point that depends on the good sorted cores.

    10BC/15BC is considered config A;  12BC is considered config B

    [Point] ->8 entries-:
        0: 10BC/15BC CF4;
        1: 10BC/15BC CF5;
        2: 10BC/15BC CF6;
        3: 10BC/15BC CF7;
        4: 12BC CF4;
        5: 12BC CF5;
        6: 12BC CF6;
        7: 12BC CF7;

    Consumer: p10_pstate_parameter_build

    </description>
    <valueType>int16</valueType>
    <array>8</array>
    <platInit/>
    <!-- Idx 0 1 2 3 4 5 6 7  -->
    <!-- CFG A A A A B B B B  -->
    <!-- CF  4 5 6 7 4 5 6 7  -->
    <default>0,2,2,2,0,2,2,4</default>
    <mrw/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_LARGE_DROOP_DETECT_ADJUST</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Integer adjustment value applied to the #W LARGE_DROOP_DETECT value of the
    respective curve fit (CF) point.

    [Point] ->8 entries-:
        0: CF0;
        1: CF1;
        2: CF2;
        3: CF3;
        4: CF4;
        5: CF5;
        6: CF6;
        7: CF7;

    Consumer: p10_pstate_parameter_build
    </description>
    <valueType>int8</valueType>
    <array>8</array>
    <platInit/>
    <initToZero/>
    <mrw/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_TRIP_OFFSET_ADJUST</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Integer adjustment value applied to the #W TRIP_OFFSET value of the
    respective curve fit (CF) point.

    [Point] ->8 entries-:
        0: CF0;
        1: CF1;
        2: CF2;
        3: CF3;
        4: CF4;
        5: CF5;
        6: CF6;
        7: CF7;

    Consumer: p10_pstate_parameter_build
    </description>
    <valueType>int8</valueType>
    <array>8</array>
    <initToZero/>
    <mrw/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_DROOP_EXTREME_OVERRIDE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Digital Droop Sensors (DDS) Extreme Threshold Select Value per VPD point.
    a negative value below the DDS setting that will trigger droop event.  This
    attibute overrides the

    Array of 9 entries-:
        0: CF0;
        1: CF1;
        2: CF2;
        3: CF3;
        4: CF4;
        5: CF5;
        6: CF6;
        7: CF7;
        8: Enable

    If index 8 is non-zero, the other entries are considered valid.

    Producer: Override
    </description>
    <valueType>uint8</valueType>
    <array>9</array>
    <platInit/>
    <enum>
        OFF= 0x00,
        8mV= 0x01,
        16mV = 0x02,
        24mV = 0x03,
        32mV = 0x04,
        40mV = 0x05,
        48mV = 0x06,
        56mV = 0x07,
        64mV = 0x08,
        72mV = 0x09,
        80mV = 0x0A,
        88mV = 0x0B,
        92mV = 0x0C,
        96mV = 0x0D
    </enum>
    <initToZero/>
    <overrideOnly/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SAFE_MODE_NODDS_UPLIFT_0P5PCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Uplift voltage percentage (in 0.5% units) applied to the #V computed safe mode
    value to account for the lack of DDS protection in Safe Mde.

    Array of 2 entries-:
        0: VDD;
        1: VCS;
    Consumer: p10_setup_evid.C
    </description>
    <valueType>uint32</valueType>
    <array>2</array>
    <platInit/>
    <default>100, 100</default>  <!-- 10% for each -->
    <overrideOnly/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_DPLL_SLEW_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Indicates the response of the DPLL frequency upon DDS events if the DDS is
    enabled.

    NONE -> DPLL Mode 2, JUMP_PROTECT -> DPLL Mode 3,  SLEW_MODE -> DPLL Mode 4

    Producer: MRWB
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        NONE = 0x00,
        JUMP_PROTECT = 0x01,
        SLEW_MODE = 0x02
    </enum>
    <initToZero/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_TRIP_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Indicates whether to calculate trip offsets per core or per chip. Default is per
    chip.

    CHIP or CORE

    Producer: MRWB
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        CHIP = 0x00,
        CORE = 0x01
    </enum>
    <default>CHIP</default>
    <initToZero/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_TRIP_INTERPOLATION_CONTROL</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    A bit vector to indicate which of FDCR items to interpolate. Multiple items
    can be set to be interpolated.

    Producer: MRWB
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        TRIP    = 0x80,
        DATA0   = 0x40,
        DATA1   = 0x20,
        DATA2   = 0x10,
        LARGE   = 0x8,
        SMALL   = 0x4,
        SLOPEA  = 0x2,
        SLOPEB  = 0x1
    </enum>
    <default>0x88</default>
    <initToZero/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DUMP_STOP_INFO_ENABLE_ERRORLOG</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    if set to 1, p10_dump_stop_info output will be written to error logs
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DUMP_STOP_INFO_SUPPRESS_ERROR_TRACE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    if set to 1, FAPI_ERR records are suppressed from being produced by
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PGPE_HCODE_FUNCTION_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enables the PGPE Hcode to physically perform frequency and voltage based on
    parameters (eg #V VPD, system parameters, biases, VFRTs. etc). If OFF,
    PGPE provides an immedicate good response to Pstate/WOF IPC operations
    the OCC for firmware integration testing

    Consumer: p10_hcode_image_build.c -> PGPE Header field

    Platform default: ON
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <overrideOnly/>
    <default>ON</default>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PM_GLOBAL_FIR_TRACE_EN</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enable Global FIR tracing through PM Complex Reset/Initialization
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <writeable/>
    <overrideOnly/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_POUND_W_STATIC_DATA_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enables pstate parameter block code to use the static #W data

    Consumer: p10_pstate_parameter_build.C

    Platform default:OFF
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <initToZero/>
    <overrideOnly/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_POUND_V_STATIC_DATA_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enables pstate parameter block code to use the static #V data

    Consumer: p10_pstate_parameter_block.C

    Platform default:OFF
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
<!--    <initToZero/> -->
    <writeable/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_AW_STATIC_DATA_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enables pstate parameter block code to use the static AW data

    Consumer: p10_pstate_parameter_block.C

    Platform default:OFF
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_POUNDV_BUCKET_NUM</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Attribute in place to allow override of which POUNDV bucket to use to set
    data.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        BUCKETA = 1,
        BUCKETB = 2
    </enum>
    <initToZero/>
    <overrideOnly/>
    <group>vpd</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_POUNDV_BUCKET_NUM_OVERRIDE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    1 if override of poundv bucket num is available. 0 if override is unavailable.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>vpd</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SKIP_WAKEUP</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    The PM_RESET hwp calls special wakeup enable on all EX targets, then will
    wakeup bit on the core if special wakeup is done. In some hostboot does
    want these steps of the PM_RESET. This attribute gives platform the
    to decide if they want to enable special wakeup and autowakeup on the
    during PM_RESET.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <writeable/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYS_VRT_STATIC_DATA_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enables pstate parameter block code to use the static system vrt data

    Consumer: p10_pstate_parameter_build.C -> PGPE Hcode

    Platform default:OFF
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01,
        VDN_STEP_OFF = 0x02
    </enum>
    <initToZero/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_POUNDV_VALIDITY_HALT_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables the validity checking of #V VPD content from causing IPL failures.

    OFF:Will enable PStates given all validity checks pass. If validity checks
    a failure is log and error reaction will occur (eg IPL failure) ON: Will
    #V validity checking of #V from causing IPL to halt. check failures will
    error logs and Pstates (including other functions) will be disabled.

    Producer: Override

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <initToZero/>
    <overrideOnly/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_RING_DBG_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Debug modes supported for QME Scan layout in HOMER.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        SCAN_RING_NO_DEBUG = 0x00,
        SCAN_RING_TRACE_DEBUG = 0x01,
        SCAN_RING_DEEP_DEBUG = 0x02
    </enum>
    <initToZero/>
    <group>debug</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PM_MALF_ALERT_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Switch to enable or disable Power Management Malfunction Alert Handling on
    platform support. e.g. True for PHYP based systems and False for based
    depending on support available.

    Producer: Initialized by Hostboot firmware based on platform support Read by
    p10_pm_stop_gpe_init.C
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FALSE = 0x00,
        TRUE = 0x01
    </enum>
    <initToZero/>
    <writeable/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PM_HALT_FFDC_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Switch to enable or disable Power Management Complex FFDC collection during
    the PM Complex Halt flow to HOMER to assist with failure analysis and recovery.

    Producer: HB must set or reset this based on the platform use-case and
    p10_pm_halt.C, p10_pm_callout.C
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FALSE = 0x00,
        TRUE = 0x01
    </enum>
    <initToZero/>
    <writeable/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_DDS_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables the enablement of Digital Droop Sensors (DDS) in the system.

    Producer:MRW

    Consumers:p10_pstate_parameter_build ->
    QME Pstate parameter block ????
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_DDS_FREQ_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>

    Producer:Override

    Consumers:p10_pstate_parameter_build ->
    QME Pstate parameter block ????
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>
 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_AUXILLARY_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Control XGPE boot: ON : enable xgpe to boot
                       OFF: disable xgpe boot

    Producer:Override

    Consumers: p10_pstate_parameter_build and p10_pm_xgpe_init
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        ON = 0x00,
        OFF = 0x01
    </enum>
    <default>ON</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>
  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PSTATES_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Controls the mode of Pstate Protocol for testing. ON: Boots the PGPE in "OCC
    Mode" but does NOT start the Pstate protocol OFF: Does NOT boot the PGPE
    Boots the PGPE and automatically starts the Pstate protocol. PMCR
    to move Pstates are honored.

    Producer:Override

    Consumers: p10_pstate_parameter_build and p10_pm_pstate_gpe_init
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        ON = 0x00,
        OFF = 0x01,
        AUTO = 0x02
    </enum>
    <default>ON</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_SUSPEND_OCC_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    pm_suspend_procedure will first put the system in safe mode and
    we have 2 methods to do that, one is thru occ and if that fails then will do thru pgpe.
    On awan/cronus if we want to test procedure, OCC won't be running,
    hence will use this attribute to disable occ method

    Producer:Override

    Consumers: p10_suspend_powman.C
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_RESCLK_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables the enablement of resonant clocking in the system.

    Producer: Override Consumers: p10_pstate_parameter_build to clear the flag
    for PGPE reaction

    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_RESCLK_ISTEP4_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enables resonant clocks in the system at istep4

    Producer: Override

    Consumers: p10_hcd_core_startclocks.C

    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF = 0x00,
        ON = 0x01
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>


  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_RVRM_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables RVRM enablement in the system

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <default>ON</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_WOF_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables Work Load Optimized Frequency (WOF) algorithms to modify frequency
    active core count and other inputs.

    OFF:Will enable WOF given all validity check pass. If validity checks fail,
    be disabled for the present IPL.

    ON: Will disable WOF OFF_SKIP_DD: as but skips any validity checking of the
    design level (lab use

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB) for
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1,
        OFF_SKIP_DD=2
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_WOV_OVERV_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables Workload Optimized Voltage (WOV) overvolting algorithms to compensate
    for work-load induced droops.

    OFF: Will enable WOV overvolting given all validity check pass. If validity
    WOV overvolting will be disabled for the present IPL.

    ON:Will disable overvolting

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_WOV_UNDERV_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables Workload Optimized Voltage (WOV) undervolting algorithms which
    voltage below the value calculated from VPD.

    OFF:Will enable WOV undervolting given all validity check pass. If validity
    WOV undervolting will be disabled for the present IPL.

    ON: Will disable undervolting

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
      <id>ATTR_WOF_INDEX_SELECT</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Selects the WOF table from a set of WOF tables

    Valid values:  0, 1, 2

    Consumers: Hostboot firmware
    </description>
    <valueType>uint8</valueType>
    <platInit>mrw</platInit>
    <default>0</default>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_WOF_DISABLE_DIMENSION</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    A bit vector to allow the disablement of WOF dimensions.  If a dimension is
    disabled, the TDP default value defined in the WOF Tables header is used
    with the exception of Vratio;  that default is hardcoded to 100%.

     [Index]->5 entries-:
         0: VDD
         1: VCS
         2: IO
         3: Ambient condition
         4: Vratio
    </description>
    <valueType>uint8</valueType>
    <array>5</array>
    <platInit/>
    <default>0,1,0,0,0</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_THROTTLE_CONTROL_LOOP_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables Workload Optimized Frequency Throttle Control Loop

    OFF:Will enable WOF Throttle control loop is validity check pass. If validity
    check fails, then WOF Throttle control loop will be disabled for the present IPL.

    ON: Will disable throttle control loop

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <overrideOnly/>
    <initToZero/>
    <group>enablement</group>
  </attribute>
 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_PITCH_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    ON: Disables PGPE Throttle CI loop. Raw overage value written to
    WCOR. Bit in WCOR indicates the Overage has subsided and by how much.

    OFF: Allows PGPE Throttle Loop to be enabled.

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <overrideOnly/>
    <initToZero/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_THROTTLE_CONTROL_LOOP_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
     If WOF Throttle Control Loop is enabled, then selects the mode to update
     throttle control values.

    BINARY: Will update the throttle control values by half the current value of
    throttle.

    DECINC: Will update throttle control value by one in each step.

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        BINARY = 0x0,
        DECINC = 0x1
    </enum>
    <default>BINARY</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_THROTTLE_CONTROL_KP</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Throttle control loop proportional parameter. Value is in 64ths

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>48</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_THROTTLE_CONTROL_KI</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Throttle control loop integral parameter. Value is in 64ths

    Producer: Override

    Consumers: p10_build_pstate_datablock -> Pstate Parameter Block (PPB)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>32</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>


  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_OCS_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables Over Current Sensor functions

    OFF:Will enable Over Current Sensor (OCS) given all validity check pass. If
    checks fail, WOV undervolting will be disabled for the present IPL.

    ON: Will disable OCS and WOF (TBD on the this phase in of validity)

    Producer: Override

    Consumers: p10_pstate_parameter_build -> PGPE Hcode
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PGPE_CURRENT_READ_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables PGPE from reading the rail currents and populating content to the OCC.

    OFF:Will enable the PGPE Current reading function

    ON: Will disable the PGPE Current reading function.  The OCC SRAM will NOT be
    updated with any readings.

    Producer: Override

    Consumers: p10_pstate_parameter_build -> PGPE Hcode
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_DCM_TRACKING_ENABLE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables the PGPE to clip Pstates based on the sibling Dual Chip Module (DCM)
    Pstate value to have the combination generally track.  The DCM values are
    NOT interlocked as this is to aid in thermal management.

    Producer: p10_build_pstate_datablock

    Consumers: PGPE HCode

    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FALSE=0,
        TRUE=1
    </enum>
    <initToZero/>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_WOF_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of WOF checking in relationship to system reaction under firmware.

    FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails the IPL.
    INFO - if not ATTR_SYSTEM_WOF_DISABLE, Info error log; WOF is disabled; IPL continues.
    WARN - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error
             logs, WOF is disabled; IPL continues.
    OFF  - no checking performed; IPL continues.  WOF is disabled;.

    Producer: Override

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>INFO</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_WOF_LAB_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of WOF checking in relationship to system reaction under Cronus.

    FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails the IPL.
    INFO - if not ATTR_SYSTEM_WOF_DISABLE, Info error log; WOF is disabled; IPL continues.
    WARN - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error
             logs, WOF is disabled; IPL continues.
    OFF  - no checking performed; IPL continues.  WOF is disabled;.

    Producer: Override

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>WARN</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>
 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PDV_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of #V checking in relationship to system reaction under FW

    FAIL - Fails the IPL (product default).
    INFO - Info error log; Pstates are disabled; IPL continues.
    WARN - Error messages to traces; no error logs, Pstates are disabled
            (as #V is bad), IPL continues.
    OFF  - no checking performed; IPL continues. Pstates are disabled.

    Producer: Override

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>INFO</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PDV_LAB_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of #V checking in relationship to system reaction under Cronus

    FAIL - Fails the IPL (product default).
    INFO - Info error log; Pstates are disabled; IPL continues.
    WARN - Error messages to traces; no error logs, Pstates are disabled
            (as #V is bad), IPL continues.
    OFF  - no checking performed; IPL continues. Pstates are disabled.

    Producer: Override

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>WARN</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PDW_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of #W checking in relationship to system reaction

    FAIL - if not ATTR_SYSTEM_DDS_DISABLE, fails the IPL (product default);.
    INFO - if not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; Info
            error log; DDSs are disabled; IPL continues.
    WARN - if not ATTR_SYSTEM_DDS_DISABLE, error messages to traces; no error
            logs, DDS are disabled, IPL continues.
    OFF  - no checking performed; IPL continues. DDS are disabled.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>INFO</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

<!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_IQ_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of IQ checking in relationship to system reaction

    FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails the IPL (product default);
    INFO - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; Info
                error log; WOF is disabled; IPL continues.
    WARN - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error
            logs, WOF is disabled, IPL continues.
    OFF - no checking performed; IPL continues.  WOF is disabled..
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>WARN</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PDV_TDP_CURRENT_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of #V TDP current checking via Model Data(6) in relationship
    to system reaction under firmware.

    FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails the IPL
    INFO - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; Info
                error log; WOF is disabled; IPL continues(product default)
    WARN - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error
            logs, WOF is disabled, IPL continues.
    OFF - no checking performed.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_PDV_TDP_CURRENT_LAB_VALIDATION_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the mode of #V TDP current checking via Model Data(6) in relationship
    to system reaction under Cronus.

    FAIL - if not ATTR_SYSTEM_WOF_DISABLE, fails the IPL
    INFO - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; Info
                error log; WOF is disabled; IPL continues
    WARN - if not ATTR_SYSTEM_WOF_DISABLE, error messages to traces; no error
            logs, WOF is disabled, IPL continues.(lab default)
    OFF - no checking performed.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FAIL = 0,
        INFO = 1,
        WARN = 2,
        OFF  = 3
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PBAX_BRDCST_ID_VECTOR</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Receive PBAX Broadcast Group. Vector that is indexed when decoded PMISC with
    decoded PMISC pbax_chipid value. If the bit in this vector at decoded
    location is a 1, then this receive engine will participate the broadcast

    Override attribute. Platform value of 0 indiates the OCC firmware will this
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>pbax</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PBAX_CHIPID</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Receive PBAX Chipid. Value that indicates this PBA's PBAX Chipid within the
    Is matched to pbax_chipid of the Address phase if

    Provided by the Machine Readable Workbook.

    Platform default:Nimbus systems - set so value in ATTR_FABRIC_GROUP_ID
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <group>pbax</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PBAX_GROUPID</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Receive PBAX Groupid. Value that indicates this PBA's PBAX Group affinity.
    matched to pbax_groupid of the PMISC Address phase.

    Provided by the Machine Readable Workbook.

    Platform default:Nimbus systems = 0
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <group>pbax</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SPIPSS_FREQUENCY</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    SPIPSS Clock Frequency (binary in KHz)

    Valid range: 500KHz to 2500KHz

    Consumer: p10_pss_init

    Overridden by the Machine Readable Workbook.

    If default of 0 is read, HWP will set SPIPSS frequency to 10MHz.
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <group>pss</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SPIPSS_SELECT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Defines which of the PSS chip selects (0 or 1) that the APSS is connected

    Producer:  Machine Readable Workbook
    Consumer: p10_pm_pss_init
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        NONE = 0xFF,
        CS0 = 0x00,
        CS1 = 0x01
    </enum>
    <initToZero/>
    <overrideOnly/>
    <group>pss</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PROC_R_DISTLOSS_UOHM</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Impedance (binary in microOhms) of the distribution loss sense point to the
    value is applied to each processor instance.

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer: Machine Readable Workbook (per the power subsystem design)

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <initToZero/>
    <group>sysparms</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PROC_R_LOADLINE_UOHM</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Impedance (binary microOhms) of the load line from a processor VRM to the
    pins. This value is applied to each processor instance.

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO

    Note:no loadline may be present in the system; thus, a value of 0 is legal.

    Producer: Machine Readable Workbook (per the power subsystem design)

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <initToZero/>
    <group>sysparms</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PROC_VRM_VOFFSET_UV</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Offset voltage (binary in microvolts) to apply to the VDD VRM distribution
    processor module. This value is applied to each processor instance.

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer: Machine Readable Workbook (per the power subsystem design)

    Consumers: p10_pstate_parameter_build
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <initToZero/>
    <group>sysparms</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_CORE_THROTTLE_ASSERT_COUNT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The number of XGPE Fixed Timer Interrupts (see Hcode documentation for to
    a core throttle when OCC Flag 3[Core Throttle Continuous Enable] is set.

    A value of 0 when Continuous Change Enable is set will deassert throttle.

    Producer:Override/Lab

    Consumers:p10_hcode_image_build.c -> XGPE Header field
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>didt</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_CORE_THROTTLE_DEASSERT_COUNT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The number of XGPE Fixed Timer Interrupts (see Hcode documentation for
    durations) to deassert core throttle when OCC Flag 3[Core Continuous
    Enable] is set.

    A value of 0 when Continuous Change Enable is set and is non-0, throttling
    always on.

    Producer:Override/Lab

    Consumers:p10_hcode_image_build.c -> PGPE Header field
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>didt</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_POUNDV_BUCKET_DATA</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The keyword data is read directly from #V VPD and stored in this
    attribute without being altered
    NOTE: you may need to handle correcting endianness if you are using this
    </description>
    <valueType>uint8</valueType>
    <array>351</array>
    <platInit/>
    <initToZero/>
    <group>vpd</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_POUNDW_BUCKET_DATA</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The keyword data is read directly from #W VPD and stored in this
    attribute without being altered
    NOTE: you may need to handle correcting endianness if you are using this
    </description>
    <valueType>uint8</valueType>
    <array>2953</array>
    <platInit/>
    <initToZero/>
    <group>vpd</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_AVSBUS_BUSNUM</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Defines the AVSBus (0, 1 or 2) which has the indicated rail VRM

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer:Machine Readable Workbook

    Consumers: p10_set_evid; p10_set_voltage (tool) ->
    Global Pstate Parameter Block (GPPB) for PGPE;  OCC Pstate Parameter Block
    OCC

    *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If
    is not the case, the value must be appropriately set by the platform (eg MRW
    or equivalent)
    </description>
    <valueType>uint8</valueType>
    <array>4</array>
    <platInit>mrw</platInit>
    <default>0</default>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_AVSBUS_FREQUENCY</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    AVSBus Clock Frequency (binary in KHz)

    Consumer: p10_ocb_init.C

    Overridden by the Machine Readable Workbook.

    If default of 0 is read, HWP will set AVSBus frequency to 1MHz.
    </description>
    <valueType>uint32</valueType>
    <platInit>mrw</platInit>
    <initToZero/>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_AVSBUS_RAIL</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Defines the AVSBus rail selector number (0 - 15) for the VRM on the bus
    by ATTR_AVSBUS_BUSNUM[x].

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO

    Producer:Machine Readable Workbook

    Consumers: p10_set_evid; p10_set_voltage (tool) ->
    Global Pstate Parameter Block (GPPB) for PGPE OCC Pstate Parameter Block
    OCC

    *MOST* systems use Bus 0 for VDD, Bus 1 for VCS, Bus 2 for VIO and VDN. If
    is not the case, the value must be appropriately set by the platform (eg
    or equivalent)
    </description>
    <valueType>uint8</valueType>
    <array>4</array>
    <platInit>mrw</platInit>
    <default>0</default>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_EXTERNAL_VRM_STEPSIZE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Step size (binary in microvolts) to take upon external VRM voltage. This
    provide a limit of the external VRMs steps and  is used as part of the
    overall voltage time calculation.

    The consuming code provides a default value of 50mv (5000uV) if this
    attribute is zero.

    Consumer: p10_pstate_parameter_build -> p10_setup_evid Pstate Parameter
    (PPB) for PGPE
    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO;

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <default>0</default>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_DEC_UV_PER_US</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Transition rate (binary in microVolts per microsecond) of the VRM for a
    decreasing voltage transition. This is used as part of the overall voltage
    time calculation.

    The consuming code provides a default value of 10000 uV/us if this attribute
    is zero.

    Consumer: p10_pstate_parameter_build -> Pstate Parameter Block (PPB) for PGPE

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO;

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <default>0</default>
    <writeable/>
    <overrideOnly/>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_EXTERNAL_VRM_TRANSITION_RATE_INC_UV_PER_US</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Transition rate (binary in microVolts per microsecond) of the VRM for an
    increasing voltage transition. This is used as part of the overall voltage
    time calculation.

    The consuming code provides a default value of 10000 uV/us if this attribute
    is zero.

    Consumer: p10_pstate_parameter_build -> Pstate Parameter Block (PPB) for PGPE

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO;

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <default>0</default>
    <writeable/>
    <overrideOnly/>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_EXTERNAL_VRM_TRANSITION_STABILIZATION_TIME_NS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Time (binary in nanoseconds) to allow the voltage rail to stabilize before
    transition to be fully complete. This applies to both increasing and
    decreasing transitions as part of the overall voltage transition calculation.

    The consuminug code provides a default value of 5000ns (5us) if this attribute
    is zero.

    Note: the smallest possible delay is limited to 1ns.

    Consumer: p10_pstate_parameter_build -> Pstate Parameter Block (PPB) for PGPE

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO;

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <default>0</default>
    <writeable/>
    <overrideOnly/>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_EXTERNAL_VRM_TRANSITION_START_NS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Delay (binary in nanoseconds) from the time the VRM receives the write
    until the voltage actually moves.  This value is used for both increasing
    and decreasing transitions as part of the overall voltage transition
    calculation.

    The consuming code provides a default value of 8000ns (8us) if this attribute
    is zero.

    Note: the  smallest possible delay is limited to 1ns.

    Consumer: p10_pstate_parameter_build -> Pstate Parameter Block (PPB) for PGPE

    [index] ->0: VDD; 1: VCS; 2: VDN; 3: VIO;

    Provided by the Machine Readable Workbook after system characterization.
    </description>
    <valueType>uint32</valueType>
    <array>4</array>
    <platInit/>
    <default>0</default>
    <writeable/>
    <overrideOnly/>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SADDLEBACK_VRM_ROLLOVER_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enable the Saddleback rollover errata correction

    Consumer: p10_pstate_parameter_build -> Pstate Parameter Block (PPB) for PGPE

    Provided by the Machine Readable Workbook based on system use of the Saddleback
    contoller.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <mrw/>
    <group>vrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_TABLE_DATA</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    WOF data from SEEPROM which contains WOF header data + VRT data (vrt +
    for 6 Vcs, 26 Vdd, 4 IO, 4 AC)

    Consumer: p10_pstate_parameter_build
    </description>
    <valueType>uint8</valueType>
    <array>40064</array>
    <platInit/>
    <initToZero/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_VRATIO_VDD_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The percentage (in 0.1% units) of VDD power that is attributed to the
    indicated region associated with each core/cache set.

    [index] ->8 entries-:
        0: CORE;
        1: CACHE_BASE;          // This includes both clock and snoop AC power
        2: RACETRACK_PER_CORE;  // Amount of racetrack allotment per coore
        3: MMA;
        4: Reserved;
        5: Reserved;
        6: Reserved;
        7: Reserved;

    Consumer:  p10_pstate_parameter_build -> PGPE Hcode

    </description>
    <valueType>uint16</valueType>
    <array>8</array>
    <platInit/>
    <enum>
        CORE                = 0,
        CACHE_BASE          = 1,
        RACETRACK_PER_CORE  = 2,
        MMA                 = 3,
        RESERVED4           = 4,
        RESERVED5           = 5,
        RESERVED6           = 6,
        RESERVED7           = 7
    </enum>
    <default>800, 150, 50, 0, 0, 0, 0, 0</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_VRATIO_VCS_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The percentage (in 0.1% units) of VCS power that is attributed to the
    indicated region associated with each core/cache set.

    [index] ->8 entries-:
        0: CORE;
        1: CACHE_BASE;      // This includes both clock and snoop AC power
        2: Reserved2;
        3: Reserved3;
        4: Reserved4;
        5: Reserved5;
        6: Reserved6;
        7: Reserved7;

    Consumer:  p10_pstate_parameter_build -> PGPE Hcode

    </description>
    <valueType>uint16</valueType>
    <array>8</array>
    <platInit/>
    <enum>
        CORE                = 0,
        CACHE_BASE          = 1,
        RESERVED2           = 2,
        RESERVED3           = 3,
        RESERVED4           = 4,
        RESERVED5           = 5,
        RESERVED6           = 6,
        RESERVED7           = 7
    </enum>
    <default>200, 800, 0, 0, 0, 0, 0, 0</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOF_IO_BASE_POWER_0P01W</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    The base TDP power (in 0.01W units) of AVDD, VPCI, and VDN rails that don't
    vary with I/O configuration.

    The value comes from the maximum power assumed for the system during WOF
    table generation minus the computed link power based on the VIO voltage
    for the system TDP configuration.

    The value represented is the per socket configuration that supports 4 node
    operation.

    Each dimension assumes a different value for the VIO rail.

    [index] ->2 entries-:
        0: 1.0V;
        1: 0.9V;
        2: Reserved;
        3: Reserved;

    Producer: Machine Readable Workbook

    Consumers: p10_hcode_image_build -> XGPE Hcode

    </description>
    <valueType>uint16</valueType>
    <array>4</array>
    <platInit>mrw</platInit>
    <default>1721,2482,0,0</default>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_MAX_DROOP_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Not supported in P10.
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_OVERV_MAX_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    If WOV overvolting is enabled, then this specifies the maximum amount of
    The value is specified in tenths of percentage(0.1%).

    If, 0, then default value of 30(3%) is used.

    Values can range from 1(0.1%) to 100(10%). Values greater than 100 are to
    clipped to 100 (10%).
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>50</default>  <!-- 5.0% -->
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_OVERV_STEP_DECR_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    If WOV undervolting is enabled, this specifies the amount to decrease
    from the present voltage to expand the overvolt effect. The value is specified
    in tenths of 1%.

    If 0, then default value of 0.5%(5) is used.

    Values can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    clipped to 20 (2%).
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>1</default>  <!-- 0.1% -->
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_OVERV_STEP_INCR_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    If WOV undervolting is enabled, this specifies the amount to increase
    from the present voltage to expand the overvolt effect. The value is specified
    in tenths of 1%.

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>10</default>  <!-- 1.0% -->
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_OVERV_VMAX_SETPOINT_MV</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Maximum regulator voltage allowed without exceeding the technology Vmax at
    pins.

    If, 0, then default value of 1275 (1.275V) is used

    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_UNDERV_MAX_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    If WOV undervolting is enabled, then this specifies the maximum percentage
    that the voltage can move from the base voltage. The value is specified in
    tenths of percentage(0.1%).

    If, 0, then default value of 10%(100) is used.

    Value can range from 10(1%) to 255(25.5%).
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>200</default>  <!-- 20.0% -->
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_LIGHT_PERF_LOSS_THRESH_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Not supported on P10
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_HEAVY_PERF_LOSS_THRESH_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Not supported on P10
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_UNDERV_STEP_DECR_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    If WOV undervolting is enabled, this specifies the amount to decrease from
    the present voltage to expand the undervolt effect. The value is specified
    in tenths of 1%.

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>1</default>  <!-- 0.1% -->
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_UNDERV_STEP_INCR_10THPCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    If WOV undervolting is enabled, this specifies the amount to increase from
    the present voltage to reduce the undervolt effect. The value is specified
    in tenths of 1%.

    If 0, then default value of 0.5%(5) is used.

    Value can range from 1(0.1%) to 20(2%). Values greater than 20 are clipped
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>10</default>  <!-- 1.0% -->
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_WOV_UNDERV_VMIN_MV</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Minimum regulator voltage allowed without violating the chip Vmin at the
    pins.

    If, 0, then the value of the #V PowerSave voltage is used.
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>wov</group>
  </attribute>

    <!-- ********************************************************************* -->
    <attribute>
        <id>ATTR_WOV_DIRTY_UNCURRENT_CONTROL</id>
        <targetType>TARGET_TYPE_SYSTEM</targetType>
        <description>
        The dirty value sent to OCC upon PGPE detecting a DDS based droop.  The
        encoding represent the following:
        b0x(0,1):  not dirty, NA
        b10(  2):  dirty, no OCC Ceff reaction expected
        b11(  3):  dirty, OCC Ceff reaction expected
        [Index]->2 entries-:
        0: LIGHT
        1: HEAVY
        </description>
        <valueType>uint8</valueType>
        <array>2</array>
        <default>0x0, 0x3</default>
        <overrideOnly/>
        <group>wov</group>
    </attribute>

    <!-- ********************************************************************* -->
    <attribute>
        <id>ATTR_OCS_WITH_DDS_DISABLE</id>
        <targetType>TARGET_TYPE_SYSTEM</targetType>
        <description>
        Allows the OCS function to operate without real DDS enablement for unit
        testing purposes.
        </description>
        <valueType>uint8</valueType>
        <enum>
        OFF=0,
        ON=1
        </enum>
        <platInit/>
        <initToZero/>
        <overrideOnly/>
        <group>wov</group>
    </attribute>

    <!-- ********************************************************************* -->
    <attribute>
        <id>ATTR_WOV_OVERV_WITH_DDS_DISABLE</id>
        <targetType>TARGET_TYPE_SYSTEM</targetType>
        <description>
        Allows the WOV Overvolting function to operate without real DDS enablement for unit
        testing purposes.
        </description>
        <valueType>uint8</valueType>
        <enum>
        OFF=0,
        ON=1
        </enum>
        <platInit/>
        <initToZero/>
        <overrideOnly/>
        <group>wov</group>
    </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_DPLL_FMAX_FAST_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disable the Fast Fmax Slewing function of the DPLL when in SLEW_MODE

    Producer: Override
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_DPLL_FMIN_FAST_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disable the Fast Fmin Slewing function of the DPLL when in SLEW_MODE

    Producer: Override
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_FMAX_OVERRIDE_KHZ</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Override for DPLL Fmax value when in ATTR_DDS_DPLL_SLEW_MODE.SLEW_MODE

    [Point] ->9 entries-:
        0: CF0;
        1: CF1;
        2: CF2;
        3: CF3;
        4: CF4;
        5: CF5;
        6: CF6;
        7: CF7;
        8: Enable

    Producer: Override
    </description>
    <valueType>uint16</valueType>
    <array>9</array>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DDS_FMIN_OVERRIDE_KHZ</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Override for DPLL Fmin value when in ATTR_DDS_DPLL_SLEW_MODE.SLEW_MODE

    [Point] ->9 entries-:
        0: CF0;
        1: CF1;
        2: CF2;
        3: CF3;
        4: CF4;
        5: CF5;
        6: CF6;
        7: CF7;
        8: Enable

    Producer: Override
    </description>
    <valueType>uint16</valueType>
    <array>5</array>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dds</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_FREQ_PB_MHZ_POUNDV_FALLBACK</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    The powerbus frequency that should be used to locate a valid #V bucket in
    Module VPD if the actual ATTR_FREQ_PB_MHZ value isn't present.
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <enum>
        NO_FALLBACK = 0,
        1600 = 1600,
        1866 = 1866,
        2000 = 2000,
        2133 = 2133,
        2400 = 2400
    </enum>
    <default>NO_FALLBACK</default>
    <writeable/>
    <overrideOnly/>
    <group>vpd</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SAFE_MODE_FREQUENCY_MHZ</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Safe mode frequency in MHz computed as MAX(#V PowerSave Freq, ATTR_FREQ_CORE_FLOOR_MHZ).
    This attribute is used to update DPLL frequency register for booting and by
    PGPE Hcode (as a Pstate) when Safe Mode operation is necessary.

    Consumer: p10_setup_evid.C, PGPE Hcode

    Producer: p10_pstate_parameter_build
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>safe</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SAFE_MODE_VOLTAGE_MV</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Safe mode set point voltages for VDD and VCS in mV used for booting.

    If not overridden,  computed from the #V VPD Curve Fit VDD points for voltage
    and current plus the system load line and distrubution losses such to support
    ATTR_SAFE_MODE_FREQUENCY_MHZ frequency and then uplifted by ATTR_BOOT_VOLTAGE_BIAS_0P5PCT.

    [index] ->0: VDD; 1: VCS;

    Consumer: p10_setup_evid.C

    Producer: p10_pstate_parameter_build
    </description>
    <valueType>uint32</valueType>
    <array>2</array>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>safe</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_VDN_UPLIFT_MV</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Voltage (in mV) to uplift the VDN rail for P10 systems

    Consumer: p10_setup_evid.C

    Producer: Machine Readable Workbook
    </description>
    <valueType>uint32</valueType>
    <platInit>mrw</platInit>
    <default>125</default>
    <group>mrw</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_PMCR_MOST_RECENT_MODE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables the platform mode where the most recent PMCR update
    will be the controlling value for Pstate changes. If disabled,
    the legacy "fastest one wins" algorithm is used.

    Producer: p10_build_pstate_datablock

    Consumers: p10_hcode_image_build ->
    PGPE Header
    QME attribute
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        FALSE=0,
        TRUE=1
    </enum>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_UNSECURE_HOMER_ADDRESS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Address is allocated by hostboot and HBRT and is populated
    by p10_hcode_image_build with sc2 instruction. It enables CME to invoke
    a transition from HV to UV during STOP entry on an SMF enabled system.
    Address value should be aligned with 2MB boundary.

    Producer: Initialized by Hostboot firmware based on platform support
    Consumers: Read by p10_hcode_image_build.C
    </description>
    <valueType>uint64</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>smf</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_UNSECURE_HOMER_SIZE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Size of memory which hostboot must copy from a temp buffer to
    an unsecure region of main store memory. Once HOMER is built, hostboot reads
    the attribute and copies the amount of memory specified in this attribute from
    a temp buffer to an unsecure region of main memory specifed in an attribute
    ATTR_UNSECURE_HOMER_ADDRESS

    Producer: Initialized by hostboot firmware based on platform support

    Consumers: Read by p10_hcode_image_build.C
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <writeable/>
    <group>smf</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_FUSED_CORE_PAIRED_MODE_ENABLED</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
        Set when QMCR[FUSED_CORE_PAIR_MODE] is to be set by QME Hcode
    </description>
    <enum>FALSE = 0x0, TRUE = 0x1</enum>
    <valueType>uint8</valueType>
    <writeable/>
    <initToZero/>
    <group>state</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_MMA_POWEROFF_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables the MMA power-off function within the QME.

    OFF: Enables the QME MMA power-off funtion as further controlled by
    ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS.

    ON: Disables the dynamic MMA power-off function within the QME The MMA will
    be on if the core is powered on.

    Producer: Override

    Consumers: QME Hcode
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <default>OFF</default>
    <overrideOnly/>
    <group>mma</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_MMA_POWERON_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables the MMA power-on function within the QME. This can be use for
    that will NEVER have MMA based applications running so as to save the MMA

    OFF: Enables the QME MMA power-on funtion. This will have the MMA powered on
    in istep 16 and then controlled by ATTR_SYSTEM_MMA_POWEROFF_DISABLE and
    thereafter.

    ON: Disables the MMA power-on function and leaves the MMA permenantly off.
    core will take illegal instruction interrupt on MMA instruction that are dispatched.

    Producer: Override

    Consumers: QME Hcode
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <initToZero/>
    <writeable/>
    <overrideOnly/>
    <group>mma</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Time to delay before powering off the MMA due to the lack of MMA instructions.

    Time = 1ms * 2**ATTR_SYSTEM_MMA_POWEROFF_DELAY_POWEROF2_MS.

    Valid values of  0x00 - 0x1B to yield times from 1ms to 24 hours -:
        0x00 - 1ms
        ...
        0x0A - 1 second (default, 2^10)
        ...
        0x1B - 1 day (2^27)
        0x1C - 0xFD - Reserved (maps as 0x1C)
        0xFE - every QME FIT timer interrupt (~250us)
        0xFF - no power off of MMA (QME Hcode still runs; different behavior
    ATTR_SYSTEM_MMA_POWEROFF_DISABLE)

    Producer:  Machine Readable Workbook

    Consumer: QME Hcode
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>0xA</default>
    <group>mma</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_RVRM_VID</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Retention Voltage ID to be applied to STOP 3 cores.

    Valid values (8mV granularity) -:
        0x00 - 000mV
        ...
        0x38 - 448mV (minimum circuit value)
        0x39 - 456mV
        ...
        0x4B - 600mV (default)
        ...
        0x6A - 848mV (maximum circuit value)
        ...
        0x7F - 1016mV
        All others reserved and flagged as errors.

    The Retention Voltage circuit has usable range of 448mV to 848mV. Values
    below 448mv (0x38) will be clipped to 448mV and values above 848mV (0x6A)
    will be clipped to 848mV.
    </description>
    <valueType>uint8</valueType>
    <writeable/>
    <default>0x4B</default>
    <overrideOnly/>
    <group>rvrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_RVRM_DEADZONE_MV</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Retention voltage deadzone where the RVRM must be disabled if the external
    effective voltage is less than ATTR_RVRM_VID (in mV) plus this attribute
    value.
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>50</default>
    <overrideOnly/>
    <group>rvrm</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_STOP_LEVELS_SUPPORTED</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Defines the STOP levels supported by the Hcode in the present driver.

    Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ...,
    bit 15 = STOP15.
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <!-- Levels supported:  0, 2, 3, 11 -->
    <default>0xB010</default>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_STOP_LEVELS_DISABLED</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Disables STOP Level operat?ions in the Power Management complex by mapping
    the respective level to the next lower supported level in a additive
    manner.

    Represented as bit vector where bit 0 = STOP0; bit 1 = STOP 1, ...,
    bit 15 = STOP15.
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>enablement</group>
  </attribute>

  <!-- ********************************************************************* -->=
  <attribute>
    <id>ATTR_BOOT_VOLTAGE_BIAS_0P5PCT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Boot bias applied to uplift the PowerSave #V VDD and VCS Voltages to boot the
    chip - % of bias (signed twos complement in 0.5 percent). This is to handle timing
    margin until droop protection is enabled.

    Producer: Override

    Consumer: p10_setup_evid (first pass)
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>0</default>
    <overrideOnly/>
    <group>bias</group>
  </attribute>

  <!-- ********************************************************************* -->=
  <attribute>
    <id>ATTR_WOF_OMI_FORCE_FREQ_MHZ</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Core Frequency at or above which the OMI buses are forced to full width
    independent of what link reduction may attempt.  When the core frequency is
    below this value.SAFE_MODE

    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <valueType>uint32</valueType>
    <initToZero/>
    <platInit/>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_SRAM_WRITE_ASSIST_MV</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    This attribute helps to indicate PGPE to turn off write assist even at high voltage
    when it is not used.
    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <overrideOnly/>
    <default>0x0</default>
    <group>wof</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_DDS_THRESHOLD_PSTATE_ENABLE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables the updating of the DDS threshold settings upon Pstate changes.

    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <overrideOnly/>
    <default>OFF</default>
    <group>dds</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_DDS_COARSE_THROTTLE_ENABLE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables coarse throttle reaction to DDS events.

    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <overrideOnly/>
    <default>OFF</default>
    <group>dds</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_DDS_FREQ_JUMP_ENABLE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables frequency jump reaction to DDS events.

    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <overrideOnly/>
    <default>OFF</default>
    <group>dds</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_DDS_BIAS_ENABLE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables DDS biasing through the use of the #W ALT frequency and voltage
    data.

    Producer:  Override/Lab
    Consumers: p10_build_pstate_datablock
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <overrideOnly/>
    <default>OFF</default>
    <group>bias</group>
  </attribute>

 <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_SYSTEM_THROTTLE_PSTATE_NUMBER_LIMIT</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Limits the number of Pstates below the frequency floor that can be used for
    throttling.

    Valid responsive values:  0 to 63.  Values above 63 will be capped to 63.

    Consumer: p10_pstate_parameter_build ->
              OCC Parameter Block
    </description>
    <valueType>uint8</valueType>
    <platInit/>
    <default>0xFF</default>
    <group>throttle</group>
  </attribute>

<!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_THROTTLE_TABLE_OVERRIDE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Override content of the 64 entry Core Throttle Table used to throttle the
    cores below the Fmin frequency.

    Consumer: p10_pstate_parameter_build ->
              Local Parameter Block -> QME Hcode
    </description>
    <valueType>uint32</valueType>
    <array>64</array>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_THROTTLE_MODE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Mode of the throttle control function.

    NONE - No throttling
    ICTMN - Instruction Core Throttle / M/N windows
    PP_PCT_RED - Power Proxy Percent Reduction
    PP_TARGET - Power Proxy Target

    Consumer: p10_pstate_parameter_build ->
              Local Parameter Block -> QME Hcode
    </description>
    <valueType>uint32</valueType>
    <enum>
        NONE=0,
        ICTMN=1,
        PP_PCT_RED=2,
        PP_TARGET=3
    </enum>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DLR_LINKS_ENABLED</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Array making up bit vectors indicating which of the 66 possible (max of 42)
    Data Link Layers (DLs) are alive.

        Bit   dlr_link[0] dlr_link[1] dlr_link[2]  dlr_link[3]  dlr_link[4]
         0     MC00_OMI0     PCI0-0    OPT0_AX0     OPT4_AX0     OPT6_AX0
         1     MC00_OMI1     PCI0-1    OPT0_AX1     OPT4_AX1     OPT6_AX1
         2     MC01_OMI0     PCI0-2    OPT0_O0      OPT4_O0      OPT6_O0
         3     MC01_OMI1     PCI1-0    OPT0_O1      OPT4_O1      OPT6_O1
         4     MC10_OMI0     PCI1-1    OPT0_N0      OPT4_N0      OPT6_N0
         5     MC10_OMI1     PCI1-2    OPT0_N1      OPT4_N1      OPT6_N1
         6     MC11_OMI0               OPT0_N2
         7     MC11_OMI1               OPT0_N3
         8     MC20_OMI0     OPT1_AX0  OPT3_AX0     OPT5_AX0     OPT7_AX0
         9     MC20_OMI1     OPT1_AX1  OPT3_AX1     OPT5_AX1     OPT7_AX1
        10     MC21_OMI0     OPT2_AX0  OPT3_O0      OPT5_O0      OPT7_O0
        11     MC21_OMI1     OPT2_AX1  OPT3_O1      OPT5_O1      OPT7_O1
        12     MC30_OMI0               OPT3_N0      OPT5_N0      OPT7_N0
        13     MC30_OMI1               OPT3_N1      OPT5_N1      OPT7_N1
        14     MC31_OMI0               OPT3_N2
        15     MC31_OMI1               OPT3_N3

    Consumer: p10_pstate_parameter_build -> XGPE Hcode
    </description>
    <valueType>uint16</valueType>
    <array>5</array>
    <writeable/>
    <initToZero/>
    <group>dlr</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DLR_SAMPLE_TIME_MS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Time (in millisecond) (P) that the IO DLs are sampled such to produce an I/O
    Power value into the WOF algorithm.

    If 0, a default value of 2 is used.
    Valid values:  1 to 1000 (1 milliscodnd to 1 second)

    Consumer: p10_pstate_parameter_build -> XGPE Hcode
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dlr</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DLR_AVERAGE_HISTORY_DEPTH_OVERRIDE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Depth (N) of the running average history buffer used for Dynamic Lane Reduction
    (DL)to allow hysteresis by making P*N > (OCC WOF tick time).  See
    ATTR_DLR_SAMPLE_TIME_MS.

    If 0, a default value of 4 is used.
    Valid values: 1, 2, 4, 8 and 16

    Consumer: p10_pstate_parameter_build -> XGPE Hcode
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dlr</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_DLR_PLSF_OVERRIDE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Override for XGPE built in table.

    Table of 8-bit per-link-type scaling factors (PLSF) to normalize the relative
    power per link (16 types), used for chip activity calculation.

    One table represents all possible link types

     [Index]->32 entries-:
         0: 32G-A-6x18;
         1: 32G-A-7x18;
         2: 32G-X-6x18;
         3: 32G-X-7x18;
         4: 32G-OC-12x8;
         5: 32G-NV-12x4;
         6: 50G-A;
         7: 50G-X;
         8: 50G-OC;
         9: 50G-NV-12x4;
        10: 32G-OM;
        11: PCIE-G4-4X4X8X
        12: PCIE-G4-8X
        13: PCIE-G4-16X
        14: PCIE-G5-4X
        15: PCIE-G5-8X
        all others reserved

    TODO:  More definition of this attribute is needed!!!
    Consumer: p10_pstate_parameter_build -> XGPE Hcode
    </description>
    <valueType>uint8</valueType>
    <array>32</array>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>dlr</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_SAFE_MODE_XSTOP</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>
    Enables a system checkstop upon entering safe mode for debug.
    Producer:  Override/Lab
    Consumers: p10_pm_pgpe_init
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <overrideOnly/>
    <default>OFF</default>
    <group>debug</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_WOF_ALTITUDE_TEMP_ADJUSTMENT</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Temperature adjustment due to altitude in degrees Celsius/km*1000.

    Default: 8C/2100m = 8C/2.1Km = 3.809 C/kM;  Encode: 3.809 C/kM*1000 = 3809
    Producer:  Override
    Consumers: p10_pstate_parameter_block
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <overrideOnly/>
    <default>3809</default>
    <group>wof</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_WOF_TDP_ALTITUDE_REFERENCE_M</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Altitude (in meters) on which WOF Ambient Condition is based.

    Producer:  Override
    Consumers: p10_pstate_parameter_block
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <default>1000</default>
    <overrideOnly/>
    <group>wof</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_SYSTEM_FMAX_ENABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Enable the use of the #V Fmax value within each chip in the system.  In this
    mode, Pstate 0 is determined by finding the maximimum of all #V FMax values.

    If this attribute is OFF, Pstate 0 is set by the UltraTurbo value that is
    to be common across all parts in the system as they must be from the same
    sort.

    Default: OFF
    Producer:  MRW
    Consumers: p10_pstate_parameter_block

    RTC: 269546:  remove the FMax Enable mode control
    Changing the default to ON until the RTC removes all support.
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <default>ON</default>
    <group>pstate</group>
  </attribute>

  <!-- ********************************************************************* -->
  <attribute>
    <id>ATTR_CURRENT_SCALING_FACTOR</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    The scaling factor to be applied to currents read from the respective VRM
    before consumption.

     [Index]->8 entries-:
         0: VDD
         1: VCS
         2: VDN
         3: VIO
         4: AVDD
         5: Reserved
         6: Reserved
         7: Reserved
    </description>
    <valueType>uint8</valueType>
    <array>8</array>
    <platInit>mrw</platInit>
    <default>1,1,1,1,1,1,1,1</default>
    <group>vrm</group>
  </attribute>

  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_IO_GROUNDED_CONTROLLERS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description> It is a 16 bit vector which represents a list of controllers that
     are grounded in either the module package or the board on which the module is
     plugged. The bit definition are as follows:
        00  NMMU
        01  EMO01
        02  EMO23
        03  EMO45
        04  EMO67
        05  PAU0
        06  Reserved
        07  Reserved
        08  PAU3
        09  PAU4
        10  PAU5
        11  PAU6
        12  PAU7
        13  PCIE0
        14  PCIE1
    </description>
    <valueType>uint16</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
  </attribute>
  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_IO_GROUNDED_LINKS</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description> It is a 64 bit vector. It represents the link that are grounded in either the
     module package or the board on which the module is plugged. See Table 104 in PowMan Hcode
     specification.
    </description>
    <valueType>uint64</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
  </attribute>
  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_WOF_IO_POWER_MODE</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description> Value of attribute determines if DLR is done or a static computation is done with
    updated dynamic configuration.
    </description>
    <valueType>uint8</valueType>
     <enum>
     STATIC  = 0,
     DYNAMIC = 1
     </enum>
    <default>STATIC</default>
    <platInit/>
    <overrideOnly/>
  </attribute>
  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_EXTENDED_FREQ_MODE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>
    Indicates whether to consider pstate to freq offset for p10 vs pnext systems
    Producer: MRWB
    </description>
    <valueType>uint32</valueType>
     <enum>
     NEW_FREQ = 1,
     OLD_FREQ = 2,
     USE_RDP  = 3
     </enum>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
    <group>wof</group>
  </attribute>
  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_DVFS_ADJUSTMENT</id>
    <targetType>TARGET_TYPE_PROC_CHIP</targetType>
    <description>This is placeholder attribute that is plumbed into the Global Pstate Parameter Block
    for future use.
    </description>
    <valueType>uint32</valueType>
    <platInit/>
    <initToZero/>
    <overrideOnly/>
  </attribute>
  <!-- *********************************************************************-->
  <attribute>
    <id>ATTR_OCC_START_DISABLE</id>
    <targetType>TARGET_TYPE_SYSTEM</targetType>
    <description>Disables the starting of the OCC PPC405.  This is typically used
    in lab environments under Cronus.
    </description>
    <valueType>uint8</valueType>
    <enum>
        OFF=0,
        ON=1
    </enum>
    <platInit/>
    <overrideOnly/>
    <default>OFF</default>
    <group>istep21</group>
  </attribute>
  <!-- *********************************************************************-->
</attributes>
